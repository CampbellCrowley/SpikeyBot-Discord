// Copyright 2020 Campbell Crowley. All rights reserved.
// Author: Campbell Crowley (web@campbellcrowley.com)
const socketIo = require('socket.io-client');
const common = require('../common.js');
const crypto = require('crypto');
const spawn = require('spawn');
const path = require('path');
const fs = require('fs');

const ShardingMaster = require('./ShardingMaster.js');

const configDir = path.resolve(__dirname + '/../../config/');
const botCWD = path.resolve(__dirname + '/../../');

/**
 * @description The slave that is managed by {@link ShardingMaster}. This does
 * nothing to communicate with Discord until the master has told it to do so.
 * The main purpose of this is to connect and listen to the master for commands
 * and messages. This class must have a config file generated by the master
 * named similarly to `shard_abc_config.json` in the `./config/` directory.
 * @class
 */
class ShardingSlave {
  /**
   * @description Starts the slave, and attempts to connect to the master
   * immediately. Throws errors if setup is incorrect.
   */
  constructor() {
    common.begin(false, true);

    const files = fs.readdirSync(configDir);
    const file = files.find((el) => el.match(/^shard_[a-z]+_config\.json$/));
    if (!file) {
      throw new Error('Failed to find shard config file required for boot.');
    }
    const data = fs.readFileSync(file);
    /**
     * @description Parsed config file from disk.
     * @private
     * @type {object}
     * @constant
     */
    this._config = JSON.parse(data);
    /**
     * @description The settings the master has told us to operate with. This
     * includes the botName, heartbeat settings, as well as shard ID and count.
     * Null until a connection is established.
     * @private
     * @type {?object}
     */
    this._settings = null;

    /**
     * @description This slave's ID/Name.
     * @public
     * @type {string}
     * @constant
     */
    this.id = this._config.id;
    /**
     * @description The public key of this shard.
     * @public
     * @type {string}
     * @constant
     */
    this.pubKey = this._config.pubKey;
    /**
     * @description The private key identifying this shard.
     * @private
     * @type {string}
     * @constant
     */
    this._privKey = this._config.privKey;

    /**
     * @description The current status information about this shard. This is
     * sent to the master as a heartbeat.
     * @private
     * @type {ShardingMaster.ShardStatus}
     */
    this._status = new ShardingMaster.ShardStatus(this.id);

    const host = this._config.host;
    const now = Date.now();
    const sign = crypto.createSign(this._config.signAlgorithm);
    sign.update(`${this.id}${now}`);
    sign.end();
    const signature = sign.sign(this._privKey, 'utf8');

    /**
     * @description The socket.io socket used to communicate with the master.
     * @private
     * @type {socketIo.Socket}
     * @constant
     */
    this._socket = socketIo(`${host.protocol}//${host.host}:${host.port}`, {
      path: host.path,
      extraHeaders: {authorization: `${this.id};${signature};${now}`},
    });
    this._socket.on('connect', () => this._socketConnected());
    this._socket.on('disconnect', () => this._socketDisconnected());
    this._socket.on('evalRequest', () => this._evalRequest());
    this._socket.on('update', () => this._updateRequest());
  }

  /**
   * @description Socket connected event handler.
   * @private
   */
  _socketConnected() {
    common.log('Socket connected to master');
  }
  /**
   * @description Socket disconnected event handler.
   * @private
   */
  _socketDisconnected() {
    common.log('Socket disconnected from master');
  }
  /**
   * @description Master has requested shard evaluates a script.
   * @private
   * @param {Array.<*>} args Array of arguments from broadcast.
   * @param {Function} cb Callback function with optional error, otherwise
   * success message is second parameter.
   */
  _evalRequest(args, cb) {
    if (!this._child) {
      cb('Not Running');
      return;
    }
    cb('Not Implemented');
    // TODO: Implement IPC for eval request and response.
  }
  /**
   * @description Master has sent a status update, and potentially expects a
   * response.
   * @private
   * @param {object} settings Current settings for operation.
   */
  _updateRequest(settings) {
    this._settings = settings;
    common.log(
        'New settings received from master: ' + JSON.stringify(settings));
    const s = this._status;
    s.goalShardId = settings.id;
    s.goalShardCount = settings.count;

    if (s.currentShardId != s.goalShardId ||
        s.currentShardCount != s.goalShardCount) {
      if (s.currentShardId >= 0) {
        this._child.kill('SIGTERM');
        s.stopTime = Date.now();
      } else {
        this._spawnChild();
      }
    }
    if (this._settings.heartbeat.updateStyle === 'pull') {
      this._generateHeartbeat();
    }
    // TODO: Implement 'push' update style event loop.
    // TODO: Implement suicide at both expected reboot and death timeouts.
  }

  /**
   * @description Spawn the child process with the current settings available.
   * @private
   */
  _spawnChild() {
    if (this._status.goalShardId < 0) return;
    common.log('Spawning child shard #' + this._status.goalShardId);
    this._child = spawn(
        'node',
        [
          ...(this._settings.nodeArgs || []),
          'src/SpikeyBot.js',
          `--shardid=${this._status.goalShardId}`,
          ...(this._settings.botArgs || []),
        ],
        {
          cwd: botCWD,
          detached: false,
        });
    this._child.on('error', (err) => {
      this._child = null;
      common.error('Failed to spawn child process!');
      console.error(err);
      this._status.goalShardId = -1;
      this._status.goalShardCount = -1;
    });
    this._child.on('exit', (code, signal) => {
      common.log('Child exited with code ' + code + ' (' + signal + ')');
      this._child = null;
      if (this._status.goalShardId >= 0) this._spawnChild();
    });
    this._child.on('message', (...args) => this._childMessage(...args));
  }

  /**
   * @description Handle a message from the child.
   * @private
   * @param {object} message A parsed JSON object or primitive value.
   */
  _childMessage(message) {
    console.log(message);
    // TODO: Handle messages from child. These will most commonly be responses
    // to eval requests.
  }

  /**
   * @description Fetch stats necessary for heartbeat message to the master,
   * then sends the message.
   * @private
   */
  _generateHeartbeat() {
    // TODO: Fetch stats and send heartbeat.
  }

  /**
   * @description Cleanup and fully shutdown gracefully.
   * @public
   */
  exit() {
    if (this._socket) this._socket.close();
    // TODO: Don't exit until child has shutdown, as we don't want to leave it
    // orphaned.
    process.exit(0);
  }
}

if (require.main === module) {
  console.log('Started via CLI, booting up...');
  const slave = new ShardingSlave(process.argv[2]);

  process.on('SIGINT', slave.exit);
  process.on('SIGTERM', slave.exit);
}
module.exports = ShardingSlave;
