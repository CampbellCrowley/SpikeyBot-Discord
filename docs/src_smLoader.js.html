<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>SpikeyBot-Discord Source: src/smLoader.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.slate.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">SpikeyBot-Discord</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-lib_twemojiChecker.html">lib/twemojiChecker</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="ApiEndpoint.html">ApiEndpoint</a></li><li><a href="ApiRequestBody.html">ApiRequestBody</a></li><li><a href="BotCommands.html">BotCommands</a></li><li><a href="ChatBot.html">ChatBot</a></li><li><a href="CmdScheduling.html">CmdScheduling</a></li><li><a href="CmdScheduling-ScheduledCommand.html">CmdScheduling~ScheduledCommand</a></li><li><a href="Command.html">Command</a></li><li><a href="Command-CommandSetting.html">Command~CommandSetting</a></li><li><a href="Command-SingleCommand.html">Command~SingleCommand</a></li><li><a href="Common.html">Common</a></li><li><a href="Connect4.html">Connect4</a></li><li><a href="Connect4_Game.html">Connect4#Game</a></li><li><a href="CpuWatcher.html">CpuWatcher</a></li><li><a href="Define.html">Define</a></li><li><a href="DevCmds.html">DevCmds</a></li><li><a href="Echo.html">Echo</a></li><li><a href="Echo-Character.html">Echo~Character</a></li><li><a href="EE.html">EE</a></li><li><a href="EventEmitter.html">EventEmitter</a></li><li><a href="Events.html">Events</a></li><li><a href="FileServer.html">FileServer</a></li><li><a href="FunTranslators.html">FunTranslators</a></li><li><a href="HG.html">HG</a></li><li><a href="HGWeb.html">HGWeb</a></li><li><a href="HungryGames.html">HungryGames</a></li><li><a href="HungryGames-Action.html">HungryGames~Action</a></li><li><a href="HungryGames-ActionManager.html">HungryGames~ActionManager</a></li><li><a href="HungryGames-ActionStore.html">HungryGames~ActionStore</a></li><li><a href="HungryGames-Action-GiveRoleAction.html">HungryGames~Action~GiveRoleAction</a></li><li><a href="HungryGames-Action-RunCommandAction.html">HungryGames~Action~RunCommandAction</a></li><li><a href="HungryGames-Action-SendAutoplayingMessageAlertAction.html">HungryGames~Action~SendAutoplayingMessageAlertAction</a></li><li><a href="HungryGames-Action-SendDayEndMessageAction.html">HungryGames~Action~SendDayEndMessageAction</a></li><li><a href="HungryGames-Action-SendDayStartMessageAction.html">HungryGames~Action~SendDayStartMessageAction</a></li><li><a href="HungryGames-Action-SendEventMessageAction.html">HungryGames~Action~SendEventMessageAction</a></li><li><a href="HungryGames-Action-SendMessageAction.html">HungryGames~Action~SendMessageAction</a></li><li><a href="HungryGames-Action-SendPlayerRankMessageAction.html">HungryGames~Action~SendPlayerRankMessageAction</a></li><li><a href="HungryGames-Action-SendStatusListAction.html">HungryGames~Action~SendStatusListAction</a></li><li><a href="HungryGames-Action-SendTeamRankMessageAction.html">HungryGames~Action~SendTeamRankMessageAction</a></li><li><a href="HungryGames-Action-SendVictorAction.html">HungryGames~Action~SendVictorAction</a></li><li><a href="HungryGames-Action-TakeRoleAction.html">HungryGames~Action~TakeRoleAction</a></li><li><a href="HungryGames-ArenaEvent.html">HungryGames~ArenaEvent</a></li><li><a href="HungryGames-Battle.html">HungryGames~Battle</a></li><li><a href="HungryGames-ChannelAction.html">HungryGames~ChannelAction</a></li><li><a href="HungryGames-Day.html">HungryGames~Day</a></li><li><a href="HungryGames-DefaultOptions.html">HungryGames~DefaultOptions</a></li><li><a href="HungryGames-DefaultOptions-BooleanOption.html">HungryGames~DefaultOptions~BooleanOption</a></li><li><a href="HungryGames-DefaultOptions-NumberOption.html">HungryGames~DefaultOptions~NumberOption</a></li><li><a href="HungryGames-DefaultOptions-ObjectOption.html">HungryGames~DefaultOptions~ObjectOption</a></li><li><a href="HungryGames-DefaultOptions-Option.html">HungryGames~DefaultOptions~Option</a></li><li><a href="HungryGames-DefaultOptions-SelectOption.html">HungryGames~DefaultOptions~SelectOption</a></li><li><a href="HungryGames-Event.html">HungryGames~Event</a></li><li><a href="HungryGames-EventContainer.html">HungryGames~EventContainer</a></li><li><a href="HungryGames-FinalEvent.html">HungryGames~FinalEvent</a></li><li><a href="HungryGames-ForcedOutcome.html">HungryGames~ForcedOutcome</a></li><li><a href="HungryGames-Game.html">HungryGames~Game</a></li><li><a href="HungryGames-Grammar.html">HungryGames~Grammar</a></li><li><a href="HungryGames-GuildGame.html">HungryGames~GuildGame</a></li><li><a href="HungryGames-MemberAction.html">HungryGames~MemberAction</a></li><li><a href="HungryGames-Messages.html">HungryGames~Messages</a></li><li><a href="HungryGames-NormalEvent.html">HungryGames~NormalEvent</a></li><li><a href="HungryGames-OutcomeProbabilities.html">HungryGames~OutcomeProbabilities</a></li><li><a href="HungryGames-Player.html">HungryGames~Player</a></li><li><a href="HungryGames-Simulator.html">HungryGames~Simulator</a></li><li><a href="HungryGames-Simulator-Worker.html">HungryGames~Simulator~Worker</a></li><li><a href="HungryGames-StatGroup.html">HungryGames~StatGroup</a></li><li><a href="HungryGames-StatManager.html">HungryGames~StatManager</a></li><li><a href="HungryGames-Stats.html">HungryGames~Stats</a></li><li><a href="HungryGames-Team.html">HungryGames~Team</a></li><li><a href="HungryGames-UserIconUrl.html">HungryGames~UserIconUrl</a></li><li><a href="HungryGames-WeaponEvent.html">HungryGames~WeaponEvent</a></li><li><a href="Images.html">Images</a></li><li><a href="Main.html">Main</a></li><li><a href="MainModule.html">MainModule</a></li><li><a href="MemWatcher.html">MemWatcher</a></li><li><a href="MessageMaker.html">MessageMaker</a></li><li><a href="Messages.html">Messages</a></li><li><a href="Moderation.html">Moderation</a></li><li><a href="ModLog.html">ModLog</a></li><li><a href="ModLog-Settings.html">ModLog~Settings</a></li><li><a href="Music.html">Music</a></li><li><a href="NPC.html">NPC</a></li><li><a href="Patreon.html">Patreon</a></li><li><a href="Patreon-toExport.html">Patreon~toExport</a></li><li><a href="Pets.html">Pets</a></li><li><a href="Pets-BaseMoves.html">Pets~BaseMoves</a></li><li><a href="Pets-BasePetClasses.html">Pets~BasePetClasses</a></li><li><a href="Pets-BasePets.html">Pets~BasePets</a></li><li><a href="Pets-Constants.html">Pets~Constants</a></li><li><a href="Pets-NPC.html">Pets~NPC</a></li><li><a href="Pets-Pet.html">Pets~Pet</a></li><li><a href="Polling.html">Polling</a></li><li><a href="Polling-Poll.html">Polling~Poll</a></li><li><a href="RaidBlock.html">RaidBlock</a></li><li><a href="RaidBlock-RaidSettings.html">RaidBlock~RaidSettings</a></li><li><a href="RoleColors.html">RoleColors</a></li><li><a href="RoleManager.html">RoleManager</a></li><li><a href="Sandbox.html">Sandbox</a></li><li><a href="ShardingMaster.html">ShardingMaster</a></li><li><a href="ShardingMaster.ShardInfo.html">ShardingMaster.ShardInfo</a></li><li><a href="ShardingMaster.ShardMasterConfig.html">ShardingMaster.ShardMasterConfig</a></li><li><a href="ShardingMaster.ShardMasterConfig.HeartbeatConfig.html">ShardingMaster.ShardMasterConfig.HeartbeatConfig</a></li><li><a href="ShardingMaster.ShardMasterConfig.MailConfig.html">ShardingMaster.ShardMasterConfig.MailConfig</a></li><li><a href="ShardingMaster.ShardStatus.html">ShardingMaster.ShardStatus</a></li><li><a href="ShardingSlave.html">ShardingSlave</a></li><li><a href="SMLoader.html">SMLoader</a></li><li><a href="SpikeyBot.html">SpikeyBot</a></li><li><a href="Spotify.html">Spotify</a></li><li><a href="Strings.html">Strings</a></li><li><a href="Strings-Locale.html">Strings~Locale</a></li><li><a href="SubModule.html">SubModule</a></li><li><a href="TicTacToe.html">TicTacToe</a></li><li><a href="TicTacToe_Game.html">TicTacToe#Game</a></li><li><a href="TTS.html">TTS</a></li><li><a href="Twitch.html">Twitch</a></li><li><a href="Uno.html">Uno</a></li><li><a href="Uno_Card.html">Uno#Card</a></li><li><a href="Uno_Game.html">Uno#Game</a></li><li><a href="WebAccount.html">WebAccount</a></li><li><a href="WebApi.html">WebApi</a></li><li><a href="WebProxy.html">WebProxy</a></li><li><a href="WebSettings.html">WebSettings</a></li><li><a href="WebStats.html">WebStats</a></li><li><a href="WebUserData.html">WebUserData</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="global.html#__stack">__stack</a></li><li><a href="global.html#_handler">_handler</a></li><li><a href="global.html#_saveData">_saveData</a></li><li><a href="global.html#addListener">addListener</a></li><li><a href="global.html#clearEvent">clearEvent</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createProxyServer">createProxyServer</a></li><li><a href="global.html#createRightProxy">createRightProxy</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#hasPort">hasPort</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#self">self</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#sqlCon">sqlCon</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#unhandledRejection">unhandledRejection</a></li><li><a href="global.html#useColors">useColors</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="externals.list.html" class="dropdown-toggle" data-toggle="dropdown">Externals<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="external-Discord.html">Discord</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: src/smLoader.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">// Copyright 2018-2020 Campbell Crowley. All rights reserved.
// Author: Campbell Crowley (dev@campbellcrowley.com)
const fs = require('fs');
const childProcess = require('child_process');
require('./mainModule.js')(SMLoader); // Extends the MainModule class.

/**
 * @classdesc Manages loading, unloading, and reloading of all SubModules.
 * @class
 * @augments MainModule
 */
function SMLoader() {
  const self = this;
  /** @inheritdoc */
  this.myName = 'SMLoader';

  /** @inheritdoc */
  this.import = function(data) {
    if (!data) return;
    subModules = data.subModules;
    subModuleNames = data.subModuleNames;
  };
  /** @inheritdoc */
  this.export = function() {
    const output = {
      subModules: subModules,
      subModuleNames: subModuleNames,
    };
    subModules = null;
    subModuleNames = null;
    return output;
  };
  /** @inheritdoc */
  this.terminate = function() {
    for (const i in subModules) {
      if (subModules[i] &amp;&amp; subModules[i].end) {
        subModules[i].end();
      }
    }
  };
  /** @inheritdoc */
  this.initialize = function() {
    self.command.on('reload', commandReload);
    self.command.on('unload', commandUnload);
    self.command.on('load', commandLoad);
    self.command.on(
        new self.command.SingleCommand(['help', 'commands'], commandHelp));

    Object.assign(self.bot, toAssign.bot);
    Object.assign(self.client, toAssign.client);

    self.common.readAndParse(smListFilename, (err, parsed) => {
      if (err) {
        self.error(
            'Failed to read list of subModules from file: ' + smListFilename);
        console.error(err);
        return;
      }
      goalSubModuleNames = parsed[self.bot.getFullBotName()];
      if (!goalSubModuleNames) {
        self.error(
            'Unable to find subModule list for bot: (' +
            self.bot.getFullBotName() + ') ' + smListFilename);
        goalSubModuleNames = parsed['FALLBACK'];
        return;
      }
      self.reload();
    });
    if (self.client.shard) {
      /* eslint-disable no-unused-vars */
      /**
       * Receive message from another shard asking for us to reload subModules.
       *
       * @see {@link SMLoader~shardReload}
       *
       * @private
       */
      self.client.commandReload = shardReload;
      /**
       * Receive message from another shard asking for us to unload subModules.
       *
       * @see {@link SMLoader~shardUnload}
       *
       * @private
       */
      self.client.commandUnload = shardUnload;
      /**
       * Receive message from another shard asking for us to load subModules.
       *
       * @see {@link SMLoader~shardLoad}
       *
       * @private
       */
      self.client.commandLoad = shardLoad;
      /* eslint-enable no-unused-vars */
    }
  };
  this.shutdown = function() {
    self.command.removeListener('reload');
    self.command.removeListener('unload');
    self.command.removeListener('load');
    self.command.removeListener('help');

    if (self.client.shard) {
      self.client.commandReload = null;
      self.client.commandUnload = null;
      self.client.commandLoad = null;
    }
  };
  /** @inheritdoc */
  this.unloadable = function() {
    return subModuleNames.findIndex((el) => !subModules[el].unloadable()) &lt; 0;
  };
  /** @inheritdoc */
  this.save = function(...args) {
    for (const i in subModules) {
      if (subModules[i] &amp;&amp; subModules[i].save) {
        const start = Date.now();
        subModules[i].save.apply(null, args);
        const delta = Date.now() - start;
        if (delta > 10) {
          this.common.logWarning(
              i + ' took an excessive ' + delta + 'ms to start saving data!');
        }
      }
    }
  };

  /**
   * @description Timeout for delay to save SMList.
   * @private
   * @type {?Timeout}
   * @default
   */
  let saveTimeout = null;

  /**
   * @description Save the current goal submodules to file.
   * @private
   * @param {boolean} [force=false] Force immediately saving instead of delaying
   *     a bit.
   */
  function saveSMList(force) {
    if (!force) {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => saveSMList(true), 1000);
      return;
    }
    self.common.readAndParse(smListFilename, (err, parsed) => {
      if (err) {
        self.error('Failed to save SM List!');
        console.error(err);
        return;
      }
      parsed[self.bot.getFullBotName()] = goalSubModuleNames;
      self.common.mkAndWriteSync(
          smListFilename, null, JSON.stringify(parsed, null, 2));
    });
  }

  /**
   * Properties to merge into other objects. `bot` is merged into self.bot,
   * `client` is merged into self.client.
   *
   * @private
   * @type {Class}
   */
  const toAssign = {bot: {}, client: {}};

  /**
   * The filename storing the list of all SubModules to load.
   *
   * @private
   * @constant
   * @default
   * @type {string}
   */
  const smListFilename = './subModules.json';

  /**
   * The list of all submodule names currently loaded.
   *
   * @private
   * @type {string[]}
   */
  let subModuleNames = [];
  /**
   * The list of all submodules that we are intended to have loaded currently.
   * This should reflect the file at {@link SMloader~smListFilename}. Null means
   * the data is not available, and no action should be taken.
   *
   * @private
   * @type {null|string[]}
   */
  let goalSubModuleNames = null;
  /**
   * Instances of SubModules currently loaded mapped by their name.
   *
   * @private
   * @type {object.&lt;SubModule>}
   */
  let subModules = {};

  /**
   * Timeouts for retrying to unload submodules that are currently not in an
   * unloadable state. Mapped by name of submodule.
   *
   * @private
   * @type {object.&lt;Timeout>}
   */
  const unloadTimeouts = {};

  /**
   * Callbacks for when a scheduled module to unload, has been unloaded. Mapped
   * by name of subModule, then array of all callbacks.
   *
   * @private
   * @type {object.&lt;Array.&lt;Function>>}
   */
  const unloadCallbacks = {};

  /**
   * Discord IDs that are allowed to reboot the bot.
   *
   * @private
   * @type {string[]}
   * @constant
   */
  const trustedIds = [
    '124733888177111041',  // Me
    '126464376059330562',  // Rohan
  ];

  /**
   * The message sent to the channel where the user asked for help.
   *
   * @private
   * @type {string}
   * @constant
   */
  const helpmessagereply = 'I sent you a DM with commands!';
  /**
   * The message sent to the channel where the user asked to be DM'd, but we
   * were unable to deliver the DM.
   *
   * @private
   * @type {string}
   * @constant
   */
  const blockedmessage =
      'I couldn\'t send you a message, you probably blocked me :(';

  /**
   * @description Get array of all submodule names and the commit they were last
   * loaded from.
   *
   * @public
   * @returns {Array.&lt;{name: string, commit: string}>} Array of submodule names
   * and commit short hashes.
   */
  toAssign.bot.getSubmoduleCommits = function() {
    return subModuleNames.map((el) => {
      return {name: el, commit: subModules[el].commit || 'Unknown'};
    });
  };

  /**
   * @description Get a reference to a submodule with the given name.
   *
   * @public
   * @param {string} name The name of the submodule.
   * @returns {?SubModule} Reference to the currently loaded submodule with the
   * given name, or null if not loaded.
   */
  toAssign.bot.getSubmodule = function(name) {
    if (!subModules[name]) {
      return null;
    }
    return subModules[name];
  };

  /**
   * Unloads submodules that is currently loaded.
   *
   * @public
   *
   * @param {string} name Specify submodule to unload. If it is already
   * unloaded, it will be ignored and return successful.
   * @param {object} [opts] Options object.
   * @param {boolean} [opts.schedule=true] Automatically re-schedule unload for
   * submodule if it is in an unloadable state.
   * @param {boolean} [opts.ignoreUnloadable=false] Force a submodule to unload
   * even if it is not in an unloadable state.
   * @param {boolean} [opts.updateGoal=true] Update the goal state of the
   * subModule to unloaded.
   * @param {Function} [cb] Callback to fire once the operation is complete.
   * Single parameter is null if success, or string if error.
   */
  this.unload = function(name, opts, cb) {
    if (!opts) {
      opts = {
        schedule: true,
        updateGoal: true,
        ignoreUnloadable: false,
        reloading: false,
      };
    } else {
      if (opts.schedule == null) opts.schedule = true;
      if (opts.updateGoal == null) opts.updateGoal = true;
    }
    const sm = subModules[name];
    if (!sm) {
      const nameIndex = subModuleNames.findIndex((el) => el == name);
      if (nameIndex >= 0) {
        self.error(
            'Unloaded module still exists in list of names!' +
            ' This should not happen!');
        subModuleNames.splice(nameIndex, 1);
      }
      cb(null);
      return;
    }
    if (!opts.ignoreUnloadable) {
      if (!sm.unloadable() ||
          (opts.reloading &amp;&amp; (sm.reloadable &amp;&amp; !sm.reloadable()))) {
        if (opts.schedule) {
          if (unloadTimeouts[name]) {
            if (!unloadCallbacks[name]) unloadCallbacks[name] = [];
            unloadCallbacks[name].push(cb);
          } else {
            unloadTimeouts[name] = setTimeout(function() {
              delete unloadTimeouts[name];
              self.unload(name, opts, cb);
            }, 10000);
          }
        } else {
          cb('Not Unloadable');
        }
        return;
      }
    }
    try {
      if (subModules[name].save) {
        subModules[name].save();
      } else {
        self.error('Submodule ' + name + ' does not have a save() function.');
      }
      if (subModules[name].end) {
        subModules[name].end();
      } else {
        self.error('Submodule ' + name + ' does not have an end() function.');
      }
    } catch (err) {
      self.error('Error on unloading ' + name);
      console.log(err);
    }
    let message;
    try {
      delete require.cache[require.resolve(name)];
      const index = subModuleNames.findIndex((el) => el == name);
      if (index &lt; 0) {
        self.error(
            'Failed to find submodule name in list of loaded submodules! ' +
            name);
        console.log(subModuleNames);
      } else {
        subModuleNames.splice(index, 1);
      }
      if (opts.updateGoal) {
        const goalIndex = goalSubModuleNames.findIndex((el) => el == name);
        if (goalIndex &lt; 0) {
          self.error(
              'Failed to find submodule name in list of goal submodules! ' +
              name);
          console.log(goalSubModuleNames);
        } else {
          goalSubModuleNames.splice(goalIndex, 1);
        }
      }
      delete subModules[name];
      message = null;
    } catch (err) {
      self.error('Failed to clear: ' + name);
      console.log(err);
      message = 'Failed to Unload';
    }
    saveSMList();
    cb(message);
    if (unloadCallbacks[name]) {
      unloadCallbacks[name].splice(0).forEach((el) => {
        el(message);
      });
    }
  };
  /**
   * Loads submodules from file.
   *
   * @public
   *
   * @param {string} name Specify submodule to load. If it is already loaded,
   * they will be ignored and return successful.
   * @param {object} [opts] Options object.
   * @param {boolean} [opts.updateGoal=true] Update the goal state of the
   * subModule to loaded.
   * @param {Function} [cb] Callback to fire once the operation is complete.
   * Single parameter is null if success, or string if error.
   */
  this.load = function(name, opts, cb) {
    if (!opts) {
      opts = {updateGoal: true};
    } else {
      if (opts.updateGoal == null) opts.updateGoal = true;
    }
    if (subModules[name]) {
      if (opts.updateGoal &amp;&amp; !goalSubModuleNames.includes(name)) {
        goalSubModuleNames.push(name);
      }
    }
    try {
      subModules[name] = require(name);
      subModules[name].modifiedTime = fs.statSync(__dirname + '/' + name).mtime;
      if (subModuleNames.includes(name)) {
        self.error(
            'Submodule that is not loaded already exists in list of ' +
            'loaded names! This should not happen!');
      } else {
        subModuleNames.push(name);
      }
      if (opts.updateGoal &amp;&amp; !goalSubModuleNames.includes(name)) {
        goalSubModuleNames.push(name);
      }
    } catch (err) {
      cb('Failed to Load');
      if (err.message.startsWith('Cannot find module')) {
        self.error(
            'Failed to load submodule: ' + name + ' (' + err.message + ')');
      } else {
        self.error('Failed to load submodule: ' + name);
        console.error(err);
      }
      return;
    }
    try {
      subModules[name].begin(
          self.Discord, self.client, self.command, self.common, self.bot);
    } catch (err) {
      self.error('Failed to initialize submodule: ' + name);
      console.error(err);
      delete require.cache[require.resolve(name)];
      cb('Failed to Initialize');
      return;
    }
    cb(null);
  };
  /**
   * @description Reloads submodules from file. Reloads currently loaded modules
   * if `name` is not specified. If a submodule is specified that is not loaded,
   * it will skip the unload step, bull will still be attempted to be loaded.
   * @public
   *
   * @param {?string|string[]} [name] Specify submodules to reload, or null to
   * reload all submodules to their goal state.
   * @param {object} [opts] Options object.
   * @param {boolean} [opts.schedule=true] Automatically re-schedule reload for
   * submodules if they are not in an unloadable state.
   * @param {boolean} [opts.ignoreUnloadable=false] Force a submodule to unload
   * even if it is not in an unloadable state.
   * @param {boolean} [opts.force=false] Reload a submodule even if the
   * currently loaded version is identical to the version on file. If false it
   * will not be reloaded if the version would not be changed due to a reload.
   * @param {Function} [cb] Callback to fire once the operation is complete.
   * Single parameter has array of strings of status of each module attempted to
   * be reloaded.
   */
  this.reload = function(name, opts, cb) {
    if (typeof cb !== 'function') cb = function() {};
    if (typeof name === 'string') name = [name];
    if (!name || name.length === 0) name = goalSubModuleNames;
    if (!Array.isArray(name) || name.length === 0) {
      cb([]);
      return;
    }
    if (!opts) {
      opts = {schedule: true, force: false, ignoreUnloadable: false};
    } else if (opts.schedule == null) {
      opts.schedule = true;
    }
    opts.reloading = true;
    opts.updateGoal = false;

    const numTotal = name.length;
    let numComplete = 0;
    const output = [];
    for (let i = 0; i &lt; numTotal; i++) {
      if (!opts.force &amp;&amp; subModules[name[i]]) {
        try {
          const mtime = fs.statSync(`${__dirname}/${name[i]}`).mtime;
          // For some reason, directly comparing these two for equality does not
          // work.
          if (mtime - subModules[name[i]].modifiedTime == 0) {
            output.push(`~~${name[i]}~~`);
            done();
            continue;
          }
        } catch (err) {
          self.error(
              'Failed to stat submodule: ' + __dirname + '/' + name[i]);
          console.error(err);
          output.push('(' + name[i] + ': failed to stat)');
        }
      }
      reloadSingle(name[i]);
    }
    /**
     * Actually trigger the reload process for a single submodule.
     *
     * @private
     * @param {string} name The submodule name to reload.
     */
    function reloadSingle(name) {
      self.unload(name, opts, (err) => {
        if (err) {
          output.push(`${name}: ${err}`);
          done();
          return;
        }
        self.load(name, opts, (err2) => {
          if (err2) {
            output.push(`${name}: ${err2}`);
            done();
            return;
          }
          output.push(`${name}: \`Success\``);
          done();
        });
      });
    }
    /**
     * Called when a submodule's reload process is completed. Fires main
     * callback once all submodules reloads have been completed.
     *
     * @private
     */
    function done() {
      numComplete++;
      if (numComplete != numTotal) return;
      cb(output);
    }
  };

  /**
   * Reload all sub modules by unloading then re-requiring.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#reload
   */
  function commandReload(msg) {
    if (trustedIds.includes(msg.author.id)) {
      if (self.client.shard) {
        const message = encodeURIComponent(msg.text);
        self.client.shard.broadcastEval(
            `this.commandReload("${message}",${self.client.shard.ids[0]})`);
      }
      let toReload = msg.text.split(' ').splice(1);
      const opts = {};
      toReload = toReload.filter((el) => {
        switch (el) {
          case '--force':
            opts.force = true;
            return false;
          case '--no-schedule':
            opts.ignoreUnloadable = true;
            return false;
          case '--immediate':
            opts.schedule = false;
            return false;
          default:
            return true;
        }
      });
      self.common
          .reply(
              msg, 'Reloading modules... (waiting until users ' +
                  'won\'t notice interruption)')
          .then((warnMessage) => {
            self.reload(toReload, opts, (out) => {
              const embed = new self.Discord.MessageEmbed();
              embed.setTitle('Reload complete.');
              embed.setColor([255, 0, 255]);
              embed.setDescription(out.join('\n') || 'NOTHING reloaded');
              warnMessage.edit(self.common.mention(msg), embed);
            });
          });
    } else {
      self.common.reply(
          msg, 'LOL! Good try!',
          'It appears SpikeyRobot doesn\'t trust you enough with this ' +
              'command. Sorry!');
    }
  }

  /**
   * @description Other shard has requested a reload command.
   * @private
   * @param {string} message The command message to parse.
   * @param {number} id Shard id requesting this.
   */
  function shardReload(message, id) {
    if (id == self.client.shard.ids[0]) return;
    let toReload = decodeURIComponent(message).split(' ').splice(1);
    const opts = {};
    toReload = toReload.filter((el) => {
      switch (el) {
        case '--force':
          opts.force = true;
          return false;
        case '--no-schedule':
          opts.ignoreUnloadable = true;
          return false;
        case '--immediate':
          opts.schedule = false;
          return false;
        default:
          return true;
      }
    });
    self.reload(toReload, opts, () => {});
  }
  /**
   * @description Other shard has requested an unload command.
   * @private
   * @param {string} message The command message to parse.
   * @param {number} id Shard id requesting this.
   */
  function shardUnload(message, id) {
    if (id == self.client.shard.ids[0]) return;
    let toUnload = decodeURIComponent(message).split(' ').splice(1);
    const opts = {};
    toUnload = toUnload.filter((el) => {
      switch (el) {
        case 'force':
          opts.force = true;
          return false;
        case 'no-schedule':
          opts.ignoreUnloadable = true;
          return false;
        case 'immediate':
          opts.schedule = false;
          return false;
        default:
          return true;
      }
    });
    for (let i = 0; i &lt; toUnload.length; i++) {
      self.unload(toUnload[i], opts, () => {});
    }
  }
  /**
   * @description Other shard has requested a load command.
   * @private
   * @param {string} message The command message to parse.
   * @param {number} id Shard id requesting this.
   */
  function shardLoad(message, id) {
    if (id == self.client.shard.ids[0]) return;
    const toLoad = decodeURIComponent(message).split(' ').splice(1);
    for (let i = 0; i &lt; toLoad.length; i++) {
      self.load(toLoad[i], null, () => {});
    }
  }

  /**
   * Unload specific sub modules.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#unload
   */
  function commandUnload(msg) {
    if (trustedIds.includes(msg.author.id)) {
      if (self.client.shard) {
        const message = encodeURIComponent(msg.text);
        self.client.shard.broadcastEval(
            `this.commandUnload("${message}",${self.client.shard.ids[0]})`);
      }
      let toUnload = msg.text.split(' ').splice(1);
      const opts = {};
      toUnload = toUnload.filter((el) => {
        switch (el) {
          case 'force':
            opts.force = true;
            return false;
          case 'no-schedule':
            opts.ignoreUnloadable = true;
            return false;
          case 'immediate':
            opts.schedule = false;
            return false;
          default:
            return true;
        }
      });
      self.common.reply(msg, 'Unloading modules...').then((warnMessage) => {
        const numTotal = toUnload.length;
        let numComplete = 0;
        const outs = [];
        for (let i = 0; i &lt; numTotal; i++) {
          unloadSingle(toUnload[i]);
        }
        /**
         * Begins actually loading a module.
         *
         * @private
         *
         * @param {string} name The name of the module.
         */
        function unloadSingle(name) {
          self.unload(name, opts, (out) => {
            outs.push(name + ': ' + (out || 'Success'));
            done();
          });
        }
        /**
         * Triggered on each completed action.
         *
         * @private
         */
        function done() {
          numComplete++;
          if (numComplete &lt; numTotal) return;
          const embed = new self.Discord.MessageEmbed();
          embed.setTitle('Unload complete.');
          embed.setColor([255, 0, 255]);
          embed.setDescription(outs.join(' ') || 'NOTHING unloaded');
          warnMessage.edit(self.common.mention(msg), embed);
        }
        if (numTotal == 0) done();
      });
    } else {
      self.common.reply(
          msg, 'LOL! Good try!',
          'It appears SpikeyRobot doesn\'t trust you enough with this ' +
              'command. Sorry!');
    }
  }

  /**
   * Load specific sub modules.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#load
   */
  function commandLoad(msg) {
    if (trustedIds.includes(msg.author.id)) {
      if (self.client.shard) {
        const message = encodeURIComponent(msg.text);
        self.client.shard.broadcastEval(
            `this.commandLoad("${message}",${self.client.shard.ids[0]})`);
      }
      const toLoad = msg.text.split(' ').splice(1);
      self.common.reply(msg, 'Loading modules...').then((warnMessage) => {
        const numTotal = toLoad.length;
        let numComplete = 0;
        const outs = [];
        for (let i = 0; i &lt; numTotal; i++) {
          loadSingle(toLoad[i]);
        }
        /**
         * Begins actually loading a module.
         *
         * @private
         * @param {string} name The name of the subModule.
         */
        function loadSingle(name) {
          self.load(name, null, (out) => {
            outs.push(name + ': ' + (out || 'Success'));
            done();
          });
        }
        /**
         * Triggered on each completed action.
         *
         * @private
         */
        function done() {
          numComplete++;
          if (numComplete &lt; numTotal) return;
          const embed = new self.Discord.MessageEmbed();
          embed.setTitle('Load complete.');
          embed.setColor([255, 0, 255]);
          embed.setDescription(outs.join(' ') || 'NOTHING loaded');
          warnMessage.edit(self.common.mention(msg), embed);
        }
        if (numTotal == 0) done();
      });
    } else {
      self.common.reply(
          msg, 'LOL! Good try!',
          'It appears SpikeyRobot doesn\'t trust you enough with this ' +
              'command. Sorry!');
    }
  }

  /**
   * Send help message to user who requested it.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#help
   */
  function commandHelp(msg) {
    let error = false;
    /**
     * Send the help message.
     *
     * @private
     * @param {Discord~MessageEmbed} help THe message to send.
     */
    function send(help) {
      msg.author.send(help).catch((err) => {
        if (msg.guild !== null &amp;&amp; !error) {
          error = true;
          self.common
              .reply(
                  msg, 'Oops! I wasn\'t able to send you the help!\n' +
                      'Did you block me?',
                  err.message)
              .catch(() => {});
          self.error(
              'Failed to send help message in DM to user: ' + msg.author.id +
              ' ' + help.title);
          console.error(err);
        }
      });
    }
    try {
      for (const i in subModules) {
        if (!(subModules[i] instanceof Object) || !subModules[i].helpMessage) {
          continue;
        }
        if (!Array.isArray(subModules[i].helpMessage)) {
          subModules[i].helpMessage = [subModules[i].helpMessage];
        }
        subModules[i].helpMessage.forEach(send);
      }
      if (msg.guild !== null) {
        self.common
            .reply(
                msg, helpmessagereply,
                'Tip: https://www.spikeybot.com/help/ also has more ' +
                    'information.')
            .catch((err) => {
              self.error(
                  'Unable to reply to help command in channel: ' +
                  msg.channel.id);
              console.log(err);
            });
      }
    } catch (err) {
      self.common.reply(msg, blockedmessage);
      self.error('An error occured while sending help message!');
      console.error(err);
    }
  }

  /**
   * Get a list of the current SubModules intended to be loaded.
   *
   * @public
   * @returns {string[]} Array of the names of the SubModules (ex:
   * './connect4.js').
   */
  toAssign.bot.getGoalSubModules = function() {
    return goalSubModuleNames.slice(0);
  };

  /**
   * Check current loaded submodule commit to last modified commit, and reload
   * if the file has changed.
   *
   * @public
   */
  toAssign.client.reloadUpdatedSubModules = function() {
    try {
      self.log('Reloading updated submodules.');
      for (let i = 0; i &lt; subModuleNames.length; i++) {
        childProcess
            .exec(
                'git diff-index --quiet ' +
                subModules[subModuleNames[i]].commit + ' -- ./src/' +
                subModuleNames[i])
            .on('close', ((name) => {
              return (code) => {
                if (code) {
                  self.reload(
                      name, {force: true}, (out) => self.log(out.join(' ')));
                } else {
                  self.debug(`${name} unchanged (${code})`);
                }
              };
            })(subModuleNames[i]));
      }
    } catch (err) {
      self.error('Failed to reload updated submodules!');
      console.error(err);
    }
  };
}
module.exports = new SMLoader();
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	<small>Website Contact: <a href="mailto:web@spikeybot.com">web@spikeybot.com</a>.</small><br><small>&copy; Copyright 2019-2020, Campbell Crowley. <a href="https://docs.google.com/document/d/1SAC2aPxxeNqRjlZzjwrnCyyWWyt09ZP-AP7BDBjjQDg/edit?usp=sharing">Privacy Policy</a></small>
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
	
		on Saturday, June 6, 2020 12:49 PM (-07:00)
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->

<script>
	(function ( i, s, o, g, r, a, m ) {
		i['GoogleAnalyticsObject'] = r;
		i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push( arguments )
		}, i[r].l = 1 * new Date();
		a = s.createElement( o ),
			m = s.getElementsByTagName( o )[0];
		a.async = 1;
		a.src = g;
		m.parentNode.insertBefore( a, m )
	})( window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga' );

	ga( 'create', 'UA-89923351-1', 'www.spikeybot.com' );
	ga( 'send', 'pageview' );
</script>



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
