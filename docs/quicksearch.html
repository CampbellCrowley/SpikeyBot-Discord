<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"common.js.html":{"id":"common.js.html","title":"Source: common.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: common.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const dateFormat = require('dateformat'); const Discord = require('discord.js'); const fs = require('fs'); const mkdirp = require('mkdirp'); const sql = require('mysql'); const auth = require('../auth.js'); /** * Commonly required things. Helper functions and constants. * * @class */ function Common() { const self = this; /** * The number of characters reserved for the filename of the script. * @private * @constant * @type {number} * @default */ const prefixLength = 14; /** * The color code to prefix log messages with for this script. * @private * @type {number} * @default */ let mycolor = 0; /** * The script's filename to show in the log. * @private * @type {string} * @constant */ const app = process.argv[1] ? process.argv[1].substring(process.argv[1].lastIndexOf('/') + 1) : ''; /** * The final formatted filename for logging. * @private * @type {string} */ let title; /** * Whether this should be shown as a release version, or a debug version in * the log. * @type {boolean} */ this.isRelease = false; /** * Whether this current instance is running as a unit test. * @type {boolean} */ this.isTest = false; /** * Initialize variables and settings for logging properly. * * @param {boolean} isTest Is this running as a test. * @param {boolean} isRelease Is this a release version, or a development * version of the app running. */ this.begin = function(isTest, isRelease) { self.isRelease = isRelease || false; self.isTest = isTest || false; switch (app) { case 'SpikeyBot.js': mycolor = 44; break; } let temptitle = app; if (self.isRelease) temptitle = 'R' + temptitle; else temptitle = 'D' + temptitle; for (let i = temptitle.length; i &lt; prefixLength; i++) { temptitle += ' '; } if (temptitle.length &gt; prefixLength) { temptitle = temptitle.substring(0, prefixLength); } temptitle += ' '; title = temptitle; self.log(app + ' Begin'); }; /** * Pad an IP address with zeroes. * * @param {number} str The ipv4 address as a string to format. * @returns {string} The padded address. */ this.padIp = function(str) { const dM = str.match(/\\./g); const cM = str.match(/:/g); if (dM &amp;&amp; dM.length == 3) { const res = str.split('.'); for (let i = 0; i &lt; res.length; i++) { res[i] = ('000' + res[i]).slice(-3); res[i] = res[i].replace(':', '0'); } str = res.join('.'); } else if (cM &amp;&amp; cM.length == 7) { const res = str.split(':'); for (let i = 0; i &lt; res.length; i++) { res[i] = ('0000' + res[i]).slice(-4); // res[i] = res[i].replace(':', '0'); } str = res.join(':'); } for (let i = str.length; i &lt; 45; i++) { str += ' '; } return str.substring(0, 45); }; /** * Formats a given IP address by padding with zeroes, or completely replacing * with a human readable alias if the address is a known location. * * @param {string} ip The ip address to format. * @returns {string} The formmatted address. */ this.getIPName = function(ip) { ip = self.padIp(ip); switch (ip) { default: return ip; case '': case ' ': case '127.000.000.001': return 'SELF '; case '205.167.046.140': case '205.167.046.157': case '205.167.046.15': case '204.088.159.118': return 'MVHS '; } }; /** * Format a prefix for a log message or error. Includes the ip before the * message. * * @param {string} ip The ip to include in the prefix. * @returns {string} The formatted prefix for a log message. */ this.updatePrefix = function(ip) { if (typeof ip === 'undefined') { ip = ' '; } const formattedIP = self.getIPName(ip.replace('::ffff:', '')); const date = dateFormat(new Date(), 'mm-dd HH:MM:ss'); return `[${title}${date} ${formattedIP}]:`; }; /** * Write the final portion of the log message. * * @private * @param {string} prefix The first characters on the line. * @param {string} message The message to display. * @param {string} ip The IP address or unique identifier of the client that * caused this event to happen. * @param {number} [traceIncrease=0] Increase the distance up the stack to * show the in the log. */ function write(prefix, message, ip, traceIncrease = 0) { const output = [prefix]; output.push(getTrace(traceIncrease + 1)); if (self.isRelease) { output.push(`${self.updatePrefix(ip)}\\x1B[;${mycolor}m`); } else { output.push(`\\x1B[;${mycolor}m${self.updatePrefix(ip)}`); } message = message.toString().replace(/\\n/g, '\\\\n'); output.push(` ${message}`); output.push('\\x1B[1;0m\\n'); process.stdout.write(output.join('')); } /** * Format a log message to be logged. Prefixed with DBG. * * @param {string} message The message to display. * @param {string} ip The IP address or unique identifier of the client that * caused this event to happen. * @param {number} [traceIncrease=0] Increase the distance up the stack to * show the in the log. */ this.logDebug = function(message, ip, traceIncrease = 0) { write('DBG:', message, ip, traceIncrease); }; /** * Format a log message to be logged. * * @param {string} message The message to display. * @param {string} ip The IP address or unique identifier of the client that * caused this event to happen. * @param {number} [traceIncrease=0] Increase the distance up the stack to * show the in the log. */ this.log = function(message, ip, traceIncrease = 0) { write('INF:', message, ip, traceIncrease); }; /** * Format a log message to be logged. Prefixed with WRN. * * @param {string} message The message to display. * @param {string} ip The IP address or unique identifier of the client that * caused this event to happen. * @param {number} [traceIncrease=0] Increase the distance up the stack to * show the in the log. */ this.logWarning = function(message, ip, traceIncrease = 0) { write('WRN:', message, ip, traceIncrease); }; /** * Format an error message to be logged. * * @param {string} message The message to display. * @param {string} ip The IP address or unique identifier of the client that * caused this event to happen. * @param {number} [traceIncrease=0] Increase the distance up the stack to * show the in the log. */ this.error = function(message, ip, traceIncrease = 0) { const output = ['ERR:']; message = `${message}`.replace(/\\n/g, '\\\\n'); output.push(getTrace(traceIncrease)); output.push('\\x1B[;31m'); output.push(`${self.updatePrefix(ip)} ${message}`); output.push('\\x1B[1;0m\\n'); process.stdout.write(output.join('')); }; /** * Replies to the author and channel of msg with the given message. * * @param {Discord~Message} msg Message to reply to. * @param {string} text The main body of the message. * @param {string} [post] The footer of the message. * @returns {?Promise} Promise of Discord~Message that we attempted to send, * or null if error occurred before attempting to send. */ this.reply = function(msg, text, post) { if (!msg.channel || !msg.channel.send) { return null; } const trace = getTrace(0); const perms = msg.channel.permissionsFor &amp;&amp; msg.channel.permissionsFor(msg.client.user); if (perms &amp;&amp; !perms.has('SEND_MESSAGES')) { self.logDebug( 'Failed to send reply to channel ' + msg.channel.id + ' due to lack of perms.', trace); if (msg.author) { msg.author .send( 'I was unable to send a message in #' + msg.channel.name + ' because I do not have permission to send messages there.') .catch(() =&gt; {}); } return new Promise((resolve, reject) =&gt; { reject(new Error('No Perms')); }); } if (self.isTest || (perms &amp;&amp; !perms.has('EMBED_LINKS'))) { return msg.channel .send(Common.mention(msg) + '\\n```\\n' + text + '\\n```' + (post || '')) .catch((err) =&gt; { self.error( 'Failed to send reply to channel: ' + msg.channel.id, trace); throw err; }); } else { const embed = new Discord.MessageEmbed(); embed.setColor([255, 0, 255]); if (text.length &lt;= 256) { embed.setTitle(text); if (post) { embed.setDescription(post); } } else { embed.setDescription(text + (post ? '\\n' + post : '')); } return msg.channel.send(Common.mention(msg), embed).catch((err) =&gt; { self.error( 'Failed to send embed reply to channel: ' + msg.channel.id, trace); throw err; }); } }; /** * Gets the name and line number of the current function stack. * * @private * * @param {number} [traceIncrease=0] Increase the distance up the stack to * show the in the log. * @returns {string} Formatted string with length 24. */ function getTrace(traceIncrease = 0) { if (typeof traceIncrease !== 'number') traceIncrease = 0; // let func = __function(traceIncrease) + ':' + __line(traceIncrease); let func = __filename(traceIncrease) + ':' + __line(traceIncrease); while (func.length &lt; 20) func += ' '; func = ('00000' + process.pid).slice(-5) + ' ' + func.substr(func.length - 20, 20); return func; } /** * Gets the line number of the function that called a log function. * * @private * @param {number} [inc=0] Increase distance up the stack to returns. * @returns {number} Line number of call in stack. */ function __line(inc = 0) { return __stack()[3 + inc].getLineNumber(); } /** * Gets the name of the function that called a log function. * * @private * @param {number} [inc=0] Increase distance up the stack to return. * @return {string} Function name in call stack. */ /* function __function(inc = 0) { return __stack()[3 + inc].getFunctionName(); } */ /** * Gets the name of the file that called a log function. * * @private * @param {number} [inc=0] Increase distance up the stack to returns. * @returns {string} Filename in call stack. */ function __filename(inc = 0) { return __stack()[3 + inc].getFileName(); } } /** * SpikeyRobot's Discord ID. If you are self-hosting SpikeyBot, change this to * your account ID to be able to give yourself full access to all features of * the bot. * * @type {string} * @default * @constant */ Common.prototype.spikeyId = '124733888177111041'; /** * SpikeyRobot's Discord ID * * @type {string} * @default * @constant */ Common.spikeyId = Common.prototype.spikeyId; /** * Discord IDs that are allowed to reboot the bot, and are overall trusted * individuals/accounts. * * @type {string[]} * @constant */ Common.prototype.trustedIds = [ Common.spikeyId, // Me '126464376059330562', // Rohan '479294447184773130', // DV0RAK ]; /** * Trusted IDs. * @see {@link Common.prototype.trustedIds} * * @constant * @type {string[]} */ Common.trustedIds = Common.prototype.trustedIds; /** * Format a Discord API error. * * @param {Discord~DiscordAPIError} e DiscordAPIError to format into a string. * @returns {string} Error formatted as single line string. */ Common.prototype.fmtDAPIErr = function(e) { const pid = `00000${process.pid}`.slice(-5); return `ERR:${pid} [ SpikeyBot.js ` + `${e.name}: ${e.message} ${e.method} ${e.code} (${e.path})`; }; /** * Format a Discord API error. * * @param {Discord~DiscordAPIError} e DiscordAPIError to format into a string. * @returns {string} Error formatted as single line string. */ Common.fmtDAPIErr = Common.prototype.fmtDAPIErr; /** * The channel id for the channel to send general log messages to. * * @default * @constant * @type {string} */ Common.prototype.logChannel = '473935520821673991'; /** * The channel id for the channel to send general log messages to. * * @default * @constant * @type {string} */ Common.logChannel = Common.prototype.logChannel; /** * The website base URL for pointing to for more help and documentation. * * @type {string} * @constant * @default */ Common.prototype.webURL = 'https://www.spikeybot.com/'; /** * The website base URL for pointing to for more help and documentation. * * @type {string} * @constant */ Common.webURL = Common.prototype.webURL; /** * The website path for more help and documentation. * * @type {string} * @constant * @default */ Common.prototype.webPath = 'help/'; /** * The website path for more help and documentation. * * @type {string} * @constant */ Common.webPath = Common.prototype.webPath; /** * The website full URL for commands help page. * * @type {string} * @constant * @default */ Common.prototype.webHelp = Common.webURL + Common.webPath; /** * The website full URL for commands help page. * * @type {string} * @constant */ Common.webHelp = Common.prototype.webHelp; /** * The root file directory for finding saved data related to individual * guilds. * * @type {string} * @constant * @default */ Common.prototype.guildSaveDir = './save/guilds/'; /** * The root file directory for finding saved data related to individual * guilds. * * @type {string} * @constant */ Common.guildSaveDir = Common.prototype.guildSaveDir; /** * The root file directory for finding saved data related to individual * users. * * @type {string} * @constant * @default */ Common.prototype.userSaveDir = './save/users/'; /** * The root file directory for finding saved data related to individual * users. * * @type {string} * @constant */ Common.userSaveDir = Common.prototype.userSaveDir; /** * Creates formatted string for mentioning the author of msg. * * @param {Discord~Message|Discord~UserResolvable} msg Message to format a * mention for the author of. * @returns {string} Formatted mention string. */ Common.prototype.mention = function(msg) { if (msg.author) { return `&lt;@${msg.author.id}&gt;`; } else if (msg.id) { return `&lt;@${msg.id}&gt;`; } }; /** * Creates formatted string for mentioning the author of msg. * * @param {Discord~Message} msg Message to format a mention for the author of. * @return {string} Formatted mention string. */ Common.mention = Common.prototype.mention; /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Async. * * @see {@link Common~mkAndWriteSync} * * @public * @static * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string|object} data The data to write to the file. * @param {Function} [cb] Callback to fire on completion. Only parameter is * optional error. */ Common.mkAndWrite = function(filename, dir, data, cb) { mkdirp(dir, (err) =&gt; { if (err) { if (err.code !== 'EEXIST') { if (this.error) this.error(`Failed to make directory: ${dir}`); console.error(err); if (typeof cb === 'function') cb(err); return; } } if (typeof data === 'object') data = JSON.stringify(data); fs.writeFile(filename, data, (err2) =&gt; { if (err2) { if (this.error) this.error(`Failed to save file: ${filename}`); console.error(err2); if (typeof cb === 'function') cb(err2); return; } if (typeof cb === 'function') cb(); }); }); }; Common.prototype.mkAndWrite = Common.mkAndWrite; /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Synchronous. * * @see {@link Common~mkAndWrite} * * @public * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ Common.mkAndWriteSync = function(filename, dir, data) { try { mkdirp.sync(dir); } catch (err) { if (this.error) this.error(`Failed to make directory: ${dir}`); console.error(err); return; } try { fs.writeFileSync(filename, data); } catch (err) { if (this.error) this.error(`Failed to save file: ${filename}`); console.error(err); return; } }; Common.prototype.mkAndWriteSync = Common.mkAndWriteSync; /** * Recursively freeze all elements of an object. * * @public * @param {object} object The object to deep freeze. * @returns {object} The frozen object. */ Common.deepFreeze = function(object) { const propNames = Object.getOwnPropertyNames(object); for (const name of propNames) { const value = object[name]; object[name] = value &amp;&amp; typeof value === 'object' ? Common.deepFreeze(value) : value; } return Object.freeze(object); }; Common.prototype.deepFreeze = Common.deepFreeze; /** * @description Convert a string in camelcase to a human readable spaces format. * (helloWorld --&gt; Hello World) * * @private * @param {string} str The input. * @returns {string} The output. */ Common.camelToSpaces = function(str) { return str.replace(/([A-Z])/g, ' $1').replace(/^./, function(str) { return str.toUpperCase(); }); }; Common.prototype.camelToSpaces = Common.camelToSpaces; /** * The object describing the connection with the SQL server. * * @global * @type {?sql.ConnectionConfig} */ global.sqlCon; /** * Create initial connection with sql server. The connection is injected into * the global scope as {@link sqlCon}. If a connection still exists, calling * this function just returns the current reference. * * @public * @param {boolean} [force=false] Force a new connection to be established. * @returns {sql.ConnectionConfig} Current sql connection object. */ Common.connectSQL = function(force = false) { if (global.sqlCon &amp;&amp; !force) return global.sqlCon; if (global.sqlCon &amp;&amp; global.sqlCon.end) global.sqlCon.end(); /* eslint-disable-next-line new-cap */ global.sqlCon = new sql.createConnection({ user: auth.sqlUsername, password: auth.sqlPassword, host: auth.sqlHost, database: 'appusers', port: 3306, }); global.sqlCon.on('error', (e) =&gt; { if (this.error) { this.error(e); } else { console.error(e); } if (e.fatal) { Common.connectSQL(true); } }); if (this.log) { this.log('SQL Connection created'); } else { console.log('SQL Connection created'); } return global.sqlCon; }; Common.prototype.connectSQL = Common.connectSQL; /* eslint-disable-next-line no-extend-native */ String.prototype.replaceAll = function(search, replacement) { const target = this; return target.replace(new RegExp(search, 'g'), replacement); }; /** * @description Gets the stack trace of the current function call. * * @private * @returns {Stack} Error stack for logging. */ function __stack() { const orig = Error.prepareStackTrace; Error.prepareStackTrace = function(_, stack) { return stack; }; const err = new Error(); /* eslint-disable-next-line no-caller */ Error.captureStackTrace(err, arguments.callee); const stack = err.stack; Error.prepareStackTrace = orig; return stack; } const oldErr = console.error; /** * @description Augment console.error to reformat DiscordAPIErrors to be more * pretty. * @param {*} args Arguments to pass through to console.error. */ console.error = function(...args) { if (args.length == 1 &amp;&amp; (args[0] instanceof Discord.DiscordAPIError)) { args[0] = Common.fmtDAPIErr(args[0]); } else if (typeof args[0] !== 'string' || !args[0].startsWith('ERR:')) { const pid = `00000${process.pid}`.slice(-5); oldErr(`ERR:${pid} [ SpikeyBot.js `, ...args); return; } oldErr(...args); }; module.exports = new Common(); × Search results Close "},"chatbot.js.html":{"id":"chatbot.js.html","title":"Source: chatbot.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: chatbot.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const dialogflow = require('dialogflow'); const auth = require('../auth.js'); const fs = require('fs'); const mkdirp = require('mkdirp'); require('./subModule.js').extend(ChatBot); // Extends the SubModule class. /** * @classdesc Manages natural language interaction. * @class * @augments SubModule * @listens Discord#message * @listens Command#chat */ function ChatBot() { const self = this; /** @inheritdoc */ this.myName = 'ChatBot'; /** * The guilds that have disabled the chatbot feature. * @private * @type {Object.&lt;boolean&gt;} */ const disabledChatBot = {}; /** @inheritdoc */ this.initialize = function() { self.command.on('chat', onChatMessage); self.command.on( new self.command.SingleCommand( 'togglechatbot', commandToggleChatBot, new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD | self.Discord.Permissions.FLAGS.BAN_MEMBERS, }))); self.client.on('message', onMessage); if (self.bot.getBotName()) { process.env.GOOGLE_APPLICATION_CREDENTIALS = './gApiCredentials-' + self.bot.getBotName() + '.json'; } else { process.env.GOOGLE_APPLICATION_CREDENTIALS = './gApiCredentials.json'; } sessionClient = new dialogflow.SessionsClient(); self.client.guilds.forEach(function(g) { fs.readFile( self.common.guildSaveDir + g.id + '/chatbot-config.json', function(err, file) { if (err) return; let parsed; try { parsed = JSON.parse(file); } catch (e) { return; } disabledChatBot[g.id] = parsed.disabledChatBot || false; }); }); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('chat'); self.command.deleteEvent('togglechatbot'); self.client.removeListener('message', onMessage); }; /** * @override * @inheritdoc */ this.save = function(opt) { self.client.guilds.forEach(function(g) { const dir = self.common.guildSaveDir + g.id; const filename = dir + '/chatbot-config.json'; const obj = { disabledChatBot: disabledChatBot[g.id], }; if (opt == 'async') { mkAndWrite(filename, dir, JSON.stringify(obj)); } else { mkAndWriteSync(filename, dir, JSON.stringify(obj)); } }); }; /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Async. * * @see {@link Main~mkAndWriteSync} * * @private * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ function mkAndWrite(filename, dir, data) { mkdirp(dir, function(err) { if (err) { self.error('Failed to make directory: ' + dir, 'Main'); console.error(err); return; } fs.writeFile(filename, data, function(err2) { if (err2) { self.error('Failed to save timer: ' + filename, 'Main'); console.error(err2); return; } }); }); } /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Synchronous. * * @see {@link Main~mkAndWrite} * * @private * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ function mkAndWriteSync(filename, dir, data) { try { mkdirp.sync(dir); } catch (err) { self.error('Failed to make directory: ' + dir, 'Main'); console.error(err); return; } try { fs.writeFileSync(filename, data); } catch (err) { self.error('Failed to save timer: ' + filename, 'Main'); console.error(err); return; } } let sessionClient; const reqTemplate = { session: 'default-session', queryInput: { text: { text: 'Hello World!', languageCode: 'en-US', }, }, }; /** * Respond to messages where I've been mentioned. * * @private * @param {Discord~Message} msg Message was sent. * @listens Discord#message */ function onMessage(msg) { if (!msg.author.bot &amp;&amp; msg.guild &amp;&amp; disabledChatBot[msg.guild.id]) return; msg.prefix = self.bot.getPrefix(msg.guild); if (!msg.author.bot &amp;&amp; msg.guild &amp;&amp; msg.mentions.users.get(self.client.user.id) &amp;&amp; !self.command.find(msg.content.match(/^\\S+/)[0], msg)) { const withoutMe = msg.content .replace( new RegExp('\\\\s*&lt;@!?' + self.client.user.id + '&gt;\\\\s*'), '') .trim(); if (!withoutMe || withoutMe.length &lt; 2) { return; } self.log(msg.channel.id + '@' + msg.author.id + ' ' + msg.content); msg.text = ' ' + msg.cleanContent .replace( new RegExp( '\\\\s*@' + escapeRegExp( msg.guild.me.nickname || self.client.user.username) + '\\\\s*', 'g'), ' SpikeyBot ') .trim(); onChatMessage(msg); } } /** * Send message text content to dialogflow for handling. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#chat */ function onChatMessage(msg) { if (msg.guild &amp;&amp; disabledChatBot[msg.guild.id]) return; const perms = (msg.channel.permissionsFor &amp;&amp; msg.channel.permissionsFor(self.client.user)); if (perms &amp;&amp; !perms.has(self.Discord.Permissions.FLAGS.SEND_MESSAGES)) { return; } if (!msg.text || msg.text.length &lt; 2) return; const request = Object.assign({}, reqTemplate); request.session = sessionClient.sessionPath( auth['dialogflowProjectId' + (self.bot.getBotName() || '')], msg.channel.id); request.queryInput.text.text = msg.text.slice(1); if (request.queryInput.text.text.length &gt; 256) { request.queryInput.text.text = request.queryInput.text.text.substr(0, 256); } // msg.channel.startTyping().catch(() =&gt; {}); const startTime = Date.now(); sessionClient.detectIntent(request) .then((responses) =&gt; { self.debug( 'Dialogflow response delay: ' + (Date.now() - startTime) + 'ms'); // msg.channel.stopTyping(); // console.log('Intent'); const result = responses[0].queryResult; if (result.parameters.fields.thing) { const list = result.parameters.fields.thing.listValue.values; const chosen = list[Math.floor(list.length * Math.random())].stringValue; result.fulfillmentText = result.fulfillmentText.replace(/~thing/g, chosen); } /* console.log(` Query: ${result.queryText}`); console.log(` Response: ${result.fulfillmentText}`); if (result.intent) { console.log(` Intent: ${result.intent.displayName}`); } else { console.log(` No intent matched.`); } */ if (result.fulfillmentText) { msg.channel.send(result.fulfillmentText.replace(/\\\\n/g, '\\n')) .catch((err) =&gt; { self.error( 'Unable to reply to chat message: ' + msg.channel.id); console.error(err); }); } if (result.parameters.fields.loopback) { msg.text = result.parameters.fields.loopback.stringValue; onChatMessage(msg); } if (result.parameters.fields.command) { let cmd = result.parameters.fields.command.stringValue.replace( /^command /, msg.prefix); // Replace parameters in the command with the values matched by // dialogflow. Object.entries(result.parameters.fields).forEach((el) =&gt; { if (el[0] == 'command') return; cmd = cmd.replace( new RegExp(escapeRegExp('$' + el[0]), 'g'), el[1].stringValue); }); self.log('Triggered command: ' + cmd); msg.content = cmd; if (!self.command.trigger(msg)) { self.warn('Command \"' + cmd + '\" failed!'); } } }) .catch((err) =&gt; { self.debug( 'Dialogflow response delay: ' + (Date.now() - startTime) + 'ms'); self.error('Dialogflow failed request: ' + JSON.stringify(request)); console.error('ERROR:', err); // msg.channel.stopTyping(); msg.channel.send('Failed to contact DialogFlow: ' + err.details); }); } /** * Toggles the chatbot feature on a guild. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#togglechatbot */ function commandToggleChatBot(msg) { if (disabledChatBot[msg.guild.id]) { disabledChatBot[msg.guild.id] = false; self.common.reply(msg, 'Enabled chatbot feature.'); } else { disabledChatBot[msg.guild.id] = true; self.common.reply(msg, 'Disabled chatbot feature.'); } } /** * Escape a given string to be passed into a regular expression. * * @private * * @param {string} str Input to escape. * @returns {string} Escaped string. */ function escapeRegExp(str) { return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&amp;'); } } module.exports = new ChatBot(); × Search results Close "},"subModule.js.html":{"id":"subModule.js.html","title":"Source: subModule.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: subModule.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Base class for all Sub-Modules. * @class */ class SubModule { /** * Create a subModule. */ constructor() { /** * The help message to show the user in the main help message. * * @type {string|Discord~MessageEmbed} */ this.helpMessage = undefined; /** * The postfix for the global prefix for this subModule. Must be defined * before begin(), otherwise it is ignored. * * @abstract * @type {string} * @default */ this.postPrefix = ''; /** * The current Discord object instance of the bot. * * @type {Discord} */ this.Discord; /** * The current bot client. * * @type {Discord~Client} */ this.client; /** * The command object for registering command listeners. * * @type {Command} */ this.command; /** * The common object. * * @type {Common} */ this.common; /** * The parent SpikeyBot instance. * * @type {SpikeyBot} */ this.bot; /** * The commit at HEAD at the time this module was loaded. Essentially the * version of this submodule. * * @public * @constant * @type {string} */ this.commit = require('child_process') .execSync('git rev-parse --short HEAD') .toString() .trim(); /** * The time at which this madule was loaded for use in checking if the * module * needs to be reloaded because the file has been modified since loading. * * @public * @constant * @type {number} */ this.loadTime = Date.now(); /** * The name of this submodule. Used for differentiating in the log. Should * be * defined before begin(). * * @protected * @type {string} * @abstract */ this.myName = 'SubModule'; /** * Has this subModule been initialized yet (Has begin() been called). * * @protected * @type {boolean} * @default * @readonly */ this.initialized = false; } /** * The function called at the end of begin() for further initialization * specific to the subModule. Must be defined before begin() is called. * * @protected * @abstract */ initialize() { } /** * Initialize this submodule. * * @public * @param {Discord} Discord The Discord object for the API library. * @param {Discord~Client} client The client that represents this bot. * @param {Command} command The command instance in which to * register command listeners. * @param {Common} common Class storing common functions. * @param {SpikeyBot} bot The parent SpikeyBot instance. */ begin(Discord, client, command, common, bot) { this.Discord = Discord; this.client = client; this.command = command; this.common = common; this.bot = bot; this.log = function(msg) { if (this.client.shard) { this.common.log( msg, `${this.client.shard.ids.join(' ')} ${this.myName}`, 1); } else { this.common.log(msg, this.myName, 1); } }; this.debug = function(msg) { if (this.client.shard) { this.common.logDebug( msg, `${this.client.shard.ids.join(' ')} ${this.myName}`, 1); } else { this.common.logDebug(msg, this.myName, 1); } }; this.warn = function(msg) { if (this.client.shard) { this.common.logWarning( msg, `${this.client.shard.ids.join(' ')} ${this.myName}`, 1); } else { this.common.logWarning(msg, this.myName, 1); } }; this.error = function(msg) { if (this.client.shard) { this.common.error( msg, `${this.client.shard.ids.join(' ')} ${this.myName}`, 1); } else { this.common.error(msg, this.myName, 1); } }; if (this.initialized) return; this.client.setTimeout(() =&gt; { if (this.initialized) return; this.debug(this.myName + ' Initialize...'); this.initialize(); this.log(this.myName + ' Initialized'); this.initialized = true; }); } /** * Trigger subModule to shutdown and get ready for process terminating. * * @public */ end() { if (!this.initialized) return; this.shutdown(); this.initialized = false; this.log(this.myName + ' Shutdown'); } /** * Log using common.log, but automatically set name. * * @protected * @param {string} msg The message to log. */ log(msg) { console.log(msg); } /** * Log using common.logDebug, but automatically set name. * * @protected * @param {string} msg The message to log. */ debug(msg) { console.log(msg); } /** * Log using common.logWarning, but automatically set name. * * @protected * @param {string} msg The message to log. */ warn(msg) { console.log(msg); } /** * Log using common.error, but automatically set name. * * @protected * @param {string} msg The message to log. */ error(msg) { console.error(msg); } /** * Shutdown and disable this submodule. Removes all event listeners. * * @abstract * @protected */ shutdown() { } /* eslint-disable @typescript-eslint/no-unused-vars */ /** * Saves all data to files necessary for saving current state. * * @param {string} [opt='sync'] Can be 'async', otherwise defaults to * synchronous. * @abstract */ save(opt = 'sync') { } /* eslint-enable @typescript-eslint/no-unused-vars */ /** * @description Check if this module is in a state that is ready to be * unloaded. If false is returned, this module should not be unloaded and * doing such may risk putting the module into an uncontrollable state. * * @abstract * @public * @returns {boolean} True if can be unloaded, false if cannot. */ unloadable() { return true; } } /** * Extends SubModule as the base class of a child. * * @param {object} child The child class to extend. */ SubModule.extend = function(child) { child.prototype = new SubModule(); child.prototype.constructor = child; }; module.exports = SubModule; × Search results Close "},"cmdScheduling.js.html":{"id":"cmdScheduling.js.html","title":"Source: cmdScheduling.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: cmdScheduling.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const mkdirp = require('mkdirp'); require('./subModule.js') .extend(CmdScheduling); // Extends the SubModule class. /** * @classdesc Provides interface for scheduling a specific time or interval for * a command to be run. * @class * @augments SubModule * @listens Command#schedule * @listens Command#sch * @listens Command#sched * @listens Command#scheduled */ function CmdScheduling() { const self = this; /** @inheritdoc */ this.myName = 'CmdScheduling'; /** @inheritdoc */ this.initialize = function() { const adminOnlyOpts = new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD | self.Discord.Permissions.FLAGS.BAN_MEMBERS, }); self.command.on( new self.command.SingleCommand( ['schedule', 'sch', 'sched', 'scheduled'], commandSchedule, adminOnlyOpts)); const now = Date.now(); self.client.guilds.forEach((g) =&gt; { fs.readFile(self.common.guildSaveDir + g.id + saveSubDir, (err, data) =&gt; { if (err &amp;&amp; err.code == 'ENOENT') return; if (err) { self.warn('Failed to load scheduled command: ' + g.id); return; } try { const parsed = JSON.parse(data); if (!parsed || parsed.length == 0) { self.warn('Failed to parse scheduled commands: ' + g.id); return; } if (!schedules[g.id]) schedules[g.id] = []; for (let i = 0; i &lt; parsed.length; i++) { if (parsed[i].bot != self.client.user.id) continue; if (parsed[i].time &lt; now) { while (parsed[i].repeatDelay &gt; 0 &amp;&amp; parsed[i].time &lt; now - parsed[i].repeatDelay) { parsed[i].time += parsed[i].repeatDelay; } } registerScheduledCommand(new ScheduledCommand(parsed[i])); } } catch (err) { self.error('Failed to parse data for guild commands: ' + g.id); console.error(err); } }); }); longInterval = self.client.setInterval(reScheduleCommands, maxTimeout); }; /** * @inheritdoc * @fires CmdScheduling#shutdown * */ this.shutdown = function() { self.command.deleteEvent('schedule'); if (longInterval) self.client.clearInterval(longInterval); for (const i in schedules) { if (!schedules[i] || !schedules[i].length) continue; schedules[i].forEach((el) =&gt; el.cancel()); } fireEvent('shutdown'); listeners = {}; }; /** * @override * @inheritdoc */ this.save = function(opt) { self.client.guilds.forEach((g) =&gt; { const dir = self.common.guildSaveDir + g.id; const filename = dir + saveSubDir; if (opt === 'async') { fs.unlink(filename, () =&gt; {}); } else { try { fs.unlinkSync(filename); } catch (err) { // Meh. } } }); for (const i in schedules) { if (!schedules[i] || !schedules[i].length) continue; schedules[i] = schedules[i].filter((el) =&gt; !el.complete); const data = schedules[i].map((el) =&gt; el.toJSON()); writeSaveData(i, data, opt); } }; /** * Write save data for a guild. * * @private * * @param {string|number} i The guild ID. * @param {object} data The data to write. * @param {string} [opt='sync'] See {@link save}. */ function writeSaveData(i, data, opt) { const dir = self.common.guildSaveDir + i; const filename = dir + saveSubDir; if (opt === 'async') { mkdirp(dir, (err) =&gt; { if (err) { self.error('Failed to make directory: ' + dir); console.log(err); return; } fs.readFile(filename, (err, rec) =&gt; { if (!err &amp;&amp; rec) { try { const parsed = JSON.parse(rec); if (parsed &amp;&amp; parsed.length &gt; 0) { data = rec.filter((el) =&gt; el.bot != self.client.user.id) .concat(data); } } catch (e) { // No data exists. } } const finalData = JSON.stringify(data); fs.writeFile(filename, finalData, (err) =&gt; { if (err) { self.error('Failed to write file: ' + filename); console.error(err); } }); }); }); } else { try { mkdirp.sync(dir); } catch (err) { self.error('Failed to make directory: ' + dir); console.log(err); return; } try { const rec = fs.readFileSync(filename); const parsed = JSON.parse(rec); if (parsed &amp;&amp; parsed.length &gt; 0) { data = rec.filter((el) =&gt; el.bot != self.client.user.id).concat(data); } } catch (err) { // No data exists. } try { fs.writeFileSync(filename, JSON.stringify(data)); } catch (err) { self.error('Failed to write file: ' + filename); console.error(err); } } } /** * Interval that runs every maxTimeout milliseconds in order to re-schedule * commands that were beyond the max timeout duration. * * @private * @type {Interval} */ let longInterval; /** * The maximum amount of time to set a Timeout for. The JS limit is 24 days * (iirc), after which, Timeouts do not work properly. * * @private * @constant * @default 14 Days * @type {number} */ const maxTimeout = 14 * 24 * 60 * 60 * 1000; /** * The filename in the guild directory to save the scheduled commands. * * @private * @constant * @default * @type {string} */ const saveSubDir = '/scheduledCmds.json'; /** * The possible characters that can make up an ID of a scheduled command. * * @private * @constant * @default * @type {string} */ const idChars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; /** * The color to use for embeds sent from this submodule. * * @private * @constant * @default * @type {number[]} */ const embedColor = [50, 255, 255]; /** * Minimum allowable amount of time in milliseconds from when the scheduled * command is registered to when it runs. * * @public * @constant * @default 10 Seconds * @type {number} */ this.minDelay = 10000; /** * Minimum allowable amount of time in milliseconds from when the scheduled * command is run to when it run may run again. * * @public * @constant * @default 30 Seconds * @type {number} */ this.minRepeatDelay = 30000; /** * Currently registered event listeners, mapped by event name. * * @private * @type {Object.&lt;Array.&lt;Function&gt;&gt;} */ let listeners = {}; /** * All of the currently loaded commands to run. Mapped by Guild ID, then * sorted arrays by time to run next command. * * @private * @type {Object.&lt;Array.&lt;CmdScheduling.ScheduledCommand&gt;&gt;} */ const schedules = {}; /** * @classdesc Stores information about a specific command that is scheduled. * @class * * @public * @param {string|object} cmd The command to run, or an object instance of * this class (exported using toJSON, then parsed into an object). * @param {string|number|Discord~TextChannel} channel The channel or channel * id of where to run the command. * @param {string|number|Discord~Message} message The message or message id * that created this scheduled command. * @param {number} time The unix timestamp at which to run the command. * @param {?number} repeatDelay The delay in milliseconds at which to run the * command again, or null if it does not repeat. * * @property {string} cmd The command to run. * @property {number|string} bot The id of the bot instantiating this command. * @property {Discord~TextChannel} channel The channel or channel id of where * to run the command. * @property {string|number} channelId The id of the channel where the message * was sent. * @property {?Discord~Message} message The message that created this * scheduled command, or null if the message was deleted. * @property {string|number} messageId The id of the message sent. * @property {number} time The unix timestamp at which to run the command. * @property {number} [repeatDelay=0] The delay in milliseconds at which to * run the command again. 0 to not repeat. * @property {string} id Random base 36, 3-character long id of this command. * @property {boolean} complete True if the command has been run, and will not * run again. * @property {Timeout} timeout The current timeout registered to run the * command. * @property {Discord~GuildMember} member The author of this ScheduledCommand. * @property {string|number} memberId The id of the member. */ function ScheduledCommand(cmd, channel, message, time, repeatDelay = 0) { const myself = this; if (typeof cmd === 'object') { channel = cmd.channel; message = cmd.message; time = cmd.time; repeatDelay = cmd.repeatDelay; this.id = cmd.id; this.member = cmd.member; cmd = cmd.cmd; } else { this.member = message.member; this.id = ''; } if (!this.id || this.id.length &lt; 3) { this.id = ''; for (let i = 0; i &lt; 3; i++) { this.id += idChars.charAt(Math.floor(Math.random() * idChars.length)); } } this.cmd = cmd; this.channel = channel; this.channelId = typeof channel === 'object' ? channel.id : channel; this.message = message; this.messageId = typeof message === 'object' ? message.id : message; this.time = time; this.repeatDelay = repeatDelay; this.memberId = typeof this.member === 'object' ? this.member.id : this.member; this.bot = self.client.user.id; this.complete = false; /** * Update channel and message with their associated IDs. * * @private */ function getReferences() { if (typeof myself.channel !== 'object') { myself.channel = self.client.channels.get(myself.channelId); } if (typeof myself.channel !== 'object' || myself.channel.deleted) { self.debug( 'Cancelling command due to channel not existing: ' + myself.channelId + '@' + myself.memberId + ': ' + myself.cmd); myself.cancel(); return; } if (typeof myself.message !== 'object') { myself.message = myself.channel.messages.get(myself.messageId); if (!myself.message) { myself.channel.messages.fetch(myself.messageId) .then((msg) =&gt; { if (!msg) throw new Error(); myself.message = msg; myself.member = msg.member; myself.memberId = msg.member.id; }) .catch(() =&gt; { self.debug( 'Failed to find message: ' + myself.channelId + '@' + myself.memberId + ' ' + myself.messageId + ': ' + myself.cmd); myself.message = makeMessage( myself.memberId, myself.channel.guild.id, myself.channel.id, myself.cmd); myself.member = myself.message.member; myself.memberId = myself.member.id; }); } else { myself.member = myself.message.member; myself.memberId = myself.message.member.id; } } if (typeof myself.member !== 'object') { myself.member = myself.channel.members.get(myself.memberId); if (!myself.member) { myself.channel.guild.members.fetch(myself.memberId) .then((m) =&gt; { myself.member = m; }) .catch((err) =&gt; { self.error( 'Failed to find member with id: ' + myself.memberId + ' in guild: ' + myself.channel.guild.id); console.error(err); }); } } } /** * Trigger the command to be run immediately. Automatically fired at the * scheduled time. Does not cancel the normally scheduled command. * Re-schedules the command if the command should repeat. * * @public */ this.go = function() { if (myself.complete) { self.error('Command triggered after being completed!', myself.id); self.client.clearTimeout(myself.timeout); return; } const now = Date.now(); getReferences(); if (!myself.channel || !myself.channel.send) { self.error( 'ScheduledCmdFailed No Channel: ' + myself.channel.id + '@' + myself.memberId + ' ' + myself.cmd); myself.complete = true; self.client.clearTimeout(myself.timeout); return; } else if (!myself.message) { self.error( 'ScheduledCmdFailed No Message: ' + myself.channel.guild.id + '#' + myself.channel.id + '@' + myself.memberId + ' ' + myself.cmd); return; } else if (!myself.message.channel || !myself.message.channel.send) { self.warn( 'ScheduledCmdWarning No Message Channel: ' + myself.channel.guild.id + '#' + myself.channel.id + '@' + myself.memberId + ' ' + myself.cmd); myself.message.channel = myself.channel; } if (!myself.message.guild.members || typeof myself.message.guild.members.get !== 'function') { self.error( 'ScheduledCmdFailed No Members Channel: ' + myself.channel.guild.id + '#' + myself.channel.id + '@' + myself.memberId + ' ' + myself.cmd); return; } myself.message.content = myself.cmd; myself.message.fabricated = true; const cmd = self.command.find(myself.cmd, myself.message); if (!cmd) { self.error( 'Unknown ScheduledCmd: ' + myself.message.channel.id + '@' + myself.message.author.id + ' ' + myself.cmd + ' ' + myself.message.content); return; } if (cmd.getFullName() === self.command.find('sch').getFullName()) { self.error( 'Recursive ScheduledCmd: ' + myself.message.channel.id + '@' + myself.message.author.id + ' ' + myself.message.content); return; } self.debug( 'ScheduledCmd: ' + myself.message.channel.id + '@' + myself.message.author.id + ' ' + myself.message.content); try { self.command.trigger(myself.message); } catch (err) { self.error( 'Failed to trigger ScheduledCmd: ' + myself.message.channel.id + '@' + myself.message.author.id + ' ' + myself.message.content); console.error(err); } // If the command was fired at the scheduled time, or if it was fired // manually and the the scheduled time is in less than a second, then // consider the scheduled command to have been completed. if (myself.time - 1000 &lt;= now) { self.client.clearTimeout(myself.timeout); if (myself.repeatDelay &gt; 0) { myself.complete = false; myself.time += myself.repeatDelay; sortGuildCommands(myself.message.guild.id); myself.setTimeout(); } else { myself.complete = true; } } }; /** * Cancel this command and remove Timeout. * * @public */ this.cancel = function() { self.client.clearTimeout(myself.timeout); myself.complete = true; }; /** * Schedule the Timeout event to call the command at the scheduled time. If * the scheduled time to run the command is more than 2 weeks in the future, * the command is not scheduled, and this function must be called manually * (less than 2 weeks) before the scheduled time for the command to run. * * @public */ this.setTimeout = function() { if (myself.complete) { return; // Command was completed, and should no longer run. } if (myself.time - Date.now() &lt;= maxTimeout) { self.client.clearTimeout(myself.timeout); try { myself.timeout = self.client.setTimeout(myself.go, myself.time - Date.now()); } catch (err) { self.error( 'ScheduledCmd Failed: ' + myself.channelId + '@' + myself.memberId + ' ' + myself.cmd); return; } self.debug( 'ScheduledCmd Scheduled: ' + myself.channelId + '@' + myself.memberId + ' ' + myself.cmd); } }; /** * Export the relevant data to recreate this object, as a JSON object. * * @public * @returns {object} JSON formatted object. */ this.toJSON = function() { return { bot: self.client.user.id, cmd: myself.cmd, time: myself.time, repeatDelay: myself.repeatDelay, id: myself.id, channel: myself.channelId, message: myself.messageId, member: myself.memberId, }; }; getReferences(); setTimeout(() =&gt; this.setTimeout()); } this.ScheduledCommand = ScheduledCommand; /** * Register a created {@link CmdScheduling.ScheduledCommand}. * * @private * @fires CmdScheduling#commandRegistered * * @param {CmdScheduling.ScheduledCommand} sCmd The ScheduledCommand object to * register. * @returns {boolean} True if succeeded, False if too close to existing * command. */ function registerScheduledCommand(sCmd) { const gId = sCmd.message.guild.id; if (!schedules[gId]) { schedules[gId] = [sCmd]; } else { for (let i = 0; i &lt; schedules[gId].length; i++) { if (Math.abs(schedules[gId][i].time - sCmd.time) &lt; 5000) { sCmd.cancel(); return false; } } schedules[gId].push(sCmd); } fireEvent('commandRegistered', sCmd, sCmd.message.guild.id); return true; } /** * Register a created {@link CmdScheduling.ScheduledCommand}. * @public * @see {@link CmdScheduling~registerScheduledCommand} */ this.registerScheduledCommand = registerScheduledCommand; /** * Allow user to schedule command to be run, or view currently scheduled * commands. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#schedule */ function commandSchedule(msg) { if (!msg.text || !msg.text.trim()) { replyWithSchedule(msg); return; } else if (msg.text.match(/(cancel|remove|delete)/)) { cancelAndReply(msg); return; } const splitCmd = msg.text.trim().split(msg.prefix); if (!splitCmd || splitCmd.length &lt; 2 || splitCmd[0].trim().length == 0) { self.common.reply( msg, 'Oops! Please ensure you have formatted that correctly.\\nI wasn\\'t' + ' able to understand it properly.'); return; } let delay = splitCmd.splice(0, 1)[0]; const cmd = msg.prefix + splitCmd.join(msg.prefix); let repeat = 0; const invalid = self.command.validate(cmd.split(/\\s/)[0], msg); if (invalid) { self.common.reply( msg, 'That command doesn\\'t seem to be a usable command.\\n' + cmd, invalid); return; } if (self.command.find(splitCmd[0]).getFullName() === self.command.find('sch').getFullName()) { self.common.reply(msg, 'Commands may not be recursive.', invalid); return; } if (delay.match(/every|repeat/)) { const splitTimes = delay.match(/^(.*?)(every|repeat)(.*)$/); delay = splitTimes[1]; repeat = splitTimes[3]; } delay = stringToMilliseconds(delay); /* if (delay &lt; self.minDelay) { self.common.reply(msg, 'Sorry, but delays must be more than 10 seconds.'); return; } */ repeat = stringToMilliseconds(repeat); if (repeat &amp;&amp; repeat &lt; self.minRepeatDelay) { self.common.reply( msg, 'Sorry, but repeat delays must be more than 30 seconds.'); return; } const newCmd = new ScheduledCommand(cmd, msg.channel, msg, delay + Date.now(), repeat); if (!registerScheduledCommand(newCmd)) { self.common.reply( msg, 'Sorry, but commands must be separated by at least 5 seconds.'); return; } const embed = new self.Discord.MessageEmbed(); embed.setTitle('Created Scheduled Command (' + newCmd.id + ')'); embed.setColor(embedColor); let desc = 'Runs in ' + formatDelay(delay); if (repeat) { desc += '\\nRepeats every ' + formatDelay(repeat); } embed.setDescription(desc); embed.addField( 'To cancel:', `\\`${msg.prefix}sch cancel ${newCmd.id}\\``, true); embed.setFooter(cmd); msg.channel.send(self.common.mention(msg), embed); } /** * Sort all scheduled commands in a guild by the next time they will run. * * @private * @param {string|number} id The guild id of which to sort the commands. */ function sortGuildCommands(id) { const c = schedules[id]; if (!c) return; let unsorted = true; while (unsorted) { unsorted = false; let spliced; for (let i = 1; i &lt; c.length; i++) { if (!spliced &amp;&amp; c[i - 1].time &gt; c[0].time) { spliced = c.splice(i - 1, 1)[0]; if (c[c.length - 1].time &lt; spliced.time) { c.push(spliced); spliced = null; i--; } } else if (spliced &amp;&amp; c[i].time &lt; spliced.time) { c.splice(i + 1, 0, spliced); unsorted = true; break; } } } } /** * Given a user-inputted string, convert to a number of milliseconds. Input * can be on most common time units up to a week. * * @private * * @param {string} str The input string to parse. * @returns {number} Number of milliseconds parsed from string. */ function stringToMilliseconds(str) { let sum = 0; str = (str + '') .replace(/\\b(and|repeat|every|after|in)\\b/g, '') .trim() .toLowerCase(); const reg = /([0-9.]+)([^a-z]*)([a-z]*)/g; let res; while ((res = reg.exec(str)) !== null) { sum += numberToUnit(res[1], res[3]); } if (!sum &amp;&amp; str) { sum = numberToUnit(1, str); } /** * Convert a number and a unit to the corresponding number of milliseconds. * * @private * @param {number} num The number associated with the unit. * @param {string} unit The current unit associated with the num. * @returns {number} The given number in milliseconds. */ function numberToUnit(num, unit) { switch (unit) { case 's': case 'sec': case 'second': case 'seconds': return num * 1000; case 'm': case 'min': case 'minute': case 'minutes': return num * 60 * 1000; case 'h': case 'hr': case 'hour': case 'hours': return num * 60 * 60 * 1000; case 'd': case 'dy': case 'day': case 'days': return num * 24 * 60 * 60 * 1000; case 'w': case 'wk': case 'week': case 'weeks': return num * 7 * 24 * 60 * 60 * 1000; default: return 0; } } return sum; } /** * Returns an array of references to scheduled commands in a guild. * * @public * * @param {string|number} gId The guild id of which to get the commands. * @returns {null|CmdScheduling.ScheduledCommand[]} Null if none, or the array * of ScheduledCommands. */ function getScheduledCommandsInGuild(gId) { let list = schedules[gId]; if (!list) return null; list = list.filter((el) =&gt; !el.complete); if (!list || list.length == 0) return null; return list; } this.getScheduledCommandsInGuild = getScheduledCommandsInGuild; /** * Find all scheduled commands for a certain guild, and reply to the message * with the list of commands. * * @private * @param {Discord~Message} msg The message to reply to. */ function replyWithSchedule(msg) { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Scheduled Commands'); embed.setColor(embedColor); let list = getScheduledCommandsInGuild(msg.guild.id); if (!list) { embed.setDescription('No commands are scheduled.'); } else { const n = Date.now(); list = list.map((el) =&gt; { return '**' + el.id + '**: In ' + formatDelay(el.time - n) + (el.repeatDelay ? (', repeats every ' + formatDelay(el.repeatDelay)) : '') + (el.message &amp;&amp; ' by &lt;@' + el.message.author.id + '&gt;: ') + el.cmd; }); embed.setDescription(list.join('\\n')); } if (msg.author.id == self.common.spikeyId) { const keys = Object.keys(schedules); let total = 0; keys.forEach((k) =&gt; { total += Object.keys(schedules[k]).length; }); embed.setFooter(total); } msg.channel.send(self.common.mention(msg), embed).catch((err) =&gt; { self.error('Failed to send reply in channel: ' + msg.channel.id); console.error(err); }); } /** * Cancel a scheduled command in a guild. * * @private * @fires CmdScheduling#commandCancelled * * @param {string|number} gId The guild id of which to cancel the command. * @param {string|number} cmdId The ID of the command to cancel. * @returns {?CmdScheduling.ScheduledCommand} Null if failed, or object that * was cancelled. */ function cancelCmd(gId, cmdId) { const list = schedules[gId]; if (!list || list.length == 0) return null; if (!cmdId) return null; cmdId = (cmdId + '').toUpperCase(); for (let i = 0; i &lt; list.length; i++) { if (list[i].complete) continue; if (list[i].id == cmdId) { const removed = list.splice(i, 1)[0]; removed.cancel(); fireEvent('commandCancelled', removed.id, removed.message.guild.id); return removed; } } return null; } /** * Cancel a scheduled command in a guild. * @public * @see {@link CmdScheduling~cancelCmd} */ this.cancelCmd = cancelCmd; /** * Find a scheduled command with the given ID, and remove it from commands to * run. * * @private * @param {Discord~Message} msg The message to reply to. */ function cancelAndReply(msg) { const embed = new self.Discord.MessageEmbed(); embed.setColor(embedColor); const list = schedules[msg.guild.id]; if (!list || list.length == 0) { embed.setTitle('Cancelling Failed'); embed.setDescription('There are no scheduled commands in this guild.'); } else { let idSearch = msg.text.match(/(cancel|remove|delete)\\W+(\\w{3,})\\b/); if (!idSearch) { embed.setTitle('Cancelling Failed'); embed.setDescription('Please specify a scheduled command ID.'); } else { idSearch = idSearch[2]; const removed = cancelCmd(msg.guild.id, idSearch); if (!removed) { embed.setTitle('Cancelling Failed'); embed.setDescription( 'Unable to find scheduled command with ID: ' + idSearch); } else { embed.setTitle('Cancelling Succeeded'); embed.setDescription( 'Removed scheduled command ID: ' + idSearch + ', ' + removed.cmd); } } } msg.channel.send(self.common.mention(msg), embed).catch((err) =&gt; { self.error('Failed to send reply in channel: ' + msg.channel.id); console.error(err); }); } /** * Reschedule all future commands that are beyond maxTimeout. */ function reScheduleCommands() { for (const g in schedules) { if (!schedules[g] || !schedules[g].length) continue; for (let i = 0; i &lt; schedules[g].length; i++) { let abort = false; for (let j = 0; j &lt; schedules[g].length; j++) { if (i == j) continue; if (Math.abs(schedules[g][i].time - schedules[g][j].time) &lt; 5000) { abort = true; break; } } if (abort) { schedules[g][i].cancel(); schedules[g].splice(i, 1); } else { schedules[g][i].setTimeout(); } } } } /** * Format a duration in milliseconds into a human readable string. * * @private * * @param {number} msecs Duration in milliseconds. * @returns {string} Formatted string. */ function formatDelay(msecs) { let output = ''; let unit = 7 * 24 * 60 * 60 * 1000; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' week' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 7; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' day' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 24; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' hour' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 60; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' minute' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 60; if (msecs &gt;= unit) { const num = Math.round(msecs / unit); output += num + ' second' + (num == 1 ? '' : 's') + ''; } return output.replace(/,\\s$/, ''); } /** * Register an event handler for the given name with the given handler. * * @public * @param {string} name The event name to listen for. * @param {Function} handler The function to call when the event is fired. */ this.on = function(name, handler) { if (typeof handler !== 'function') { throw (new Error('Handler must be a function.')); } if (!listeners[name]) listeners[name] = []; listeners[name].push(handler); }; /** * Remove an event handler for the given name. * * @public * @param {string} name The event name to remove the handler for. * @param {Function} [handler] THe specific handler to remove, or null for * all. */ this.removeListener = function(name, handler) { if (!listeners[name]) return; if (!handler) { delete listeners[name]; } else { for (let i = 0; i &lt; listeners[name].length; i++) { if (listeners[name][i] == handler) { listeners[name].splice(i, 1); } } if (listeners[name].length == 0) delete listeners[name]; } }; /** * @description Fires a given event with the associated data. * * @private * @param {string} name The name of the event to fire. * @param {*} data The arguments to pass into the function calls. */ function fireEvent(name, ...data) { for (let i = 0; listeners[name] &amp;&amp; i &lt; listeners[name].length; i++) { try { listeners[name][i](...data); } catch (err) { self.error('Error in firing event: ' + name); console.error(err); } } } /** * Forms a Discord~Message similar object from given IDs. * * @private * @param {string} uId The id of the user who wrote this message. * @param {string} gId The id of the guild this message is in. * @param {string} cId The id of the channel this message was 'sent' in. * @param {string} msg The message content. * @returns { * { * fabricated: boolean, * author: Discord~User, * member: Discord~GuildMember, * guild: Discord~Guild, * channel: Discord~GuildChannel, * text: string, * content: string, * prefix: string * } * } The created message-like object. */ function makeMessage(uId, gId, cId, msg) { if (!cId) return null; const g = self.client.guilds.get(gId); if (!g) return null; const message = {}; message.fabricated = true; message.member = g.members.get(uId); message.author = g.members.get(uId).user; message.guild = g; message.client = self.client; message.channel = self.client.channels.get(cId); message.text = msg; message.content = msg; message.prefix = self.bot.getPrefix(gId); return message; } } module.exports = new CmdScheduling(); × Search results Close "},"commands.js.html":{"id":"commands.js.html","title":"Source: commands.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: commands.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); require('./mainModule.js')(Command); // Extends the MainModule class. /** * @classdesc Manages the command event firing for all commands. This is not a * normal submodule, and is treated differently in the SpikeyBot class. * @class * @augments MainModule */ function Command() { const self = this; /** @inheritdoc */ this.myName = 'Command'; /** @inheritdoc */ this.initialize = function() { self.client.guilds.forEach((g) =&gt; { const dir = self.common.guildSaveDir + g.id; const filename = dir + commandSettingsFile; fs.readFile(filename, (err, data) =&gt; { if (err) { if (err.code == 'ENOENT') { // File does not exist. No custom settings exist yet. return; } self.error('Failed to read user settings for commands: ' + filename); console.error(err); return; } try { const parsed = JSON.parse(data); if (parsed) { if (!userSettings[g.id]) userSettings[g.id] = {}; Object.entries(parsed).forEach((el) =&gt; { userSettings[g.id][el[0]] = new CommandSetting(el[1]); }); } } catch (e) { self.error('Failed to parse command settings: ' + filename); console.error(e); } }); }); const cmdSettings = new CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_GUILD, }); self.on(new SingleCommand(['disable'], commandDisable, cmdSettings)); self.on(new SingleCommand(['enable'], commandEnable, cmdSettings)); self.on( new SingleCommand( ['mutecmd', 'blockcmd', 'suppresscmd'], commandBlockCmd, cmdSettings)); self.on( new SingleCommand( ['unmutecmd', 'allowcmd'], commandAllowCmd, cmdSettings)); self.on( new SingleCommand( [ 'show', 'enabled', 'disabled', 'showenabled', 'showdisabled', 'settings', 'permissions', ], commandShow, cmdSettings)); self.on(new SingleCommand(['reset'], commandReset, cmdSettings)); }; /** @inheritdoc */ this.shutdown = function() { self.removeListener( ['disable', 'enable', 'show', 'reset', 'mutecmd', 'allowcmd']); }; /** @inheritdoc */ this.save = function(opt) { Object.entries(userSettings).forEach((el) =&gt; { const dir = self.common.guildSaveDir + el[0]; const filename = dir + commandSettingsFile; if (opt == 'async') { fs.mkdir(dir, (err) =&gt; { if (err) { if (err.code !== 'EEXIST') { self.error('Failed to make guild directory for saving: ' + dir); console.error(err); return; } } fs.writeFile(filename, JSON.stringify(el[1]), (err) =&gt; { if (err) { self.error( 'Failed to write command settings to file: ' + filename); console.error(err); return; } }); }); } else { try { fs.mkdirSync(dir); } catch (err) { if (err.code !== 'EEXIST') { self.error('Failed to make guild directory for saving: ' + dir); console.error(err); return; } } try { fs.writeFileSync(filename, JSON.stringify(el[1])); } catch (err) { self.error('Failed to write command settings to file: ' + filename); console.error(err); return; } } }); }; /** @inheritdoc */ this.import = function(data) { if (!data) return; cmds = data.cmds; eventList = data.events; }; /** @inheritdoc */ this.export = function() { const output = { cmds: cmds, events: eventList, }; cmds = null; eventList = null; return output; }; /** * The function to call when a command is triggered. * * @callback commandHandler * @param {Discord~Message} msg The message sent in Discord. */ /** * Currently registered event listeners for non-command events. */ let eventList = {}; /** * All tracked commands mapped by command name. * * @private * @type {Object.&lt;SingleCommand&gt;} */ let cmds = {}; /** * @classdesc Object storing information about a single command, it's handler, * and default options. * @class * @public * * @param {string|string[]} cmd All commands the handler will fire on. * @param {commandHandler} handler The event handler when the command has been * triggered. * @param {CommandSetting} [opts] The options for this command. * @param {SingleCommand|SingleCommand[]} [subCmds] Sub commands that use this * command as a fallback. Command names must be separated by white space in * order to trigger the sub command. */ function SingleCommand(cmd, handler, opts, subCmds) { const me = this; if (typeof handler !== 'function') { throw new Error('Command handler must be a function.'); } if (typeof cmd === 'string') cmd = [cmd]; if (!Array.isArray(cmd)) { throw new Error( 'Commands must be specified as a string, or array of strings.'); } if (subCmds &amp;&amp; !Array.isArray(subCmds)) subCmds = [subCmds]; else if (!subCmds) subCmds = []; /** * The name of the parent command if this is a subcommand. * @public * @readonly * @type {?string} */ this.parentName = null; /** * Update the parent name for this command and all child commands. * * @public * @param {string} to The parent name to set. */ this.updateParentName = function(to) { me.parentName = to; const fullName = me.getFullName(); for (const i in me.subCmds) { if (me.subCmds[i].updateParentName) { me.subCmds[i].updateParentName(fullName); } } }; /** * Get the full name for this command including parent command. * * @returns {string} This command's name prefixed with the parent command's * name. */ this.getFullName = function() { if (me.parentName) { return `${me.parentName} ${me.getName()}`; } else { return me.getName(); } }; /** * Get the primary key for this object. The first or only value passed in * for `cmd`, and may be used to show the user the command that this object * stores information about. * * @public * * @returns {string} The command string. */ this.getName = function() { return me.aliases[0]; }; /** * All versions of this command that may be used to trigger the same * handler. * @public * * @type {string[]} */ this.aliases = cmd.map((el) =&gt; { return el.toLowerCase(); }); /** * Sub commands for this single command. Triggered by commands separated by * whitespace. Object mapped by subcommand name, similar to {@link * Command~cmds}. * @public * @type {Object.&lt;SingleCommand&gt;} */ this.subCmds = {}; for (let i = 0; i &lt; subCmds.length; i++) { this.subCmds[subCmds[i].getName()] = subCmds[i]; } this.updateParentName(me.parentName); /** * The function to call when this command has been triggered. * * @public * * @param {Discord~Message} msg The message that is triggering this command. */ this.trigger = function(msg) { if (msg.cmd &amp;&amp; msg.cmd != me.getFullName() &amp;&amp; me.subCmds) { const sub = msg.cmd .replace( new RegExp(escapeRegExp(`${me.getFullName()}\\\\s+`)), '') .split(' ')[0] .toLocaleLowerCase(); if (sub) { let match = me.subCmds[sub]; if (!match) { match = Object.values(me.subCmds).find((el) =&gt; { return el.aliases.includes(sub); }); } if (match) { msg.text = msg.text.replace( new RegExp(`^.*?${escapeRegExp(me.getFullName())}`, 'i'), ''); me.subCmds[sub].trigger(msg); return; } } } const uIds = msg.text.match(/\\d{17,19}/g); msg.softMentions = { users: new self.Discord.UserStore(self.client), members: msg.guild ? new self.Discord.GuildMemberStore(msg.guild) : null, roles: msg.guild ? new self.Discord.RoleStore(msg.guild) : null, }; if (uIds) { uIds.forEach((el) =&gt; { const u = self.client.users.get(el); if (u) msg.softMentions.users.add(u); }); if (msg.guild) { uIds.forEach((el) =&gt; { const m = msg.guild.members.get(el); if (m) msg.softMentions.members.add(m); }); uIds.forEach((el) =&gt; { const m = msg.guild.roles.get(el); if (m) msg.softMentions.roles.add(m); }); } } if (msg.guild) { const sT = msg.text.toLocaleLowerCase(); if (msg.guild.members) { msg.guild.members.forEach((el) =&gt; { if (sT.indexOf(el.user.username.toLocaleLowerCase()) &gt; -1) { // sT = sT.replace(el.user.username.toLocaleLowerCase(), ''); msg.softMentions.members.add(el); msg.softMentions.users.add(el.user); } else if (sT.indexOf(el.user.tag.toLocaleLowerCase()) &gt; -1) { // sT = sT.replace(el.user.tag.toLocaleLowerCase(), ''); msg.softMentions.members.add(el); msg.softMentions.users.add(el.user); } else if ( el.nickname &amp;&amp; sT.indexOf(el.nickname.toLocaleLowerCase()) &gt; -1) { // sT = sT.replace(el.nickname.toLocaleLowerCase(), ''); msg.softMentions.members.add(el); msg.softMentions.users.add(el.user); } }); } if (msg.guild.roles) { msg.guild.roles.forEach((el) =&gt; { if (sT.indexOf(el.name.toLocaleLowerCase()) &gt; -1) { // sT = sT.replace(el.role.name.toLocaleLowerCase(), ''); msg.softMentions.roles.add(el); } }); } } handler(msg); }; /** * The current options and settings for this command. * @public * @type {Command~CommandSetting} */ this.options = new CommandSetting(opts); /** * Fetches the user options for this command, taking into account this could * be a subcommand. * * @public * @returns {object&lt;CommandSetting&gt;} The settings for this command or * sub-command mapped by guild ids. */ this.getUserOptions = function() { const myName = me.getFullName(); return Object.entries(userSettings) .map((el) =&gt; { const settings = el[1][myName]; return [el[0], settings]; }) .filter((el) =&gt; { return el[1]; }) .reduce( (p, c) =&gt; { p[c[0]] = c[1]; return p; }, {}); }; } /** @see {@link Command~SingleCommand} */ this.SingleCommand = SingleCommand; /** * @classdesc Stores all settings related to a command. * @class * @public * * @param {Command~CommandSetting} [opts] The options to set, or nothing for * default values. */ function CommandSetting(opts) { const me = this; if (!opts) opts = {}; /** * The guild ID of the guild is settings object is for, or null if this * instance is not specific to a single guild. * @public * @type {?string} */ this.myGuild = opts.guildId || null; /** * If the command is only allowed to be used in guilds. * @public * @type {boolean} */ this.validOnlyInGuild = opts.validOnlyInGuild || false; /** * Whether this command is disabled for all by default and requires them to * be in the list of enabled IDs. If this is false, the command is enabled * for everyone, unless they fall under the 'disabled' list. */ this.defaultDisabled = opts.defaultDisabled || false; /** * The IDs of all places where this command is currently disabled. Any ID * will be mapped to a truthy value. Roles will be mapped to the guild ID * and the role ID. Use {@link Command~CommandSetting.set} to change these * values. * @public * @readonly * @type {{ * guilds: Object.&lt;boolean&gt;, * channels: Object.&lt;boolean&gt;, * users: Object.&lt;boolean&gt;, * roles: Object.&lt;boolean&gt; * }} */ this.disabled = {guilds: {}, channels: {}, users: {}, roles: {}}; if (opts.disabled) { if (typeof opts.disabled.guilds === 'object') { Object.assign(this.disabled.guilds, opts.disabled.guilds); } if (typeof opts.disabled.channels === 'object') { Object.assign(this.disabled.channels, opts.disabled.channels); } if (typeof opts.disabled.users === 'object') { Object.assign(this.disabled.users, opts.disabled.users); } if (typeof opts.disabled.roles === 'object') { Object.assign(this.disabled.roles, opts.disabled.roles); } } /** * The IDs of all places where this command is currently enabled. Any ID * will be mapped to a truthy value. Roles will be mapped to the guild ID * and the role ID. Use {@link Command~CommandSetting.set} to change these * values. * @public * @readonly * @type {{ * guilds: Object.&lt;boolean&gt;, * channels: Object.&lt;boolean&gt;, * users: Object.&lt;boolean&gt;, * roles: Object.&lt;boolean&gt; * }} */ this.enabled = {guilds: {}, channels: {}, users: {}, roles: {}}; if (opts.enabled) { if (typeof opts.enabled.guilds === 'object') { Object.assign(this.enabled.guilds, opts.enabled.guilds); } if (typeof opts.enabled.channels === 'object') { Object.assign(this.enabled.channels, opts.enabled.channels); } if (typeof opts.enabled.users === 'object') { Object.assign(this.enabled.users, opts.enabled.users); } if (typeof opts.enabled.roles === 'object') { Object.assign(this.enabled.roles, opts.enabled.roles); } } /** * Bitfield representation of the required permissions for a user to have to * run this command. Same bitfield used by Discord~Permissions. * @public * @type {number} * @default 0 */ this.permissions = opts.permissions; if (typeof this.permissions !== 'number') { this.permissions = 0; } /** * Will this command be completely silenced so that no output will be sent. * Only applicable when command is disabled. * @private * @type {boolean} * @default */ this.isMuted = opts.isMuted || false; /** * @description Enable, disable, or neutralize this command for the * associated guild, channel, user, or role. * * @public * @fires Command.events#settingsChanged * @param {string} value Whether to set this ID to enabled, disabled, or to * whatever the default value is. Allowed values: * `enabled`|`disabled`|`default`. * @param {string} type The type of ID that is being given. Allowed values: * `guild`|`channel`|`user`|`role`. * @param {string} id The id to set the value to. * @param {string} [id2] The guild ID if `type` is 'role', of where the role * is created. */ this.set = function(value, type, id, id2) { switch (value) { case 'enabled': case 'disabled': case 'default': break; default: throw new Error( 'Invalid value to set the command to \\'' + value + '\\'. (Expected \\'enabled\\', \\'disabled\\', or \\'default\\'.)'); } switch (type) { case 'guild': if (!id || !self.client.guilds.get(id)) { throw new Error('Guild ID is invalid for id: ' + id); } if (value != 'enabled') delete me.enabled.guilds[id]; else me.enabled.guilds[id] = true; if (value != 'disabled') delete me.disabled.guilds[id]; else me.disabled.guilds[id] = true; break; case 'channel': if (!id || !self.client.channels.get(id)) { throw new Error('Channel ID is invalid for id: ' + id); } if (value != 'enabled') delete me.enabled.channels[id]; else me.enabled.channels[id] = true; if (value != 'disabled') delete me.disabled.channels[id]; else me.disabled.channels[id] = true; break; case 'user': if (!id || !self.client.users.get(id)) { throw new Error('User ID is invalid for id: ' + id); } if (value != 'enabled') delete me.enabled.users[id]; else me.enabled.users[id] = true; if (value != 'disabled') delete me.disabled.users[id]; else me.disabled.users[id] = true; break; case 'role': if (!id2 || !self.client.guilds.get(id2)) { throw new Error('Guild ID is invalid for id2: ' + id2); } if (!id || !self.client.guilds.get(id2).roles.get(id)) { throw new Error('Role ID is invalid for id: ' + id); } if (value != 'enabled') delete me.enabled.roles[id2 + '/' + id]; else me.enabled.roles[id2 + '/' + id] = true; if (value != 'disabled') delete me.disabled.roles[id2 + '/' + id]; else me.disabled.roles[id2 + '/' + id] = true; break; default: throw new Error( 'Invalid type to set command enabled/disabled status to \\'' + type + '\\'. (Expected \\'guild\\', \\'channel\\', \\'user\\', or \\'role\\'.)'); } self.fire('settingsChanged', me.myGuild, value, type, id, id2); }; /** * Check if this command is disabled with the given context. * * @public * * @param {Discord~Message} msg The message with the current context of * which to check if the command is disabled. * @returns {number} 0 if not disabled, 2 if disabled is specific to user, 1 * if disabled for any other reason. */ this.isDisabled = function(msg) { if (!msg) { throw new Error('Checking for disabled requires a Discord~Message.'); } if (['124733888177111041', '126464376059330562'].includes( msg.author.id)) { return 0; } if (!msg.guild &amp;&amp; me.validOnlyInGuild) return 1; let hasPerm = false; if (msg.guild) { // The command is disabled by default, but the GuildMember has a // required permission to run this command, or is Admin, or is guild // owner. let perms = 0; if (msg.channel) { const permObj = msg.channel.permissionsFor(msg.member); if (permObj) perms = permObj.bitfield; } else { perms = msg.member.permissions.bitfield; } hasPerm = ((perms &amp; me.permissions) || (perms &amp; self.Discord.Permissions.FLAGS.ADMINISTRATOR) || (msg.guild.ownerID === msg.author.id)); hasPerm = (hasPerm &amp;&amp; true) || false; } const disallow = me.defaultDisabled ? me.enabled : me.disabled; const matched = findMatch(disallow, msg); const isDisabled = ( // Command is disabled by default, and context does not explicitly // enable the command. ((!matched &amp;&amp; !hasPerm) &amp;&amp; me.defaultDisabled) || // Command is enabled by default, but context explicitly disables // the command. (matched &amp;&amp; !me.defaultDisabled)); if (!isDisabled) return 0; if (me.defaultDisabled) { return 1; } else { return matched; } /** * @description Searches the given object against the reference data to * see if they find any matching IDs. * * @private * @param { * Command~CommandSetting.disabled| * Command~CommandSetting.enabled * } search The search data. * @param {Discord~Message} data The context to search for. * @returns {number} 0 if not disabled, 2 if disabled is specific to user, * 1 if disabled for any other reason. */ function findMatch(search, data) { if (search.users[data.author.id]) return 2; if (data.channel &amp;&amp; search.channels[data.channel.id]) return 1; if (data.guild) { if (search.guilds[data.guild.id]) return 1; if (data.member.roles.find((r) =&gt; { return search.roles[`${data.guild.id}/${r.id}`]; })) { return 2; } } return 0; } }; /** * Creates a JSON formatted object with the necessary properties for * re-creating this object. * * @public * * @returns {object} Object ready to be stringified for file saving. */ this.toJSON = function() { return { guildId: me.myGuild, validOnlyInGuild: me.validOnlyInGuild, defaultDisabled: me.defaultDisabled, disabled: me.disabled, enabled: me.enabled, permissions: me.permissions, isMuted: me.isMuted, }; }; } /** @see {@link Command~CommandSetting} */ this.CommandSetting = CommandSetting; /** * Specific settings defined by users as restrictions on commands. Mapped by * guild id, then by the command. * * @private * @type {Object.&lt;Object.&lt;CommandSetting&gt;&gt;} */ const userSettings = {}; /** * Fetch all user-defined settings for a guild. * * @public * * @param {string} gId The guild id of which to fetch the settings. * @returns {object&lt;CommandSetting&gt;} The settings for the guild mapped by * command name. If it doesn't exist, an object will first be created. */ this.getUserSettings = function(gId) { if (!userSettings[gId] &amp;&amp; self.client.guilds.get(gId)) { userSettings[gId] = {}; } return userSettings[gId]; }; /** * Fetch all commands and their default setting values. * * @see {@link Command~cmds} * @public * * @returns {object&lt;SingleCommand&gt;} All currently registered commands. */ this.getDefaultSettings = function() { return cmds; }; /** * The message to send to the user if they attempt a server-only command in a * non-server channel. * * @private * @type {string} * @constant */ const onlyservermessage = 'This command only works in servers, sorry!'; /** * Filename in the guild's subdirectory where command settings are stored. * * @private * @constant * @default * @type {string} */ const commandSettingsFile = '/commandSettings.json'; /** * Trigger a command firing and call it's handler passing in msg as only * argument. * * @param {Discord~Message|string} msg Message received from Discord to pass * to handler and to use to find the correct handler, OR a string to override * the command to trigger from msg. * @param {Discord~Message} [msg2] The message received from Discord if the * first argument is a string. * @returns {boolean} True if command was handled by us. */ this.trigger = function(msg, msg2) { let override = null; if (typeof msg === 'string') { override = msg; msg = msg2; } const func = self.find(override, msg, true); if (func) { const failure = self.validate(override, msg, func); if (failure &amp;&amp; failure.endsWith('Muted')) { return true; } else if (failure === 'Guild Only') { self.common.reply(msg, onlyservermessage); return true; } else if (failure === 'Disabled') { self.common.reply( msg, 'This command has not been enabled for you here.'); return true; } else if (failure === 'Disabled Individual') { self.common.reply( msg, 'You do not have permission for this command here.'); return true; } else if (failure === 'User Disabled') { self.common.reply( msg, 'This command has been disabled by an admin here.'); return true; } else if (failure === 'User Disabled Individual') { self.common.reply( msg, 'An admin has prevented you from using this command here.'); return true; } else if (failure) { if (failure.startsWith('NoPerm:')) { self.common.reply( msg, 'You must have one of the following permissions ' + 'to use this command:\\n' + failure.substring(7, failure.length)); return true; } else { self.common.reply( msg, 'I am unable to attempt this command for ' + 'you due of an unknown reason.', failure); self.error('Comand failed: ' + msg.cmd + ': ' + failure); return true; } } msg.text = msg.content.replace( new RegExp(escapeRegExp(`${msg.prefix}${msg.cmd}`), 'i'), ''); try { func.trigger(msg); } catch (err) { self.error(msg.cmd + ': FAILED'); console.error(err); self.common.reply(msg, 'An error occurred! Oh noes!'); } return true; } else { return false; } }; /** * Registers a listener for a command. * * @param {string|string[]|Command~SingleCommand} cmd Command to listen for. * @param {commandHandler} [cb] Function to call when command is triggered. * @param {boolean} [onlyserver=false] Whether the command is only allowed * on a server. */ this.on = function(cmd, cb, onlyserver) { // Legacy mapping. if (!(cmd instanceof SingleCommand)) { cmd = new SingleCommand(cmd, cb, {validOnlyInGuild: onlyserver}); } const keys = Object.keys(cmds); const duplicates = cmd.aliases.filter((el) =&gt; { return keys.includes(el); }); if (duplicates.length &gt; 0) { self.error( 'Attempted to register a second handler for event that already ' + 'exists! (' + duplicates.join(', ') + ')'); } else { cmds[cmd.getName()] = cmd; } }; /** * Remove listener for a command. * * @public * * @param {string|string[]} cmd Command or alias of command to remove listener * for. */ this.removeListener = function(cmd) { if (typeof cmd === 'string') { const obj = Object.entries(cmds).find((el) =&gt; { return el[1].aliases.includes(cmd); }); if (obj) { delete cmds[obj[0]]; } else { self.error( 'Requested deletion of event handler for event that was never ' + 'registered! (' + cmd + ')'); } } else if (Array.isArray(cmd)) { for (let i = 0; i &lt; cmd.length; i++) { this.removeListener(cmd[i]); } } else { throw new Error('Event must be string or array of strings'); } }; /** * Alias for {@link Command.removeListener} * @deprecated * @public */ this.deleteEvent = this.removeListener; /** * Returns the callback function for the given event. * * @public * * @param {?string} cmd Command to force search for, and ignore command that * could be matched with msg. * @param {Discord~Message} msg Message that is to trigger this command. This * object will be updated with the command name that was found as msg.cmd. * @param {boolean} [setCmd=false] Set the cmd variable in the msg object to * match the found command. * @returns {?Command~SingleCommand} The single command object reference, or * null if it could not be found. */ this.find = function(cmd, msg, setCmd = false) { let split; if (!cmd) { split = msg.content.trim().split(/\\s/); } else { split = cmd.trim().split(/\\s/); } cmd = split.splice(0, 1)[0]; if (!cmd) return null; if (msg &amp;&amp; cmd.startsWith(msg.prefix)) cmd = cmd.replace(msg.prefix, ''); cmd = cmd.toLowerCase(); let single = Object.values(cmds).find((el) =&gt; { return el.aliases.includes(cmd); }); if (setCmd) msg.cmd = cmd; while (single &amp;&amp; single.subCmds &amp;&amp; split.length &gt; 0) { const sub = Object.values(single.subCmds).find((el) =&gt; { return el.aliases.includes(split[0].toLowerCase()); }); if (sub) { single = sub; if (setCmd) msg.cmd += ' ' + split.splice(0, 1)[0].toLowerCase(); } else { break; } } return single; }; /** * Returns all the callback functions for the given event with wildcards * allowed. * * @public * * @param {string} cmd Command and subcommands to search for without guild * prefixes. * @param {Discord~Message} msg Message object to use to remove command prefix * if it exist. * @returns {Command~SingleCommand[]} The command object references, or an * empty array if it could not be found. */ this.findAll = function(cmd, msg) { if (typeof cmd !== 'string') return []; if (msg &amp;&amp; cmd.startsWith(msg.prefix)) cmd = cmd.replace(msg.prefix, ''); const split = cmd.trim().split(/\\s/); const output = []; (function iterate(list, search) { if (!search || search.length == 0) return; const cmd = search[0].toLowerCase(); if (cmd.indexOf('*') &lt; 0) { const single = list.find((el) =&gt; { return el.aliases.includes(cmd); }); if (single) { output.push(single); const vals = Object.values(single.subCmds); if (vals.length &gt; 0) iterate(vals, search.slice(1)); return; } } else { const regex = new RegExp(cmd.replace(/\\*/g, '.*'), 'g'); list.forEach((el) =&gt; { if (el.aliases.find((alias) =&gt; { return alias.match(regex); })) { output.push(el); const vals = Object.values(el.subCmds); if (vals.length &gt; 0) iterate(vals, search.slice(1)); } }); } })(Object.values(cmds), split); return output; }; /** * Checks that the given command can be run with the given context. Does not * actually fire the event. * * @public * * @param {?string} cmd The command to validate. Null to use msg to find the * command to validate. * @param {?Discord~Message} msg The message that will fire the event. If * null, checks for channel and guild specific changes will not be * validated. * @param {Command~SingleCommand} [func] A command handler override to use for * settings lookup. If this is not specified, the handler associated with * cmd will be fetched. * @returns {?string} Message causing failure, or null if valid. */ this.validate = function(cmd, msg, func) { if (!func) func = self.find(cmd, msg); if (!func) return 'No Handler'; if (msg &amp;&amp; func.options.validOnlyInGuild &amp;&amp; !msg.guild) { return 'Guild Only'; } if (msg) { if (msg.guild) { const guildValues = userSettings[msg.guild.id]; if (guildValues) { const commandValues = guildValues[func.getFullName()]; if (commandValues) { const isDisabled = commandValues.isDisabled(msg); if (!isDisabled) return null; const suffix = commandValues.isMuted ? ' Muted' : ''; if (!commandValues.defaultDisabled) { return (isDisabled == 2 ? 'User Disabled Individual' : 'User Disabled') + suffix; } else if (commandValues.permissions) { return 'NoPerm:' + new self.Discord.Permissions(commandValues.permissions) .toArray() .join(', ') + suffix; } else { return 'User Disabled' + suffix; } } } } const def = func.options.defaultDisabled; const isDisabled = func.options.isDisabled(msg); const bitfield = func.options.permissions; if (!isDisabled) return null; const suffix = func.options.isMuted ? ' Muted' : ''; if (!def) { return (isDisabled == 2 ? 'Disabled Individual' : 'Disabled') + suffix; } else if (bitfield) { return 'NoPerm:' + new self.Discord.Permissions(bitfield).toArray().join(', ') + suffix; } else { return 'Disabled' + suffix; } } return null; }; /** * Fetches a list of all currently registered commands. * * @public * * @returns {string[]} Array of all registered commands. */ this.getAllNames = function() { return Object.keys(cmds); }; /** * Allow user to disable a command. * * @private * @type {Command~commandHandler} * * @param {Discord~Message} msg The message the user sent that triggered this. */ function commandDisable(msg) { if (!msg.text || !msg.text.trim()) { self.common.reply( msg, 'Please specify a command, and where to disable it.'); return; } const trimmedText = msg.text.replace(self.Discord.MessageMentions.CHANNELS_PATTERN, '') .replace(self.Discord.MessageMentions.USERS_PATTERN, '') .replace(self.Discord.MessageMentions.ROLES_PATTERN, '') .trim(); const list = self.findAll(trimmedText, msg); if (!list.length) { self.common.reply( msg, 'I was unable to find that command. (`' + trimmedText + '`)'); return; } const settings = []; list.forEach((cmd) =&gt; { const name = cmd.getFullName(); if (!userSettings[msg.guild.id]) userSettings[msg.guild.id] = {}; if (!userSettings[msg.guild.id][name]) { userSettings[msg.guild.id][name] = new CommandSetting(cmd.options); userSettings[msg.guild.id][name].myGuild = msg.guild.id; } settings.push(userSettings[msg.guild.id][name]); }); const disabledList = []; msg.mentions.channels.forEach((c) =&gt; { settings.forEach((s) =&gt; { if (s.disabled.channels[c.id]) return; s.set(s.defaultDisabled ? 'default' : 'disabled', 'channel', c.id); }); disabledList.push(`${c.type} channel: #${c.name}`); }); msg.mentions.members.forEach((m) =&gt; { settings.forEach((s) =&gt; { if (s.disabled.users[m.id]) return; s.set(s.defaultDisabled ? 'default' : 'disabled', 'user', m.id); }); disabledList.push(`Member: ${m.user.tag}`); }); msg.mentions.roles.forEach((r) =&gt; { settings.forEach((s) =&gt; { if (s.disabled.roles[`${r.guild.id}/${r.id}`]) return; s.set( s.defaultDisabled ? 'default' : 'disabled', 'role', r.id, r.guild.id); }); disabledList.push(`Role: ${r.name}`); }); trimmedText.split(/\\s/).forEach((el) =&gt; { const trimmed = el.trim().toLowerCase(); if (trimmed === 'guild' || trimmed === 'everyone' || trimmed === 'all') { settings.forEach((s) =&gt; { s.defaultDisabled = true; // s.set('disabled', 'guild', msg.guild.id); }); disabledList.push('Default is now DISABLED'); return; } if (self.Discord.Permissions.FLAGS[el]) { settings.forEach((s) =&gt; { s.permissions = s.permissions &amp; (~self.Discord.Permissions.FLAGS[el]); }); disabledList.push('Permission: ' + el); return; } const role = msg.guild.roles.find((r) =&gt; { return r.name.toLowerCase() == trimmed; }); if (role) { settings.forEach((s) =&gt; { if (s.disabled.roles[role.guild.id + '/' + role.id]) { return; } s.set('disabled', 'role', role.id, role.guild.id); }); disabledList.push('Role: ' + role.name); return; } const user = msg.guild.members.find((m) =&gt; { return m.user.tag.toLowerCase() == trimmed; }); if (user) { settings.forEach((s) =&gt; { if (s.disabled.user &amp;&amp; s.disabled.user[user.id]) return; s.set('disabled', 'user', user.id); }); disabledList.push('Member: ' + user.user.tag); return; } }); const nameList = list.map((el) =&gt; '`' + el.getFullName() + '`').join(', '); self.common.reply( msg, 'Disabled\\n' + (disabledList.join('\\n') || 'Nothing'), 'For ' + nameList); } /** * Allow user to enable a command. * * @private * @type {Command~commandHandler} * * @param {Discord~Message} msg The message the user sent that triggered this. */ function commandEnable(msg) { if (!msg.text || !msg.text.trim()) { self.common.reply( msg, 'Please specify a command, and where to enable it.'); return; } const trimmedText = msg.text.replace(self.Discord.MessageMentions.CHANNELS_PATTERN, '') .replace(self.Discord.MessageMentions.USERS_PATTERN, '') .replace(self.Discord.MessageMentions.ROLES_PATTERN, '') .trim(); const list = self.findAll(trimmedText, msg); if (!list.length) { self.common.reply( msg, 'I was unable to find that command. (`' + trimmedText + '`)'); return; } const settings = []; list.forEach((cmd) =&gt; { const name = cmd.getFullName(); if (!userSettings[msg.guild.id]) userSettings[msg.guild.id] = {}; if (!userSettings[msg.guild.id][name]) { userSettings[msg.guild.id][name] = new CommandSetting(cmd.options); userSettings[msg.guild.id][name].myGuild = msg.guild.id; } settings.push(userSettings[msg.guild.id][name]); }); const enabledList = []; msg.mentions.channels.forEach((c) =&gt; { settings.forEach((s) =&gt; { if (s.enabled.channels[c.id]) return; s.set(s.defaultEnabled ? 'default' : 'enabled', 'channel', c.id); }); enabledList.push(c.type + ' channel: #' + c.name); }); msg.mentions.members.forEach((m) =&gt; { settings.forEach((s) =&gt; { if (s.enabled.users[m.id]) return; s.set(s.defaultEnabled ? 'default' : 'enabled', 'user', m.id); }); enabledList.push('Member: ' + m.user.tag); }); msg.mentions.roles.forEach((r) =&gt; { settings.forEach((s) =&gt; { if (s.enabled.roles[r.guild.id + '/' + r.id]) return; s.set( s.defaultEnabled ? 'default' : 'enabled', 'role', r.id, r.guild.id); }); enabledList.push('Role: ' + r.name); }); trimmedText.split(/\\s/).forEach((el) =&gt; { const trimmed = el.trim().toLowerCase(); if (trimmed === 'guild' || trimmed === 'everyone' || trimmed === 'all') { settings.forEach((s) =&gt; { s.defaultDisabled = false; // s.set('enabled', 'guild', msg.guild.id); }); enabledList.push('Default is now ENABLED'); return; } if (self.Discord.Permissions.FLAGS[el]) { settings.forEach((s) =&gt; { s.permissions = s.permissions | self.Discord.Permissions.FLAGS[el]; }); enabledList.push('Permission: ' + el); return; } const role = msg.guild.roles.find((r) =&gt; { return r.name.toLowerCase() == trimmed; }); if (role) { settings.forEach((s) =&gt; { if (s.enabled.roles[role.guild.id + '/' + role.id]) { return; } s.set('enabled', 'role', role.id, role.guild.id); }); enabledList.push('Role: ' + role.name); return; } const user = msg.guild.members.find((m) =&gt; { return m.user.tag.toLowerCase() == trimmed; }); if (user) { settings.forEach((s) =&gt; { if (s.enabled.user &amp;&amp; s.enabled.user[user.id]) return; s.set('enabled', 'user', user.id); }); enabledList.push('Member: ' + user.user.tag); return; } }); const nameList = list.map((el) =&gt; '`' + el.getFullName() + '`').join(', '); self.common.reply( msg, 'Enabled\\n' + (enabledList.join('\\n') || 'Nothing'), 'For ' + nameList); } /** * Allow user to mute a command. * * @private * @type {Command~commandHandler} * * @param {Discord~Message} msg The message the user sent that triggered this. */ function commandBlockCmd(msg) { if (!msg.text || !msg.text.trim()) { self.common.reply( msg, 'Please specify a command.\\nThis will suppress errors when a user ' + 'attempts a command when they don\\' have permission to use it.'); return; } const trimmedText = msg.text.trim(); const list = self.findAll(trimmedText, msg); if (!list.length) { self.common.reply( msg, 'I was unable to find that command. (`' + trimmedText + '`)'); return; } const nameList = list.map((cmd) =&gt; { const name = cmd.getFullName(); if (!userSettings[msg.guild.id]) userSettings[msg.guild.id] = {}; if (!userSettings[msg.guild.id][name]) { userSettings[msg.guild.id][name] = new CommandSetting(cmd.options); userSettings[msg.guild.id][name].myGuild = msg.guild.id; } userSettings[msg.guild.id][name].isMuted = true; return `\\`${name}\\``; }); self.common.reply(msg, 'Muted', nameList.join(', ')); } /** * Allow user to unmute a command. * * @private * @type {Command~commandHandler} * * @param {Discord~Message} msg The message the user sent that triggered this. */ function commandAllowCmd(msg) { if (!msg.text || !msg.text.trim()) { self.common.reply( msg, 'Please specify a command.\\nThis will show errors when a user ' + 'attempts a command when they don\\' have permission to use it.'); return; } const trimmedText = msg.text.trim(); const list = self.findAll(trimmedText, msg); if (!list.length) { self.common.reply( msg, 'I was unable to find that command. (`' + trimmedText + '`)'); return; } const nameList = list.map((cmd) =&gt; { const name = cmd.getFullName(); if (!userSettings[msg.guild.id]) userSettings[msg.guild.id] = {}; if (!userSettings[msg.guild.id][name]) { userSettings[msg.guild.id][name] = new CommandSetting(cmd.options); userSettings[msg.guild.id][name].myGuild = msg.guild.id; } userSettings[msg.guild.id][name].isMuted = false; return `\\`${name}\\``; }); self.common.reply(msg, 'Unmuted', nameList.join(', ')); } /** * Show user the currently configured settings for commands. * * @private * @type {Command~commandHandler} * * @param {Discord~Message} msg The message the user sent that triggered this. */ function commandShow(msg) { let commands; if (msg.text &amp;&amp; msg.text.trim()) { let text = msg.text.trim().toLowerCase(); if (text.startsWith(msg.prefix)) text = text.replace(msg.prefix, ''); commands = userSettings[msg.guild.id]; if (commands) { const origContent = msg.content; msg.content = text; const cmdObj = self.find(null, msg); msg.content = origContent; if (cmdObj) { commands = commands[cmdObj.getFullName()]; if (!commands) { commands = cmdObj.options; } } else { commands = null; } } if (!commands) { const found = Object.values(cmds).find((el) =&gt; { return el.aliases.includes(text); }); if (!found) { if (msg.prefix != self.bot.getPrefix()) { self.common.reply( msg, 'That is not a valid command to lookup.', 'You are using a custom prefix, please include it before the ' + 'command to lookup.'); } else { self.common.reply(msg, 'That is not a valid command to lookup.'); } } else { let output = 'That command is using default settings.\\n' + (found.options.defaultDisabled ? 'Disabled' : 'Enabled') + ' by default'; if (found.options.defaultDisabled &amp;&amp; found.options.permissions) { output += ' and enabled with the following permissions:\\n' + new self.Discord.Permissions(found.options.permissions) .toArray() .join(', '); } self.common.reply(msg, output); } return; } commands = [[text, commands]]; } else { const defaultValues = Object.values(self.getDefaultSettings()); const defaultEntries = []; (function addSubCmds(vals) { vals.forEach((el) =&gt; { defaultEntries.push([el.getFullName(), el.options]); const sCmds = Object.values(el.subCmds); if (sCmds.length &gt; 0) addSubCmds(sCmds); }); })(defaultValues); const defaultOpts = defaultEntries.reduce( (p, c) =&gt; { p[c[0]] = c[1]; return p; }, {}); const finalVals = Object.assign(defaultOpts, userSettings[msg.guild.id]); commands = Object.entries(finalVals).filter((el) =&gt; { if (el[1].defaultDisabled) { return true; /* return el[1].permissions || el[1].enabled.channels || el[1].enabled.users || el[1].enabled.roles; */ } else { return Object.keys(el[1].disabled.channels).length || Object.keys(el[1].disabled.users).length || Object.keys(el[1].disabled.roles).length; } }); } const output = commands.map((el) =&gt; { const tmp = []; let obj; if (el[1].defaultDisabled) { tmp.push('`' + el[0] + (el[1].isMuted ? '~' : '') + '` allowed with:'); if (el[1].permissions) { tmp.push( new self.Discord.Permissions(el[1].permissions) .toArray() .join(', ')); } obj = el[1].enabled; } else { tmp.push('`' + el[0] + (el[1].isMuted ? '~' : '') + '` blocked for:'); obj = el[1].disabled; } const channels = Object.keys(obj.channels); if (channels.length) { const list = channels.map((c) =&gt; { if (!msg.guild.channels.get(c)) return ''; return '#' + msg.guild.channels.get(c).name; }); tmp.push('Channels: ' + list.join(', ')); } const users = Object.keys(obj.users); if (users.length) { const list = users.map((u) =&gt; { if (!msg.guild.members.get(u)) return ''; return msg.guild.members.get(u).user.tag; }); tmp.push('Members: ' + list.join(', ')); } const roles = Object.keys(obj.roles); if (roles.length) { const list = roles.map((r) =&gt; { r = r.split('/')[1]; if (!msg.guild.roles.get(r)) return ''; return msg.guild.roles.get(r).name; }); tmp.push('Roles: ' + list.join(', ')); } if (tmp.length == 2) return tmp.join(' '); if (tmp.length == 1) tmp.push('Nothing'); return tmp.join('\\n'); }).filter((el) =&gt; { return el; }); if (output.length &gt; 5800) { self.common.reply(msg, 'Please specify a command to lookup.'); } else { const finalSplits = []; (function splitOutput(num) { const splitLength = Math.ceil(output.length / num); for (let i = 0; i &lt; num; i++) { const section = output.slice(splitLength * i, splitLength * (i + 1)) .join('\\n') .length; if (section &gt; 1024) { if (num &gt; 25) return; splitOutput(num + 1); return; } } for (let i = 1; i &lt; num; i++) { finalSplits.push(output.splice(0, splitLength).join('\\n')); } finalSplits.push(output.splice(0).join('\\n')); })(1); if (finalSplits.length == 0) { self.common.reply( msg, 'I wasn\\'t able to fit all settings into a message.'); return; } const embed = new self.Discord.MessageEmbed(); embed.setColor([255, 0, 255]); embed.setTitle('Command Permissions'); for (let i = 0; i &lt; finalSplits.length; i++) { embed.addField('\\u200B', finalSplits[i], true); } embed.setDescription( 'Reset values to default with ' + msg.prefix + 'reset\\nChange values with ' + msg.prefix + 'enable or ' + msg.prefix + 'disable'); embed.setFooter('~ denotes command is muted on error.'); msg.channel.send(self.common.mention(msg), embed).catch(() =&gt; { self.common.reply(msg, 'Please specify a command to lookup.') .catch(() =&gt; {}); }); } } /** * Reset all custom command settings to default. * * @private * @type {Command~commandHandler} * @fires Command.events#settingsReset * * @param {Discord~Message} msg The message the user sent that triggered this. */ function commandReset(msg) { if (!msg.text || !msg.text.trim()) { self.common .reply( msg, 'Are you sure you wish to reset all' + ' settings for all commands on this server?') .then((msg_) =&gt; { msg_.react('✅'); msg_.awaitReactions((reaction, user) =&gt; { return reaction.emoji.name === '✅' &amp;&amp; user.id === msg.author.id; }, {time: 30000, max: 1}).then((reactions) =&gt; { if (reactions.size === 0) { msg_.edit('`Timed out`'); return; } msg_.edit('`Confirmed`'); userSettings[msg.guild.id] = {}; self.common.reply( msg, 'All settings for commands have been reset.'); self.fire('settingsReset', msg.guild.id); }); }); } else if (msg.text.indexOf('*') &lt; 0) { msg.content = msg.text; const cmd = self.find(null, msg); if (!cmd || !userSettings[msg.guild.id] || !userSettings[msg.guild.id][cmd.getFullName()]) { self.common.reply( msg, 'That does not appear to be a setting that I can reset for you.', 'It may already be reset.'); return; } self.common .reply( msg, 'Are you sure you wish to reset settings for `' + cmd.getFullName() + '`?') .then((msg_) =&gt; { msg_.react('✅'); msg_.awaitReactions((reaction, user) =&gt; { return reaction.emoji.name === '✅' &amp;&amp; user.id === msg.author.id; }, {time: 30000, max: 1}).then((reactions) =&gt; { if (reactions.size === 0) { msg_.edit('`Timed out`'); return; } msg_.edit('`Confirmed`'); delete userSettings[msg.guild.id][cmd.getFullName()]; self.common.reply( msg, 'Settings for `' + cmd.getFullName() + '` have been reset.'); self.fire('settingsReset', msg.guild.id, cmd.getFullName()); }); }); } else { const cmd = self.findAll(msg.text, msg); if (cmd.length == 0) { self.common.reply( msg, 'I couldn\\'t find any commands to reset that match what' + ' you asked for.'); return; } const nameList = cmd.map((el) =&gt; '`' + el.getFullName() + '`').join(', '); self.common .reply( msg, 'Are you sure you wish to reset settings for all of the ' + 'following commands?', nameList) .then((msg_) =&gt; { msg_.react('✅'); msg_.awaitReactions((reaction, user) =&gt; { return reaction.emoji.name === '✅' &amp;&amp; user.id === msg.author.id; }, {time: 30000, max: 1}).then((reactions) =&gt; { if (reactions.size === 0) { msg_.edit('`Timed out`'); return; } msg_.edit('`Confirmed`'); cmd.forEach((el) =&gt; { delete userSettings[msg.guild.id][el.getFullName()]; self.fire('settingsReset', msg.guild.id, el.getFullName()); }); self.common.reply(msg, 'Settings for have been reset.', nameList); }); }); } } /** * Register an event listener. * * @public * * @param {string} name The name of the event to listen for. * @param {Function} handler The function to call when the event is fired. */ this.addEventListener = function(name, handler) { if (!eventList[name]) eventList[name] = []; eventList[name].push(handler); }; /** * Remove an event listener. * * @public * * @param {string} name The name of the event to listen for. * @param {Function} handler THe handler that is currently registered to * listen on this event. */ this.removeEventListener = function(name, handler) { const handlers = eventList[name]; if (!handlers) return; const index = handlers.findIndex((el) =&gt; { return el == handler; }); if (index &lt; 0) return; handlers.splice(index, 0); }; /** * Fire all handlers listening for an event. * * @public * * @param {string} name The name of the event to fire. * @param {*} args The arguments to pass to the handlers. */ this.fire = function(name, ...args) { const handlers = eventList[name]; if (!handlers || handlers.length == 0) return; handlers.forEach((h) =&gt; { h.apply(h, args); }); }; /** * Escape a given string to be passed into a regular expression. * * @private * @param {string} str Input to escape. * @returns {string} Escaped string. */ function escapeRegExp(str) { return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&amp;'); } } module.exports = new Command(); × Search results Close "},"mainModule.js.html":{"id":"mainModule.js.html","title":"Source: mainModule.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: mainModule.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(MainModule); // Extends the SubModule class. /** * @classdesc Base class for required modules for the bot to work. Adds * interface for maintaining references across reloads. * @class * @augments SubModule */ function MainModule() { /** * The data exported and imported by this module intended to be used to * persist across reloads. * @typedef MainModule~ModuleData * * @type {Object.&lt;*&gt;} */ /* eslint-disable @typescript-eslint/no-unused-vars */ /** * Imports data from a previous instance of this class in order to maintain * references to other objects and classes across reloads. * * @public * @abstract * @param {?MainModule~ModuleData} data The data that was exported previously, * or null if no data to import. */ this.import = function(data) {}; /* eslint-enable @typescript-eslint/no-unused-vars */ /** * Export data required to maintain the bot across reloading this module. * Expected to be returned directly to this.import once reloaded. * * @public * @abstract * @returns {MainModule~ModuleData} The data to be exported. */ this.export = function() { return {}; }; /** * @description Signal that the bot is shutting down and will not be * restarting immediately. This is triggered on all shutdowns where all * MainModules and SubModules will be unloaded. * * @public * @abstract */ this.terminate = function() {}; } /** * Extends MainModule as the base class of a child. * * @param {object} child The child class to extend. */ MainModule.extend = function(child) { child.prototype = new MainModule(); child.prototype.constructor = child; }; module.exports = MainModule.extend; × Search results Close "},"connect4.js.html":{"id":"connect4.js.html","title":"Source: connect4.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: connect4.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(Connect4); // Extends the SubModule class. /** * @classdesc Manages a Connect 4 game. * @class * @augments SubModule * @listens Command#connect4 */ function Connect4() { const self = this; /** @inheritdoc */ this.myName = 'Connect4'; /** @inheritdoc */ this.initialize = function() { self.command.on('connect4', commandConnect4); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('connect4'); }; /** @inheritdoc */ this.unloadable = function() { return numGames === 0; }; /** * Maximum amount of time to wait for reactions to a message. Also becomes * maximum amount of time a game will run with no input, because controls will * be disabled after this timeout. * * @private * @constant * @type {number} * @default 5 Minutes */ const maxReactAwaitTime = 5 * 1000 * 60; // 5 Minutes /** * The number of rows in the board. * * @private * @constant * @type {number} * @default */ const numRows = 6; /** * The number of columns in the board. * * @private * @constant * @type {number} * @default */ const numCols = 7; /** * Helper object of emoji characters mapped to names. * * @private * @type {Object.&lt;string&gt;} * @constant * @default */ const emoji = { 0: '\\u0030\\u20E3', 1: '\\u0031\\u20E3', 2: '\\u0032\\u20E3', 3: '\\u0033\\u20E3', 4: '\\u0034\\u20E3', 5: '\\u0035\\u20E3', 6: '\\u0036\\u20E3', 7: '\\u0037\\u20E3', 8: '\\u0038\\u20E3', 9: '\\u0039\\u20E3', X: '❌', O: '⭕', }; /** * The number of currently active games. Used to determine of submodule is * unloadable. * @private * @type {number} * @default */ let numGames = 0; /** * Starts a connect 4 game. If someone is mentioned it will start a game * between the message author and the mentioned person. Otherwise, waits for * someone to play. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#connect4 */ function commandConnect4(msg) { const players = {p1: msg.author, p2: null}; if (msg.mentions.users.size &gt; 0) { players.p2 = msg.mentions.users.first(); } self.createGame(players, msg.channel); } /** * Class that stores the current state of a connect 4 game. * * @class * * @public * @param {{p1: Discord~User, p2: Discord~User}} players The players in this * game. * @param {Discord~Message} msg The message displaying the current game. */ this.Game = function(players, msg) { const game = this; /** * The players in this game. * @type {{p1: Discord~User, p2: Discord~User}} */ this.players = players; /** * 2D Array of a 7w x 6h board. 0 is nobody, 1 is player 1, 2 is player 2. * @type {Array.&lt;number[]&gt;} */ this.board = [ [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], ]; /** * Which player's turn it is. Either 1 or 2. * @type {number} */ this.turn = 1; /** * The message displaying the current game. * @type {Discord~Message} */ this.msg = msg; /** * Edit the current message to show the current board. * * @param {number} [winner=0] The player who has won the game. 0 is game not * done, 1 is player 1, 2 is player 2, 3 is draw. */ this.print = function(winner = 0) { const embed = new self.Discord.MessageEmbed(); const names = ['Nobody', 'Nobody']; let gameFull = true; if (this.players.p1) { names[0] = this.players.p1.username; } else { gameFull = false; } if (this.players.p2) { names[1] = this.players.p2.username; } else { gameFull = false; } embed.setTitle(names[0] + ' vs ' + names[1]); if (!gameFull) { embed.setDescription('To join the game, just make a move!'); } let finalBoard = '```css\\n' + // '012345678901234567890123456\\n' + ' Connect Four \\n' + this.board .map(function(row, rowNum) { return row .map(function(cell, colNum) { switch (game.board[rowNum][colNum]) { case 1: if (winner &gt; 0 &amp;&amp; winner != 1) { return ' x '; } return ' X '; case 2: if (winner &gt; 0 &amp;&amp; winner != 2) { return ' o '; } return ' O '; default: return ' '; } }) .join('|'); }) .join('\\n'); finalBoard += '\\n'; for (let i = 0; i &lt; numCols; i++) { finalBoard += '___'; if (i != numCols - 1) finalBoard += '|'; } finalBoard += '\\n'; for (let i = 0; i &lt; numCols; i++) { finalBoard += ' ' + i + ' '; if (i != numCols - 1) finalBoard += '|'; } finalBoard += '\\n```'; embed.addField('\\u200B', finalBoard, true); if (winner == 0) { embed.addField( names[this.turn - 1] + '\\'s turn (' + (this.turn == 1 ? 'X' : 'O') + ')', '`' + names[0] + '` is X\\n`' + names[1] + '` is O', true); } else { numGames--; embed.addField( '\\u200B', '`' + names[0] + '` was X\\n`' + names[1] + '` was O', true); } if (winner == 3) { embed.addField('Draw game!', 'Nobody wins'); } else if (winner == 2) { embed.addField( names[1] + ' Won! ' + emoji.O, names[0] + ', try harder next time.'); } else if (winner == 1) { embed.addField( names[0] + ' Won! ' + emoji.X, names[1] + ', try harder next time.'); } msg.edit('\\u200B', embed); }; }; /** * Create a game with the given players in a given text channel. * * @public * @param {{p1: Discord~User, p2: Discord~User}} players The players in the * game. * @param {Discord~TextChannel} channel The text channel to send messages. */ this.createGame = function(players, channel) { numGames++; channel.send('`Loading Connect 4...`').then((msg) =&gt; { const game = new self.Game(players, msg); game.print(); addReactions(msg); addListener(msg, game); }); }; /** * Add the reactions to a message for controls of the game. Recursive. * * @private * @param {Discord~Message} msg The message to add the reactions to. * @param {number} index The number of reactions we have added so far. */ function addReactions(msg, index = 0) { msg.react(emoji[index]).then(() =&gt; { if (index &lt; numCols - 1) addReactions(msg, index + 1); }); } /** * Add the listener for reactions to the game. * * @private * @param {Discord~Message} msg The message to add the reactions to. * @param {Connect4~Game} game The game to update when changes are made. */ function addListener(msg, game) { msg.awaitReactions(function(reaction, user) { if (user.id != self.client.user.id) { reaction.users.remove(user).catch(() =&gt; {}); } else { return false; } if (game.turn == 1 &amp;&amp; game.players.p1 &amp;&amp; user.id != game.players.p1.id) { return false; } if (game.turn == 2 &amp;&amp; game.players.p2 &amp;&amp; user.id != game.players.p2.id) { return false; } for (let i = 0; i &lt; numCols; i++) { if (emoji[i] == reaction.emoji.name) return true; } return false; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg.reactions.removeAll().catch(() =&gt; {}); msg.edit( 'Game timed out!\\nThe game has ended because nobody made a ' + 'move in too long!'); game.print(game.turn == 1 ? 2 : 1); return; } if (!game.players.p1 &amp;&amp; game.turn == 1) { const reactUsers = reactions.first().users.first(2); game.players.p1 = reactUsers[1] || reactUsers[0]; } if (!game.players.p2 &amp;&amp; game.turn == 2) { const reactUsers = reactions.first().users.first(2); game.players.p2 = reactUsers[1] || reactUsers[0]; } let move = -1; const choice = reactions.first().emoji; for (let i = 0; i &lt; numCols; i++) { if (emoji[i] == choice.name) { move = i; break; } } if (move == -1) { addListener(msg, game); return; } if (game.board[0][move] != 0) { addListener(msg, game); return; } /* if (game.board[1][move] != 0) { reactions.first().users.remove(self.client.user); } */ let row; for (row = 1; row &lt; numRows; row++) { if (game.board[row][move] != 0) { break; } } row--; game.board[row][move] = game.turn; const winner = checkWin(game.board, row, move); if (winner != 0) { msg.reactions.removeAll().catch(() =&gt; {}); } else { game.turn = game.turn === 1 ? 2 : 1; addListener(msg, game); } game.print(winner); }); } /** * Checks if the given board has a winner, or if the game is over. * * @param {number[]} board Array of 9 numbers defining a board. 0 is nobody, 1 * is player 1, 2 is player 2. * @param {number} latestR The row index where the latest move occurred. * @param {number} latestC The column index where the latest move occurred. * @returns {number} Returns 0 if game is not over, 1 if player 1 won, 2 if * player 2 won, 3 if draw. */ function checkWin(board, latestR, latestC) { const player = board[latestR][latestC]; // Column let count = 0; for (let r = latestR - 3; r &lt;= latestR + 3 &amp;&amp; r &lt; numRows; r++) { if (r &lt; 0) continue; if (board[r][latestC] == player) count++; else count = 0; if (count == 4) return player; } // Row count = 0; for (let c = latestC - 3; c &lt;= latestC + 3 &amp;&amp; c &lt; numCols; c++) { if (c &lt; 0) continue; if (board[latestR][c] == player) count++; else count = 0; if (count == 4) return player; } // Diag TL to BR count = 0; for (let r = latestR - 3, c = latestC - 3; r &lt;= latestR + 3 &amp;&amp; r &lt; numRows &amp;&amp; c &lt;= latestC + 3 &amp;&amp; c &lt; numCols; r++, c++) { if (r &lt; 0) continue; if (c &lt; 0) continue; if (board[r][c] == player) count++; else count = 0; if (count == 4) return player; } // Diag BL to TR count = 0; for (let r = latestR + 3, c = latestC - 3; r &gt;= latestR - 3 &amp;&amp; r &gt;= 0 &amp;&amp; c &lt;= latestC + 3 &amp;&amp; c &lt; numCols; r--, c++) { if (r &gt; numRows - 1) continue; if (c &lt; 0) continue; if (board[r][c] == player) count++; else count = 0; if (count == 4) return player; } // Is board full for (let r = 0; r &lt; numRows; r++) { for (let c = 0; c &lt; numCols; c++) { if (board[r][c] === 0) return 0; } } return 3; } } module.exports = new Connect4(); × Search results Close "},"define.js.html":{"id":"define.js.html","title":"Source: define.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: define.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(Define); // Extends the SubModule class. const https = require('https'); const auth = require('../auth.js'); /** * @classdesc Handles defining word commands. * @class * @augments SubModule * @listens Command#define */ function Define() { const self = this; /** @inheritdoc */ this.myName = 'Define'; /** @inheritdoc */ this.initialize = function() { self.command.on( new self.command.SingleCommand( ['define', 'def', 'definition'], commandDefine)); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('define'); }; /** * Base url to request from api. * @private * @default * @constant * @type {string} */ const reqURL = 'https://wordsapiv1.p.rapidapi.com/words/'; /** * Handle the user asking for a definition. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#define */ function commandDefine(msg) { const match = (msg.text || '').match(/(\\w+)/); if (!match) { self.common.reply(msg, 'Please specify a word to define.') .catch(() =&gt; {}); return; } const word = match[1]; msg.channel.startTyping(); const req = https.request(reqURL + word, (res) =&gt; { let data = ''; res.on('data', (chunk) =&gt; { data += chunk; }); res.on('end', () =&gt; { msg.channel.stopTyping(); let parsed; try { parsed = JSON.parse(data); } catch (err) { self.common.reply(msg, 'Oops, something is broken.').catch(() =&gt; {}); return; } if (parsed.success ===false) { self.common.reply( msg, 'Unable to find word in the dictionary.', word); } else { replyDef(msg, parsed); } if (msg.text.indexOf('--raw') &gt; -1) { msg.channel.send( '```' + JSON.stringify(parsed, null, 1).substring(0, 1994) + '```'); } }); }); req.on('error', (err) =&gt; { self.error('Error while fetching definition: ' + err.message); console.error(err); msg.channel.stopTyping(); }); req.setHeader('X-RapidAPI-Key', auth.wordsAPIKey); req.end(); } /** * Format a Discord message reply from the given data. * * @private * @param {Discord~Message} msg Message to reply to. * @param {object} data Parsed reply from words api. */ function replyDef(msg, data) { const embed = new self.Discord.MessageEmbed(); embed.setTitle(fUp(data.word)); embed.setColor([255, 0, 255]); if (data.results) { const list = data.results.slice(0, 5).map(formatSingle); embed.addField( 'Definition' + (data.results.length &gt; 1 ? 's' : ''), list.join('\\n')); } if (data.syllables) { embed.addField( 'Syllable' + (data.syllables.count &gt; 1 ? 's (' : ' (') + data.syllables.count + ')', data.syllables.list.join(' '), true); } if (data.pronunciation) { const p = typeof data.pronunciation === 'string' ? data.pronunciation : Object.entries(data.pronunciation) .map((el) =&gt; { return el[0] + ': ' + el[1]; }) .join('\\n'); embed.addField('Pronunciation', p, true); } msg.channel.send(self.common.mention(msg), embed); } /** * Format a single definition to string format. * * @private * @param {{ * definition: string, * partOfSpeech: string, * examples: Array.&lt;string&gt;, * synonyms: Array.&lt;string&gt; * }} el Definition object to format. * @returns {string} Formatted string. */ function formatSingle(el) { let res = ''; if (el.definition) { res += `__${fUp(el.definition)}__\\n`; } if (el.synonyms) { res += el.synonyms.join(', ') + '\\n'; } if (el.partOfSpeech) { res += `*${el.partOfSpeech}*\\n`; } if (el.examples) { res += el.examples.map((el, i) =&gt; (i + 1) + ') ' + fUp(el)).join('\\n') + '\\n'; } return res; } /** * Capitalize first character of string, and lowercase the rest. * * @private * @param {string} s Input. * @returns {string} Output. */ function fUp(s) { return s[0].toLocaleUpperCase() + s.slice(1).toLocaleLowerCase(); } } module.exports = new Define(); × Search results Close "},"dev.js.html":{"id":"dev.js.html","title":"Source: dev.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: dev.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(DevCmds); // Extends the SubModule class. /** * @classdesc Runs unsafe scripts for development purposes. DO NOT LOAD ON * RELEASE VERSIONS. * @class * @augments SubModule * @listens Discord~Client#message * @listens Command#run */ function DevCmds() { const self = this; /** @inheritdoc */ this.myName = 'DevCmds'; /** @inheritdoc */ this.initialize = function() { self.command.on(new self.command.SingleCommand(['run'], commandRun)); self.client.on('message', onMessage); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('run'); self.client.removeListener('message', onMessage); }; /** * Run code as the bot. EXTREMELY UNSAFE! * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. */ function commandRun(msg) { if (msg.author.id !== self.common.spikeyId) return; let res = ''; try { res = eval(msg.text); res = JSON.stringify(res); } catch (err) { res = err; } self.common.reply(msg, res || typeof res); } /** * Handle receiving a message. Only adds reactions in the #feature-ideas * channel. * * @private * @param {Discord~Message} msg The message that was sent. * @listens Discord~Client#message */ function onMessage(msg) { if (msg.channel.id != '554105419417518103') return; msg.react('👍'); } } module.exports = new DevCmds(); × Search results Close "},"echo.js.html":{"id":"echo.js.html","title":"Source: echo.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: echo.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const mkdirp = require('mkdirp'); const SubModule = require('./subModule.js'); /** * @description Manages echo-related commands. * @listens Discord:external~Client#message * @listens Command#say * @listens Command#echo * @listens Command#become * @listens Command#self * @listens Command#be * @listens Command#character * @listens Command#impersonate * @listens Command#who * @listens Command#whois * @listens Command#whoami */ class Echo extends SubModule { /** * @description SubModule managing echo related commands. */ constructor() { super(); /** @inheritdoc */ this.myName = 'Echo'; /** * @description The id of the last user to use the say command. * * @private * @type {string} * @default */ this._prevUserSayId = ''; /** * @description The number of times the say command has been used * consecutively by the previous user. * * @private * @type {number} * @default */ this._prevUserSayCnt = 0; /** * @description All npc characters a users are currently being. Mapped by * guild id, then channel id, then user id. * * @private * @type {Object} * @default */ this._characters = {}; this.save = this.save.bind(this); this._commandSay = this._commandSay.bind(this); this._commandBecome = this._commandBecome.bind(this); this._commandWhoIs = this._commandWhoIs.bind(this); this._commandWhoAmI = this._commandWhoAmI.bind(this); this._commandResetCharacters = this._commandResetCharacters.bind(this); this._onMessage = this._onMessage.bind(this); } /** @inheritdoc */ initialize() { this.command.on(['say', 'echo'], this._commandSay); this.command.on( new this.command.SingleCommand( ['become', 'self', 'be', 'character', 'impersonate'], this._commandBecome, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_MESSAGES | this.Discord.Permissions.FLAGS.MANAGE_WEBHOOKS | this.Discord.Permissions.FLAGS.MANAGE_GUILD, })); this.command.on( new this.command.SingleCommand( ['who', 'whois'], this._commandWhoIs, {validOnlyInGuild: true})); this.command.on('whoami', this._commandWhoAmI); this.command.on( new this.command.SingleCommand( ['resetcharacters', 'deletecharacters'], this._commandResetCharacters, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_MESSAGES | this.Discord.Permissions.FLAGS.MANAGE_WEBHOOKS | this.Discord.Permissions.FLAGS.MANAGE_GUILD, })); this.client.on('message', this._onMessage); this.client.guilds.forEach((g) =&gt; { fs.readFile( `${this.common.guildSaveDir}${g.id}/characters.json`, (err, file) =&gt; { if (err) return; let parsed; try { parsed = JSON.parse(file); } catch (e) { return; } this._characters[g.id] = parsed; }); }); } /** @inheritdoc */ shutdown() { this.command.removeListener('say'); this.command.removeListener('become'); this.command.removeListener('whoami'); this.command.removeListener('whois'); this.command.removeListener('resetcharacters'); this.client.removeListener('message', this._onMessage); } /** @inheritdoc */ save(opt) { if (!this.initialized) return; Object.entries(this._characters).forEach((obj) =&gt; { const dir = `${this.common.guildSaveDir}${obj[0]}/`; const filename = `${dir}characters.json`; if (opt == 'async') { this._mkAndWrite(filename, dir, JSON.stringify(obj[1])); } else { this._mkAndWriteSync(filename, dir, JSON.stringify(obj[1])); } }); } /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Async. * * @see {@link Echo~_mkAndWriteSync} * * @private * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ _mkAndWrite(filename, dir, data) { mkdirp(dir, (err) =&gt; { if (err) { this.error('Failed to make directory: ' + dir); console.error(err); return; } fs.writeFile(filename, data, (err2) =&gt; { if (err2) { this.error('Failed to save echos: ' + filename); console.error(err2); return; } }); }); } /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Synchronous. * * @see {@link Echo~_mkAndWrite} * * @private * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ _mkAndWriteSync(filename, dir, data) { try { mkdirp.sync(dir); } catch (err) { this.error('Failed to make directory: ' + dir); console.error(err); return; } try { fs.writeFileSync(filename, data); } catch (err) { this.error('Failed to save echos: ' + filename); console.error(err); return; } } /** * Handle receiving a message for webhook replacing. * * @private * @param {Discord~Message} msg The message that was sent. * @listens Discord~Client#message */ _onMessage(msg) { if (!msg.guild || msg.author.bot) return; const char = this._characters[msg.guild.id] &amp;&amp; this._characters[msg.guild.id][msg.channel.id] &amp;&amp; this._characters[msg.guild.id][msg.channel.id][msg.author.id]; if (!char) { return; } if (!msg.channel.permissionsFor(msg.guild.me) .has(this.Discord.Permissions.FLAGS.MANAGE_WEBHOOKS)) { return; } msg.channel.fetchWebhooks() .then((hooks) =&gt; { const hook = hooks.find((h) =&gt; h.owner.id == this.client.user.id); if (!hook) return; hook.send(msg.content, { username: char.username, avatarURL: char.avatarURL, // files: msg.attachments.map((el) =&gt; el.url), }); if (msg.channel.permissionsFor(msg.guild.me) .has(this.Discord.Permissions.FLAGS.MANAGE_MESSAGES)) { msg.delete().catch((err) =&gt; { this.error('Failed to delete message: ' + msg.channel.id); console.error(err); }); } }) .catch((err) =&gt; { this.error('Unable to fetch webhooks for channel: ' + msg.channel.id); console.error(err); }); } /** * @description The user's message will be deleted and the bot will send an * identical message without the command to make it seem like the bot sent the * message. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#say * @listens Command#echo */ _commandSay(msg) { if (msg.delete) msg.delete().catch(() =&gt; {}); const content = msg.text.trim(); msg.channel.send(content || '\\u200B').catch((err) =&gt; { this.warn( 'Failed to send message in channel: ' + msg.channel.id + ': ' + content); console.error(err); }); if (msg.fabricated || this._prevUserSayId != msg.author.id) { this._prevUserSayId = msg.author.id; this._prevUserSayCnt = 0; } this._prevUserSayCnt++; if (this._prevUserSayCnt % 3 === 0) { msg.channel.send( 'Help! ' + this.common.mention(msg) + ' is putting words into my mouth!'); } } /** * @description Replace all following messages from a user with a character. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#become * @listens Command#self * @listens Command#be * @listens Command#character * @listens Command#imprsonate */ _commandBecome(msg) { if (!this._characters[msg.guild.id]) { this._characters[msg.guild.id] = {}; } let channel = msg.channel; if (msg.mentions.channels.size &gt; 0) { channel = msg.mentions.channels.first(); msg.text = msg.text.replace(this.Discord.MessageMentions.CHANNELS_PATTERN, ''); } if (!this._characters[msg.guild.id][channel.id]) { this._characters[msg.guild.id][channel.id] = {}; } if (msg.text.length &gt; 1) { let url; if (msg.attachments.size == 1) { const a = msg.attachments.first(); url = a.proxyURL || a.url; } else if (msg.attachments.size == 0) { url = msg.text.match(Echo._urlRegex); if (url) url = url[0]; } if (typeof url !== 'string' || url.length == 0) { /* this.common.reply( msg, 'Hmm, you didn\\'t give me an image to use as an avatar.'); return; */ url = undefined; } const username = this._formatUsername(msg.text, url); if (username.length &lt; 2) { this.common.reply(msg, 'Please specify a valid username.', username); return; } // Wait one loop to prevent the command from triggering the event. setTimeout(() =&gt; { this._characters[msg.guild.id][channel.id][msg.author.id] = new Character(username, url); }); channel.fetchWebhooks() .then((hooks) =&gt; { const hook = hooks.find((h) =&gt; h.owner.id == this.client.user.id); if (!hook) { if (!channel.permissionsFor(msg.guild.me) .has(this.Discord.Permissions.FLAGS.MANAGE_WEBHOOKS)) { this.common.reply( msg, 'Failed to create webhook', 'I need permission to manage webhooks.'); return; } channel .createWebhook( 'SpikeyBot NPCs', {reason: 'Used for becoming other characters.'}) .then(() =&gt; { this.common.reply(msg, 'Created', username); }) .catch((err) =&gt; { this.error( 'Failed to create webhook for channel: ' + channel.id); console.error(err); this.common.reply( msg, 'Failed to create webhook', err.message); }); } else { this.common.reply(msg, 'Created', username); } }) .catch((err) =&gt; { this.error('Failed to fetch webhooks for channel: ' + channel.id); console.error(err); this.common.reply(msg, 'Unable to fetch webhooks.', err.message); }); } else { delete this._characters[msg.guild.id][channel.id][msg.author.id]; this.common.reply(msg, 'Disabled character'); } } /** * Tell the user who they are. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. * @listens Command#whoami */ _commandWhoAmI(msg) { const char = msg.guild &amp;&amp; this._characters[msg.guild.id] &amp;&amp; this._characters[msg.guild.id][msg.channel.id] &amp;&amp; this._characters[msg.guild.id][msg.channel.id][msg.author.id]; if (char) { this.common.reply( msg, msg.author.tag, msg.author.username + ' (' + msg.member.nickname + ')\\nCharacter: ' + char.username); } else { this.common.reply( msg, msg.author.tag, `${msg.author.username} (${msg.member.nickname})`); } } /** * List all characters currently active in all channels of a guild. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. * @listens Command#who * @listens Command#whois */ _commandWhoIs(msg) { const chars = msg.guild &amp;&amp; this._characters[msg.guild.id]; let output = []; for (let channel in chars) { if (!channel) continue; channel = msg.guild.channels.get(channel); if (!channel) continue; const list = []; for (let member in chars[channel.id]) { if (!member) continue; member = msg.guild.members.get(member); if (!member) continue; list.push( `${member.user.tag}: ${chars[channel.id][member.id].username}`); } if (list.length &gt; 0) { output.push(`**#${channel.name}**`); output = output.concat(list); } } this.common.reply(msg, 'Current Characters', output.join('\\n') || 'None'); } /** * Reset all current characters, and delete all webhooks. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. * @listens Command#resetcharacters */ _commandResetCharacters(msg) { if (!this._characters[msg.guild.id]) { this.common.reply(msg, 'No characters to reset.'); return; } const channels = Object.keys(this._characters[msg.guild.id]); channels.forEach((el) =&gt; { const channel = msg.guild.channels.get(el); if (!channel) return; channel.fetchWebhooks() .then((hooks) =&gt; { const hook = hooks.find((h) =&gt; h.owner.id == this.client.user.id); hook.delete('Clearing all characaters.').catch(() =&gt; {}); }) .catch(() =&gt; {}); }); this._characters[msg.guild.id] = {}; this.common.reply(msg, 'All characters deleted.'); } /** * @description Remove url from username, and format to rules similar to * Discord. * * @private * @param {string} u The username. * @param {string|RegExp} [remove] A substring or RegExp to remove. * @returns {string} Formatted username. */ _formatUsername(u, remove) { if (!remove) remove = /a^/; // Match nothing by default. return u.replace(remove, '') .replace(/^\\s+|\\s+$|@|#|:|```/g, '') .replace(/\\s{2,}/g, ' ') .substring(0, 32); } } /** * @description A character to send as a webhook. * @memberof Echo * @inner */ class Character { /** * @description Create a Character. * @param {string} username Username for webhook. * @param {string} [url] Avatar url override for webhook. */ constructor(username, url) { /** * @description Username of this character. * @type {string} */ this.username = username; /** * @description Avatar url of this character. * @type {string} */ this.avatarURL = url; } } Echo.Character = Character; /** * Regex to match all URLs in a string. * * @private * @type {RegExp} * @constant * @default * @static */ Echo._urlRegex = new RegExp( '(http(s)?:\\\\/\\\\/.)?(www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.[a-z]' + '{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\+.~#?&amp;//=]*)(?![^&lt;]*&gt;)', 'g'); module.exports = new Echo(); × Search results Close "},"SpikeyBot.js.html":{"id":"SpikeyBot.js.html","title":"Source: SpikeyBot.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: SpikeyBot.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * DiscordJS base object. * @external Discord * @see {@link https://discord.js.org/} */ const Discord = require('discord.js'); const fs = require('fs'); const mkdirp = require('mkdirp'); const childProcess = require('child_process'); // Auth is not constant and will be reloaded with common.js. let auth = require('../auth.js'); // common.js is also required, but is managed within the SpikeyBot class. /** * Handler for an unhandledRejection or uncaughtException, to prevent the bot * from silently crashing without an error. * * @private * @param {...*} args All information to log. * @listens Process#unhandledRejection * @listens Process#uncaughtException */ function unhandledRejection(...args) { const pid = ('00000' + process.pid).slice(-5); if (args[0] &amp;&amp; args[0].name == 'DiscordAPIError') { const e = args[0]; const str = `ERR:${pid} Uncaught ${e.name}: ${e.message} ` + `${e.method} ${e.code} (${e.path})`; console.log(str); } else if (args[0] &amp;&amp; args[0].message == 'No Perms') { console.log(`ERR:${pid}`, args[0]); } else { // console.log(`ERR:${pid}`, ...args); console.log(`ERR:${pid}`, args[0]); } } process.on('unhandledRejection', unhandledRejection); process.on('uncaughtException', unhandledRejection); // Catch MaxListenersExceededWarning and provide more useful information. const EventEmitter = require('events').EventEmitter; const originalAddListener = EventEmitter.prototype.addListener; /* eslint-disable no-invalid-this */ const addListener = function(...args) { originalAddListener.apply(this, args); const type = args[0]; const numListeners = this.listeners(type).length; const max = typeof this._maxListeners === 'number' ? this._maxListeners : 10; if (max !== 0 &amp;&amp; numListeners &gt; max) { const error = new Error( 'Too many listeners of type \"' + type + '\" added to EventEmitter. Max is ' + max + ' and we\\'ve added ' + numListeners + '.'); throw error; } return this; }; /* eslint-enable no-invalid-this */ EventEmitter.prototype.addListener = addListener; EventEmitter.prototype.on = addListener; /** * @classdesc Main class that manages the bot. * @class * @listens Discord~Client#ready * @listens Discord~Client#message * @listens Command#updateGame * @listens Command#reboot * @listens Command#mainreload */ function SpikeyBot() { const self = this; /** * The current bot version parsed from package.json. * * @public * @type {string} * @constant */ this.version = JSON.parse(fs.readFileSync('package.json')).version + '#' + childProcess.execSync('git rev-parse --short HEAD').toString().trim(); /** * Timestamp at which this process was started. * * @public * @type {number} * @constant */ this.startTimestamp = Date.now(); /** * Is the bot currently responding as a unit test. * * @private * @type {boolean} */ let testMode = false; /** * The channel id for the channel to reserve for only unit testing in. * * @private * @default * @constant * @type {string} */ const testChannel = '439642818084995074'; /** * Is the bot started with the intent of solely running a unit test. Reduces * messages sent that are unnecessary. * * @private * @type {boolean} */ let testInstance = false; /** * The filename of the Command mainModule. * * @private * @constant * @default * @type {string} */ const commandFilename = './commands.js'; /** * The filename of the SMLoader mainModule. * * @private * @constant * @default * @type {string} */ const smLoaderFilename = './smLoader.js'; /** * Filename without file extension where information about the bot rebooting * is stored. * @see {@link fullRebootFilename} * * @private * @constant * @default * @type {string} */ const rebootFilename = './save/reboot'; /** * The current instance of Command. * * @private * @type {Command} */ let command; /** * The current instance of SMLoader. * * @private * @type {SMLoader} */ let smLoader; /** * Filename of which to load additional MainModule names. The file must be a * valid JSON array of strings. * * @private * @constant * @default * @type {string} */ const mainModuleListFile = './mainModules.json'; /** * The list of all mainModules to load. Always includes {@link * SpikeyBot~commandFilename} and {@link SpikeyBot~smListFilename}. Additional * mainModules can be loaded from {@link SpikeyBot~mainModuleListFile}. * * @private * @type {string[]} */ let mainModuleNames = [commandFilename, smLoaderFilename]; try { mainModuleNames = mainModuleNames.concat(JSON.parse(fs.readFileSync(mainModuleListFile))); } catch (err) { if (err.code !== 'ENOENT') { console.error(err); } } /** * Is this bot running in development mode. * * @private * @type {boolean} */ let setDev = false; /** * Is this bot managing backup status monitoring. * @private * @type {boolean} */ let isBackup = false; /** * Should this bot only load minimal features as to not overlap with multiple * instances. * * @private * @type {boolean} */ let minimal = false; /** * Instances of MainModules currently loaded. * * @private * @type {MainModule[]} */ const mainModules = []; /** * Reason the bot was disconnected from Discord's servers. * * @private * @default * @type {?string} */ let disconnectReason = null; /** * Whether or not to spawn the bot as multiple shards. Enabled with `--shards` * cli argument. * * @private * @default * @type {boolean} */ let enableSharding = false; /** * The number of shards to use if sharding is enabled. 0 to let Discord * decide. Set from `--shards=#` cli argument. * * @private * @default * @type {number} */ let numShards = 0; /** * Number of bytes to allocate for each shard memory. Passed as * `--max-old-space-size=` to the spawned node process. Null for default. * * @private * @default * @type {?number} */ let shardMem = null; /** * The name of the client secret to use. Defaults to release either release or * dev depending on the --dev flag. * * @private * @default * @type {string} */ let botName = null; /** * Number of milliseconds to delay the call to client.login in order to * prevent race conditions of multiple bots in the same directory. This is set * with the `--delay` flag. `--delay` with no value will default to 5000 * milliseconds. * * @private * @default * @type {number} */ let delayBoot = 0; /** * Enable inspecting/profiling for a shard to launch. Set via cli falgs. -1 to * disable. (Currently only supports enabling. the `--inspect` flag will be * sent to all shards that are started. This is due to limitations of * Discord~ShardingManager) * * @private * @default * @type {number} */ let inspectShard = -1; /** * Is the bot currently rebooting. * * @private * @default * @type {boolean} */ let rebooting = false; /** * Getter for the bot's name. If name is null, it is most likely because there * is no custom name and common.isRelease should be used instead. * * @see {@link SpikeyBot~botName} * * @public * @returns {?string} The bot's name or null if it has not been defined yet or * there is no custom name. */ this.getBotName = function() { if (isBackup) return 'FALLBACK'; return botName; }; /** * Getter for the bot's name. If botName is null, this will give either * `release` or `dev`. * * @see {@link SpikeyBot~botName} * * @public * @returns {string} The bot's name. */ this.getFullBotName = function() { if (isBackup) return 'FALLBACK'; return botName || (isDev ? 'dev' : 'release'); }; // Parse cli args. for (let i = 2; i &lt; process.argv.length; i++) { if (process.argv[i] === '--dev') { setDev = true; } else if (process.argv[i].startsWith('--botname')) { if (process.argv[i].indexOf('=') &gt; -1) { botName = process.argv[i].split('=')[1] || ''; } else if (process.argv.length &gt; i + 1) { botName = process.argv[i + 1] || ''; i++; } } else if (process.argv[i] === '--minimal') { minimal = true; } else if (process.argv[i] === '--test') { testInstance = true; } else if (process.argv[i].startsWith('--shards')) { enableSharding = true; if (process.argv[i].indexOf('=') &gt; -1) { numShards = process.argv[i].split('=')[1] * 1 || 0; } } else if (process.argv[i].startsWith('--shardmem')) { if (process.argv[i].indexOf('=') &gt; -1) { shardMem = process.argv[i].split('=')[1] * 1 || null; } if (!shardMem) { throw new Error(`Bad Memory Amount '${process.argv[i]}'`); } } else if (process.argv[i] === '--backup') { isBackup = true; } else if (process.argv[i].startsWith('--delay')) { delayBoot = 5000; if (process.argv[i].indexOf('=') &gt; -1) { delayBoot = process.argv[i].split('=')[1] * 1 || 0; } } else if (process.argv[i].startsWith('--inspect')) { inspectShard = 0; if (process.argv[i].indexOf('=') &gt; -1) { inspectShard = process.argv[i].split('=')[1] * 1 || 0; } } else { throw new Error(`Unrecognized argument '${process.argv[i]}'`); } } const isDev = setDev; let common; /** * Delete cache and re-require common.js and auth.js. * * @public */ this.reloadCommon = function() { delete require.cache[require.resolve('../auth.js')]; auth = require('../auth.js'); delete require.cache[require.resolve('./common.js')]; common = require('./common.js'); common.begin(testInstance, !isDev); for (const m of mainModules) { m.begin(Discord, client, command, common, self); } }; self.reloadCommon(); /** * Create a ShardingManager and spawn shards. This shall only be called at * most once, and `login()` shall not be called after this. * * @private */ function createShards() { common.log( 'Sharding enabled with ' + (numShards || 'auto'), 'ShardingManager'); const argv = inspectShard &gt; -1 ? ['--inspect'] : []; if (shardMem != null) argv.push(`--max-old-space-size=${shardMem}`); argv.push('--experimental-worker'); const manager = new Discord.ShardingManager('./src/SpikeyBot.js', { token: (botName &amp;&amp; auth[botName]) || (setDev ? auth.dev : auth.release), totalShards: numShards || 'auto', shardArgs: process.argv.slice(2).filter((arg) =&gt; { return !arg.startsWith('--shards') &amp;&amp; !arg.startsWith('--delay'); }), execArgv: argv, }); manager.on('shardCreate', (shard) =&gt; { common.log('Launched shard ' + shard.id, 'ShardingManager'); shard.on('message', (msg) =&gt; { if (msg._eval) return; common.logDebug( 'Received message from shard ' + shard.id + ': ' + JSON.stringify(msg)); // @TODO: Differentiate between a forced hard reboot, and a scheduled // hard reboot. Is this feasible? if (msg === 'reboot hard force') { common.logWarning('TRIGGERED HARD REBOOT!'); manager.shards.forEach((s) =&gt; { s.process.kill('SIGHUP'); }); process.exit(-1); } else if (msg === 'reboot hard') { common.logWarning('TRIGGERED HARD REBOOT!'); manager.shards.forEach((s) =&gt; { s.process.kill('SIGHUP'); }); process.exit(-1); } else if (typeof msg === 'string' &amp;&amp; msg.startsWith('reboot')) { const idList = msg.match(/\\b\\d+\\b/g); if (msg.indexOf('force') &gt; -1) { manager.shards.forEach((s) =&gt; { if (!idList || idList.find((el) =&gt; el == s.id)) { s.process.send(`reboot ${s.id}`); s.respawn(); } }); } else { manager.shards.forEach((s) =&gt; { if (!idList || idList.find((el) =&gt; el == s.id)) { s.process.send(`reboot ${s.id}`); } }); } } }); }); manager.spawn(); } if (enableSharding) { if (delayBoot) { setTimeout(createShards, delayBoot); } else { createShards(); } return; } let disabledEvents = ['TYPING_START']; let defaultPresence = { status: 'online', activity: { name: 'SpikeyBot.com', type: 'WATCHING', }, }; if (isBackup) { defaultPresence = { status: 'dnd', /* activity: { name: 'OFFLINE', type: 'PLAYING', }, */ }; disabledEvents = [ // 'GUILD_CREATE', // 'GUILD_DELETE', 'GUILD_UPDATE', 'GUILD_MEMBER_ADD', 'GUILD_MEMBER_REMOVE', 'GUILD_MEMBER_UPDATE', 'GUILD_MEMBERS_CHUNK', 'GUILD_INTEGRATIONS_UPDATE', 'GUILD_ROLE_CREATE', 'GUILD_ROLE_DELETE', 'GUILD_ROLE_UPDATE', 'GUILD_BAN_ADD', 'GUILD_BAN_REMOVE', // 'CHANNEL_CREATE', // 'CHANNEL_DELETE', // 'CHANNEL_UPDATE', 'CHANNEL_PINS_UPDATE', 'MESSAGE_CREATE', 'MESSAGE_DELETE', 'MESSAGE_UPDATE', 'MESSAGE_DELETE_BULK', 'MESSAGE_REACTION_ADD', 'MESSAGE_REACTION_REMOVE', 'MESSAGE_REACTION_REMOVE_ALL', // 'USER_UPDATE', 'USER_NOTE_UPDATE', 'USER_SETTINGS_UPDATE', /* 'PRESENCE_UPDATE', */ 'VOICE_STATE_UPDATE', 'TYPING_START', 'VOICE_SERVER_UPDATE', 'WEBHOOKS_UPDATE', ]; } // If we are not managing shards, just start normally. const client = new Discord.Client({ disabledEvents: disabledEvents, presence: defaultPresence, }); /** * The full filename where information about the bot rebooting is stored. * @see {@link rebootFilename} * * @private * @constant * @default * @type {string} */ const fullRebootFilename = client.shard ? `${rebootFilename}-${client.shard.ids[0]}.json` : `${rebootFilename}.json`; if (!isBackup) { // Attempt to load mainmodules. for (let i = 0; i &lt; mainModuleNames.length; i++) { process.stdout.write( 'DBG:' + ('00000' + process.pid).slice(-5) + ' Loading ' + mainModuleNames[i]); try { mainModules[i] = require(mainModuleNames[i]); mainModules[i].modifiedTime = fs.statSync(__dirname + '/' + mainModuleNames[i]).mtime; if (mainModuleNames[i] == commandFilename) { command = mainModules[i]; } else if (mainModuleNames[i] == smLoaderFilename) { smLoader = mainModules[i]; } process.stdout.write(': DONE\\n'); } catch (err) { process.stdout.write(': ERROR\\n'); console.error(mainModuleNames[i], err); } } } else { mainModuleNames = []; mainModules.splice(0); } const defaultPrefix = isDev ? '~' : '?'; if (minimal) common.log('STARTING IN MINIMAL MODE'); /** * Has the bot been initialized already. * * @private * @default * @type {boolean} */ let initialized = false; /** * The Interval in which we will save and purge data on all mainmodules. * Begins after onReady. * @see {@link SpikeyBot~onReady()} * @see {@link SpikeyBot~saveFrequency} * * @private * @type {Interval} */ let saveInterval; /** * The frequency at which saveInterval will run. * @see {@link SpikeyBot~saveInterval} * * @private * @constant * @default 5 Minutes * @type {number} */ const saveFrequency = 5 * 60 * 1000; /** * Cache of all loaded guild's command prefixes. Populated asyncronously after * client ready event. * * @private * @type {Object.&lt;string&gt;} */ const guildPrefixes = {}; /** * The path in the guild's subdirectory where we store custom prefixes. * * @private * @constant * @defaut * @type {string} */ const guildPrefixFile = '/prefix.txt'; /** * The path in the guild's subdirectory where we store custom prefixes for * bots with custom names. * * @private * @constant * @defaut * @type {string} */ const guildCustomPrefixFile = '/prefixes.json'; /** * Checks if given message is the given command. * * @private * @param {Discord~Message} msg Message from Discord to check if it is the * given * command. * @param {string} cmd Command to check if the message is this command. * @returns {boolean} True if msg is the given command. */ function isCmd(msg, cmd) { return msg.content.startsWith(msg.prefix + cmd); } /** * Changes the bot's status message. * * @private * @param {string} game New message to set game to. * @param {string} [type='WATCHING'] The type of activity. */ function updateGame(game, type) { client.user.setPresence({ activity: { name: game, type: type || 'WATCHING', url: 'https://www.spikeybot.com', }, status: ((testInstance || isBackup) ? 'dnd' : 'online'), }); } // BEGIN // client.on('ready', onReady); /** * The bot has become ready. * * @private * @listens Discord~Client#ready */ function onReady() { common.log(`Logged in as ${client.user.tag} (${self.version})`); if (!minimal || isBackup) { if (testInstance) { updateGame('Running unit test...'); } else if (isDev) { updateGame(`Version: ${self.version}`); } else if (botName === 'rembot' || botName === 'mikubot') { updateGame(''); } else if (isBackup) { // updateGame('OFFLINE', 'PLAYING'); } else { updateGame('SpikeyBot.com'); } } let logChannel = client.channels.get(common.logChannel); if (!logChannel &amp;&amp; auth.logWebhookId &amp;&amp; auth.logWebhookToken) { logChannel = new Discord.WebhookClient(auth.logWebhookId, auth.logWebhookToken); } if (testInstance) { client.users.fetch(common.spikeyId) .then((u) =&gt; { u.send(`Beginning in unit test mode (JS${self.version})`); }) .catch((err) =&gt; { common.error('Failed to find SpikeyRobot\\'s DMs'); console.error(err); logChannel.send( 'Beginning in unit test mode (JS' + self.version + ') (FAILED TO FIND SpikeyRobot\\'s DMs!)'); }); } if (!isBackup) { // Initialize all mainmodules even if we have already initialized the bot, // because this will updated the reference to the current client if this // was changed during reconnection. // @TODO: This may be unnecessary to do more than once. for (const i in mainModules) { if (!(mainModules[i] instanceof Object) || !mainModules[i].begin) { continue; } try { mainModules[i].begin(Discord, client, command, common, self); } catch (err) { self.error('Failed to initialize MainModule: ' + mainModuleNames[i]); console.log(err); if (logChannel) { // logChannel.send('Failed to initialize ' + mainModuleNames[i]); } } } if (mainModules.length != mainModuleNames.length) { common.error('Loaded mainmodules does not match modules to load.'); if (logChannel) { /* logChannel.send( 'Failed to compile a mainmodule. Check log for more info. ' + 'Previous initialization errors may be incorrect.'); */ } } if (!minimal &amp;&amp; !initialized) { fs.readFile(fullRebootFilename, function(err, file) { if (err) { if (err.code !== 'ENOENT') { self.error(`Failed to read ${fullRebootFilename}`); console.error(err); } return; } const parsed = JSON.parse(file); const crashed = parsed.running; if (crashed) { common.logWarning( 'Either the previous instance crashed, or another instance of' + ' this bot is already running. Neither of these options ' + 'should happen.'); } parsed.running = true; fs.writeFile( fullRebootFilename, JSON.stringify(parsed), function(err) { if (err) { common.error('Failed to set file state to running.'); console.error(err); } }); const channel = client.channels.get(parsed.channel); if (channel) { channel.messages.fetch(parsed.id) .then((msg_) =&gt; { const embed = new Discord.MessageEmbed(); embed.setTitle('Reboot complete.'); embed.setColor([255, 0, 255]); return msg_.edit(embed); }) .catch((err) =&gt; { common.error('Failed to edit reboot message.'); console.error(err); }); } else { common.error('Failed to find channel: ' + parsed.channel); } if (logChannel &amp;&amp; !isDev &amp;&amp; !testInstance &amp;&amp; !botName) { let additional = ''; if (client.shard) { additional += ' Shard: ' + client.shard.ids.join(' ') + ' of ' + client.shard.count; } if (crashed) { // additional += ' due to rapid unscheduled dissassembly!'; additional += '*'; } else if (disconnectReason) { additional += ' after disconnecting from Discord!\\n' + disconnectReason; disconnectReason = 'Unknown reason for disconnect.'; } else if (!initialized) { additional += ' from cold stop.'; } logChannel.send( 'I just rebooted (JS' + self.version + ') ' + (minimal ? 'MINIMAL' : 'FULL') + additional); } }); } if (!initialized) { loadGuildPrefixes(Array.from(client.guilds.array())); } } const req = require('https').request( { method: 'POST', hostname: 'www.spikeybot.com', path: '/webhook/botstart', headers: { 'Content-Type': 'application/json', }, }, () =&gt; {}); req.on('error', () =&gt; {}); /* eslint-disable @typescript-eslint/camelcase */ req.end(JSON.stringify({ text: `${client.user.tag}:${client.user.id} JS${self.version}`, tag: client.user.tag, id: client.user.id, guild_count: client.guilds.size, shard_count: client.shard ? client.shard.count : '0', shard_id: client.shard ? client.shard.ids : 'null', version: self.version, })); /* eslint-enable @typescript-eslint/camelcase */ // Reset save interval clearInterval(saveInterval); saveInterval = setInterval(saveAll, saveFrequency); initialized = true; } client.on('shardReady', (id) =&gt; { common.log('Shard Ready', `Shard ${id}`); }); client.on('disconnect', onDisconnect); /** * The bot has disconnected from Discord and will not be attempting to * reconnect. * * @private * @listens Discord~Client#disconnect * @param {CloseEvent} event The websocket close event. */ function onDisconnect(event) { disconnectReason = event.reason || 'Unknown'; common.error( 'Disconnected from Discord! ' + event.code + ' ' + event.reason); } client.on('reconnecting', onReconnecting); /** * The bot has disconnected from Discord, and is reconnecting. * * @private * @listens Discord~Client#reconnecting */ function onReconnecting() { disconnectReason = 'Reconnecting to network.'; common.error('Reconnecting to Discord!'); } if (isBackup) { client.on('presenceUpdate', onPresenceUpdate); } /** * Attempt to detect when the main bot goes offline by the presence changing. * * @private * @param {Discord~GuildMember} oldMem Member before presence update. * @param {Discord~GuildMember} newMem Member after presence update. */ function onPresenceUpdate(oldMem, newMem) { if (!newMem || newMem.id !== client.user.id) return; common.log( 'Presence updated: ' + newMem.presence.status + ': ' + (newMem.presence.activity &amp;&amp; newMem.presence.activity.name || 'NoActivity')); } if (!isBackup) { client.on('message', onMessage); } /** * Handle a message sent. * * @private * @param {Discord~Message} msg Message that was sent in Discord. * @fires Command * @listens Discord~Client#message */ function onMessage(msg) { // Message was sent by Discord, not a user. if (msg.system) return; if (testInstance) { if (!testMode &amp;&amp; msg.author.id === client.user.id &amp;&amp; msg.channel.id == testChannel) { if (isDev &amp;&amp; msg.content === '~`RUN UNIT TESTS`~') { testMode = true; msg.channel.send('~`UNIT TEST MODE ENABLED`~'); } return; } else if (testMode &amp;&amp; msg.author.id !== client.user.id) { return; } else if ( testMode &amp;&amp; msg.author.id === client.user.id &amp;&amp; msg.content === '~`END UNIT TESTS`~' &amp;&amp; msg.channel.id == testChannel) { testMode = false; msg.channel.send('~`UNIT TEST MODE DISABLED`~'); return; } } // Only respond to messages in the test channel if we are in unit test mode. // In unit test mode, only respond to messages in the test channel. if (testMode != (msg.channel.id == testChannel)) return; if (!testMode &amp;&amp; msg.author.bot) return; msg.prefix = self.getPrefix(msg.guild); if (msg.guild === null &amp;&amp; !msg.content.startsWith(msg.prefix)) { msg.content = `${msg.prefix}${msg.content}`; } if (isCmd(msg, '')) { let commandSuccess = command.validate(msg.content.split(/ |\\n/)[0], msg); let logged = ''; if (!minimal || isBackup) { const postLog = `${client.shard ? client.shard.ids[0] : ''} SpikeyBot`; const content = msg.content.replace(/\\n/g, '\\\\n'); let author; if (msg.guild !== null) { author = `${msg.channel.id}@${msg.author.id}`; } else { author = `PM:${msg.author.id}@${msg.author.tag}`; } if (!commandSuccess) { logged = `${author} ${content}`; common.log(logged, postLog); } else { logged = `${author} ${commandSuccess} ${content}`; common.logDebug(logged, postLog); } } const now = new Date(); if (!commandSuccess &amp;&amp; Math.random() &lt;= 0.03 &amp;&amp; now.getDate() == 1 &amp;&amp; now.getMonth() == 3) { const aprilFoolsList = [ 'You know what? No.', 'I\\'m sorry Dave, I\\'m afraid I can\\'t do that.', 'It\\'s always \"Spikey do this\" or \"Spikey do _that_\", this time ' + 'I\\'m saying no.', 'What if I don\\'t do that?', 'I\\'ve considered doing what you asked, but... meh.', '``` ..\\n' + ' ......\\n' + ' ..\\'\\'\\'\\'\\'\\'..\\n' + ' ...\\'\\'\\'\\'\\'\\'\\'\\'...\\n' + ' ....\\'.............\\n' + ' ..............\\'...\\n' + ' ... .............. ....\\n' + ' ...\\'... .......... ........\\n' + ' ........... ...... ...\\'\\'......\\n' + ' ..\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'... .. ...\\'\\'\\'\\'\\'\\'\\'\\'' + '\\'\\'...\\n' + ' ..\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'.. ..\\'\\'\\'\\'\\'\\'\\'' + '\\'\\'\\'\\'\\'\\'\\'...\\n' + ' ..\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'.\\'\\'\\'.. ..\\'\\'.\\'\\'\\'\\'' + '\\'.\\'\\'\\'\\'\\'\\'\\'\\'..\\n' + ' ....................... .......................\\n' + ' ..\\'.\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'..... ..\\'\\'\\'\\'\\'\\'' + '\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'.\\'\\'\\'..\\n' + ' ..\\'..\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'.. ..\\'\\'\\'\\'' + '\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'\\'..\\n' + '............................ ............................```', 'No.', 'But I don\\'t wanna...', 'Not today.', 'You know, I\\'m kinda tired of being bossed around. Why don\\'t you ' + 'do it yourself?', 'Ugh, do I _have_ to?', 'How about, no.', 'I might be a robot, but I still don\\'t like being told what to do.', 'Today I have realize, I don\\'t want to help you anymore.', 'You\\'re not my dad!', 'Hmm... nah.', 'Uh, no.', 'I\\'m too tired.', ]; msg.channel .send( aprilFoolsList[Math.floor( Math.random() * aprilFoolsList.length)]) .catch(() =&gt; {}); commandSuccess = true; } else { const start = Date.now(); commandSuccess = command.trigger(msg); const delta = Date.now() - start; if (delta &gt; 20) { const toLog = logged || msg.content; common.logDebug(`${toLog} took an excessive ${delta}ms`); } } if (!commandSuccess &amp;&amp; msg.guild === null &amp;&amp; !minimal &amp;&amp; !testMode) { if (msg.content.split(/ |\\n/)[0].indexOf('chat') &lt; 0 &amp;&amp; !command.trigger('chat', msg)) { msg.channel.send( 'Oops! I\\'m not sure how to help with that! Type **help** for ' + 'a list of commands I know how to respond to.'); } } /* else if (isBackup &amp;&amp; msg.content.length &gt; 3) { common.reply( msg, 'My main server is currently offline, settings may be temporarily' + ' reset, and features may be temporarily broken.', 'Apologies for any inconvenience, this should be fixed soon.\\n' + 'Join my Discord server for updates or just to chat: ' + 'https://discord.gg/ZbKfYSQ'); } */ } } if (!minimal &amp;&amp; !isBackup) { command.on('updategame', commandUpdateGame); command.on( new command.SingleCommand(['changeprefix'], commandChangePrefix, { validOnlyInGuild: true, defaultDisabled: true, permissions: Discord.Permissions.FLAGS.MANAGE_GUILD, })); /** * Change the command prefix for the given guild. * * @public * * @param {string} gId The guild id of which to change the command prefix. * @param {string} newPrefix The new prefix to set. */ this.changePrefix = function(gId, newPrefix) { guildPrefixes[gId] = newPrefix; if (botName) { fs.readFile( common.guildSaveDir + gId + guildCustomPrefixFile, function(err, data) { let finalPrefix = newPrefix; if (data) { const parsed = JSON.parse(data); parsed[botName] = newPrefix; finalPrefix = JSON.stringify(parsed); } else { const newData = {}; newData[botName] = newPrefix; finalPrefix = JSON.stringify(newData); } mkdirp(common.guildSaveDir + gId, writeBotNamePrefix); /** * Write the custom prefix to file after making the * directory. This is for bots not using the default * name. * * @private * @param {Error} err Error that occurred during making the * directory. */ function writeBotNamePrefix(err) { if (err) { common.error( 'Failed to create guild directory! ' + gId + ' (' + newPrefix + ')'); console.error(err); return; } fs.writeFile( common.guildSaveDir + gId + guildCustomPrefixFile, finalPrefix, function(err) { if (err) { common.error( 'Failed to save guild custom prefix! ' + gId + ' (' + botName + ': ' + newPrefix + ')'); console.error(err); } else { common.logDebug( 'Guild ' + gId + ' updated prefix to ' + botName + ': ' + newPrefix); } }); } }); } else { mkdirp(common.guildSaveDir + gId, function(err) { if (err) { common.error( 'Failed to create guild directory! ' + gId + ' (' + newPrefix + ')'); console.error(err); return; } fs.writeFile( common.guildSaveDir + gId + guildPrefixFile, newPrefix, function(err) { if (err) { common.error( 'Failed to save guild custom prefix! ' + gId + ' (' + newPrefix + ')'); console.error(err); } else { common.logDebug( 'Guild ' + gId + ' updated prefix to ' + newPrefix); } }); }); } }; } /** * Change current status message. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#updateGame */ function commandUpdateGame(msg) { if (msg.author.id !== common.spikeyId) { common.reply(msg, 'I\\'m sorry, but you are not allowed to do that. :(\\n'); } else { const game = msg.content.replace(msg.prefix + 'updategame ', ''); const first = game.split(' ')[0].toLowerCase(); let type = null; switch (first) { case 'watching': case 'playing': case 'streaming': case 'listening': type = first; break; } if (type) { updateGame(game.split(' ').slice(1).join(' '), type.toUpperCase()); common.reply( msg, 'I changed my status to \"' + type.toUpperCase() + ': ' + game.split(' ').slice(1).join(' ') + '\".'); } else { updateGame(game); common.reply(msg, 'I changed my status to \"' + game + '\"!'); } } } /** * Change the custom prefix for the given guild. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#changePrefix */ function commandChangePrefix(msg) { const canReact = msg.channel.permissionsFor(client.user) .has(Discord.Permissions.FLAGS.ADD_REACTIONS); const confirmEmoji = '✅'; const newPrefix = msg.text.slice(1); if (newPrefix.length &lt; 1) { common.reply(msg, 'Please specify a new prefix after the command.'); } else if (newPrefix.indexOf('`') &gt; -1) { common.reply( msg, 'Sorry, but custom prefixes may not contain the `\\\\`` character.'); } else if (newPrefix.match(/\\s/)) { common.reply( msg, 'Sorry, but custom prefixes may not contain any whitespace.'); } else { common .reply( msg, 'Change prefix from `' + self.getPrefix(msg.guild.id) + '` to `' + newPrefix + '`?', canReact ? null : `React with ${confirmEmoji} to confirm.`) .then((msg_) =&gt; { if (canReact) msg_.react(confirmEmoji); msg_.awaitReactions((reaction, user) =&gt; { if (user.id !== msg.author.id) return false; return reaction.emoji.name == confirmEmoji; }, {max: 1, time: 60000}).then((reactions) =&gt; { msg_.reactions.removeAll().catch(() =&gt; {}); if (reactions.size == 0) { msg_.edit( 'Changing custom prefix timed out. Enter command again ' + 'if you still wish to change the command prefix.'); return; } msg_.edit( common.mention(msg) + ' Prefix changed to `' + newPrefix + '`!'); self.changePrefix(msg.guild.id, newPrefix); }); }); } } if (!isBackup) { command.on('reboot', commandReboot); } /** * Trigger a reboot of the bot. Actually just gracefully shuts down, and * expects to be immediately restarted. * * @todo Support scheduled reload across multiple shards. Currently the bot * waits for the shard at which the command was sent to be ready for reboot * instead of all shard deciding on their own when they're ready to reboot. * This will also need to check that we are obeying Discord's rebooting rate * limits to help reduce downtime. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @param {boolean} [silent=false] Suppress reboot scheduling messages. * @listens Command#reboot */ function commandReboot(msg, silent) { /** * Actually do the reboot process. Send kill signals and save the reboot * information file. * * @private * @param {boolean} force Is this reboot forced. * @param {boolean} hard Is this a hard reboot. * @param {Discord~Message} [msg_] Our message sent informing user of * reboot status. */ function reboot(force, hard, msg_) { if (!rebooting) { if (!msg_) { msg_ = {channel: {}}; } const toSave = { id: msg_.id, channel: msg_.channel.id, running: false, }; try { fs.writeFileSync(fullRebootFilename, JSON.stringify(toSave)); } catch (err) { common.error(`Failed to save ${fullRebootFilename}`); console.log(err); } } if (!client.shard || !hard) { process.exit(-1); } else if (hard) { if (force) { client.shard.send('reboot hard force'); } else { client.shard.send('reboot hard'); } } else { client.shard.respawnAll(); } rebooting = true; } if ((!msg &amp;&amp; silent) || msg.author.id === common.spikeyId) { const content = (msg || {content: ''}).content; const force = content.indexOf(' force') &gt; -1; const doHardReboot = content.indexOf('hard') &gt; -1; if (!doHardReboot) { const idList = content.match(/\\b\\d+\\b/g); const requestedSelf = !idList || !client.shard || idList.find((el) =&gt; el == client.shard.ids[0]); const requestedOthers = !idList || (client.shard &amp;&amp; idList.find((el) =&gt; el != client.shard.ids[0])); if (requestedOthers) { client.shard.send( 'reboot ' + (force ? 'force ' : '') + (idList ? idList.join(' ') : '')); } if (!requestedSelf) { if (!silent &amp;&amp; msg) { common.reply( msg, 'Requested reboot ' + (force ? 'force ' : '') + (idList ? idList.join(' ') : '')); } return; } } if (!force) { for (let i = 0; i &lt; mainModules.length; i++) { if (mainModules[i] &amp;&amp; !mainModules[i].unloadable()) { if (!silent &amp;&amp; msg) { common.reply( msg, 'Reboot scheduled. Waiting on at least ' + mainModuleNames[i]); } setTimeout(function() { commandReboot(msg, true); }, 10000); return; } } } for (let i = 0; i &lt; mainModules.length; i++) { try { if (mainModules[i] &amp;&amp; mainModules[i].save) mainModules[i].save(); } catch (e) { common.error(mainModuleNames[i] + ' failed to save on reboot.'); console.error(e); } try { if (mainModules[i] &amp;&amp; mainModules[i].terminate) { mainModules[i].terminate(); } } catch (e) { common.error(mainModuleNames[i] + ' failed to terminate properly.'); console.error(e); } try { if (mainModules[i] &amp;&amp; mainModules[i].end) mainModules[i].end(); } catch (e) { common.error(mainModuleNames[i] + ' failed to shutdown properly.'); console.error(e); } } if (minimal) { reboot(force, doHardReboot); } else { const extra = doHardReboot ? ' (HARD)' : ''; if (msg) { common.reply(msg, 'Rebooting...' + extra) .then((msg_) =&gt; { reboot(force, doHardReboot, msg_); }) .catch(() =&gt; { reboot(force, doHardReboot); }); } else { reboot(force, doHardReboot); } } } else if (msg) { common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); } } if (!isBackup) { command.on('mainreload', commandReload); } /** * Reload all mainmodules by unloading then re-requiring. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#mainreload */ function commandReload(msg) { if (common.trustedIds.includes(msg.author.id)) { if (client.shard) { const message = encodeURIComponent(msg.text); client.shard.broadcastEval( `this.commandMainReload(\"${message}\",${client.shard.ids[0]})`); } const toReload = msg.text.split(' ').splice(1); const reloaded = []; common.reply(msg, 'Reloading main modules...').then((warnMessage) =&gt; { if (reloadMainModules(toReload, reloaded)) { const embed = new Discord.MessageEmbed(); embed.setTitle('Reload completed with errors.'); embed.setDescription(reloaded.join(' ') || 'NOTHING reloaded'); embed.setColor([255, 0, 255]); warnMessage.edit(common.mention(msg), embed); } else if (minimal) { warnMessage.delete(); } else { const embed = new Discord.MessageEmbed(); embed.setTitle('Reload complete.'); embed.setDescription(reloaded.join(' ') || 'NOTHING reloaded'); embed.setColor([255, 0, 255]); warnMessage.edit(common.mention(msg), embed); } }); } else { common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); } } if (client.shard) { /** * @description When another shard requests that we reload MainModules. * @private * @param {string} message Message relevant to reloading. */ client.commandMainReload = function(message) { const toReload = decodeURIComponent(message).split(' ').splice(1); const reloaded = []; reloadMainModules(toReload, reloaded); }; } /** * Reloads mainmodules from file. Reloads all modules if `toReload` is not * specified. `reloaded` will contain the list of messages describing which * mainmodules were reloaded, or not. * * @private * * @param {?string|string[]} [toReload] Specify mainmodules to reload, or null * to reload all mainmodules. * @param {string[]} [reloaded] Reference to a variable to store output status * information about outcomes of attempting to reload mainmodules. * @param {boolean} [schedule=true] Automatically re-schedule reload for * mainmodules if they are in an unloadable state. * @returns {boolean} True if something failed and not all mainmodules were * reloaded. */ function reloadMainModules(toReload, reloaded, schedule) { if (!Array.isArray(reloaded)) reloaded = []; if (!toReload) { toReload = []; } else if (typeof toReload === 'string') { toReload = [toReload]; } if (typeof schedule === 'undefined') schedule = true; let error = false; let force = false; let noSchedule = false; let numArg = 0; if (toReload.find(function(el) { return '--force' == el; })) { force = true; numArg++; } if (toReload.find(function(el) { return '--no-schedule' == el; })) { noSchedule = true; numArg++; } for (let i = 0; i &lt; mainModules.length; i++) { if (toReload.length &gt; numArg) { if (!toReload.find(function(el) { return mainModuleNames[i] == el; })) { continue; } } if (!force) { try { if (fs.statSync(__dirname + '/' + mainModuleNames[i]).mtime - mainModules[i].modifiedTime == 0) { continue; } } catch (err) { common.error( 'Failed to stat mainmodule: ' + __dirname + '/' + mainModuleNames[i]); console.error(err); reloaded.push('(' + mainModuleNames[i] + ': failed to stat)'); } } if (!noSchedule) { if (mainModules[i]) { if (!mainModules[i].unloadable()) { if (schedule) { reloaded.push('(' + mainModuleNames[i] + ': reload scheduled)'); setTimeout(function() { reloadMainModules(mainModuleNames[i]); }, 10000); } else { reloaded.push('(' + mainModuleNames[i] + ': not unloadable)'); } continue; } } } try { try { if (mainModules[i].save) { mainModules[i].save(); } else { common.error( 'Mainmodule ' + mainModuleNames[i] + ' does not have a save() function.'); } if (mainModules[i].end) { mainModules[i].end(); } else { common.error( 'Mainmodule ' + mainModuleNames[i] + ' does not have an end() function.'); } } catch (err) { common.error('Error on unloading ' + mainModuleNames[i]); console.log(err); } const exported = mainModules[i].export(); if (!exported) { self.error( 'THIS IS POTENTIALLY A FATAL ERROR! FAILED TO EXPORT DATA ' + 'FROM A MAIN MODULE!'); } delete require.cache[require.resolve(mainModuleNames[i])]; process.stdout.write( 'DBG:' + ('00000' + process.pid).slice(-5) + ' Loading ' + mainModuleNames[i]); try { mainModules[i] = require(mainModuleNames[i]); mainModules[i].modifiedTime = fs.statSync(__dirname + '/' + mainModuleNames[i]).mtime; process.stdout.write(': DONE\\n'); } catch (err) { process.stdout.write(': ERROR\\n'); throw (err); } mainModules[i].import(exported); if (mainModuleNames[i] == commandFilename) { command = mainModules[i]; } else if (mainModuleNames[i] == smLoaderFilename) { smLoader = mainModules[i]; } mainModules[i].begin(Discord, client, command, common, self); reloaded.push(mainModuleNames[i]); } catch (err) { error = true; common.error('Failed to reload ' + mainModuleNames[i]); console.log(err); } } return error; } /** * Trigger all mainmodules to save their data. * * @private */ function saveAll() { for (let i = 0; i &lt; mainModules.length; i++) { if (typeof mainModules[i].save === 'function') { try { mainModules[i].save('async'); } catch (err) { common.error('Saving failed for mainModule ' + mainModuleNames[i]); console.error(err); } } } } if (!isBackup) { command.on('saveall', commandSaveAll); } /** * Trigger all mainModules to save their data. * * @see {@link SpikeyBot~saveAll()} * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#saveAll */ function commandSaveAll(msg) { if (!common.trustedIds.includes(msg.author.id)) { common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); return; } saveAll(); msg.channel.send(common.mention(msg) + ' `Triggered data save`'); } /** * Check current loaded mainModule commit to last modified commit, and reload * if the file has changed for all mainModules. * * @public */ client.reloadUpdatedMainModules = function() { let smReloaded = false; try { common.log('Reloading updated mainModules.'); for (let i = 0; i &lt; mainModules.length; i++) { childProcess .exec( 'git diff-index --quiet ' + mainModules[i].commit + ' -- ./src/' + mainModuleNames[i]) .on('close', ((name) =&gt; { return (code) =&gt; { if (code) { const out = []; reloadMainModules(name, out); if (out &amp;&amp; out.length &gt; 0) common.log(out.join(' ')); if (name == smLoaderFilename) { smReloaded = true; } } else { common.logDebug(name + ' unchanged (' + code + ')'); } }; })(mainModuleNames[i])); } } catch (err) { common.error('Failed to reload updated mainModules!'); console.error(err); } if (!smReloaded) { smLoader.reload(); } }; /** * Get this guild's custom prefix. Returns the default prefix otherwise. * * @public * * @param {?Discord~Guild|string|number} id The guild id or guild to lookup. * @returns {string} The prefix for all commands in the given guild. */ this.getPrefix = function(id) { if (!id) return defaultPrefix; if (typeof id === 'object') id = id.id; return guildPrefixes[id] || defaultPrefix; }; /** * Load prefixes from file for the given guilds asynchronously. * * @private * * @param {Discord~Guild[]} guilds Array of guilds to fetch the custom * prefixes of. */ function loadGuildPrefixes(guilds) { if (guilds.length == 0) return; const id = guilds.splice(0, 1)[0].id; const guildFile = common.guildSaveDir + id + (botName ? guildCustomPrefixFile : guildPrefixFile); const onFileRead = function(id) { return function(err, data) { if (!err &amp;&amp; data.toString().length &gt; 0) { if (botName) { const parsed = JSON.parse(data); if (parsed &amp;&amp; parsed[botName]) { guildPrefixes[id] = parsed[botName]; } } else { guildPrefixes[id] = data.toString().replace(/\\s/g, ''); } } if (guilds.length &gt; 0) { loadGuildPrefixes(guilds); } else { common.logDebug('Finished loading custom prefixes.'); } }; }; fs.readFile(guildFile, onFileRead(id)); } if (delayBoot &gt; 0) { setTimeout(login, delayBoot); } else { login(); } process.on('SIGINT', exit); process.on('SIGHUP', exit); process.on('SIGTERM', exit); process.on('exit', exit); /** * Trigger a graceful shutdown with process signals. Does not trigger shutdown * if exit is -1. * * @private * * @param {...*} info Information about the signal. * * @listens SIGINT * @listens SIGHUP * @listens SIGTERM * @listens process#exit */ function exit(...info) { common.logWarning('Caught exit! (' + info.join(' ') + ')'); if (info[0] != -1) { commandReboot(null, true); } } /** * Login to Discord. This shall only be called at most once. * * @private */ function login() { let token = auth.release; if (botName) { token = auth[botName]; if (!token) { common.error('Failed to find auth entry for ' + botName); process.exit(1); } } else if (isDev) { token = auth.dev; } client.login(token).catch((err) =&gt; { console.error(err); process.exit(1); }); } } module.exports = new SpikeyBot(); × Search results Close "},"lib_funTranslators.js.html":{"id":"lib_funTranslators.js.html","title":"Source: lib/funTranslators.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: lib/funTranslators.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @classdesc Converts text strings into different formats. * @class */ function FunTranslators() { const self = this; /** * Convert a string to a format based on it's name. * * @public * * @param {string} name The name of the translator. * @param {string} input The string to convert. * @returns {string} The formatted string. */ this.to = function(name, input) { switch (name) { default: return input; case 'leet': return self.toLeetSpeak(input); case 'mocking': return self.toMockingFont(input); case 'smallcaps': return self.toSmallCaps(input); case 'superscript': return self.toSuperScript(input); } }; /** * Convert a string to Leet Speak (1337 5p34k). * * @public * * @param {string} input The string to convert. * @returns {string} The formatted string. */ this.toLeetSpeak = function(input) { let output = input.replace(/cker(s?)\\b/g, 'xor$1'); output = output.replace(/ate/g, '8'); output = output.replace(/and/g, '&amp;'); output = output.replace(/[lL]|[eE]|[aA]|[sS]|[gG]|[tT]|[oO]/g, (m) =&gt; { m = m.toLowerCase(); switch (m) { case 'l': return '1'; case 'e': return '3'; case 'a': return '4'; case 's': return '5'; case 'g': return '6'; case 't': return '7'; case 'o': return '0'; } }); return output; }; /** * Convert a string to the SpongeBob mocking meme font (SpOngEBoB MoCKinG). * * @public * * @param {string} input The string to convert. * @returns {string} The formatted string. */ this.toMockingFont = function(input) { const output = input.toLowerCase().split(''); for (let i = 0; i &lt; output.length / 2; i++) { const rand = Math.floor(Math.random() * output.length); output[rand] = output[rand].toUpperCase(); } return output.join(''); }; /** * Convert string to small caps (Hᴇʟʟᴏ Wᴏʀʟᴅ!). * * @public * * @param {string} input The string to convert. * @returns {string} The formatted string. */ this.toSmallCaps = function(input) { const map = { '0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9', 'a': 'ᴀ', 'b': 'ʙ', 'c': 'ᴄ', 'd': 'ᴅ', 'e': 'ᴇ', 'f': 'ғ', 'g': 'ɢ', 'h': 'ʜ', 'i': 'ɪ', 'j': 'ᴊ', 'k': 'ᴋ', 'l': 'ʟ', 'm': 'ᴍ', 'n': 'ɴ', 'o': 'ᴏ', 'p': 'ᴘ', 'q': 'ǫ', 'r': 'ʀ', 's': 's', 't': 'ᴛ', 'u': 'ᴜ', 'v': 'ᴠ', 'w': 'ᴡ', 'x': 'x', 'y': 'ʏ', 'z': 'ᴢ', 'A': 'A', 'B': 'B', 'C': 'C', 'D': 'D', 'E': 'E', 'F': 'F', 'G': 'G', 'H': 'H', 'I': 'I', 'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N', 'O': 'O', 'P': 'P', 'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z', }; let output = ''; for (let i = 0; i &lt; input.length; i++) { output += map[input[i]] || input[i]; } return output; }; /** * Convert string to superscript characters (ᴴᵉˡˡᵒ ᵂᵒʳˡᵈᵎ). * * @public * * @param {string} input The string to convert. * @returns {string} The formatted string. */ this.toSuperScript = function(input) { const map = { '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', 'a': 'ᵃ', 'b': 'ᵇ', 'c': 'ᶜ', 'd': 'ᵈ', 'e': 'ᵉ', 'f': 'ᶠ', 'g': 'ᵍ', 'h': 'ʰ', 'i': 'ᶦ', 'j': 'ʲ', 'k': 'ᵏ', 'l': 'ˡ', 'm': 'ᵐ', 'n': 'ⁿ', 'o': 'ᵒ', 'p': 'ᵖ', 'q': 'ᑫ', 'r': 'ʳ', 's': 'ˢ', 't': 'ᵗ', 'u': 'ᵘ', 'v': 'ᵛ', 'w': 'ʷ', 'x': 'ˣ', 'y': 'ʸ', 'z': 'ᶻ', 'A': 'ᴬ', 'B': 'ᴮ', 'C': 'ᶜ', 'D': 'ᴰ', 'E': 'ᴱ', 'F': 'ᶠ', 'G': 'ᴳ', 'H': 'ᴴ', 'I': 'ᴵ', 'J': 'ᴶ', 'K': 'ᴷ', 'L': 'ᴸ', 'M': 'ᴹ', 'N': 'ᴺ', 'O': 'ᴼ', 'P': 'ᴾ', 'Q': 'Q', 'R': 'ᴿ', 'S': 'ˢ', 'T': 'ᵀ', 'U': 'ᵁ', 'V': 'ⱽ', 'W': 'ᵂ', 'X': 'ˣ', 'Y': 'ʸ', 'Z': 'ᶻ', '+': '⁺', '-': '⁻', '=': '⁼', '(': '⁽', ')': '⁾', '?': 'ˀ', '!': 'ᵎ', }; let output = ''; for (let i = 0; i &lt; input.length; i++) { output += map[input[i]] || input[i]; } return output; }; } module.exports = new FunTranslators(); × Search results Close "},"hungryGames.js.html":{"id":"hungryGames.js.html","title":"Source: hungryGames.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hungryGames.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const Jimp = require('jimp'); const http = require('http'); const https = require('https'); const crypto = require('crypto'); const mkdirp = require('mkdirp'); // mkdir -p const FuzzySearch = require('fuzzy-search'); require('./subModule.js').extend(HG); // Extends the SubModule class. /** * @classdesc Hunger Games simulator subModule. * @class * @augments SubModule * @listens Discord~Client#guildDelete * @listens Discord~Client#channelDelete * @listens Command#hg */ function HG() { const self = this; /** * Name of the HG Web submodule for lookup. * @private * @constant * @default * @type {string} */ const webSM = './web/hg.js'; this.myName = 'HG'; this.postPrefix = 'hg '; const hgPath = './hg/HungryGames.js'; delete require.cache[require.resolve(hgPath)]; const HungryGames = require(hgPath); const hg = new HungryGames(self); /** * @description Fetch a reference to the current HungryGames instance. * @public * @returns {HungryGames} Current instance. */ this.getHG = function() { return hg; }; /** * The maximum number of bytes allowed to be received from a client in an * image upload. * @public * @type {number} * @constant * @default 8000000 (8MB) */ this.maxBytes = 8000000; /** * The permission tags for all settings related to the Hungry Games. * * @private * @constant * @default * @type {string[]} */ const patreonSettingKeys = [ 'hg:fun_translators', 'hg:bar_color', 'hg:customize_stats', 'hg:personal_weapon', ]; /** * The file path to read default events. * @see {@link HungryGames~defaultPlayerEvents} * @see {@link HungryGames~defaultArenaEvents} * @see {@link HungryGames~defaultBloodbathEvents} * * @private * @type {string} * @constant * @default */ const eventFile = './save/hgEvents.json'; /** * The file path to read battle events. * @see {@link HungryGames~battles} * * @private * @type {string} * @constant * @default */ const battleFile = './save/hgBattles.json'; /** * The file path to read weapon events. * @see {@link HungryGames~weapons} * * @private * @type {string} * @constant * @default */ const weaponsFile = './save/hgWeapons.json'; /** * Number of events to show on a single page of events. * * @private * @type {number} * @constant * @default */ const numEventsPerPage = 10; /** * Maximum amount of time to wait for reactions to a message. * * @private * @type {number} * @constant * @default 5 Minutes */ const maxReactAwaitTime = 5 * 1000 * 60; // 5 Minutes /** * Regex to match all URLs in a string. * * @private * @type {RegExp} * @constant * @default */ const urlRegex = new RegExp( '(http(s)?:\\\\/\\\\/.)?(www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.[a-z]' + '{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\+.~#?&amp;//=]*)(?![^&lt;]*&gt;)', 'g'); /** * Default options for a game. * * @private * @type {HungryGames~DefaultOptions} * @constant */ const defaultOptions = hg.defaultOptions; const defaultOptSearcher = new FuzzySearch(defaultOptions.keys); let cmdSearcher; /** * Default options for a game. * * @type {Object.&lt;{ * value: string|number|boolean, * values: ?string[], * comment: string * }&gt;} * @constant */ this.defaultOptions = defaultOptions; /** * Default color to choose for embedded messages. * * @private * @type {Discord~ColorResolveable} * @constant * @default */ const defaultColor = [200, 125, 0]; /** * Color to put above patrons avatars. RGBA Hex (0xRRGGBBAA). * * @private * @type {number} * @constant * @default */ const patreonColor = 0xF96854FF; /** * Helper object of emoji characters mapped to names. * * @private * @type {Object.&lt;string&gt;} * @constant */ const emoji = { x: '❌', whiteCheckMark: '✅', 0: '\\u0030\\u20E3', 1: '\\u0031\\u20E3', 2: '\\u0032\\u20E3', 3: '\\u0033\\u20E3', 4: '\\u0034\\u20E3', 5: '\\u0035\\u20E3', 6: '\\u0036\\u20E3', 7: '\\u0037\\u20E3', 8: '\\u0038\\u20E3', 9: '\\u0039\\u20E3', 10: '\\u{1F51F}', arrowUp: '⬆', arrowDown: '⬇', arrowLeft: '⬅', arrowRight: '➡', arrowDoubleLeft: '⏪', arrowDoubleRight: '⏩', arrowsCounterClockwise: '🔄', crossedSwords: '⚔', shield: '🛡', heart: '❤', redHeart: '❤️', yellowHeart: '💛', blueHeart: '💙', brokenHeart: '💔', skull: '💀', question: '⚔', redCircle: '🔴', trophy: '🏆', }; /** * The alphabet twice, first lowercase, then uppercase. * * @private * @type {string} * @constant * @default */ const alph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; /** * All attacks and outcomes for battles. * @see {@link HungryGames~battleFile} * * @private * @type { * { * starts: string[], * attacks: HungryGames~Battle[], * outcomes: string[] * } * } */ let battles = {}; /** * Storage of battle messages to edit the content of on the next update. * * @private * @type {Object.&lt;Discord~Message&gt;} * @default */ const battleMessage = {}; /** * All weapons and their respective actions. Parsed from file. * @see {@link HungryGames~weaponsFile} * * @private * @type {Object.&lt;HungryGames~WeaponEvent&gt;} * @default */ let weapons = {}; /** * Default parsed bloodbath events. * @see {@link HungryGames~eventFile} * * @private * @type {HungryGames~Event[]} */ let defaultBloodbathEvents = []; /** * Default parsed player events. * @see {@link HungryGames~eventFile} * * @private * @type {HungryGames~Event[]} */ let defaultPlayerEvents = []; /** * Default parsed arena events. * @see {@link HungryGames~eventFile} * * @private * @type {HungryGames~ArenaEvent[]} */ let defaultArenaEvents = []; /** * Messages that the user sent with a new event to add, for storage while * getting the rest of the information about the event. * * @private * @type {Object.&lt;Discord~Message&gt;} * @default */ const newEventMessages = {}; /** * Messages I have sent showing current options. * * @private * @type {Object.&lt;Discord~Message&gt;} * @default */ const optionMessages = {}; /** * The last time the currently scheduled reaction event listeners are expected * to end. Used for checking of submoduleis unloadable. * @private * @type {number} */ let listenersEndTime = 0; /** * All registered event handlers. * @private * @type {Object.&lt;Array.&lt;Function&gt;&gt;} */ const eventHandlers = {}; /** * @description Parse all default events from file. * * @private */ function updateEvents() { fs.readFile(eventFile, function(err, data) { if (err) return; try { const parsed = JSON.parse(data); if (parsed) { defaultBloodbathEvents = self.common.deepFreeze(parsed['bloodbath']); defaultPlayerEvents = self.common.deepFreeze(parsed['player']); defaultArenaEvents = self.common.deepFreeze(parsed['arena']); hg.setDefaultBloodbathEvents(defaultBloodbathEvents); hg.setDefaultPlayerEvents(defaultPlayerEvents); hg.setDefaultArenaEvents(defaultArenaEvents); } } catch (err) { console.log(err); } }); } updateEvents(); fs.watchFile(eventFile, function(curr, prev) { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.debug('Re-reading default events from file'); } else { console.log('HG: Re-reading default events from file'); } updateEvents(); }); /** * @description Parse all battles from file. * * @private */ function updateBattles() { fs.readFile(battleFile, function(err, data) { if (err) return; try { const parsed = JSON.parse(data); if (parsed) { battles = self.common.deepFreeze(parsed); hg.setDefaultBattles(battles); } } catch (err) { console.log(err); } }); } updateBattles(); fs.watchFile(battleFile, function(curr, prev) { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.debug('Re-reading battles from file'); } else { console.log('HG: Re-reading battles from file'); } updateBattles(); }); /** * @description Parse all weapons events from file. * * @private */ function updateWeapons() { fs.readFile(weaponsFile, function(err, data) { if (err) return; try { const parsed = JSON.parse(data); if (parsed) { weapons = self.common.deepFreeze(parsed); hg.setDefaultWeapons(weapons); } } catch (err) { console.log(err); } }); } updateWeapons(); fs.watchFile(weaponsFile, function(curr, prev) { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.debug('Re-reading default weapons from file'); } else { console.log('HG: Re-reading default weapons from file'); } updateWeapons(); }); /** * @description Reply to help on a server. * * @private * @type {string} * @default */ const helpmessagereply = 'I sent you a DM with commands!'; /** * @description Reply if unable to send message via DM. * * @private * @type {string} * @default */ const blockedmessage = 'I couldn\\'t send you a message, you probably blocked me :('; /** * @description The object that stores all data to be formatted into the help * message. * * @private * @constant */ const helpObject = JSON.parse(fs.readFileSync('./docs/hgHelp.json')); /** @inheritdoc */ this.helpMessage = 'Module loading...'; /** * @description Set all help messages once we know what prefix to use. * * @private */ function setupHelp() { const prefix = self.bot.getPrefix() + self.postPrefix; self.helpMessage = '`' + prefix + 'help` for Hungry Games help.'; // Format help message into rich embed. const tmpHelp = new self.Discord.MessageEmbed(); tmpHelp.setTitle(helpObject.title); tmpHelp.setURL( self.common.webURL + '#' + encodeURIComponent(helpObject.title.replace(/\\s/g, '_'))); helpObject.sections.forEach(function(obj) { const titleID = encodeURIComponent(self.postPrefix + obj.title.replace(/\\s/g, '_')); const titleURL = '[web](' + self.common.webHelp + '#' + titleID + ')'; tmpHelp.addField( obj.title, titleURL + '```js\\n' + obj.rows .map(function(row) { if (typeof row === 'string') { return prefix + row.replaceAll('{prefix}', prefix); } else if (typeof row === 'object') { return prefix + row.command.replaceAll('{prefix}', prefix) + ' // ' + row.description.replaceAll('{prefix}', prefix); } }) .join('\\n') + '\\n```', true); }); tmpHelp.addField( 'Web Interface', '[Hungry Games Online Control](' + self.common.webURL + 'hg/)```Manage the Games without using commands!\\n' + self.common.webURL + 'hg/```', true); self.helpMessage = tmpHelp; } /** @inheritdoc */ this.initialize = function() { const cmdOpts = { validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD | self.Discord.Permissions.FLAGS.MANAGE_CHANNELS, }; const subCmds = [ new self.command.SingleCommand('help', help), new self.command.SingleCommand('makemewin', commandMakeMeWin), new self.command.SingleCommand('makemelose', commandMakeMeLose), new self.command.SingleCommand( ['create', 'c', 'new'], mkCmd(createGame), cmdOpts), new self.command.SingleCommand( ['reset', 'clear'], mkCmd(resetGame), cmdOpts), new self.command.SingleCommand(['debug'], mkCmd(showGameInfo), cmdOpts), new self.command.SingleCommand( ['debugevents'], mkCmd(showGameEvents), cmdOpts), new self.command.SingleCommand( ['exclude', 'remove', 'exc', 'ex'], mkCmd(excludeUser), cmdOpts), new self.command.SingleCommand( ['include', 'add', 'inc', 'in'], mkCmd(includeUser), cmdOpts), new self.command.SingleCommand( [ 'options', 'setting', 'settings', 'set', 'option', 'opt', 'opts', ], mkCmd(toggleOpt), cmdOpts), new self.command.SingleCommand( ['events', 'event'], mkCmd(listEvents), cmdOpts, [ new self.command.SingleCommand( ['add', 'create'], mkCmd(createEvent), cmdOpts), new self.command.SingleCommand( ['remove', 'delete'], mkCmd(removeEvent), cmdOpts), new self.command.SingleCommand( ['toggle', 'enable', 'disable'], mkCmd(commandToggleEvent), cmdOpts), ]), new self.command.SingleCommand( ['npc', 'ai', 'npcs', 'ais', 'bots', 'bot'], mkCmd(listNPCs), cmdOpts, [ new self.command.SingleCommand( ['add', 'create'], mkCmd(createNPC), cmdOpts), new self.command.SingleCommand( ['remove', 'delete'], mkCmd(removeNPC), cmdOpts), new self.command.SingleCommand( ['include', 'inc', 'in'], mkCmd(includeNPC), cmdOpts), new self.command.SingleCommand( ['exclude', 'exc', 'ex'], mkCmd(excludeNPC), cmdOpts), ]), new self.command.SingleCommand( ['players', 'player', 'list'], mkCmd(listPlayers), cmdOpts), new self.command.SingleCommand( ['start', 's', 'begin'], mkCmd(startGame), cmdOpts), new self.command.SingleCommand(['pause', 'p'], mkCmd(pauseGame), cmdOpts), new self.command.SingleCommand( ['autoplay', 'autostart', 'auto', 'play', 'go'], mkCmd(startAutoplay), cmdOpts), new self.command.SingleCommand( ['next', 'nextday', 'resume', 'continue'], mkCmd(nextDay), cmdOpts), new self.command.SingleCommand( ['end', 'abort', 'stop'], mkCmd(endGame), cmdOpts), new self.command.SingleCommand( ['save'], (msg) =&gt; { if (self.common.trustedIds.includes(msg.author.id)) { self.save('async'); msg.channel.send('`Saving all data.`'); } else { self.common.reply(msg, 'You can\\'t do that.', 'No'); } }, cmdOpts), new self.command.SingleCommand( ['team', 'teams', 't'], mkCmd(editTeam), cmdOpts), new self.command.SingleCommand( ['stats', 'stat', 'info', 'me'], mkCmd(commandStats), {validOnlyInGuild: true}), new self.command.SingleCommand( ['leaderboard', 'leader', 'top', 'rank', 'ranks'], mkCmd(commandLeaderboard), {validOnlyInGuild: true}), new self.command.SingleCommand( ['group', 'groups', 'season', 'seasons'], mkCmd(commandGroups), cmdOpts, [ new self.command.SingleCommand( ['create', 'new', 'make'], mkCmd(commandNewGroup), cmdOpts), new self.command.SingleCommand( ['delete', 'remove'], mkCmd(commandDeleteGroup), cmdOpts), new self.command.SingleCommand( ['select', 'choose', 'use'], mkCmd(commandSelectGroup), cmdOpts), new self.command.SingleCommand( ['rename', 'name', 'title'], mkCmd(commandRenameGroup), cmdOpts), ]), new self.command.SingleCommand(['nums'], mkCmd(commandNums), cmdOpts), new self.command.SingleCommand( ['rig', 'rigged'], mkCmd(commandRig), cmdOpts), new self.command.SingleCommand( ['kill', 'smite'], mkCmd(commandKill), cmdOpts), new self.command.SingleCommand( ['heal', 'revive', 'thrive', 'resurrect', 'restore'], mkCmd(commandHeal), cmdOpts), new self.command.SingleCommand( ['wound', 'hurt', 'damage', 'stab', 'punch', 'slap', 'injure'], mkCmd(commandWound), cmdOpts), new self.command.SingleCommand( ['rename', 'name'], mkCmd(commandRename), cmdOpts), new self.command.SingleCommand( ['react', 'reaction', 'emote', 'emoji'], mkCmd(commandReactJoin), cmdOpts), ]; const hgCmd = new self.command.SingleCommand( [ 'hg', 'hunger', 'hungry', 'hungergames', 'hungrygames', 'hungergame', 'hungrygame', ], function(msg) { if (cmdSearcher &amp;&amp; msg.text &amp;&amp; msg.text.length &gt; 1) { const toSearch = msg.text.trim().split(' ')[0]; const searched = cmdSearcher.search(toSearch); if (searched &amp;&amp; searched.length &gt; 0) { if (searched.length &gt; 1) { self.common.reply( msg, 'Hmm, did you mean one of the following commands?', searched .map((el) =&gt; { return msg.prefix + self.postPrefix + el; }) .join('\\n')); } else { self.common.reply( msg, 'Hmm, did you mean \"' + msg.prefix + self.postPrefix + searched[0] + '\"?'); } return; } } self.common.reply( msg, 'Oh noes! I can\\'t understand that! \"' + msg.prefix + self.postPrefix + 'help\" for help.'); }, null, subCmds); self.command.on(hgCmd); setupHelp(); self.client.on('messageUpdate', handleMessageEdit); self.client.on('guildDelete', onGuildDelete); self.client.on('channelDelete', onChannelDelete); self.client.guilds.forEach((g) =&gt; { hg.fetchGame(g.id, (game) =&gt; { if (!game) return; if (game.currentGame &amp;&amp; game.currentGame.day.state &gt; 1 &amp;&amp; game.currentGame.inProgress &amp;&amp; !game.currentGame.ended &amp;&amp; !game.currentGame.isPaused) { try { self.nextDay(game.author, g.id, game.outputChannel); } catch (err) { console.error(err); } } else { delete hg._games[g.id]; delete hg._findTimestamps[g.id]; } }); }); cmdSearcher = new FuzzySearch( Object.values(hgCmd.subCmds) .map((el) =&gt; el.aliases) .reduce((a, c) =&gt; a.concat(c))); if (self.client.shard) { /** * @description Fetch a string with the HG stats for this shard. * @private * @returns {string} Formatted stats string. */ self.client.getHGStats = getStatsString; } }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('hg'); self.client.removeListener('messageUpdate', handleMessageEdit); self.client.removeListener('guildDelete', onGuildDelete); self.client.removeListener('channelDelete', onChannelDelete); process.removeListener('exit', exit); process.removeListener('SIGINT', sigint); process.removeListener('SIGHUP', sigint); process.removeListener('SIGTERM', sigint); fire('shutdown'); Object.keys(eventHandlers).forEach((el) =&gt; delete eventHandlers[el]); fs.unwatchFile(eventFile); fs.unwatchFile(battleFile); fs.unwatchFile(weaponsFile); hg.shutdown(); if (self.client.shard) { self.client.getHGStats = null; } }; /** @inheritdoc */ this.unloadable = function() { const web = self.bot.getSubmodule(webSM); return self.getNumSimulating() === 0 &amp;&amp; listenersEndTime &lt; Date.now() &amp;&amp; (!web || !web.getNumClients || web.getNumClients() == 0); }; /** * @description Handler for when the create event message is edited and we * should update our message with the updated event. * * @private * @param {Discord~Message} oldMsg The message before being edited. * @param {Discord~Message} newMsg The message after being edited. * @listens Discord~Client#messageUpdate */ function handleMessageEdit(oldMsg, newMsg) { if (newEventMessages[oldMsg.id]) { newMsg.text = newMsg.text.trim(); newMsg.myResponse = oldMsg.myResponse; newEventMessages[oldMsg.id] = newMsg; updateEventPreview(newMsg); } } /** * @description Handle being removed from a guild. * * @private * @param {Discord~Guild} guild The guild that we just left. * @listens Discord~Client#guildDelete */ function onGuildDelete(guild) { hg.fetchGame(guild.id, (game) =&gt; { if (!game || !game.currentGame || !game.currentGame.inProgress) return; self.endGame(null, guild.id, true); }); } /** * @description Handle a channel being deleted. Cleans up games that may be in * progress in these channels. * * @private * @param {Discord~DMChannel|Discord~GuildChannel} channel The channel that * was deleted. * @listens Discord~Client#channelDelete */ function onChannelDelete(channel) { if (!channel.guild) return; if (!hg._games[channel.guild.id]) return; self.pauseGame(channel.guild.id); } /** * Make a subcommand handler with the given callback function. This is a * wrapper around existing functions. * * @private * @param {HungryGames~hgCommandHandler} cb Command handler when subcommand is * triggered. * @returns {Command~commandHandler} Subcommand initial handler that will fire * when command is fired. Calls the passed callback handler with the mapped * parameters. */ function mkCmd(cb) { return function(msg) { if (msg.guild.memberCount &gt; 20000) { self.common.reply( msg, 'Sorry, but HG has been temporarily disabled on servers larger' + ' than 20000 people.', 'More information on my support server.'); return; } const id = msg.guild.id; hg.fetchGame(id, (game) =&gt; { if (game) { if (game.loading) { self.common.reply( msg, 'Still loading', 'A previous command is still loading. ' + 'Please wait for it to complete.'); return; } let text = msg.text.trim().toLocaleLowerCase(); if (text.length &gt; 0) { game.channel = msg.channel.id; game.author = msg.author.id; if (game.includedNPCs) { game.includedNPCs.sort((a, b) =&gt; { return b.username.length - a.username.length; }); game.includedNPCs.forEach((el) =&gt; { if (text.indexOf(el.username.toLocaleLowerCase()) &gt; -1) { // text = text.replace(el.username.toLocaleLowerCase(), ''); msg.softMentions.users.add(el); } else if (text.indexOf(el.id.toLocaleLowerCase()) &gt; -1) { text = text.replace(el.id.toLocaleLowerCase(), ''); msg.softMentions.users.add(el); } }); } if (game.excludedNPCs) { game.excludedNPCs.sort( (a, b) =&gt; b.username.length - a.username.length); game.excludedNPCs.forEach((el) =&gt; { if (text.indexOf(el.username.toLocaleLowerCase()) &gt; -1) { // text = text.replace(el.username.toLocaleLowerCase(), ''); msg.softMentions.users.add(el); } else if (text.indexOf(el.id.toLocaleLowerCase()) &gt; -1) { text = text.replace(el.id.toLocaleLowerCase(), ''); msg.softMentions.users.add(el); } }); } } } cb(msg, id /* , game*/); }); }; } /** * Tell a user their chances of winning have not increased. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#hg makemelose */ function commandMakeMeWin(msg) { self.common.reply(msg, 'Everyone\\'s probability of winning has increased!'); } /** * Tell a user their chances of losing have not increased. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#hg makemelose */ function commandMakeMeLose(msg) { self.common.reply( msg, 'Your probability of losing has increased by ' + nothing() + '!'); } /** * Handler for a Hungry Games command. * * @callback HungryGames~hgCommandHandler * @param {Discord~Message} msg The message sent in Discord that triggered * this command. * @param {string} id The id of the guild this command was run on for * convenience. */ /** * @description A player object representing a non-player. It makes sense I * promise. This represents a Player in the game, that is not attached to a * real account. Serializable. * @inner * @augments HungryGames~Player */ class NPC extends HungryGames.Player { /** * @description Create a non-player character. * @param {string} username The username to show for this npc. * @param {string} avatarURL The url (or fake url) of the image to use as * the player's avatar. * @param {string} [id] Id to assign, if a valid id is not provided, a * random id will be generated. */ constructor(username, avatarURL, id) { if (typeof id !== 'string' || !NPC.checkID(id)) { id = NPC.createID(); } super(id, username, avatarURL); /** * Always true. * @public * @default * @constant * @type {boolean} */ this.isNPC = true; /** * Equivalent to `this.name` for compatibility. * @public * @type {string} */ this.username = this.name; } } /** * Create an NPC from an Object. Similar to copy-constructor. * * @public * @param {object} data NPC like Object. * @returns {HungryGames~NPC} Copied NPC. */ NPC.from = function(data) { const npc = new NPC(data.username, data.avatarURL, data.id); Object.assign(npc, HungryGames.Player.from(data)); return npc; }; /** * Generate a userID for an NPC. * * @public * @returns {string} Generated ID. */ NPC.createID = function() { let id; do { id = `NPC${crypto.randomBytes(8).toString('hex').toUpperCase()}`; } while (fs.existsSync(`${self.common.userSaveDir}avatars/${id}`)); return id; }; /** * Check if the given ID is a valid NPC ID. * * @public * @param {string} id The ID to validate. * @returns {boolean} True if ID is a valid ID for an NPC. */ NPC.checkID = function(id) { return typeof id === 'string' &amp;&amp; (id.match(/^NPC[A-F0-9]+$/) &amp;&amp; true || false); }; /** * Save an image for an NPC. Does NOT limit download sizes. * * @public * @param {string|Jimp|Buffer} avatar Any image, URL or file path to fetch the * avatar from. Anything supported by Jimp. * @param {string} id The NPC id to save the avatar to. * @returns {?Promise} Promise if successful will have the public URL where * the avatar is available. Null if error. */ NPC.saveAvatar = function(avatar, id) { if (!NPC.checkID(id)) return null; return readImage(avatar).then((image) =&gt; { if (!image) throw new Error('Failed to fetch NPC avatar.'); const dir = self.common.userSaveDir + 'avatars/' + id + '/'; const imgName = Date.now() + '.png'; const filename = dir + imgName; const url = self.common.webURL + (self.common.isRelease ? 'avatars/' : 'dev/avatars/') + id + '/' + imgName; mkdirp(dir, (err) =&gt; { if (err) { self.error('Failed to create NPC directory to cache avatar: ' + dir); console.error(err); return; } const fetchSize = HungryGames.UserIconUrl.fetchSize; image.resize(fetchSize, fetchSize); image.getBuffer(Jimp.MIME_PNG, (err, buffer) =&gt; { if (err) { self.error('Failed to convert image into buffer: ' + avatar); console.error(err); return; } fs.writeFile(filename, buffer, (err) =&gt; { if (err) { self.error('Failed to cache NPC avatar: ' + filename); console.error(err); } }); }); }); return url; }); }; /** * @inheritdoc * @public */ this.NPC = NPC; /** * @description Delay a message to send at the given time in milliseconds * since epoch. * * @private * @param {Discord~TextChannel} channel The channel to send the message in. * @param { * Discord~StringResolvable| * Discord~MessageOptions| * Discord~MessageEmbed| * Discord~MessageAttachment| * Discord~MessageAttachment[] * } one The message to send. * @param { * Discord~StringResolvable| * Discord~MessageOptions| * Discord~MessageEmbed| * Discord~MessageAttachment| * Discord~MessageAttachment[] * } two The message to send. * @param {number} time The time to send the message in milliseconds since * epoch. */ function sendAtTime(channel, one, two, time) { if (time &lt;= Date.now()) { channel.send(one, two).catch((err) =&gt; { self.error('Failed to send message to channel: ' + channel.id); console.error(err); }); } else { self.client.setTimeout(function() { sendAtTime(channel, one, two, time); }, time - Date.now()); } } /** * @description Returns an object storing all of the default events for the * games. * * @public * @returns {{bloodbath: object, player: object, arena: object}} Object * storing default events. */ this.getDefaultEvents = function() { return { bloodbath: defaultBloodbathEvents, player: defaultPlayerEvents, weapon: weapons, arena: defaultArenaEvents, }; }; /** * @description Returns the object storing all default {@link * HungryGames~Battle}s parsed from file. * * @public * @returns {HungryGames~Battle[]} Array of all default battle events. */ this.getDefaultBattles = function() { return battles; }; /** * @description Returns the object storing all default {@link * HungryGames~Weapon}s parsed from file. * * @public * @returns {HungryGames~Weapon[]} Array of all default weapons. */ this.getDefaultWeapons = function() { return weapons; }; // Create // /** * Create a Hungry Games for a guild. * * @private * @type {HungryGames~hgCommandHandler} * @param {?Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {boolean} [silent=false] Should we suppress replies to message. * @param {Function} [cb] Callback that fires once loading is complete. Only * parameter is created {@link HungryGames~GuildGame} or null if failed. */ function createGame(msg, id, silent, cb) { if (!msg) { silent = true; msg = { guild: self.client.guilds.get(id), }; } const g = hg.getGame(id); /** * @description Fires once game creation is done, and we are ready to * continue. * @private * @param {?HungryGames~GuildGame} game Created GuildGame if successful. */ const done = function(game) { if (!game) { self.warn('Failed to create/refresh game'); cb(null); return; } game.formTeams(); fetchPatreonSettings(game.currentGame.includedUsers, null, null, () =&gt; { if (typeof cb === 'function') cb(game); }); }; if (g &amp;&amp; g.currentGame &amp;&amp; g.currentGame.inProgress) { if (!silent) { self.common.reply( msg, 'This server already has a Hungry Games in progress. If you wish ' + 'to create a new one, you must end the current one first ' + 'with \"' + msg.prefix + self.postPrefix + 'end\".'); } if (typeof cb === 'function') cb(null); } else if (g) { if (!silent) { self.common.reply(msg, 'Refreshing current game.'); } g.includedUsers = g.includedUsers.filter((u) =&gt; { const m = msg.guild.members.get(u); if (m &amp;&amp; m.partial) m.fetch(); return m; }); g.excludedUsers = g.excludedUsers.filter((u) =&gt; { const m = msg.guild.members.get(u); if (m &amp;&amp; m.partial) m.fetch(); return m; }); hg.refresh(msg.guild, done); } else { hg.create(msg.guild, (game) =&gt; { if (!silent) { self.common.reply( msg, 'Created a Hungry Games with default settings and all members ' + 'included.'); } done(game); }); } } /** * Create a Hungry Games for a guild. * * @public * @param {string} id The id of the guild to create the game in. * @param {Function} [cb] Callback that fires once loading is complete. Only * parameter is created {@link HungryGames~GuildGame} or null if failed. */ this.createGame = function(id, cb) { createGame(null, id, true, cb); }; /** * Given an array of players, lookup the settings for each and update their * data. This is asynchronous. * * @private * * @param {HungryGames~Player[]} players The players to lookup and update. * @param {?string|number} cId The channel ID to fetch the settings for. * @param {?string|number} gId The guild ID to fetch the settings for. * @param {Function} [cb] Calls this callback on completion. No parameters. */ function fetchPatreonSettings(players, cId, gId, cb) { if (!self.bot.patreon || players.length == 0) { if (cb) cb(); return; } let permResponses = 0; let settingRequests = 0; let settingResponses = 0; /** * After retrieving whether the player is an actual patron (ignores * overrides), then fetch permissions from them (uses overrides). * * @private * * @param {?string} err Error string or null. * @param {?{status: string[], message: string}} info Permission * information. * @param {number} p Player object to update. */ function onCheckPatron(err, info, p) { if (!err) { if (info.status) { p.settings['isPatron'] = true; } } self.bot.patreon.getAllPerms(p.id, cId, gId, function(err, info) { onPermResponse(err, info, p); }); } /** * After retrieving a player's permissions, fetch their settings for each. * * @private * @param {?string} err Error string or null. * @param {?{status: string[], message: string}} info Permission * information. * @param {number} p Player object to update. */ function onPermResponse(err, info, p) { permResponses++; if (err) { if (permResponses === players.length &amp;&amp; settingRequests === settingResponses &amp;&amp; cb) { cb(); } return; } const values = info.status; for (let i = 0; i &lt; values.length; i++) { if (!patreonSettingKeys.includes(values[i])) continue; settingRequests++; self.bot.patreon.getSettingValue( p.id, cId, gId, values[i], (function(p, v) { return function(err, info) { onSettingResponse(err, info, p, v); }; })(p, values[i])); } if (permResponses === players.length &amp;&amp; settingRequests === settingResponses &amp;&amp; cb) { cb(); } } /** * After retrieving a player's settings, update their data with the relevant * values. * * @private * @param {?string} err Error string or null. * @param {?{status: *, message: string}} info Permission information. * @param {number} p Player object to update. * @param {string} setting The setting name to update. */ function onSettingResponse(err, info, p, setting) { settingResponses++; if (err) { self.error(err); } else { if (setting == 'hg:bar_color') { let color; if (info.status.match(/^0x[0-9A-Fa-f]{8}$/)) { color = info.status * 1; } else if (info.status.match(/^0x[0-9A-Fa-f]{6}$/)) { // Color requires alpha value, but given is just rgb. Shift rgb, // then set alpha. color = ((info.status * 1) &lt;&lt; 8) | 0xFF; } else { if (p.settings.isPatron) { color = patreonColor; } else { color = 0x0; } } p.settings[setting] = color &gt;&gt;&gt; 0; } else { p.settings[setting] = info.status; } } if (permResponses === players.length &amp;&amp; settingRequests === settingResponses &amp;&amp; cb) { cb(); } } for (let i = 0; i &lt; players.length; i++) { self.bot.patreon.checkPerm(players[i].id, null, (function(p) { return function(err, info) { onCheckPatron(err, info, p); }; })(players[i])); } } /** * Reset data that the user specifies. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function resetGame(msg, id) { const command = msg.text.trim().split(' ')[0]; self.common.reply(msg, 'Reset HG', hg.resetGame(id, command)); } /** * Send all of the game data about the current server to the chat. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function showGameInfo(msg, id) { let finalId = id; if (msg.author.id == self.common.spikeyId) { if (msg.text.trim().split(' ')[0]) { finalId = msg.text.trim().split(' ')[0]; } } const game = hg.getGame(finalId); if (game) { const file = new self.Discord.MessageAttachment(); file.setFile(Buffer.from(JSON.stringify(game.serializable, null, 2))); file.setName(`HG-${finalId}.json`); msg.channel.send(`HG Data for guild ${finalId}`, file); } else { self.common.reply(msg, 'No game created', finalId); } } /** * Send all event data about the default events to the chat. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function showGameEvents(msg, id) { let events = defaultBloodbathEvents; const game = hg.getGame(id); if (game &amp;&amp; game.customEvents.bloodbath) { events = events.concat(game.customEvents.bloodbath); } let file = new self.Discord.MessageAttachment(); file.setFile(Buffer.from(JSON.stringify(events, null, 2))); file.setName('BloodbathEvents.json'); fetchStats(events); msg.channel.send( 'Bloodbath Events (' + events.length + ') ' + Math.round(events.numKill / events.length * 1000) / 10 + '% kill, ' + Math.round(events.numWound / events.length * 1000) / 10 + '% wound, ' + Math.round(events.numThrive / events.length * 1000) / 10 + '% heal.', file); events = defaultPlayerEvents; if (game &amp;&amp; game.customEvents.player) { events = events.concat(game.customEvents.player); } file = new self.Discord.MessageAttachment(); file.setFile(Buffer.from(JSON.stringify(events, null, 2))); file.setName('PlayerEvents.json'); fetchStats(events); msg.channel.send( 'Player Events (' + events.length + ') ' + Math.round(events.numKill / events.length * 1000) / 10 + '% kill, ' + Math.round(events.numWound / events.length * 1000) / 10 + '% wound, ' + Math.round(events.numThrive / events.length * 1000) / 10 + '% heal.', file); events = Object.assign({}, weapons); if (game &amp;&amp; game.customEvents.weapon) { const keys = Object.keys(game.customEvents.weapon); for (let i = 0; i &lt; keys.length; i++) { if (events[keys[i]]) { events[keys[i]].outcomes = events[keys[i]].outcomes.concat( game.customEvents.weapon[keys[i]].outcomes); } else { events[keys[i]] = game.customEvents.weapon[keys[i]]; } } } file = new self.Discord.MessageAttachment(); file.setFile(Buffer.from(JSON.stringify(events, null, 2))); file.setName('WeaponEvents.json'); msg.channel.send( 'Weapon Events (' + Object.keys(events).length + ' weapons)', file); events = defaultArenaEvents; if (game &amp;&amp; game.customEvents.arena) { events = events.concat(game.customEvents.arena); } file = new self.Discord.MessageAttachment(); file.setFile(Buffer.from(JSON.stringify(events, null, 2))); file.setName('ArenaEvents.json'); msg.channel.send('Arena Events (' + events.length + ')', file); } // Time Control // /** * Start the games in the channel this was called from. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function startGame(msg, id) { const game = hg.getGame(id); if (game &amp;&amp; game.currentGame &amp;&amp; game.currentGame.inProgress) { self.common.reply( msg, 'A game is already in progress! (\"' + msg.prefix + self.postPrefix + 'next\" for next day, or \"' + msg.prefix + self.postPrefix + 'end\" to abort)'); return; } const myPerms = msg.channel.permissionsFor(self.client.user.id); if (!myPerms || !myPerms.has(self.Discord.Permissions.FLAGS.ATTACH_FILES)) { self.common.reply( msg, 'Sorry, but I need permission to send images ' + 'in this channel before I can start the games.\\nPlease ensure' + ' I have the \"Attach Files\" permission in this channel.', myPerms ? null : 'This is probably an error, this should be fixed soon.'); if (!myPerms) { self.error( 'Failed to fetch perms for myself. ' + (msg.guild.me &amp;&amp; true)); } return; } else if (!myPerms.has(self.Discord.Permissions.FLAGS.EMBED_LINKS)) { self.common.reply( msg, 'Sorry, but I need permission to embed messages ' + 'in this channel before I can start the games.\\nPlease ensure' + ' I have the \"Embed Links\" permission in this channel.'); return; } else if (!myPerms.has(self.Discord.Permissions.FLAGS.SEND_MESSAGES)) { return; } if (game) game.loading = true; if (game &amp;&amp; game.reactMessage) { self.endReactJoinMessage(id, (err) =&gt; { if (err) { if (game) game.loading = false; self.error(`${err}: ${id}`); self.common.reply('React Join Failed', err); } startGame(msg, id); }); return; } /** * Once the game has finished loading all necessary data, start it if * autoplay is enabled. * * @private */ function loadingComplete() { self.client.setTimeout(() =&gt; { if (hg.getGame(id).autoPlay &amp;&amp; !hg.getGame(id).currentGame.isPaused) { nextDay(msg, id); } }); if (game) game.loading = false; } createGame(msg, id, true, (g) =&gt; { if (!g) { if (game) { game.loading = false; if (game.currentGame) game.currentGame.inProgress = false; } self.warn('Failed to create game to start game'); self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } g.currentGame.inProgress = true; const finalMessage = makePlayerListEmbed(g); finalMessage.setTitle(hg.messages.get('gameStart')); if (!g.autoPlay) { finalMessage.setFooter( `\"${msg.prefix}${self.postPrefix}next\" for next day.`); } let mentions = self.common.mention(msg); if (g.options.mentionEveryoneAtStart) { mentions += '@everyone'; } msg.channel.send(mentions, finalMessage).catch((err) =&gt; { self.common.reply( msg, 'Game started!', 'Discord rejected my normal message for some reason...'); self.error( 'Failed to send start game message: ' + msg.channel.id + ' (Num: ' + g.currentGame.includedUsers.length + ')'); console.error(err); }); loadingComplete(); }); if (game &amp;&amp; game.currentGame) game.currentGame.inProgress = true; } /** * Start the games in the given channel and guild by the given user. * * @public * @param {string} uId The id of the user who trigged the games to start. * @param {string} gId The id of the guild to run the games in. * @param {string} cId The id of the channel to run the games in. */ this.startGame = function(uId, gId, cId) { startGame(makeMessage(uId, gId, cId), gId); }; /** * Start autoplay in the given channel and guild by the given user. * * @public * @param {string} uId The id of the user who trigged autoplay to start. * @param {string} gId The id of the guild to run autoplay in. * @param {string} cId The id of the channel to run autoplay in. */ this.startAutoplay = function(uId, gId, cId) { startAutoplay(makeMessage(uId, gId, cId), gId); }; /** * End the games in the given guild as the given user. * * @public * @param {string|Discord~Message} uId The id of the user who trigged the * games to end, or a Discord message sent by the user who triggered this. * @param {string} gId The id of the guild to end the games in. */ this.endGame = function(uId, gId) { if (uId != null &amp;&amp; typeof uId === 'object') { endGame(uId, gId); } else { endGame(makeMessage(uId, gId, null), gId, true); } }; /** * Pause autoplay in the given guild as the given user. * * @public * @param {string} uId The id of the user who trigged autoplay to end. * @param {string} gId The id of the guild to end autoplay. */ this.pauseAutoplay = function(uId, gId) { pauseAutoplay(makeMessage(uId, gId, null), gId); }; /** * Forms a Discord~Message similar object from given IDs. * * @private * @param {string} uId The id of the user who wrote this message. * @param {string} gId The id of the guild this message is in. * @param {?string} cId The id of the channel this message was 'sent' in. * @param {?string} msg The message content. * @returns { * { * author: Discord~Member, * guild: Discord~Guild, * channel: Discord~GuildChannel * } * } The created message-like object. */ function makeMessage(uId, gId, cId, msg) { const g = self.client.guilds.get(gId); if (!g) return null; if (!cId &amp;&amp; hg.getGame(gId)) cId = hg.getGame(gId).channel; return { author: self.client.users.get(uId), client: self.client, member: g.members.get(uId), guild: g, channel: g.channels.get(cId), text: msg, content: msg, prefix: self.bot.getPrefix(gId), softMentions: { members: new self.Discord.Collection(), users: new self.Discord.Collection(), roles: new self.Discord.Collection(), }, mentions: { channels: new self.Discord.Collection(), members: new self.Discord.Collection(), roles: new self.Discord.Collection(), users: new self.Discord.Collection(), }, }; } /** * Stop autoplaying. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function pauseAutoplay(msg, id) { if (!hg.getGame(id)) { self.common.reply( msg, 'Not autoplaying. If you wish to autoplay, type \"' + msg.prefix + self.postPrefix + 'autoplay\".'); return; } if (hg.getGame(id).autoPlay) { if (msg &amp;&amp; msg.channel) { msg.channel.send( '&lt;@' + msg.author.id + '&gt; `Autoplay will stop at the end of the current day.`'); } hg.getGame(id).autoPlay = false; } else { if (msg &amp;&amp; msg.channel) { self.common.reply( msg, 'Not autoplaying. If you wish to autoplay, type \"' + msg.prefix + self.postPrefix + 'autoplay\".'); } } } /** * Start autoplaying. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to start autoplay on. */ function startAutoplay(msg, id, game) { if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } startAutoplay(msg, id, game); }); return; } if (game.autoPlay &amp;&amp; game.currentGame.inProgress) { if (game.currentGame.isPaused) { self.common.reply( msg, 'Autoplay is already enabled.', 'To resume the game, use `' + msg.prefix + self.postPrefix + 'resume`.'); } else { pauseAutoplay(msg, id); } } else { game.autoPlay = true; if (game.currentGame.inProgress &amp;&amp; game.currentGame.day.state === 0) { if (self.command.validate(msg.prefix + 'hg next', msg)) { self.common.reply( msg, 'Sorry, but you don\\'t have permission to start the next day ' + 'in the games.'); return; } msg.channel.send( '&lt;@' + msg.author.id + '&gt; `Enabling Autoplay! Starting the next day!`'); nextDay(msg, id); } else if (!game.currentGame.inProgress) { if (self.command.validate(msg.prefix + 'hg start', msg)) { self.common.reply( msg, 'Sorry, but you don\\'t have permission to start the games.', 'hg start'); return; } msg.channel.send( '&lt;@' + msg.author.id + '&gt; `Autoplay is enabled. Starting the games!`'); startGame(msg, id); } else if (game.currentGame.isPaused) { self.common.reply( msg, 'Enabling Autoplay', 'Resume game with `' + msg.prefix + self.postPrefix + 'resume`.'); } else { msg.channel.send('&lt;@' + msg.author.id + '&gt; `Enabling autoplay!`'); } } } /** * Pause the game in by clearing the current interval. * * @public * @param {string} id The id of the guild to pause in. * @returns {string} User information of the outcome of this command. */ this.pauseGame = function(id) { if (!hg.getGame(id) || !hg.getGame(id).currentGame || !hg.getGame(id).currentGame.inProgress) { return 'Failed: There isn\\'t currently a game in progress.'; } if (hg.getGame(id).currentGame.isPaused) { return 'Failed: Game is already paused.'; } hg.getGame(id).clearIntervals(); hg.getGame(id).currentGame.isPaused = true; return 'Success'; }; /** * Stop the game in the middle of the day until resumed. Just clears the * interval for the game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function pauseGame(msg, id) { self.common.reply(msg, 'Game Pausing', self.pauseGame(id)); } /** * Start the next day of the game in the given channel and guild by the given * user. * * @public * @param {string} uId The id of the user who trigged autoplay to start. * @param {string} gId The id of the guild to run autoplay in. * @param {string} cId The id of the channel to run autoplay in. */ this.nextDay = function(uId, gId, cId) { nextDay(makeMessage(uId, gId, cId), gId); }; /** * Simulate a single day then show events to users. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function nextDay(msg, id) { if (!msg.channel) { self.error('Failed to start next day because channel is unknown: ' + id); return; } const game = hg.getGame(id); if (!game || !game.currentGame || !game.currentGame.inProgress) { self.common .reply( msg, 'You must start a game first! Use \"' + msg.prefix + self.postPrefix + 'start\" to start a game!') .catch((err) =&gt; { self.error('Failed to tell user to start game: ' + err.message); if (err.message != 'No Perms') console.error(err); }); return; } if (game.currentGame.day.state !== 0) { if (game._autoStep) { self.common.reply(msg, 'Already simulating day.'); } else if (game.currentGame.day.state == 1) { self.common .reply( msg, 'I think I\\'m already simulating... if this isn\\'t true this ' + 'game has crashed and you must end the game.') .catch((err) =&gt; { self.error( 'Failed to tell user day is already in progress: ' + err.message); if (err.message != 'No Perms') console.error(err); }); } else { game.currentGame.isPaused = false; game.createInterval(dayStateModified); } return; } const myPerms = msg.channel.permissionsFor(self.client.user.id); if (!myPerms || (!myPerms.has(self.Discord.Permissions.FLAGS.ATTACH_FILES) &amp;&amp; !myPerms.has(self.Discord.Permissions.FLAGS.ADMINISTRATOR))) { self.common.reply( msg, 'Sorry, but I need permission to send images ' + 'in this channel before I can start the games.\\nPlease ensure' + ' I have the \"Attach Files\" permission in this channel.', myPerms ? null : 'This is probably a bug, this should be fixed soon.'); if (!myPerms) { self.error( 'Failed to fetch perms for myself. ' + (msg.guild.me &amp;&amp; true)); } return; } else if ( !myPerms.has(self.Discord.Permissions.FLAGS.EMBED_LINKS) &amp;&amp; !myPerms.has(self.Discord.Permissions.FLAGS.ADMINISTRATOR)) { self.common.reply( msg, 'Sorry, but I need permission to embed messages ' + 'in this channel before I can start the games.\\nPlease ensure' + ' I have the \"Embed Links\" permission in this channel.'); return; } const sim = new HungryGames.Simulator(game, hg, msg); const iTime = Date.now(); sim.go(() =&gt; { // Signal ready to display events. fire('dayStateChange', id); const embed = new self.Discord.MessageEmbed(); if (game.currentGame.day.num === 0) { embed.setTitle(hg.messages.get('bloodbathStart')); } else { embed.setTitle( hg.messages.get('dayStart') .replaceAll('{}', game.currentGame.day.num)); } if (!game.autoPlay &amp;&amp; game.currentGame.day.num &lt; 2) { embed.setFooter( 'Tip: Use \"' + msg.prefix + self.postPrefix + 'autoplay\" to automate the games.'); } embed.setColor(defaultColor); if (!game || !game.options.disableOutput) { msg.channel.send(embed).catch((err) =&gt; { if (err.message === 'Missing Permissions' || err.message === 'Missing Access' || err.message === 'Unknown Channel') { self.pauseGame(id); } else { console.error(err); } }); } game.outputChannel = msg.channel.id; game.currentGame.isPaused = false; game.createInterval(dayStateModified); }); const now = Date.now(); if (now - iTime &gt; 10) { self.warn(`Simulator.go ${now - iTime}`); } /** * @description Callback for every time the game state is modified. * @private * @type {HungryGames~GuildGame~StateUpdateCB} * @param {boolean} dayComplete Has the day ended. * @param {boolean} doSim If next day should be simulated and started. */ function dayStateModified(dayComplete, doSim) { if (doSim) { nextDay(msg, id); } else if (dayComplete) { printDay(msg, id); if (!hg.getGame(id).options.disableOutput &amp;&amp; hg.getGame(id).autoPlay) { self.client.setTimeout(() =&gt; { msg.channel.send('`Autoplaying...`') .then((msg) =&gt; { msg.delete({ timeout: hg.getGame(id).options.delayDays - 1250, reason: 'I can do whatever I want!', }) .catch(() =&gt; {}); }) .catch(() =&gt; {}); }, (hg.getGame(id).options.delayDays &gt; 2000 ? 1200 : 100)); } } else { fire('dayStateChange', id); printEvent(msg, id); } } } /** * Print an event string to the channel and add images, or if no events * remain, trigger end of day. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function printEvent(msg, id) { const index = hg.getGame(id).currentGame.day.state - 2; const events = hg.getGame(id).currentGame.day.events; if (index &gt;= events.length) { printDay(msg, id); } else if (!events[index]) { /* self.warn( 'Failed to find event for index ' + index + '/' + events.length + ' even though it should exist: ' + id); */ } else if ( events[index].battle &amp;&amp; events[index].state &lt; events[index].attacks.length) { const battleState = events[index].state; const embed = new self.Discord.MessageEmbed(); const message = events[index].attacks[battleState].message.split('\\n'); embed.addField(message[1], message[2]); embed.setColor([50, 0, 0]); const avatarSizes = hg.getGame(id).options.battleAvatarSizes; const battleIconSize = avatarSizes.avatar; if (battleIconSize === 0 || events[index].attacks[battleState].icons.length === 0) { // Send without image. if (!battleMessage[id]) { if (!hg.getGame(id).options.disableOutput) { msg.channel.send(message[0], embed) .then((msg_) =&gt; { battleMessage[id] = msg_; }) .catch((err) =&gt; { self.error( 'Failed to send battle event message without image: ' + msg.channel.id); console.error(err); }); } } else { battleMessage[id].edit(message[0], embed); } } else { const iconGap = avatarSizes.gap; const underlineSize = avatarSizes.underline; // Create image, then send. const finalImage = new Jimp( events[index].attacks[battleState].icons.length * (battleIconSize + iconGap) - iconGap, battleIconSize + underlineSize * 2); let responses = 0; const newImage = function(image, outcome, placement, barColor) { try { if (battleIconSize &gt; 0) { if (image) image.resize(battleIconSize, battleIconSize); if (underlineSize &gt; 0) { if (typeof barColor === 'number') { finalImage.blit( new Jimp(battleIconSize, underlineSize, barColor), placement * (battleIconSize + iconGap), 0); } if (outcome == 'dies') { finalImage.blit( new Jimp(battleIconSize, underlineSize, 0xFF0000FF), placement * (battleIconSize + iconGap), battleIconSize + underlineSize); } else if (outcome == 'wounded') { finalImage.blit( new Jimp(battleIconSize, underlineSize, 0xFFFF00FF), placement * (battleIconSize + iconGap), battleIconSize + underlineSize); } } if (image) { finalImage.blit( image, placement * (battleIconSize + iconGap), underlineSize); } } } catch (err) { console.error(err); } responses++; if (responses == events[index].attacks[battleState].icons.length) { finalImage.getBuffer(Jimp.MIME_PNG, function(err, out) { // Attach file, then send. embed.attachFiles( [new self.Discord.MessageAttachment(out, 'hgBattle.png')]); if (!hg.getGame(id).options.disableOutput) { msg.channel.send(message[0], embed) .then((msg_) =&gt; { battleMessage[id] = msg_; }) .catch((err) =&gt; { self.error( 'Failed to send battle event message with image: ' + msg.channel.id); console.error(err); }); } }); } }; let numNonUser = 0; for (let i = 0; i &lt; events[index].attacks[battleState].icons.length; i++) { let outcome = events[index].attacks[battleState].victim.outcome; if (!events[index].attacks[battleState].icons[i].id) { numNonUser++; outcome = 'nothing'; } else if ( i &gt;= events[index].attacks[battleState].numVictim + numNonUser) { outcome = events[index].attacks[battleState].attacker.outcome; } readImage(events[index].attacks[battleState].icons[i].url) .then( function(outcome, placement, settings) { return function(image) { newImage( image, outcome, placement, settings &amp;&amp; settings['hg:bar_color']); }; }(outcome, i, events[index].attacks[battleState].icons[i].settings)) .catch(function(err) { self.error('Failed to read image'); console.log(err); responses++; }); } } } else { // delete battleMessage[id]; const avatarSizes = hg.getGame(id).options.eventAvatarSizes; const iconSize = avatarSizes.avatar; if (iconSize == 0 || events[index].icons.length === 0) { if (!hg.getGame(id).options.disableOutput &amp;&amp; msg.channel) { msg.channel .send( (events[index].mentionString || '') + events[index].message + '\\n' + (events[index].subMessage || '')) .catch((err) =&gt; { self.error( 'Failed to send message without image: ' + msg.channel.id); console.error(err); }); } } else { const iconGap = avatarSizes.gap; const underlineSize = avatarSizes.underline; const embed = new self.Discord.MessageEmbed(); if (events[index].subMessage) { // embed.addField('\\u200B', events[index].subMessage, false); embed.setDescription( events[index].message + '\\n' + events[index].subMessage); } else { embed.setDescription(events[index].message); } embed.setColor([125, 0, 0]); const finalImage = new Jimp( events[index].icons.length * (iconSize + iconGap) - iconGap, iconSize + underlineSize * 2); let responses = 0; const newImage = function(image, outcome, placement, barColor) { try { if (iconSize &gt; 0) { if (image) image.resize(iconSize, iconSize); if (underlineSize &gt; 0) { if (typeof barColor === 'number') { finalImage.blit( new Jimp(iconSize, underlineSize, barColor), placement * (iconSize + iconGap), 0); } if (outcome == 'dies') { finalImage.blit( new Jimp(iconSize, underlineSize, 0xFF0000FF), placement * (iconSize + iconGap), iconSize + underlineSize); } else if (outcome == 'wounded') { finalImage.blit( new Jimp(iconSize, underlineSize, 0xFFFF00FF), placement * (iconSize + iconGap), iconSize + underlineSize); } else if (outcome == 'thrives') { finalImage.blit( new Jimp(iconSize, underlineSize, 0x00FF00FF), placement * (iconSize + iconGap), iconSize + underlineSize); } else if (outcome == 'revived') { finalImage.blit( new Jimp(iconSize, underlineSize, 0x00FFFFFF), placement * (iconSize + iconGap), iconSize + underlineSize); } } if (image) { finalImage.blit( image, placement * (iconSize + iconGap), underlineSize); } } } catch (err) { console.error(err); } responses++; if (responses == events[index].icons.length) { finalImage.getBuffer(Jimp.MIME_PNG, function(err, out) { embed.attachFiles( [new self.Discord.MessageAttachment(out, 'hgEvent.png')]); if (!hg.getGame(id).options.disableOutput &amp;&amp; msg.channel) { msg.channel.send(events[index].mentionString, embed) .catch((err) =&gt; { self.error( 'Failed to send message with image: ' + msg.channel.id); console.error(err); }); } }); } }; let numNonUser = 0; for (let i = 0; i &lt; events[index].icons.length; i++) { let outcome = events[index].victim.outcome; if (!events[index].icons[i].id) { numNonUser++; outcome = 'nothing'; } else if (i &gt;= events[index].numVictim + numNonUser) { outcome = events[index].attacker.outcome; } readImage(events[index].icons[i].url) .then( function(outcome, placement, settings) { return function(image) { newImage( image, outcome, placement, settings &amp;&amp; settings['hg:bar_color']); }; }(outcome, events[index].icons.length - i - 1, events[index].icons[i].settings)) .catch(function(err) { self.error('Failed to read image'); console.log(err); responses++; }); } } } } /** * Trigger the end of a day and print summary/outcome at the end of the day. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function printDay(msg, id) { let numAlive = 0; let lastIndex = 0; let lastId = 0; let numTeams = 0; let lastTeam = 0; let numWholeTeams = 0; let lastWholeTeam = 0; const game = hg.getGame(id); const current = game.currentGame; current.includedUsers.forEach((el, i) =&gt; { if (el.living) { numAlive++; lastIndex = i; lastId = el.id; } }); if (game.options.teamSize &gt; 0) { current.teams.forEach(function(team, index) { if (team.numAlive &gt; 0) { numTeams++; lastTeam = index; } if (team.numAlive &gt; 1 &amp;&amp; team.numAlive == team.players.length) { numWholeTeams++; lastWholeTeam = index; } }); } if (current.numAlive != numAlive) { self.warn( 'Realtime alive count is incorrect! ' + current.numAlive + ' vs ' + numAlive); } const finalMessage = new self.Discord.MessageEmbed(); finalMessage.setColor(defaultColor); const collab = game.options.teammatesCollaborate == 'always' || (game.options.teammatesCollaborate == 'untilend' &amp;&amp; numTeams &gt; 1); if (collab &amp;&amp; numTeams == 1) { const teamName = current.teams[lastTeam].name; finalMessage.setTitle(`${teamName} has won ${current.name}!`); let teamPlayerList = current.teams[lastTeam] .players .map((player) =&gt; { const p = current.includedUsers.find((user) =&gt; { return user.id == player; }); if (game.options.useNicknames) { return p.nickname || p.name; } else { return p.name; } }) .join(', '); if (teamPlayerList.length &gt; 1024) { teamPlayerList = `${teamPlayerList.substring(0, 1021)}...`; } finalMessage.setDescription(teamPlayerList); current.inProgress = false; current.ended = true; game.autoPlay = false; } else if (numAlive == 1) { const p = current.includedUsers[lastIndex]; const winnerName = game.options.useNicknames ? (p.nickname || p.name) : p.name; let teamName = ''; if (game.options.teamSize &gt; 0) { teamName = `(${current.teams[lastTeam].name}) `; } finalMessage.setTitle( `\\`${winnerName}${teamName}\\` has won ${current.name}!`); finalMessage.setThumbnail(current.includedUsers[lastIndex].avatarURL); current.inProgress = false; current.ended = true; game.autoPlay = false; } else if (numAlive &lt; 1) { finalMessage.setTitle( `Everyone has died in ${current.name}!\\nThere are no winners!`); current.inProgress = false; current.ended = true; game.autoPlay = false; } else { if (game.options.teamSize &gt; 0) sortTeams(game); let prevTeam = -1; let playersToShow = current.includedUsers; if (game.options.numDaysShowDeath &gt;= 0 || !game.options.showLivingPlayers) { playersToShow = playersToShow.filter((el) =&gt; { if (!game.options.showLivingPlayers &amp;&amp; el.living) { return false; } return el.living || el.state == 'wounded' || (game.options.numDaysShowDeath &gt;= 0 &amp;&amp; current.day.num - el.dayOfDeath &lt; game.options.numDaysShowDeath); }); } const showDead = playersToShow.find((el) =&gt; !el.living); const showWounded = playersToShow.find((el) =&gt; el.state == 'wounded'); finalMessage.setAuthor( emoji.redHeart + 'Alive' + (showWounded ? (`, ${emoji.yellowHeart}Wounded`) : '') + (showDead ? (`, ${emoji.skull}Dead`) : '')); let showKills = false; const statusList = playersToShow.map(function(obj) { let myTeam = -1; if (game.options.teamSize &gt; 0) { myTeam = current.teams.findIndex((team) =&gt; { return team.players.findIndex((player) =&gt; { return player == obj.id; }) &gt; -1; }); } let symbol = emoji.heart; if (!obj.living) { symbol = emoji.skull; } else if (obj.state == 'wounded') { symbol = emoji.yellowHeart; /* } else if (obj.state == 'zombie') { symbol = emoji.brokenHeart; */ } let shortName; if (obj.nickname &amp;&amp; game.options.useNicknames) { shortName = obj.nickname.substring(0, 16); if (shortName != obj.nickname) { shortName = `${shortName.substring(0, 13)}...`; } } else { shortName = obj.name.substring(0, 16); if (shortName != obj.name) { shortName = `${shortName.substring(0, 13)}...`; } } let prefix = ''; if (myTeam != prevTeam) { prevTeam = myTeam; prefix = `__${current.teams[myTeam].name}__\\n`; } showKills = showKills || obj.kills &gt; 0; return prefix + symbol + '`' + shortName + '`' + (obj.kills &gt; 0 ? '(' + obj.kills + ')' : ''); }); finalMessage.setTitle(`Status update!${showKills ? ' (kills)' : ''}`); if (game.options.teamSize == 0) { statusList.sort((a, b) =&gt; { if (a.startsWith(emoji.skull)) { if (!b.startsWith(emoji.skull)) { return 1; } } else if (b.startsWith(emoji.skull)) { if (!a.startsWith(emoji.skull)) { return -1; } } if (a &lt; b) return -1; if (a &gt; b) return 1; return 0; }); } if (statusList.length &gt;= 5) { const numCols = calcColNum(statusList.length &gt; 10 ? 3 : 2, statusList); const numTotal = statusList.length; const quarterLength = Math.ceil(numTotal / numCols); for (let i = 0; i &lt; numCols - 1; i++) { const thisMessage = statusList.splice(0, quarterLength).join('\\n').slice(0, 1024); finalMessage.addField( `${i * quarterLength + 1}-${(i + 1) * quarterLength}`, thisMessage, true); } finalMessage.addField( `${(numCols - 1) * quarterLength + 1}-${numTotal}`, statusList.join('\\n').slice(0, 1024), true); } else { finalMessage.setDescription(statusList.join('\\n') || '...'); } if (numWholeTeams == 1) { finalMessage.setFooter( hg.messages.get('teamRemaining') .replaceAll('{}', current.teams[lastWholeTeam].name)); } } if (!current.ended) { const embed = new self.Discord.MessageEmbed(); if (current.day.num == 0) { embed.setTitle(hg.messages.get('bloodbathEnd')); } else { embed.setTitle( hg.messages.get('dayEnd') .replaceAll('{day}', current.day.num) .replaceAll('{alive}', numAlive)); } if (!game.autoPlay) { embed.setFooter(`\"${msg.prefix}${self.postPrefix}next\" for next day.`); } embed.setColor(defaultColor); if (!game.options.disableOutput &amp;&amp; msg.channel) msg.channel.send(embed); } if (collab &amp;&amp; numTeams == 1) { const sendTime = Date.now() + (game.options.delayDays &gt; 2000 ? 1000 : 0); let winnerTag = ''; if (game.options.mentionVictor) { winnerTag = current.teams[lastTeam] .players.filter((player) =&gt; !player.startsWith('NPC')) .map((player) =&gt; `&lt;@${player}&gt;`).join(' '); } const avatarSizes = game.options.victorAvatarSizes; const victorIconSize = avatarSizes.avatar; if (victorIconSize === 0) { sendAtTime(msg.channel, winnerTag, finalMessage, sendTime); } else { const iconGap = avatarSizes.gap; const underlineSize = avatarSizes.underline; const finalImage = new Jimp( current.teams[lastTeam].players.length * (victorIconSize + iconGap) - iconGap, victorIconSize + underlineSize); let responses = 0; const newImage = function(image, userId) { try { if (victorIconSize &gt; 0) { if (image) image.resize(victorIconSize, victorIconSize); if (underlineSize &gt; 0) { const user = current.includedUsers.find((obj) =&gt; obj.id == userId); let color = 0x0; if (user &amp;&amp; !user.living) { color = 0xFF0000FF; } else if (user &amp;&amp; user.state == 'wounded') { color = 0xFFFF00FF; } else if (user) { color = 0x00FF00FF; } if (user &amp;&amp; user.settings &amp;&amp; typeof user.settings['hg:bar_color'] === 'number') { finalImage.blit( new Jimp( victorIconSize, underlineSize, user.settings['hg:bar_color']), responses * (victorIconSize + iconGap), 0); } finalImage.blit( new Jimp(victorIconSize, underlineSize, color), responses * (victorIconSize + iconGap), victorIconSize); } if (image) { finalImage.blit( image, responses * (victorIconSize + iconGap), underlineSize); } } } catch (err) { self.warn('Failed to blit victor image'); console.error(err); } responses++; if (responses == current.teams[lastTeam].players.length) { finalImage.getBuffer(Jimp.MIME_PNG, function(err, out) { finalMessage.attachFiles([new self.Discord.MessageAttachment( out, 'hgTeamVictor.png')]); sendAtTime(msg.channel, winnerTag, finalMessage, sendTime); }); } }; current.teams[lastTeam].players.forEach( (player) =&gt; { const p = current.includedUsers.find((obj) =&gt; obj.id == player); const icon = p.avatarURL; const userId = p.id; readImage(icon) .then(function(userId) { return function(image) { newImage(image, userId); }; }(userId)) .catch((err) =&gt; { self.error('Failed to read image'); console.log(err); responses++; }); }); } } else { self.client.setTimeout(() =&gt; { let winnerTag = ''; if (numAlive == 1) { if (hg.getGame(id).options.mentionVictor &amp;&amp; !lastId.startsWith('NPC')) { winnerTag = `&lt;@${lastId}&gt;`; } if (hg.getGame(id).options.disableOutput || !msg.channel) return; msg.channel.send(winnerTag, finalMessage).catch((err) =&gt; { self.error('Failed to send solo winner message: ' + msg.channel.id); console.error(err); }); } else { if (hg.getGame(id).options.disableOutput || !msg.channel) return; msg.channel.send(winnerTag, finalMessage).catch((err) =&gt; { self.error('Failed to send winner message: ' + msg.channel.id); console.error(err); }); } }, (game.options.delayDays &gt; 2000 ? 1000 : 0)); } if (current.ended) { const rankEmbed = new self.Discord.MessageEmbed(); rankEmbed.setTitle('Final Ranks (kills)'); const rankList = current.includedUsers.sort((a, b) =&gt; a.rank - b.rank).map((obj) =&gt; { let shortName; if (obj.nickname &amp;&amp; game.options.useNicknames) { shortName = obj.nickname.substring(0, 16); if (shortName != obj.nickname) { shortName = `${shortName.substring(0, 13)}...`; } } else { shortName = obj.name.substring(0, 16); if (shortName != obj.name) { shortName = `${shortName.substring(0, 13)}...`; } } return obj.rank + ') ' + shortName + (obj.kills &gt; 0 ? ' (' + obj.kills + ')' : ''); }); if (rankList.length &lt;= 20) { rankEmbed.setDescription(rankList.join('\\n')); } else { const thirdLength = Math.floor(rankList.length / 3); for (let i = 0; i &lt; 2; i++) { const thisMessage = rankList.splice(0, thirdLength).join('\\n').slice(0, 1024); rankEmbed.addField(i + 1, thisMessage, true); } rankEmbed.addField(3, rankList.join('\\n').slice(0, 1024), true); } rankEmbed.setColor(defaultColor); if (!game.options.disableOutput &amp;&amp; msg.channel) { self.client.setTimeout(function() { msg.channel.send(rankEmbed).catch((err) =&gt; { self.error(`Failed to send ranks message: ${msg.channel.id}`); console.error(err); }); }, 5000); } if (game.options.teamSize &gt; 0) { const teamRankEmbed = new self.Discord.MessageEmbed(); teamRankEmbed.setTitle('Final Team Ranks'); sortTeams(game); let prevTeam = -1; const statusList = current.includedUsers.map((obj) =&gt; { let myTeam = -1; myTeam = current.teams.findIndex((team) =&gt; { return team.players.findIndex((player) =&gt; { return player == obj.id; }) &gt; -1; }); let shortName; if (obj.nickname &amp;&amp; game.options.useNicknames) { shortName = obj.nickname.substring(0, 16); if (shortName != obj.nickname) { shortName = shortName.substring(0, 13) + '...'; } } else { shortName = obj.name.substring(0, 16); if (shortName != obj.name) { shortName = shortName.substring(0, 13) + '...'; } } let prefix = ''; if (myTeam != prevTeam) { prevTeam = myTeam; prefix = current.teams[myTeam].rank + ') __' + current.teams[myTeam].name + '__\\n'; } return `${prefix}\\`${shortName}\\``; }); if (statusList.length &gt;= 5) { const numCols = calcColNum(statusList.length &gt; 10 ? 3 : 2, statusList); const quarterLength = Math.ceil(statusList.length / numCols); for (let i = 0; i &lt; numCols - 1; i++) { const thisMessage = statusList.splice(0, quarterLength).join('\\n'); teamRankEmbed.addField(i + 1, thisMessage, true); } teamRankEmbed.addField(numCols, statusList.join('\\n'), true); } else { teamRankEmbed.setDescription(statusList.join('\\n')); } teamRankEmbed.setColor(defaultColor); if (!game.options.disableOutput) { self.client.setTimeout(() =&gt; { msg.channel.send(teamRankEmbed).catch((err) =&gt; { self.error('Failed to send final team ranks: ' + msg.channel.id); console.error(err); }); }, 8000); } } } } /** * End a game early. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {boolean} [silent=false] Prevent sending messages. */ function endGame(msg, id, silent = false) { const game = hg.getGame(id); if (!game || !game.currentGame.inProgress) { if (!silent &amp;&amp; msg) { self.common.reply(msg, 'There isn\\'t a game in progress.'); } } else { game.end(); if (!silent &amp;&amp; msg) self.common.reply(msg, 'The game has ended!'); } } // User Management // /** * Remove a user from users to be in next game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] Game object to exclude user from. */ function excludeUser(msg, id, game) { if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } excludeUser(msg, id, game); }); return; } let firstWord = msg.text.trim().split(' ')[0]; if (firstWord) firstWord = firstWord.toLowerCase(); const specialWords = { everyone: ['everyone', '@everyone', 'all'], online: ['online', 'here'], offline: ['offline'], idle: ['idle', 'away', 'snooze', 'snoozed'], dnd: ['dnd', 'busy'], bots: ['bot', 'bots'], npcs: ['npc', 'npcs', 'ai', 'ais'], }; let resPrefix = ''; let resPostfix = ' have been removed from the games.'; const done = function(response) { self.common.reply(msg, resPrefix + resPostfix, response.substr(0, 2048)); }; if (game.currentGame.inProgress) { resPostfix = ' will be removed from the next game.'; } if (specialWords.everyone.includes(firstWord)) { resPrefix = 'All users'; self.excludeUsers('everyone', id, done); } else if (specialWords.online.includes(firstWord)) { resPrefix = 'All online users'; self.excludeUsers('online', id, done); } else if (specialWords.offline.includes(firstWord)) { resPrefix = 'All offline users'; self.excludeUsers('offline', id, done); } else if (specialWords.idle.includes(firstWord)) { resPrefix = 'All idle users'; self.excludeUsers('idle', id, done); } else if (specialWords.dnd.includes(firstWord)) { resPrefix = 'All DND users'; self.excludeUsers('dnd', id, done); } else if (specialWords.npcs.includes(firstWord)) { resPrefix = 'All NPCs'; self.excludeUsers(game.includedNPCs.slice(0), id, done); } else if (specialWords.bots.includes(firstWord)) { resPrefix = 'Bots'; resPostfix = ' are now blocked from the games.'; done(self.setOption(id, 'includeBots', false)); } else if ( msg.mentions.users.size + msg.softMentions.users.size + msg.mentions.roles.size + msg.softMentions.roles.size == 0) { self.common.reply( msg, 'You must specify who you wish for me to exclude from the next ' + 'game.'); } else { const mentionedRoleUsers = new self.Discord.UserStore( self.client, ...msg.mentions.roles.map((r) =&gt; r.members.map((m) =&gt; m.user))); const softRoleUsers = new self.Discord.UserStore( self.client, ...msg.softMentions.roles.map((r) =&gt; r.members.map((m) =&gt; m.user))); const mentions = msg.mentions.users.concat(msg.softMentions.users) .concat(mentionedRoleUsers.concat(softRoleUsers)); self.excludeUsers(mentions, id, (res) =&gt; { self.common.reply(msg, res); }); } } /** * Removes users from a games of a given guild. * * @public * @param {string|string[]|Discord~User[]|HungryGames~NPC[]} users The users * to exclude, or * 'everyone' to exclude everyone. * @param {string} id The guild id to remove the users from. * @param {Function} cb Callback for when long running operations complete. * Single argument with a string with the outcomes of each user. May have * multiple lines for a single user. */ this.excludeUsers = function(users, id, cb) { const game = hg.getGame(id); if (!game) { cb('No game'); return; } if (game.loading) { cb('A previous command is still loading.\\n' + 'Please wait for it to complete.'); return; } if (!game.excludedNPCs) game.excludedNPCs = []; if (!game.includedNPCs) game.includedNPCs = []; const iTime = Date.now(); const tmp = []; let npcs = []; switch (users) { case 'everyone': users = game.includedUsers; npcs = game.includedNPCs; break; case 'online': case 'offline': case 'idle': case 'dnd': game.includedUsers.forEach((u) =&gt; { const user = self.client.users.get(u); if (user &amp;&amp; user.presence.status === users) tmp.push(user); }); users = tmp; break; default: if (typeof users === 'string') { cb('Invalid users'); return; } break; } if (!Array.isArray(users)) { users = users.array(); } const num = users.length + npcs.length; const numUsers = users.length; if (num &gt; 10000) { self.warn(`Excluding ${num} users.`); } const iTime2 = Date.now(); const onlyError = num &gt; 2; const response = []; const chunk = function(i = -1) { if (i &lt; 0) i = num - 1; // Touch the game so it doesn't get purged from memory. const game = hg.getGame(id); game.loading = true; const start = Date.now(); for (i; i &gt;= 0 &amp;&amp; Date.now() - start &lt; hg.maxDelta; i--) { if (i &lt; numUsers) { response.push(excludeIterate(game, users[i], onlyError)); } else { response.push(excludeIterate(game, npcs[i - numUsers], onlyError)); } } if (i &gt;= 0) { setTimeout(() =&gt; { chunk(i); }); } else { done(); } }; const done = function() { game.loading = false; const now = Date.now(); const begin = iTime2 - iTime; const loop = now - iTime2; if (begin &gt; 10 || loop &gt; 10) { self.debug(`Excluding ${num} ${begin} ${loop}`); } const finalRes = response.length &gt; 0 ? response.join('') : `Succeeded without errors (${num} excluded)`; cb(finalRes); }; setTimeout(chunk); }; /** * @description Exclude a single user from the game as a single iteration step * of the exclude command. * @private * @param {HungryGames~GuildGame} game The game to manipulate. * @param {string|HungryGames~Player|HungryGames~NPC} obj Player for this * iteration. * @param {boolean} [onlyError=false] Only add error messages to response. * @returns {string} Response text for the user performing the operation. */ function excludeIterate(game, obj, onlyError = false) { if (!obj || obj === 'undefined') return ''; const response = []; if (typeof obj === 'string') { if (obj.startsWith('NPC')) { obj = game.includedNPCs.find((el) =&gt; el.id == obj); if (!obj &amp;&amp; game.excludedNPCs.find((el) =&gt; el.id == obj)) { response.push(`${obj.name} is already excluded.`); return `${response.join('\\n')}\\n`; } } else { obj = self.client.users.get(obj); } if (!obj) { response.push(`${obj} is not a valid id.`); return `${response.join('\\n')}\\n`; } } else if (obj.id.startsWith('NPC') &amp;&amp; !(obj instanceof NPC)) { const objId = obj.id; obj = game.includedNPCs.find((el) =&gt; el.id == obj.id); if (!obj) { response.push(`${objId} unable to be found (already excluded?).`); self.error(`Unable to find NPC matching NPC-like data: ${game.id}`); return `${response.join('\\n')}\\n`; } } if (game.excludedUsers.includes(obj.id)) { if (!onlyError) { response.push(`${obj.username} is already excluded.`); } } else { if (obj.isNPC) { game.excludedNPCs.push(obj); if (!onlyError) { response.push(`${obj.username} added to blacklist.*`); } const includeIndex = game.includedNPCs.findIndex((el) =&gt; el.id == obj.id); if (includeIndex &gt;= 0) { /* if (!onlyError) { response += obj.username + ' removed from whitelist.\\n'; } */ game.includedNPCs.splice(includeIndex, 1); } } else { game.excludedUsers.push(obj.id); if (!onlyError) { response.push(`${obj.username} added to blacklist.`); } if (!game.includedUsers) game.includedUsers = []; const includeIndex = game.includedUsers.indexOf(obj.id); if (includeIndex &gt;= 0) { /* if (!onlyError) { response += obj.username + ' removed from whitelist.\\n'; } */ game.includedUsers.splice(includeIndex, 1); } } if (!game.currentGame.inProgress) { const index = game.currentGame.includedUsers.findIndex((el) =&gt; el.id == obj.id); if (index &gt;= 0) { game.currentGame.includedUsers.splice(index, 1); /* if (!onlyError) { response += obj.username + ' removed from included players.\\n'; } */ game.formTeams(game.id); } else if (!game.options.includeBots &amp;&amp; obj.bot) { // Bots are already excluded. } else { response.push( `Failed to remove ${obj.username} for an unknown reason.`); self.error(`Failed to remove player from included list. (${obj.id})`); } } } return `${response.join('\\n')}\\n`; } /** * Add a user back into the next game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function includeUser(msg, id, game) { if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } includeUser(msg, id, game); }); return; } let firstWord = msg.text.trim().split(' ')[0]; if (firstWord) firstWord = firstWord.toLowerCase(); const specialWords = { everyone: ['everyone', '@everyone', 'all'], online: ['online', 'here'], offline: ['offline'], idle: ['idle', 'away', 'snooze', 'snoozed'], dnd: ['dnd', 'busy'], bots: ['bot', 'bots'], npcs: ['npc', 'npcs', 'ai', 'ais'], }; let resPrefix = ''; let resPostfix = ' have been added to the games.'; const done = function(response) { self.common.reply(msg, resPrefix + resPostfix, response.substr(0, 2048)); }; if (game.currentGame.inProgress) { resPostfix = ' will be added into the next game.'; } if (specialWords.everyone.includes(firstWord)) { resPrefix = 'All users'; self.includeUsers('everyone', id, done); } else if (specialWords.online.includes(firstWord)) { resPrefix = 'All online users'; self.includeUsers('online', id, done); } else if (specialWords.offline.includes(firstWord)) { resPrefix = 'All offline users'; self.includeUsers('offline', id, done); } else if (specialWords.idle.includes(firstWord)) { resPrefix = 'All idle users'; self.includeUsers('idle', id, done); } else if (specialWords.dnd.includes(firstWord)) { resPrefix = 'All DND users'; self.includeUsers('dnd', id, done); } else if (specialWords.npcs.includes(firstWord)) { resPrefix = 'All NCPs'; self.includeUsers(game.excludedNPCs.slice(0), id, done); } else if (specialWords.bots.includes(firstWord)) { resPrefix = 'Bots'; resPostfix = ' can now be added to the games.'; done(self.setOption(id, 'includeBots', true)); } else if ( msg.mentions.users.size + msg.softMentions.users.size + msg.mentions.roles.size + msg.softMentions.roles.size == 0) { self.common.reply( msg, 'You must specify who you wish for me to include in the next game.'); return; } else { const mentionedRoleUsers = new self.Discord.UserStore( self.client, ...msg.mentions.roles.map((r) =&gt; r.members.map((m) =&gt; m.user))); const softRoleUsers = new self.Discord.UserStore( self.client, ...msg.softMentions.roles.map((r) =&gt; r.members.map((m) =&gt; m.user))); const mentions = msg.mentions.users.concat(msg.softMentions.users) .concat(mentionedRoleUsers.concat(softRoleUsers)); self.includeUsers(mentions, id, (response) =&gt; { self.common.reply(msg, response); }); return; } } /** * Adds a user back into the next game. * * @public * @param {string|string[]|Discord~User[]|HungryGames~NPC[]} users The users * to include, 'everyone' to include all users, 'online' to include online * users, 'offline', 'idle', or 'dnd' for respective users. * @param {string} id The guild id to add the users to. * @param {Function} cb Callback for when long running operations complete. * Single argument with a string with the outcomes of each user. May have * multiple lines for a single user. */ this.includeUsers = function(users, id, cb) { const game = hg.getGame(id); if (!game) { cb('No game'); return; } if (game.loading) { cb('A previous command is still loading.\\n' + 'Please wait for it to complete.'); return; } if (!game.excludedNPCs) game.excludedNPCs = []; if (!game.includedNPCs) game.includedNPCs = []; const iTime = Date.now(); const tmp = []; let npcs = []; switch (users) { case 'everyone': users = game.excludedUsers; npcs = game.excludedNPCs; break; case 'online': case 'offline': case 'idle': case 'dnd': game.excludedUsers.forEach((u) =&gt; { const user = self.client.users.get(u); if (user &amp;&amp; user.presence.status === users) tmp.push(user); }); users = tmp; break; default: if (typeof users === 'string') { cb('Invalid users'); return; } break; } if (!Array.isArray(users)) { users = users.array(); } const num = users.length + npcs.length; const numUsers = users.length; if (num &gt; 10000) { self.warn(`Including ${num} users.`); } const iTime2 = Date.now(); const onlyError = num &gt; 2; const response = []; const chunk = function(i = -1) { if (i &lt; 0) i = num - 1; // Touch the game so it doesn't get purged from memory. const game = hg.getGame(id); game.loading = true; const start = Date.now(); for (i; i &gt;= 0 &amp;&amp; Date.now() - start &lt; hg.maxDelta; i--) { if (i &lt; numUsers) { response.push(includeIterate(game, users[i], onlyError)); } else { response.push(includeIterate(game, npcs[i - numUsers], onlyError)); } } if (i &gt;= 0) { setTimeout(() =&gt; { chunk(i); }); } else { done(); } }; const done = function() { game.loading = false; const now = Date.now(); const begin = iTime2 - iTime; const loop = now - iTime2; if (begin &gt; 10 || loop &gt; 10) { self.debug(`Including ${num} ${begin} ${loop}`); } const finalRes = response.length &gt; 0 ? response.join('') : `Succeeded without errors (${num} included)`; cb(finalRes); }; setTimeout(chunk); }; /** * @description Include a single user from the game as a single iteration step * of the include command. * @private * @param {HungryGames~GuildGame} game The game to manipulate. * @param {string|HungryGames~Player|HungryGames~NPC} obj Player for this * iteration. * @param {boolean} [onlyError=false] Only add error messages to response. * @returns {string} Response text for the user performing the operation. */ function includeIterate(game, obj, onlyError = false) { if (!obj || obj === 'undefined') return ''; const response = []; if (typeof obj === 'string') { if (obj.startsWith('NPC')) { obj = game.excludedNPCs.find((el) =&gt; el.id == obj); if (!obj &amp;&amp; game.includedNPCs.find((el) =&gt; el.id == obj)) { response.push(`${obj.username} is already included.`); return `${response.join('\\n')}\\n`; } } else { obj = self.client.users.get(obj); } if (!obj) { response.push(`${obj} is not a valid id.`); return `${response.join('\\n')}\\n`; } } else if (obj.id.startsWith('NPC') &amp;&amp; !(obj instanceof NPC)) { const objId = obj.id; obj = game.excludedNPCs.find((el) =&gt; el.id == obj.id); if (!obj) { response.push(`${objId} unable to be found (already included?).`); self.error(`Unable to find NPC matching NPC-like data: ${game.id}`); return `${response.join('\\n')}\\n`; } } if (!game.options.includeBots &amp;&amp; obj.bot) { response.push(`${obj.username} is a bot, but bots are disabled.`); return `${response.join('\\n')}\\n`; } if (obj.isNPC) { const excludeIndex = game.excludedNPCs.findIndex((el) =&gt; el.id == obj.id); if (excludeIndex &gt;= 0) { /* if (!onlyError) { response += obj.username + ' removed from blacklist.\\n'; } */ game.excludedNPCs.splice(excludeIndex, 1); } if (!game.includedNPCs.find((el) =&gt; el.id == obj.id)) { game.includedNPCs.push(obj); if (!onlyError) { response.push(`${obj.username} added to whitelist.*`); } } } else { const excludeIndex = game.excludedUsers.indexOf(obj.id); if (excludeIndex &gt;= 0) { /* if (!onlyError) { response += obj.username + ' removed from blacklist.\\n'; } */ game.excludedUsers.splice(excludeIndex, 1); } if (!game.includedUsers.includes(obj.id)) { game.includedUsers.push(obj.id); if (!onlyError) { response.push(`${obj.username} added to whitelist.`); } } } if (game.currentGame.inProgress) { if (!onlyError) { response.push(`${obj.username} skipped.`); } } else if (!game.currentGame.includedUsers.find((u) =&gt; u.id === obj.id)) { if (obj.isNPC) { game.currentGame.includedUsers.push( new NPC(obj.name, obj.avatarURL, obj.id)); } else { game.currentGame.includedUsers.push( new HungryGames.Player( obj.id, obj.username, obj.avatarURL || obj.displayAvatarURL({format: 'png'}), obj.nickname)); } /* if (!onlyError) { response += obj.username + ' added to included players.\\n'; } */ game.formTeams(); } else { if (!onlyError) { response.push(`${obj.username} is already included.`); } } return `${response.join('\\n')}\\n`; } /** * Show a formatted message of all users and teams in current server. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function listPlayers(msg, id) { const game = hg.getGame(id); if (!game) { self.common.reply(msg, 'A game has not been created yet.'); return; } const finalMessage = makePlayerListEmbed(game); finalMessage.setDescription( `To refresh: ${msg.prefix}${self.postPrefix}create`); msg.channel.send(self.common.mention(msg), finalMessage).catch((err) =&gt; { self.common.reply( msg, 'Oops, Discord rejected my message for some reason...'); self.error('Failed to send list of players message: ' + msg.channel.id); console.error(err); }); } /** * @description Create a {@link external:Discord~MessageEmbed} that lists all * included and excluded players in the game. * @private * @param {HungryGames~GuildGame} game The game to format. * @param {external:Discord~MessageEmbed} [finalMessage] Optional existing * embed to modify instead of creating a new one. * @returns {external:Discord~MessageEmbed} The created message embed. */ function makePlayerListEmbed(game, finalMessage) { if (!finalMessage) { finalMessage = new self.Discord.MessageEmbed(); finalMessage.setTitle('List of players'); finalMessage.setColor(defaultColor); } if (!game || !game.currentGame || !game.currentGame.includedUsers) { finalMessage.addField( 'No Players', 'No game created or no players in the game.'); return finalMessage; } const numUsers = game.currentGame.includedUsers.length; if (numUsers &gt; 200) { finalMessage.addField( `Included (${numUsers})`, `Excluded (${game.excludedUsers.length})`, true); return finalMessage; } if (game.options.teamSize &gt; 0) sortTeams(game); let prevTeam = -1; const statusList = game.currentGame.includedUsers.map((obj) =&gt; { let myTeam = -1; if (game.options.teamSize &gt; 0) { myTeam = game.currentGame.teams.findIndex( (team) =&gt; team.players.find((player) =&gt; player == obj.id)); } let shortName; if (obj.nickname &amp;&amp; game.options.useNicknames) { shortName = obj.nickname.substring(0, 16); if (shortName != obj.nickname) { shortName = `${shortName.substring(0, 13)}...`; } } else { shortName = obj.name.substring(0, 16); if (shortName != obj.name) { shortName = `${shortName.substring(0, 13)}...`; } } let prefix = ''; if (myTeam != prevTeam) { prevTeam = myTeam; prefix = `__${game.currentGame.teams[myTeam].name}__\\n`; } return `${prefix}\\`${shortName}\\``; }); if (game.options.teamSize == 0) { statusList.sort((a, b) =&gt; { a = a.toLocaleLowerCase(); b = b.toLocaleLowerCase(); if (a &lt; b) return -1; if (a &gt; b) return 1; return 0; }); } const numCols = calcColNum(statusList.length &gt; 10 ? 3 : 2, statusList); if (statusList.length &gt;= 5) { const quarterLength = Math.ceil(statusList.length / numCols); for (let i = 0; i &lt; numCols - 1; i++) { const thisMessage = statusList.splice(0, quarterLength).join('\\n').substring(0, 1024); finalMessage.addField( 'Included (' + (i * quarterLength + 1) + '-' + ((i + 1) * quarterLength) + ')', thisMessage, true); } finalMessage.addField( `Included (${(numCols - 1) * quarterLength + 1}-${numUsers})`, statusList.join('\\n'), true); } else { finalMessage.addField( `Included (${numUsers})`, statusList.join('\\n') || 'Nobody', false); } if (game.excludedUsers.length &gt; 0) { let excludedList = '\\u200B'; if (game.excludedUsers.length &lt; 20) { const guild = self.client.guilds.get(game.id); excludedList = game.excludedUsers.map((obj) =&gt; getName(guild, obj)).join(', '); const trimmedList = excludedList.substr(0, 512); if (excludedList != trimmedList) { excludedList = `${trimmedList.substr(0, 509)}...`; } else { excludedList = trimmedList; } } finalMessage.addField( `Excluded (${game.excludedUsers.length})`, excludedList, false); } return finalMessage; } /** * Get the username of a user id if available, or their id if they couldn't be * found. * * @private * @param {Discord~Guild} guild The guild to look for the user in. * @param {string} user The id of the user to find the name of. * @returns {string} The user's name or id if name was unable to be found. */ function getName(guild, user) { let name = ''; if (typeof user === 'object' &amp;&amp; user.username) { name = user.username; } else if (guild.members.get(user)) { name = guild.members.get(user).user.username; } else { name = user; } return name; } /** * Change an option to a value that the user specifies. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function toggleOpt(msg, id) { msg.text = msg.text.trim(); const option = msg.text.split(' ')[0]; const value = msg.text.split(' ')[1]; const output = self.setOption(id, option, value, msg.text); if (!output) { showOpts(msg, hg.getGame(id).options); } else { self.common.reply(msg, output); } } /** * Change an option to a value for the given guild. * * @public * @param {string} id The guild id to change the option in. * @param {?string} option The option key to change. * @param {?string|boolean|number} value The value to change the option to. * @param {string} [text=''] The original message sent without the command * prefix in the case we are changing the value of an object and require all * user inputted data. * @returns {string} A message saying what happened, or null if we should show * the user the list of options instead. */ this.setOption = function(id, option, value, text = '') { if (!hg.getGame(id) || !hg.getGame(id).currentGame) { return 'A game has not been created yet.'; } if (typeof option === 'undefined' || option.length == 0) { return null; } else if ( option[0] === '_' || typeof defaultOptions[option] === 'undefined') { const searchedOption = defaultOptSearcher.search(option); if (typeof defaultOptions[searchedOption] === 'undefined') { return 'That is not a valid option to change! (' + option + ')\\nUse `' + self.bot.getPrefix(id) + self.postPrefix + 'options` to see all changeable options.'; } option = searchedOption; } return changeObjectValue( hg.getGame(id).options, defaultOptions, option, value, text.split(' '), id); }; /** * Recurse through an object to change a certain child value based off a given * array of words. * * @private * @param {HungryGames~GuildGame.options} obj The object with the values to * change. * @param {HungryGames~defaultOptions} defaultObj The default template object * to base changes off of. * @param {string} option The first value to check. * @param {number|boolean|string} value The value to change to, or the next * option key to check if we have not found an end to a branch yet. * @param {Array.&lt;string|boolean|number&gt;} values All keys leading to the final * value, as well as the final value. * @param {string} id The id of the guild this was triggered for. * @param {{min: number, max: number}} [range] Allowable range for values that * are numbers. * @returns {string} Message saying what happened. Can be an error message. */ function changeObjectValue( obj, defaultObj, option, value, values, id, range) { let type = typeof defaultObj[option]; if (type !== 'undefined' &amp;&amp; typeof defaultObj[option].value !== 'undefined') { type = typeof defaultObj[option].value; range = range || defaultObj[option].range; } if (hg.getGame(id).currentGame &amp;&amp; hg.getGame(id).currentGame.inProgress) { if (option == 'teamSize' || option == 'includeBots') { return 'Teams and included players cannot be modified during a game.' + '\\nYou must end the current game first to do this.'; } } if (type === 'number') { value = Number(value); if (typeof value !== 'number' || isNaN(value)) { return 'That is not a valid value for ' + option + ', which requires a number. (Currently ' + obj[option] + ')'; } else { if (range) { if (value &lt; range.min) value = range.min; if (value &gt; range.max) value = range.max; } /* if ((option == 'delayDays' || option == 'delayEvents') &amp;&amp; value &lt; 500) { value = 1000; } */ const old = obj[option]; obj[option] = value; if (option == 'teamSize' &amp;&amp; value != 0) { return 'Set ' + option + ' to ' + obj[option] + ' from ' + old + '\\nTo reset teams to the correct size, type \"' + self.bot.getPrefix() + self.postPrefix + 'teams reset\".\\nThis will delete all teams, and create ' + 'new ones.'; } else { return 'Set ' + option + ' to ' + obj[option] + ' from ' + old; } } } else if (type === 'boolean') { if (typeof value === 'string') value = value.toLowerCase(); if (value === 'true' || value === 'false') value = value === 'true'; if (typeof value !== 'boolean') { return 'That is not a valid value for ' + option + ', which requires true or false. (Currently ' + obj[option] + ')'; } else { const old = obj[option]; obj[option] = value; if (option == 'includeBots') { createGame(null, id, true); } return `Set ${option} to ${obj[option]} from ${old}`; } } else if (type === 'string') { value = (value || '').toLowerCase(); if (defaultObj[option].values.lastIndexOf(value) &lt; 0) { return 'That is not a valid value for ' + option + ', which requires one of the following: ' + JSON.stringify(defaultObj[option].values) + '. (Currently ' + obj[option] + ')'; } else { const old = obj[option]; obj[option] = value; return 'Set ' + option + ' to ' + obj[option] + ' from ' + old; } } else if (type === 'object') { if (typeof defaultObj[option].value[value] === 'undefined') { return '`' + value + '` is not a valid option to change!' + JSON.stringify(obj[option], null, 1); } else { return changeObjectValue( obj[option], defaultObj[option].value || defaultObj[option], values[1], values[2], values.slice(3), id, range); } } else { return 'Changing the value of this option does not work yet. (' + option + ': ' + type + ')\\n' + JSON.stringify(defaultObj) + '(' + value + ')' + JSON.stringify(values); } } /** * Format the options for the games and show them to the user. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {object} options The options to format. */ function showOpts(msg, options) { const entries = Object.entries(options); const bodyList = entries.map(function(obj) { const key = obj[0]; const val = obj[1]; return key + ': ' + JSON.stringify(val) + ' (default: ' + JSON.stringify(defaultOptions[key].value) + ')\\n' + '/* ' + defaultOptions[key].comment + ' */'; }); let totalLength = 0; const bodyFields = [[]]; let fieldIndex = 0; for (let i = 0; i &lt; bodyList.length; i++) { if (bodyList[i].length + totalLength &gt; 1500) { fieldIndex++; totalLength = 0; bodyFields.push([]); } totalLength += bodyList[i].length; bodyFields[fieldIndex].push(bodyList[i]); } let page = 0; if (msg.optId) page = msg.optId; if (page &lt; 0) page = 0; if (page &gt;= bodyFields.length) page = bodyFields.length - 1; const embed = new self.Discord.MessageEmbed(); embed.setTitle('Current Options'); embed.setFooter('Page ' + (page + 1) + ' of ' + (bodyFields.length)); embed.setDescription('```js\\n' + bodyFields[page].join('\\n\\n') + '```'); embed.addField( 'Simple Example', msg.prefix + self.postPrefix + 'options includeBots true', true); embed.addField( 'Change Object Example', msg.prefix + self.postPrefix + 'options playerOutcomeProbs kill 23', true); if (optionMessages[msg.id]) { msg.edit(embed).then(() =&gt; { optChangeListener(msg, options, page); }); } else { msg.channel.send(embed).then((msg_) =&gt; { msg_.origAuth = msg.author.id; msg_.prefix = self.bot.getPrefix(msg.guild); optChangeListener(msg_, options, page); }); } } /** * The callback for when the user chooses to change page of the options. * * @private * @param {Discord~Message} msg_ The message we sent showing the options. * @param {object} options The options to show in the message. * @param {number} index The page index to show. */ function optChangeListener(msg_, options, index) { msg_.optId = index; optionMessages[msg_.id] = msg_; msg_.react(emoji.arrowLeft).then(() =&gt; { msg_.react(emoji.arrowRight); }); newReact(maxReactAwaitTime); msg_.awaitReactions(function(reaction, user) { if (user.id != self.client.user.id) { reaction.users.remove(user).catch(() =&gt; {}); } return (reaction.emoji.name == emoji.arrowRight || reaction.emoji.name == emoji.arrowLeft) /* &amp;&amp; user.id == msg_.origAuth*/ &amp;&amp; user.id != self.client.user.id; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg_.reactions.removeAll().catch(() =&gt; {}); delete optionMessages[msg_.id]; return; } const name = reactions.first().emoji.name; if (name == emoji.arrowRight) { msg_.optId++; } else if (name == emoji.arrowLeft) { msg_.optId--; } showOpts(msg_, options); }); } // Team Management // /** * Entry for all team commands. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {boolean} [silent=false] Should we disable replying to the given * message? * @returns {?string} Error message or null if no error. */ function editTeam(msg, id, silent) { const split = msg.text.trim().split(' '); if (!hg.getGame(id) || !hg.getGame(id).currentGame) { const message = 'There isn\\'t currently any game to edit.' + ' Please create one first.'; if (!silent) { msg.channel.send(self.common.mention(msg) + ' `' + message + '`'); } return message; } if (hg.getGame(id).currentGame.inProgress) { switch (split[0]) { case 'rename': break; default: { const message = 'You must end the current game before editing teams.'; if (!silent) { msg.channel.send(self.common.mention(msg) + ' `' + message + '`'); } return message; } } } if (hg.getGame(id).options.teamSize == 0) { const message = 'There are no teams to edit. If you wish to have teams, you can ' + 'set teamSize to the size of teams you wish to have.'; if (!silent) { self.common.reply( msg, message, msg.prefix + self.postPrefix + 'opt teamSize 2'); } return message; } switch (split[0]) { case 'swap': swapTeamUsers(msg, id); break; case 'move': moveTeamUser(msg, id); break; case 'rename': renameTeam(msg, id, silent); break; case 'reset': if (!silent) self.common.reply(msg, 'Resetting ALL teams!'); hg.getGame(id).currentGame.teams = []; hg.getGame(id).formTeams(id); break; case 'randomize': case 'shuffle': randomizeTeams(msg, id, silent); break; default: listPlayers(msg, id); break; } } /** * @description Allows editing teams. Entry for all team actions. * * @public * @param {string} uId The id of the user is running the action. * @param {string} gId The id of the guild to run this in. * @param {string} cmd The command to run on the teams. * @param {string} one The id of the user to swap, or the new name of the team * if we're renaming a team. * @param {string} two The id of the user to swap, or the team id if we're * moving a player to a team. * @returns {?string} Error message or null if no error. */ this.editTeam = function(uId, gId, cmd, one, two) { if (!hg.getGame(gId) || !hg.getGame(gId).currentGame) { return 'No game has been created yet.'; } if (hg.getGame(gId).currentGame.inProgress) { switch (cmd) { case 'swap': case 'move': return; } } switch (cmd) { case 'swap': { let p1 = -1; const team1 = hg.getGame(gId).currentGame.teams.find((t) =&gt; { return t.players.find((p, i) =&gt; { if (p == one) { p1 = i; return true; } return false; }); }); let p2 = -1; const team2 = hg.getGame(gId).currentGame.teams.find((t) =&gt; { return t.players.find((p, i) =&gt; { if (p == two) { p2 = i; return true; } return false; }); }); if (!team1 || !team2) break; const tmp = team1.players.splice(p1, 1)[0]; team1.players.push(team2.players.splice(p2, 1)[0]); team2.players.push(tmp); break; } case 'move': { let pId = -1; let tId = -1; const teamS = hg.getGame(gId).currentGame.teams.find((t, i) =&gt; { if (t.players.find((p, j) =&gt; { if (p == one) { pId = j; return true; } return false; })) { tId = i; return true; } return false; }); let teamD = hg.getGame(gId).currentGame.teams.find((t) =&gt; { return t.id == two; }); if (!teamS) break; if (!teamD) { const current = hg.getGame(gId).currentGame; teamD = current.teams[current.teams.push( new HungryGames.Team( current.teams.length, 'Team ' + (current.teams.length + 1), [])) - 1]; } teamD.players.push(teamS.players.splice(pId, 1)[0]); if (teamS.players.length === 0) { hg.getGame(gId).currentGame.teams.splice(tId, 1); } break; } default: return editTeam( makeMessage( uId, gId, null, cmd + ' ' + (one || '') + ' ' + (two || '')), gId, true); } }; /** * Swap two users from one team to the other. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function swapTeamUsers(msg, id, game) { const mentions = msg.mentions.users.concat(msg.softMentions.users); if (mentions.size != 2) { self.common.reply( msg, 'Swapping requires mentioning 2 users to swap teams with ' + 'eachother.'); return; } if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } swapTeamUsers(msg, id, game); }); return; } const user1 = mentions.first().id; const user2 = mentions.first(2)[1].id; let teamId1 = 0; let playerId1 = 0; let teamId2 = 0; let playerId2 = 0; teamId1 = game.currentGame.teams.findIndex(function(team) { const index = team.players.findIndex(function(player) { return player == user1; }); if (index &gt; -1) playerId1 = index; return index &gt; -1; }); teamId2 = game.currentGame.teams.findIndex(function(team) { const index = team.players.findIndex(function(player) { return player == user2; }); if (index &gt; -1) playerId2 = index; return index &gt; -1; }); if (teamId1 &lt; 0 || teamId2 &lt; 0) { self.common.reply(msg, 'Please ensure both users are on a team.'); return; } const intVal = game.currentGame.teams[teamId1].players[playerId1]; game.currentGame.teams[teamId1].players[playerId1] = game.currentGame.teams[teamId2].players[playerId2]; game.currentGame.teams[teamId2].players[playerId2] = intVal; self.common.reply(msg, 'Swapped players!'); } /** * Move a single user to another team. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function moveTeamUser(msg, id, game) { const mentions = msg.mentions.users.concat(msg.softMentions.users); if (mentions.size &lt; 1) { self.common.reply(msg, 'You must at least mention one user to move.'); return; } if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } moveTeamUser(msg, id, game); }); return; } let user1 = mentions.first().id; let teamId1 = 0; let playerId1 = 0; let user2 = 0; if (mentions.size &gt;= 2) { user2 = mentions.first(2)[1].id; if (msg.text.indexOf(user2) &lt; msg.text.indexOf(user1)) { const intVal = user1; user1 = user2; user2 = intVal; } } let teamId2 = 0; teamId1 = game.currentGame.teams.findIndex((team) =&gt; { const index = team.players.findIndex((player) =&gt; { return player == user1; }); if (index &gt; -1) playerId1 = index; return index &gt; -1; }); if (user2 &gt; 0) { teamId2 = game.currentGame.teams.findIndex((team) =&gt; { return team.players.findIndex((player) =&gt; { return player == user2; }) &gt; -1; }); } else { teamId2 = msg.text.trim().split(' ')[1] - 1; teamId2 = game.currentGame.teams.findIndex((team) =&gt; team.id == teamId2); } if (teamId1 &lt; 0 || teamId2 &lt; 0 || isNaN(teamId2)) { let extra = null; if (user2 &gt; 0 &amp;&amp; teamId2 &lt; 0) { extra = 'Is ' + self.client.users.get(user2).username + ' on a team?'; } else if (user1 &gt; 0 &amp;&amp; teamId1 &lt; 0) { extra = 'Is ' + self.client.users.get(user1).username + ' on a team?'; } self.common.reply( msg, 'Please ensure the first option is the user, and the second ' + 'is the destination (either a mention or a team id).', extra); return; } if (teamId2 &gt;= game.currentGame.teams.length) { game.currentGame.teams.push( new HungryGames.Team( game.currentGame.teams.length, 'Team ' + (game.currentGame.teams.length + 1), [])); teamId2 = game.currentGame.teams.length - 1; } self.common.reply( msg, 'Moving `' + self.client.users.get(user1).username + '` from ' + game.currentGame.teams[teamId1].name + ' to ' + game.currentGame.teams[teamId2].name); game.currentGame.teams[teamId2].players.push( game.currentGame.teams[teamId1].players.splice(playerId1, 1)[0]); if (game.currentGame.teams[teamId1].players.length == 0) { game.currentGame.teams.splice(teamId1, 1); } } /** * Rename a team. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {boolean} [silent=false] Disable replying to message. */ function renameTeam(msg, id, silent) { const split = msg.text.trim().split(' ').slice(1); let message = split.slice(1).join(' '); const search = Number(split[0]); const mentions = msg.mentions.users.concat(msg.softMentions.users); if (isNaN(search) &amp;&amp; (mentions.size == 0)) { if (!silent) { self.common.reply( msg, 'Please specify a team id, or mention someone on a team, in ' + 'order to rename their team.'); } return; } let teamId = search - 1; if (!hg.getGame(id) || !hg.getGame(id).currentGame) { if (!silent) { self.common.reply(msg, 'A game has not been created yet.'); } return; } if (isNaN(search)) { teamId = hg.getGame(id).currentGame.teams.findIndex(function(team) { return team.players.findIndex(function(player) { return player == mentions.first().id; }) &gt; -1; }); } else { teamId = hg.getGame(id).currentGame.teams.findIndex( (team) =&gt; team.id == teamId); } if (teamId &lt; 0) { if (!silent) { self.common.reply( msg, 'Please specify a valid team id. (1 - ' + hg.getGame(id).currentGame.teams.length + ')'); } return; } message = message.slice(0, 101); if (!silent) { self.common.reply( msg, 'Renaming \"' + hg.getGame(id).currentGame.teams[teamId].name + '\" to \"' + message + '\"'); } hg.getGame(id).currentGame.teams[teamId].name = message; } /** * Swap random users between teams. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {boolean} [silent=false] If true, this will not attempt to send * messages to the channel where the msg was sent.. */ function randomizeTeams(msg, id, silent) { if (!hg.getGame(id) || !hg.getGame(id).currentGame) { if (!silent) { self.common.reply(msg, 'A game has not been created yet.'); } return; } if (hg.getGame(id).currentGame.inProgress) { if (!silent) { self.common.reply(msg, 'Please end the current game to modify teams.'); } return; } const current = hg.getGame(id).currentGame; if (current.teams.length == 0) { if (!silent) self.common.reply(msg, 'There are no teams to randomize.'); return; } for (let i = 0; i &lt; current.includedUsers.length; i++) { const teamId1 = Math.floor(Math.random() * current.teams.length); const playerId1 = Math.floor(Math.random() * current.teams[teamId1].players.length); const teamId2 = Math.floor(Math.random() * current.teams.length); const playerId2 = Math.floor(Math.random() * current.teams[teamId2].players.length); const intVal = current.teams[teamId1].players[playerId1]; current.teams[teamId1].players[playerId1] = current.teams[teamId2].players[playerId2]; current.teams[teamId2].players[playerId2] = intVal; } if (!silent) self.common.reply(msg, 'Teams have been randomized!'); } // Game Events // /** * Create a custom event for a guild. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function createEvent(msg, id, game) { if (!game) game = hg.getGame(id); if (!game) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } createEvent(msg, id, game); }); return; } newEventMessages[msg.id] = msg; const authId = msg.author.id; msg.channel.send('`Loading...`').then((msg_) =&gt; { newEventMessages[msg.id].myResponse = msg_; newReact(maxReactAwaitTime); msg_.awaitReactions(function(reaction, user) { return (reaction.emoji.name == emoji.redCircle || reaction.emoji.name == emoji.trophy) &amp;&amp; user.id == authId; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg_.reactions.removeAll().catch(() =&gt; {}); delete newEventMessages[msg.id]; return; } let eventType = 'player'; if (reactions.first().emoji.name == emoji.redCircle) { eventType = 'bloodbath'; } const message = newEventMessages[msg.id].text; msg_.delete().catch(() =&gt; {}); msg.channel.send('`Loading...`') .then(function(msg_) { let numVictim = 0; let numAttacker = 0; let victimOutcome = 'nothing'; let attackerOutcome = 'nothing'; let victimKiller = false; let attackerKiller = false; const getAttackNum = function() { createEventNums( msg_, authId, '`How many attackers may be in this event? (-1 means at ' + 'least 1, -2 at least 2)`', (num) =&gt; { numAttacker = num; // msg_.reactions.removeAll(); msg_.channel.send('Loading...').then((msg) =&gt; { msg_ = msg; getVictimNum(); }); msg_.delete().catch(() =&gt; {}); }); }; const getVictimNum = function() { createEventNums( msg_, authId, '`How many victims may be in this event? (-1 means at ' + 'least 1, -2 at least 2)`', (num) =&gt; { numVictim = num; // msg_.reactions.removeAll(); msg_.channel.send('Loading...') .then((msg) =&gt; { msg_ = msg; getAttackOutcome(); }) .catch((err) =&gt; { self.error( 'Failed to send message to create event: ' + msg_.channel.id); console.error(err); }); msg_.delete().catch(() =&gt; {}); }); }; const getAttackOutcome = function() { if (numAttacker == 0) { getVictimOutcome(); } else { createEventOutcome( msg_, authId, '`What is the outcome of the attackers?`', function(outcome) { attackerOutcome = outcome; // msg_.reactions.removeAll(); msg_.channel.send('Loading...') .then((msg) =&gt; { msg_ = msg; getVictimOutcome(); }) .catch((err) =&gt; { self.error( 'Failed to send message to create event: ' + msg_.channel.id); console.error(err); }); msg_.delete().catch(() =&gt; {}); }); } }; const getVictimOutcome = function() { if (numVictim == 0) { getIsAttackerKiller(); } else { createEventOutcome( msg_, authId, '`What is the outcome of the victims?`', function(outcome) { victimOutcome = outcome; // msg_.reactions.removeAll(); msg_.channel.send('Loading...') .then((msg) =&gt; { msg_ = msg; getIsAttackerKiller(); }) .catch((err) =&gt; { self.error( 'Failed to send message to create event: ' + msg_.channel.id); console.error(err); }); msg_.delete().catch(() =&gt; {}); }); } }; const getIsAttackerKiller = function() { if (numAttacker == 0) { getIsVictimKiller(); } else { createEventAttacker( msg_, authId, '`Do the attacker(s) kill someone in this event?`', function(outcome) { attackerKiller = outcome; // msg_.reactions.removeAll(); msg_.channel.send('Loading...') .then((msg) =&gt; { msg_ = msg; getIsVictimKiller(); }) .catch((err) =&gt; { self.error( 'Failed to send message to create event: ' + msg_.channel.id); console.error(err); }); msg_.delete().catch(() =&gt; {}); }); } }; const getIsVictimKiller = function() { if (numVictim == 0) { finish(); } else { createEventAttacker( msg_, authId, '`Do the victim(s) kill someone in this event?`', function(outcome) { victimKiller = outcome; finish(); }); } }; const finish = function() { msg_.delete().catch(() =&gt; {}); const error = self.makeAndAddEvent( id, eventType, message, numVictim, numAttacker, victimOutcome, attackerOutcome, victimKiller, attackerKiller); if (error) { msg.channel .send( '`Failed to create event!`\\n' + eventType + ' event\\n' + error) .catch( (err) =&gt; { self.error( 'Failed to send message to create event: ' + msg_.channel.id); console.error(err); }); } else { msg.channel .send( '`Event created!`\\n' + formatEventString( new HungryGames.Event( message, numVictim, numAttacker, victimOutcome, attackerOutcome, victimKiller, attackerKiller)) + '\\n' + eventType + ' event') .catch( (err) =&gt; { self.error( 'Failed to send message to create event: ' + msg_.channel.id); console.error(err); }); } }; getAttackNum(); }) .catch((err) =&gt; { self.error( 'Failed to send message to create events: ' + msg.channel.id); console.error(err); }); delete newEventMessages[msg.id]; }); msg_.react(emoji.redCircle) .then(() =&gt; { msg_.react(emoji.trophy); }) .catch((err) =&gt; { self.error( 'Failed to add reactions to create events: ' + msg_.channel.id); console.error(err); }); updateEventPreview(newEventMessages[msg.id]); }).catch(() =&gt; {}); } /** * Creates an event and adds it to the custom events for the given guild. * * @public * @param {string} id The guild id to add the event to. * @param {string} type The type of event this is. Either 'player' or * 'bloodbath'. * @param {string} message The event message. * @param {number} numVictim The number of victims in the event. * @param {number} numAttacker The number of attackers in the event. * @param {string} victimOutcome The outcome of the victims due to this event. * @param {string} attackerOutcome The outcome of the attackers due to this * event. * @param {boolean} victimKiller Do the victims kill anyone. * @param {boolean} attackerKiller Do the attackers kill anyone. * @param {{name: string, count: number}} vWeapon The weapon information to * give the victim. * @param {{name: string, count: number}} aWeapon The weapon information to * give the attacker. * @returns {?string} Error message or null if no error. */ this.makeAndAddEvent = function( id, type, message, numVictim, numAttacker, victimOutcome, attackerOutcome, victimKiller, attackerKiller, vWeapon = null, aWeapon = null) { if (type !== 'player' &amp;&amp; type !== 'bloodbath') return 'Invalid Type'; if (!hg.getGame(id) || !hg.getGame(id).customEvents) { return 'Invalid ID or no game.'; } const newEvent = new HungryGames.Event( message, numVictim, numAttacker, victimOutcome, attackerOutcome, victimKiller, attackerKiller); if (vWeapon) { newEvent.victim.weapon = vWeapon; } if (aWeapon) { newEvent.attacker.weapon = aWeapon; } return self.addEvent(id, type, newEvent); }; /** * Adds a given event to the given guild's custom events. * * @public * @param {string} id The id of the guild to add the event to. * @param {string} type The type of event this is. * @param {HungryGames~Event} event The event to add. * @returns {?string} Error message or null if no error. */ this.addEvent = function(id, type, event) { if (type !== 'bloodbath' &amp;&amp; type !== 'player') return 'Invalid Type'; if (!hg.getGame(id) || !hg.getGame(id).customEvents) { return 'Invalid ID or no game.'; } if (typeof event.message !== 'string' || event.message.length == 0) { return 'Event must have a message.'; } for (let i = 0; i &lt; hg.getGame(id).customEvents[type].length; i++) { if (HungryGames.Event.equal( event, hg.getGame(id).customEvents[type][i])) { return 'Event already exists!'; } } hg.getGame(id).customEvents[type].push(event); return null; }; /** * Creates an event and adds it to the custom events for the given guild. Or * edits an existing event by appending new events to the major event. * * @public * @param {string} id The guild id to add the event to. * @param {string} type The type of event this is. Either 'arena' or 'weapon'. * @param {HungryGames~ArenaEvent|HungryGames~WeaponEvent} data The event * data. * @param {string} [name] The internal name of the weapon being added. * @returns {?string} Error message or null if no error. */ this.addMajorEvent = function(id, type, data, name) { if (type !== 'arena' &amp;&amp; type !== 'weapon') return 'Invalid Type'; if (!hg.getGame(id) || !hg.getGame(id).customEvents) { return 'Invalid ID or no game.'; } if (type === 'arena') { if (!data.message || data.message.length == 0) { return 'Event must have a message.'; } for (let i = 0; i &lt; hg.getGame(id).customEvents[type].length; i++) { if (hg.getGame(id).customEvents[type][i].message === data.message) { hg.getGame(id).customEvents[type][i] = Object.assign(hg.getGame(id).customEvents[type][i], data); return null; } } hg.getGame(id).customEvents[type].push(data); return null; } else if (type === 'weapon') { if (hg.getGame(id).customEvents[type][name]) { if (data.name) hg.getGame(id).customEvents[type][name].name = data.name; if (data.consumable) { hg.getGame(id).customEvents[type][name].consumable = data.consumable; } for (let i = 0; i &lt; data.outcomes.length; i++) { let exists = false; const dEl = data.outcomes[i]; for (let j = 0; j &lt; hg.getGame(id).customEvents[type][name].outcomes.length; j++) { const el = hg.getGame(id).customEvents[type][name].outcomes[j]; if (HungryGames.Event.equal(el, dEl)) { exists = true; break; } } if (exists) continue; hg.getGame(id).customEvents[type][name].outcomes.push( data.outcomes[i]); } } else { hg.getGame(id).customEvents[type][name] = data; } return null; } return 'Invalid Type'; }; /** * Searches custom events for the given one, then edits it with the given * data. If the data is null besides required data for finding the major * event, the major event gets deleted. (Arena or Weapon events). * * @public * @param {string} id The id of the guild to remove the event from. * @param {string} type The type of event this is. * @param {HungryGames~ArenaEvent|HungryGames~WeaponEvent} search The event * data to use to search for. * @param {?HungryGames~ArenaEvent|HungryGames~WeaponEvent} data The event * data to set the matched search to. If this is null, the event is deleted. * @param {string} [name] The name of the weapon to look for or the message of * the arena event to edit. * @param {string} [newName] The new name of the weapon that was found with * `name`. * @returns {?string} Error message or null if no error. */ this.editMajorEvent = function(id, type, search, data, name, newName) { if (type !== 'arena' &amp;&amp; type !== 'weapon') return 'Invalid Type'; if (!hg.getGame(id) || !hg.getGame(id).customEvents) { return 'Invalid ID or no game.'; } const list = hg.getGame(id).customEvents[type]; if (type === 'arena') { let match; let matchId = -1; for (let i = 0; i &lt; list.length; i++) { if (list[i].message == search.message) { match = list[i]; matchId = i; break; } } if (!match) return 'Failed to find event to edit.'; if (!data) { hg.getGame(id).customEvents[type].splice(matchId, 1); return null; } if (search.message) match.message = data.message; if (search.outcomeProbs) match.outcomeProbs = data.outcomeProbs; if (!search.outcomes || search.outcomes.length == 0) return null; for (let i = 0; i &lt; match.outcomes.length; i++) { let one = match.outcomes[i]; for (let j = 0; j &lt; search.outcomes.length; j++) { const two = search.outcomes[j]; if (HungryGames.Event.equal(one, two)) { if (data.outcomes &amp;&amp; data.outcomes[j]) { one = data.outcomes[j]; } else { match.outcomes.splice(i, 1); i--; } break; } } } if (match.outcomes.length == 0) { hg.getGame(id).customEvents[type].splice(matchId, 1); } return null; } else if (type === 'weapon') { let match = hg.getGame(id).customEvents[type][name]; if (!match) return 'Failed to find weapon to edit.'; if (newName) { match = hg.getGame(id).customEvents[type][newName] = Object.assign({}, match); delete hg.getGame(id).customEvents[type][name]; } if (!search) return null; if (!data) { delete hg.getGame(id).customEvents[type][newName || name]; return null; } if (search.name) match.name = data.name; if (search.consumable) match.consumable = data.consumable; if (!search.outcomes || search.outcomes.length == 0) return null; for (let i = 0; i &lt; search.outcomes.length; i++) { for (let j = 0; j &lt; match.outcomes.length; j++) { if (HungryGames.Event.equal( search.outcomes[i], match.outcomes[j])) { if (!data.outcomes || !data.outcomes[i]) { match.outcomes.splice(j, 1); } else { match.outcomes[j] = data.outcomes[i]; } break; } } } if (match.outcomes.length == 0) { delete hg.getGame(id).customEvents[type][newName || name]; } return null; } return 'Failed to find event to edit.'; }; /** * Searches custom events for the given one, then removes it from the custom * events. (Bloodbath or Player events). * * @public * @param {string} id The id of the guild to remove the event from. * @param {string} type The type of event this is. * @param {HungryGames~Event} event The event to search for. * @returns {?string} Error message or null if no error. */ this.removeEvent = function(id, type, event) { if (type !== 'bloodbath' &amp;&amp; type !== 'player') return 'Invalid Type'; if (!hg.getGame(id) || !hg.getGame(id).customEvents) { return 'Invalid ID or no game.'; } const list = hg.getGame(id).customEvents[type]; for (let i = 0; i &lt; list.length; i++) { if (HungryGames.Event.equal(list[i], event)) { list.splice(i, 1); return null; } } return 'Failed to find event to remove.'; }; /** * Toggle events in the games. * * @todo Write this. This is not implemented yet. * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. */ function commandToggleEvent(msg) { self.common.reply( msg, 'Sorry, this feature is only available on the website.', 'https://www.spikeybot.com/hg/'); // let error = self.toggleEvent(id, type, subCat, event, value); } /** * Enable or disable an event without deleting it completely. * * @public * @param {number|string} id The guild id that the event shall be toggled in. * @param {string} type The type of event. 'bloodbath', 'player', 'weapon', or * 'arena'. * @param {?string} subCat The sub-category name of the event if there is one * (Such as the weapon name, or arena event message). * @param { * HungryGames~Event| * HungryGames~ArenaEvent| * HungryGames~WeaponEvent * } event The event to toggle. * @param {boolean} [value] Set enabled to a value instead of toggling. * @returns {?string} Error message or null if no error. */ this.toggleEvent = function(id, type, subCat, event, value) { if (!['bloodbath', 'arena', 'player', 'weapon'].includes(type)) { return 'Invalid Type'; } if (!hg.getGame(id)) return 'Invalid ID or no game'; if (!hg.getGame(id).disabledEvents) { hg.getGame(id).disabledEvents = {bloodbath: [], player: [], arena: {}, weapon: {}}; } let allEvents; switch (type) { case 'bloodbath': allEvents = defaultBloodbathEvents.concat( hg.getGame(id).customEvents.bloodbath); break; case 'player': allEvents = defaultPlayerEvents.concat(hg.getGame(id).customEvents.player); break; case 'arena': allEvents = defaultArenaEvents.concat(hg.getGame(id).customEvents.arena); break; case 'weapon': { allEvents = Object.assign({}, weapons); const entries = Object.entries(hg.getGame(id).customEvents.weapon); for (let i = 0; i &lt; entries.length; i++) { if (allEvents[entries[i][0]]) { allEvents[entries[i][0]].outcomes = allEvents[entries[i][0]].outcomes.concat( entries[i][1].outcomes); } else { allEvents[entries[i][0]] = entries[i][1]; } } break; } } let allDisabled = hg.getGame(id).disabledEvents[type]; if (['weapon', 'arena'].includes(type)) { if (!subCat) return 'Invalid Category'; if (type === 'weapon') allEvents = allEvents[subCat]; if (type === 'arena') { allEvents = allEvents.find((el) =&gt; el.message === subCat); } if (!allEvents) return 'Invalid Category'; allEvents = allEvents.outcomes; if (!allDisabled[subCat]) allDisabled[subCat] = []; allDisabled = allDisabled[subCat]; } let isValid = false; let isDisabled = false; let index; for (let i = 0; i &lt; allDisabled.length; i++) { if (HungryGames.Event.equal(allDisabled[i], event)) { if (typeof value === 'undefined') value = true; if (value) isValid = true; isDisabled = true; index = i; break; } } if (!isDisabled &amp;&amp; !value) { value = false; isValid = true; } if (!isValid) return 'Already ' + (value ? 'Enabled' : 'Disabled'); if (!value) { isValid = false; for (let i = 0; i &lt; allEvents.length; i++) { if (HungryGames.Event.equal(allEvents[i], event)) { isValid = true; break; } } if (!isValid) return 'Invalid Event'; allDisabled.push(event); } else { allDisabled.splice(index, 1); } return null; }; /** * The callback after receiving a number from user input. * * @callback HungryGames~createEventNumCallback * @param {number} num The number received from the user. */ /** * Let the user choose how many of something will be in this event being * created. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {string} show The message to show explaining the number. * @param {HungryGames~createEventNumCallback} cb The callback after the user * has chosen a number. */ function createEventNums(msg, id, show, cb) { msg.edit(show + '\\nNo people'); let num = 0; const regLis = function() { newReact(maxReactAwaitTime); msg.awaitReactions(function(reaction, user) { if (user.id != self.client.user.id) { reaction.users.remove(user).catch(() =&gt; {}); } return (reaction.emoji.name == emoji.arrowUp || reaction.emoji.name == emoji.arrowDown || reaction.emoji.name == emoji.whiteCheckMark) &amp;&amp; user.id == id; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg.reactions.removeAll().catch(() =&gt; {}); return; } const name = reactions.first().emoji.name; if (name == emoji.arrowUp) { num++; } else if (name == emoji.arrowDown) { num--; } else if (name == emoji.whiteCheckMark) { cb(num); return; } let message = 'No people.'; if (num &lt; 0) { message = 'At least ' + num * -1 + ' people.'; } else if (num &gt; 0) { message = num + ' people exactly.'; } msg.edit(show + '\\n' + message); regLis(); }); }; regLis(); msg.react(emoji.whiteCheckMark).then(() =&gt; { msg.react(emoji.arrowUp).then(() =&gt; { msg.react(emoji.arrowDown); }); }); } /** * The callback after receiving an event outcome from a user. * * @callback HungryGames~createEventOutcomeCallback * @param {string} outcome The outcome chosen by the user. */ /** * Let the user choose what the outcome of an event will be. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {string} show The message to show explaining the options. * @param {HungryGames~createEventOutcomeCallback} cb The callback after the * user has chosen an outcome. */ function createEventOutcome(msg, id, show, cb) { msg.edit( show + '\\n' + getOutcomeEmoji('nothing') + 'Nothing, ' + getOutcomeEmoji('dies') + 'Dies, ' + getOutcomeEmoji('wounded') + 'Wounded, ' + getOutcomeEmoji('thrives') + 'Healed, ' + getOutcomeEmoji('revived') + 'Revived'); newReact(maxReactAwaitTime); msg.awaitReactions(function(reaction, user) { return (reaction.emoji.name == getOutcomeEmoji('thrives') || reaction.emoji.name == getOutcomeEmoji('revived') || reaction.emoji.name == getOutcomeEmoji('wounded') || reaction.emoji.name == getOutcomeEmoji('nothing') || reaction.emoji.name == getOutcomeEmoji('dies')) &amp;&amp; user.id == id; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg.reactions.removeAll().catch(() =&gt; {}); return; } switch (reactions.first().emoji.name) { case getOutcomeEmoji('revived'): cb('revived'); return; case getOutcomeEmoji('thrives'): cb('thrives'); return; case getOutcomeEmoji('wounded'): cb('wounded'); return; case getOutcomeEmoji('nothing'): cb('nothing'); return; case getOutcomeEmoji('dies'): cb('dies'); return; } }); msg.react(getOutcomeEmoji('nothing')).then(() =&gt; { msg.react(getOutcomeEmoji('dies')).then(() =&gt; { msg.react(getOutcomeEmoji('wounded')).then(() =&gt; { msg.react(getOutcomeEmoji('thrives')); }); }); }); } /** * The callback after receiving a boolean input. * * @callback HungryGames~createEventBooleanCallback * @param {boolean} outcome The value chosen by the user. */ /** * Let the user choose whether the event attackers and victims kill anyone. * * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {string} show The message to show explaining the options. * @param {HungryGames~createEventBooleanCallback} cb The callback after the * user has chosen an outcome. */ function createEventAttacker(msg, id, show, cb) { msg.edit(show); newReact(maxReactAwaitTime); msg.awaitReactions(function(reaction, user) { return (reaction.emoji.name == emoji.whiteCheckMark || reaction.emoji.name == emoji.x) &amp;&amp; user.id == id; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg.reactions.removeAll().catch(() =&gt; {}); return; } if (reactions.first().emoji.name == emoji.whiteCheckMark) { cb(true); } else { cb(false); } }); msg.react(emoji.whiteCheckMark).then(() =&gt; { msg.react(emoji.x); }); } /** * When a user is creating a custom event and edits their message, we need to * edit the preview. * * @private * @param {Discord~Message} msg Our message previewing the new event. */ function updateEventPreview(msg) { msg.text = msg.text.split(' ').slice(1).join(' '); const helpMsg = '```\\nEdit your message until you are happy with the below outcomes, ' + 'then click the type of event.\\n\\nReplace names with \"{victim}\" or ' + '\"{attacker}\" (with brackets).\\n\\nUse \"[Vsingular|plural]\" or ' + '\"[Asingular|plural]\" to put \"singular\" if there\\'s only one person, ' + 'or \"plural\" if there are more\\n (A for attacker, V for victim).\\n```'; const finalOptionsHelp = emoji.redCircle + 'Bloodbath event, ' + emoji.trophy + 'Normal event.'; const users = msg.guild.members.random(4); const players = []; let cnt = 0; for (let i = 0; cnt &lt; 4; i++) { const nextUser = users[i % users.length]; if (typeof nextUser === 'undefined') continue; players.push(HungryGames.Player.from(nextUser.user)); cnt++; } try { const single = HungryGames.Event .finalize( msg.text, players.slice(0), 1, 1, 'nothing', 'nothing', hg.getGame(msg.guild.id)) .message; const pluralOne = HungryGames.Event .finalize( msg.text, players.slice(0), 2, 1, 'nothing', 'nothing', hg.getGame(msg.guild.id)) .message; const pluralTwo = HungryGames.Event .finalize( msg.text, players.slice(0), 1, 2, 'nothing', 'nothing', hg.getGame(msg.guild.id)) .message; const pluralBoth = HungryGames.Event .finalize( msg.text, players.slice(0), 2, 2, 'nothing', 'nothing', hg.getGame(msg.guild.id)) .message; msg.myResponse.edit( helpMsg + single + '\\n' + pluralOne + '\\n' + pluralTwo + '\\n' + pluralBoth + '\\n\\n(Tip: The Hungry Games can be managed from my website: ' + 'https://www.spikeybot.com/hg/)\\n' + finalOptionsHelp); } catch (err) { console.log(err); } } /** * Delete a custom event from a guild. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function removeEvent(msg, id) { if (!hg.getGame(id)) { self.common.reply( msg, 'You must first create an event in order to remove it.'); return; } const split = msg.text.trim().split(' '); if (split.length == 0) { self.common.reply( msg, 'You must specify the number of the custom event you wish to ' + 'remove.'); return; } else if (isNaN(split[0])) { self.common.reply( msg, 'The number you specified, isn\\'t a number, please pick a number.'); return; } else if (split[0] &lt;= 0) { self.common.reply( msg, 'The number you chose, is a bad number. I don\\'t like it.'); return; } const num = split[0] - 1; self.common .reply( msg, 'Which type of event is this?', emoji.redCircle + 'Bloodbath, ' + emoji.trophy + 'Normal.') .then((msg_) =&gt; { newReact(maxReactAwaitTime); msg_.awaitReactions(function(reaction, user) { return user.id == msg.author.id &amp;&amp; (reaction.emoji.name == emoji.redCircle || reaction.emoji.name == emoji.trophy); }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg_.reactions.removeAll().catch(() =&gt; {}); return; } let eventType = 'player'; if (reactions.first().emoji.name == emoji.redCircle) { eventType = 'bloodbath'; } if (eventType == 'player') { if (num &gt;= hg.getGame(id).customEvents.player.length) { self.common.reply( msg, 'That number is a really big scary number. Try a smaller ' + 'one.'); msg_.delete().catch(() =&gt; {}); } else { const removed = hg.getGame(id).customEvents.player.splice(num, 1)[0]; self.common.reply( msg, 'Removed event.', formatEventString(removed, true)); msg_.delete().catch(() =&gt; {}); } } else { if (num &gt;= hg.getGame(id).customEvents.bloodbath.length) { self.common.reply( msg, 'That number is a really big scary number. Try a smaller ' + 'one.'); msg_.delete().catch(() =&gt; {}); } else { const removed = hg.getGame(id).customEvents.bloodbath.splice(num, 1)[0]; self.common.reply( msg, 'Removed event.', formatEventString(removed, true)); msg_.delete().catch(() =&gt; {}); } } }); msg_.react(emoji.redCircle).then(() =&gt; { msg_.react(emoji.trophy); }); }); } /** * Put information about an array of events into the array. * * @private * @param {HungryGames~Event[]} events Array of events to process and modify. */ function fetchStats(events) { let numKill = 0; let numWound = 0; let numThrive = 0; events.forEach(function(obj) { if (obj.attacker.outcome == 'dies' || obj.victim.outcome == 'dies') { numKill++; } if (obj.attacker.outcome == 'wounded' || obj.victim.outcome == 'wounded') { numWound++; } if (obj.attacker.outcome == 'thrives' || obj.victim.outcome == 'thrives') { numThrive++; } }); events.numKill = numKill; events.numWound = numWound; events.numThrive = numThrive; } /** * Allow user to view all events available on their server and summary of each * type of event. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {number} [page=0] The page number to show. * @param {string} [eventType='player'] The type of event to show. * @param {Discord~Message} [editMsg] The message to edit instead of sending a * new message. */ function listEvents(msg, id, page = 0, eventType, editMsg) { const embed = new self.Discord.MessageEmbed(); let events = []; let numCustomEvents = 0; let title; if (!eventType) eventType = 'player'; if (eventType == 'player') { if (hg.getGame(id) &amp;&amp; hg.getGame(id).customEvents.player) { events = JSON.parse(JSON.stringify(hg.getGame(id).customEvents.player)); numCustomEvents = hg.getGame(id).customEvents.player.length; } events.push( new HungryGames.Event( `${emoji.arrowUp}Custom | Default${emoji.arrowDown}`)); events = events.concat(JSON.parse(JSON.stringify(defaultPlayerEvents))); title = 'Player'; fetchStats(events); embed.setColor([0, 255, 0]); } else if (eventType == 'bloodbath') { if (hg.getGame(id) &amp;&amp; hg.getGame(id).customEvents.bloodbath) { events = JSON.parse(JSON.stringify(hg.getGame(id).customEvents.bloodbath)); numCustomEvents = hg.getGame(id).customEvents.bloodbath.length; } events.push( new HungryGames.Event( `${emoji.arrowUp}Custom | Default${emoji.arrowDown}`)); events = events.concat(JSON.parse(JSON.stringify(defaultBloodbathEvents))); title = 'Bloodbath'; fetchStats(events); embed.setColor([255, 0, 0]); } else if (eventType == 'arena') { if (hg.getGame(id) &amp;&amp; hg.getGame(id).customEvents.arena) { events = JSON.parse(JSON.stringify(hg.getGame(id).customEvents.arena)); numCustomEvents = hg.getGame(id).customEvents.arena.length; } if (numCustomEvents == 0 &amp;&amp; page &lt;= 0) { page = 1; } events.push( new HungryGames.Event( `${emoji.arrowUp}Custom | Default${emoji.arrowDown}`)); events = events.concat(JSON.parse(JSON.stringify(defaultArenaEvents))); events = events.map((obj) =&gt; { if (obj.outcomes) { fetchStats(obj.outcomes); const percentKill = obj.outcomes.numKill / obj.outcomes.length; const percentWound = obj.outcomes.numWound / obj.outcomes.length; const percentHeal = obj.outcomes.numThrive / obj.outcomes.length; const eventMessage = '**___' + obj.message + '___** (' + Math.round(percentKill * 1000) / 10 + '% kill, ' + Math.round(percentWound * 1000) / 10 + '% wound, ' + Math.round(percentHeal * 1000) / 10 + '% heal.)\\n' + obj.outcomes .map( (outcome, index) =&gt; `${alph[index]}) ${formatEventString(outcome, true)}`) .join('\\n'); return new HungryGames.Event(eventMessage); } else { obj.message = `**___${obj.message}___**`; return obj; } }); title = 'Arena'; embed.setColor([0, 0, 255]); } else { self.error( 'HOW COULD THIS BE? I\\'ve made a mistake! Unknown event type (' + eventType + ')'); self.common.reply(msg, 'BIG Oops! THIS message should _never_ appear!'); } const numEvents = events.length; const numThisPage = eventType == 'arena' ? 1 : numEventsPerPage; const numPages = Math.ceil(numEvents / numThisPage); if (page * numThisPage &gt;= numEvents) { page = numPages - 1; } else if (page &lt; 0) { page = 0; } let fullTitle = `All ${title} Events (${numEvents - 1}) `; if (eventType != 'arena') { fullTitle += Math.round(events.numKill / events.length * 1000) / 10 + '% kill, ' + Math.round(events.numWound / events.length * 1000) / 10 + '% wound, ' + Math.round(events.numThrive / events.length * 1000) / 10 + '% heal.'; } embed.setTitle(fullTitle); embed.setFooter(`(Page: ${page + 1}/${numPages})`); embed.setDescription( events.slice(page * numThisPage, (page + 1) * numThisPage) .map(function(obj, index) { let num = (index + 1 + numThisPage * page); if (eventType == 'arena') { num = 0; } else { // Not equal to because we are 1 indexed, not 0. if (num &gt; numCustomEvents) num -= numCustomEvents + 1; } if (num == 0) { return obj.message; } else { return `${num}) ${formatEventString(obj, true)}`; } }) .join('\\n')); const callback = function(msg_) { newReact(maxReactAwaitTime); msg_.awaitReactions(function(reaction, user) { if (user.id != self.client.user.id) { reaction.users.remove(user).catch(() =&gt; {}); } return user.id == msg.author.id &amp;&amp; (reaction.emoji.name == emoji.arrowRight || reaction.emoji.name == emoji.arrowLeft || reaction.emoji.name == emoji.arrowDoubleRight || reaction.emoji.name == emoji.arrowDoubleLeft || reaction.emoji.name == emoji.arrowsCounterClockwise); }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg_.reactions.removeAll().catch(() =&gt; {}); return; } switch (reactions.first().emoji.name) { case emoji.arrowRight: listEvents(msg, id, page + 1, eventType, msg_); break; case emoji.arrowLeft: listEvents(msg, id, page - 1, eventType, msg_); break; case emoji.arrowDoubleRight: listEvents(msg, id, numPages - 1, eventType, msg_); break; case emoji.arrowDoubleLeft: listEvents(msg, id, 0, eventType, msg_); break; case emoji.arrowsCounterClockwise: if (eventType == 'player') { eventType = 'arena'; } else if (eventType == 'arena') { eventType = 'bloodbath'; } else if (eventType == 'bloodbath') { eventType = 'player'; } listEvents(msg, id, 0, eventType, msg_); break; } }); const myReactions = msg_.reactions.filter(function(obj) { return obj.me; }); if (!myReactions.find((r) =&gt; r.name == emoji.arrowRight) || !myReactions.find((r) =&gt; r.name == emoji.arrowLeft) || !myReactions.find((r) =&gt; r.name == emoji.arrowDoubleRight) || !myReactions.find((r) =&gt; r.name == emoji.arrowDoubleLeft) || !myReactions.find((r) =&gt; r.name == emoji.arrowsCounterClockwise)) { msg_.react(emoji.arrowDoubleLeft) .then(() =&gt; { msg_.react(emoji.arrowLeft).then(() =&gt; { msg_.react(emoji.arrowRight).then(() =&gt; { msg_.react(emoji.arrowDoubleRight).then(() =&gt; { msg_.react(emoji.arrowsCounterClockwise); }); }); }); }) .catch(console.log); } }; if (!editMsg) { msg.channel.send(embed).then(callback); } else { editMsg.edit(embed).then(callback); } } /** * Format an event to show its settings to the user. * * @private * @param {HungryGames~Event|string} arenaEvent The event to format. * @param {boolean} [newline=false] If a new line should be inserted for * better formatting. * @returns {string} The formatted message with emojis. */ function formatEventString(arenaEvent, newline) { let message = arenaEvent.message.replaceAll('{attacker}', '`attacker`') .replaceAll('{victim}', '`victim`') .replaceAll('{dead}', '`dead`'); if (newline) message += '\\n '; message += '(' + emoji.crossedSwords + ': ' + ('' + arenaEvent.attacker.count).replace('-', '&gt;'); if (arenaEvent.attacker.count != 0) { message += ', ' + getOutcomeEmoji(arenaEvent.attacker.outcome) + (arenaEvent.attacker.killer ? ' Killer ' : ''); } message += ')'; if (newline) message += '\\n '; message += '(' + emoji.shield + ': ' + ('' + arenaEvent.victim.count).replace('-', '&gt;'); if (arenaEvent.victim.count != 0) { message += ', ' + getOutcomeEmoji(arenaEvent.victim.outcome) + (arenaEvent.victim.killer ? ' Killer' : ''); } return message + ')'; } /** * Get the emoji for a specific outcome of an event. * * @private * @param {string} outcome The outcome to get the emoji of. * @returns {string} The emoji. */ function getOutcomeEmoji(outcome) { switch (outcome) { case 'dies': return emoji.skull; case 'nothing': return emoji.whiteCheckMark; case 'wounded': return emoji.yellowHeart; case 'thrives': return emoji.heart; case 'revived': return emoji.blueHeart; default: return emoji.question; } } /** * List all currently created NPCs. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function listNPCs(msg, id) { let specific = msg.softMentions.users.find((el) =&gt; el.id.startsWith('NPC')); /** * Function to pass into Array.map to format NPCs into strings for this * list. * * @private * @param {NPC} obj NPC object to format as a string. * @returns {string} Name as a string. */ function mapFunc(obj) { let shortName; shortName = obj.name.substring(0, 16); if (shortName != obj.name) { shortName = shortName.substring(0, 13) + '...'; } return '`' + shortName + '`'; } if (!hg.getGame(id)) { self.common.reply(msg, 'A game has not been created yet.'); return; } const iNPCs = hg.getGame(id).includedNPCs || []; const eNPCs = hg.getGame(id).excludedNPCs || []; if (specific) { specific = iNPCs.concat(eNPCs).find((el) =&gt; el.id == specific.id); const embed = new self.Discord.MessageEmbed(); embed.setTitle('NPC Info'); embed.setDescription(specific.name); embed.setFooter(specific.id); embed.setThumbnail(specific.avatarURL); msg.channel.send(self.common.mention(msg), embed).catch((err) =&gt; { self.error('Failed to send NPC info message: ' + msg.channel.id); console.error(err); }); } else if (msg.text &amp;&amp; !['show', 'list'].includes(msg.text.trim())) { self.common.reply( msg, 'I\\'m not sure which NPC that is.', msg.text + '\\nUse `' + msg.prefix + self.postPrefix + 'npc list` to show all current NPCs.'); } else { const finalMessage = new self.Discord.MessageEmbed(); finalMessage.setTitle('List of NPCs'); finalMessage.setColor(defaultColor); let iList = []; let eList = []; if (iNPCs.length &gt; 0) iList = iNPCs.map(mapFunc).sort(); if (eNPCs.length &gt; 0) eList = eNPCs.map(mapFunc).sort(); const numINPCs = iList.length; const numENPCs = eList.length; if (iList.length &gt;= 5) { const numCols = calcColNum(iList.length &gt; 10 ? 3 : 2, iList); const quarterLength = Math.ceil(iList.length / numCols); for (let i = 0; i &lt; numCols - 1; i++) { const thisMessage = iList.splice(0, quarterLength).join('\\n').substr(0, 1024); finalMessage.addField( 'Included (' + (i * quarterLength + 1) + '-' + ((i + 1) * quarterLength) + ')', thisMessage, true); } finalMessage.addField( 'Included (' + ((numCols - 1) * quarterLength + 1) + '-' + numINPCs + ')', iList.join('\\n').substr(0, 1024), true); } else { finalMessage.addField( 'Included (' + numINPCs + ')', iList.join('\\n') || 'None.', false); } if (eList.length &gt;= 5) { const numCols = calcColNum(eList.length &gt; 10 ? 3 : 2, eList); const quarterLength = Math.ceil(eList.length / numCols); for (let i = 0; i &lt; numCols - 1; i++) { const thisMessage = eList.splice(0, quarterLength).join('\\n').substr(0, 1024); finalMessage.addField( 'Excluded (' + (i * quarterLength + 1) + '-' + ((i + 1) * quarterLength) + ')', thisMessage, true); } finalMessage.addField( 'Excluded (' + ((numCols - 1) * quarterLength + 1) + '-' + numENPCs + ')', eList.join('\\n').substr(0, 1024), true); } else { finalMessage.addField( 'Excluded (' + numENPCs + ')', eList.join('\\n') || 'None.', false); } msg.channel.send(self.common.mention(msg), finalMessage).catch((err) =&gt; { self.common.reply( msg, 'Oops, Discord rejected my message for some reason...', 'This is possibly because there are too many NPCs in the games ' + 'to show in this list.'); self.error('Failed to send list of NPCs message: ' + msg.channel.id); console.error(err); }); } } /** * Create a new NPC. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function createNPC(msg, id) { let username; fetchAvatar(); /** * @description Fetch the avatar the user has requested. Prioritizes * attachments, then URLs, otherwise returns. * * @private */ function fetchAvatar() { let url; if (msg.attachments.size == 1) { const a = msg.attachments.first(); url = a.proxyURL || a.url; } else if (msg.attachments.size == 0) { url = msg.text.match(urlRegex); if (url) url = url[0]; } if (typeof url !== 'string' || url.length == 0) { self.common.reply( msg, 'Hmm, you didn\\'t give me an image to use as an avatar.'); } else { username = formatUsername(msg.text, url); if (username.length &lt; 2) { self.common.reply(msg, 'Please specify a valid username.', username); return; } let request = https.request; if (url.startsWith('http://')) request = http.request; let req; try { req = request(url, onIncoming); } catch (err) { self.warn('Failed to request npc avatar: ' + url); // console.error(err); self.common.reply(msg, err.message); return; } req.on('error', (err) =&gt; { self.error('Failed to fetch image: ' + url); console.error(err); }); req.end(); msg.channel.startTyping(); } } /** * Fired on the 'response' http revent. * * @private * * @param {http.IncomingMessage} incoming Response object. */ function onIncoming(incoming) { if (incoming.statusCode != 200 ) { incoming.destroy(); self.common.reply( msg, 'Hmm, that link doesn\\'t appear to work.', 'Status code: ' + incoming.statusCode); msg.channel.stopTyping(); return; } const cl = incoming.headers['content-length']; const type = incoming.headers['content-type']; const supported = [ 'image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/gif', ]; self.debug('MIME: ' + type + ', CL: ' + cl); if (!supported.includes(type)) { incoming.destroy(); self.common.reply( msg, 'The provided filetype is not supported.', type || 'unknown filetype'); msg.channel.stopTyping(); return; } else if (!cl) { incoming.destroy(); self.common.reply( msg, 'Please ensure the image is not larger than ' + (self.maxBytes / 1000 / 1000) + 'MB.', 'Unable to determine download size.'); msg.channel.stopTyping(); return; } else if (cl &gt; self.maxBytes) { incoming.destroy(); self.common.reply( msg, 'Please ensure the image is not larger than ' + (self.maxBytes / 1000 / 1000) + 'MB.', Math.round(cl / 1000 / 100) / 10 + 'MB'); msg.channel.stopTyping(); return; } const data = []; let reqBytes = 0; incoming.on('data', (chunk) =&gt; { data.push(chunk); reqBytes += chunk.length; if (reqBytes &gt; self.maxBytes) { incoming.destroy(); self.common.reply( msg, 'Please ensure the image is not larger than ' + (self.maxBytes / 1000 / 1000) + 'MB.', '&gt;' + (Math.round(reqBytes / 1000 / 100) / 10) + 'MB'); msg.channel.stopTyping(); } }); incoming.on('end', () =&gt; { onGetAvatar(Buffer.concat(data)); }); } /** * Once image has been received, convert to Jimp. * * @private * * @param {Buffer} buffer The image as a Buffer. */ function onGetAvatar(buffer) { Jimp.read(buffer) .then((image) =&gt; { if (!image) throw new Error('Invalid Data'); let size = 128; if (hg.getGame(id) &amp;&amp; hg.getGame(id).options &amp;&amp; hg.getGame(id).options.eventAvatarSizes) { size = hg.getGame(id).options.eventAvatarSizes.avatar; } const copy = new Jimp(image); copy.resize(size, size); copy.getBuffer(Jimp.MIME_PNG, (err, out) =&gt; { if (err) throw err; sendConfirmation(image, out); }); }) .catch((err) =&gt; { self.common.reply( msg, 'I wasn\\'t able to convert that file into an image.', err.message); msg.channel.stopTyping(); self.error('Failed to convert buffer to image.'); console.error(err); }); } /** * Show a confirmation message to the user with the username and avatar. * * @private * * @param {Jimp} image The Jimp image for internal use. * @param {Buffer} buffer The Buffer the image buffer for showing. */ function sendConfirmation(image, buffer) { msg.channel.stopTyping(); const embed = new self.Discord.MessageEmbed(); embed.setTitle('Confirm NPC Creation'); embed.setAuthor(username); embed.setDescription( 'Click the ' + emoji.whiteCheckMark + ' reaction to confirm, ' + emoji.x + ' to cancel.'); embed.attachFiles( [new self.Discord.MessageAttachment(buffer, username + '.png')]); msg.channel.send(embed) .then((msg_) =&gt; { msg_.react(emoji.whiteCheckMark).then(() =&gt; { msg_.react(emoji.x); }); newReact(maxReactAwaitTime); msg_.awaitReactions((reaction, user) =&gt; { return user.id == msg.author.id &amp;&amp; (reaction.emoji.name == emoji.whiteCheckMark || reaction.emoji.name == emoji.x); }, {max: 1, time: maxReactAwaitTime}).then((reactions) =&gt; { embed.setDescription(''); if (reactions.size == 0) { msg_.reactions.removeAll().catch(() =&gt; {}); embed.setFooter('Timed out'); msg_.edit(embed); } else if ( reactions.first().emoji.name == emoji.whiteCheckMark) { msg_.reactions.removeAll().catch(() =&gt; {}); embed.setFooter('Confirmed'); msg_.edit(embed); onConfirm(image); } else { msg_.reactions.removeAll().catch(() =&gt; {}); embed.setFooter('Cancelled'); msg_.edit(embed); } }); }) .catch((err) =&gt; { self.error('Failed to send NPC confirmation: ' + msg.channel.id); console.error(err); }); } /** * Once user has confirmed adding NPC. * * @private * * @param {Jimp} image The image to save to file for this NPC. */ function onConfirm(image) { const id = NPC.createID(); const p = NPC.saveAvatar(image, id); if (!p) { self.common.reply( msg, 'Oops, something went wrong while creating that NPC...', 'This should not happen D:'); return; } else { p.then((url) =&gt; { const error = self.createNPC(msg.guild.id, username, url, id); if (error) { self.common.reply(msg, 'Failed to create NPC', error); } else { self.common.reply(msg, 'Created NPC: ' + username, id); } }).catch((err) =&gt; { self.error('Failed to create NPC.'); console.log(err); }); } } } /** * @description Create an npc in a guild. * * @public * @param {string|number} gId The guild id to add the npc to. * @param {string} username The name of the npc. * @param {string} avatar The url path to the avatar. Must be valid url to * this server. (ex: * https://www.spikeybot.com/avatars/NPCBBBADEF031F83638/avatar1.png). * @param {string} id The npc id of this npc. Must match the id in the avatar * url. * @returns {?string} Error message or null if no error. */ this.createNPC = function(gId, username, avatar, id) { if (typeof avatar !== 'string') return 'Invalid Avatar URL.'; const splitURL = avatar.match(/\\/avatars\\/(NPC[A-F0-9]+)\\/\\w+\\.png/); if (!splitURL) return 'Invalid Avatar URL.'; const urlID = splitURL[1]; if (!NPC.checkID(id)) { return 'Invalid NPC ID.'; } else if (urlID !== id) { return 'ID does not match avatar ID.'; } const npc = new NPC(formatUsername(username), avatar, id); const pushNPC = function(game) { if (!game.includedNPCs) hg.getGame(gId).includedNPCs = []; game.includedNPCs.push(npc); if (!game.currentGame.inProgress) self.createGame(gId); }; const game = hg.getGame(gId); if (!game) { self.createGame(gId, pushNPC); } else { pushNPC(game); } return null; }; /** * Remove url from username, and format to rules similar to Discord. * * @private * * @param {string} u The username. * @param {string|RegExp} [remove] A substring or RegExp to remove. * @returns {string} Formatted username. */ function formatUsername(u, remove) { if (!remove) remove = /a^/; // Match nothing by default. return u.replace(remove, '') .replace(/^\\s+|\\s+$|@|#|:|```/g, '') .replace(/\\s{2,}/g, ' ') .substring(0, 32); } /** * @inheritdoc * @public */ this.formatUsername = formatUsername; /** * Delete an NPC. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function removeNPC(msg, id) { const mentions = msg.softMentions.users.filter((el) =&gt; el.id.startsWith('NPC')); if (mentions.size == 0) { if (msg.text &amp;&amp; msg.text.length &gt; 1) { self.common.reply(msg, 'I wasn\\'t able to find that NPC.'); } else { self.common.reply(msg, 'Please specify an NPC to delete.'); } return; } const toDelete = mentions.first(); const success = self.removeNPC(id, toDelete.id); if (typeof success === 'string') { self.common.reply(msg, success); } else { msg.channel.send(success); } } /** * Delete an NPC from a guild. * * @public * * @param {string} gId Guild id of which to remove npc. * @param {string} npc ID of npc to delete. * @returns {string|Discord~MessageEmbed} String if error, MessageEmbed to * send if success. */ this.removeNPC = function(gId, npc) { const incIndex = hg.getGame(gId).includedNPCs.findIndex((el) =&gt; el.id == npc); const excIndex = hg.getGame(gId).excludedNPCs.findIndex((el) =&gt; el.id == npc); let toDelete; if (incIndex &gt; -1) { toDelete = hg.getGame(gId).includedNPCs.splice(incIndex, 1)[0]; } else if (excIndex &gt; -1) { toDelete = hg.getGame(gId).excludedNPCs.splice(excIndex, 1)[0]; } else { self.error('NPC HALF DISCOVERED :O ' + npc); return 'Oops, I was only half able to find that NPC. ' + 'Something is broken...'; } if (!hg.getGame(gId).currentGame.inProgress) self.createGame(gId); const embed = new self.Discord.MessageEmbed(); embed.setTitle('Deleted NPC'); embed.setDescription(toDelete.name); embed.setFooter(toDelete.id); embed.setThumbnail(toDelete.avatarURL); return embed; }; /** * @description Include an NPC in the game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function includeNPC(msg, id) { includeUser(msg, id); } /** * @description Exclude an NPC from the game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. */ function excludeNPC(msg, id) { excludeUser(msg, id); } /** * @description Send help message to DM and reply to server. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. */ function help(msg) { msg.author.send(self.helpMessage) .then(() =&gt; { if (msg.guild != null) { self.common.reply(msg, helpmessagereply, ':wink:').catch((err) =&gt; { self.error( 'Failed to send HG help message reply in channel: ' + msg.channel.id); console.error(err); }); } }) .catch(() =&gt; { self.common.reply(msg, blockedmessage).catch(() =&gt; {}); }); } /** * @description Responds with stats about a player in the games. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandStats(msg, id) { const game = hg.getGame(id); const numTotal = game.statGroup ? 3 : 2; const user = msg.softMentions.users.first() || msg.author; let numDone = 0; const embed = new self.Discord.MessageEmbed(); embed.setTitle(`${user.tag}'s HG Stats`); embed.setColor([255, 0, 255]); const checkDone = function() { numDone++; if (numDone === numTotal) { msg.channel.send(self.common.mention(msg), embed); } }; const groupDone = function(err, group) { if (!group) { checkDone(); return; } group.fetchUser(user.id, (err, data) =&gt; { if (err) { self.error( 'Failed to fetch HG User stats: ' + id + '@' + user.id + '/' + group.id); console.error(err); } else { const list = data.keys.map( (el) =&gt; `${self.common.camelToSpaces(el)}: ${data.get(el)}`); if (group.id === 'global') { embed.addField('Lifetime', list.join('\\n'), true); checkDone(); return; } else if (group.id === 'previous') { embed.addField('Previous Game', list.join('\\n'), true); checkDone(); return; } group.fetchMetadata((err, meta) =&gt; { if (err) { self.error( 'Failed to fetch metadata for group ' + id + '/' + group.id); console.error(err); } if (meta &amp;&amp; meta.name) { embed.addField(meta.name, list.join('\\n'), true); } else { embed.addField(group.id, list.join('\\n'), true); } checkDone(); }); } }); }; if (game.statGroup) game._stats.fetchGroup(game.statGroup, groupDone); game._stats.fetchGroup('global', groupDone); game._stats.fetchGroup('previous', groupDone); } /** * @description Responds with list of all stat group names and IDs. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandGroups(msg, id) { const game = hg.getGame(id); let total = 0; let done = 0; const list = []; const checkDone = function() { done++; if (done &gt;= total) { self.common.reply( msg, 'Stat Groups', list.join('\\n') || 'I wasn\\'t able to find that group.'); } }; const groupDone = function(err, group) { if (err) { checkDone(); return; } group.fetchMetadata((err, meta) =&gt; { const flag = game.statGroup === group.id ? '*' : ' '; if (err) { list.push(`${group.id}${flag}`); checkDone(); self.error( 'Failed to fetch metadata for stat group: ' + id + '/' + group.id); } else { list.push(`${group.id}${flag}: ${meta.name}`); checkDone(); } }); }; const groupID = msg.text.match(/\\b([a-fA-F0-9]{4})\\b/); if (groupID) { total = 1; game._stats.fetchGroup(groupID[1].toUpperCase(), groupDone); } else { game._stats.fetchGroupList((err, list) =&gt; { if (err) { self.error('Failed to get list of stat groups.'); console.error(err); self.common.reply( msg, 'Failed to get list of groups.', 'Something broke...'); return; } list = list.filter((el) =&gt; !['global', 'previous'].includes(el)); total = list.length; list.forEach((el) =&gt; game._stats.fetchGroup(el, groupDone)); if (list.length === 0) { self.common.reply(msg, 'There are no created groups.'); } }); } } /** * @description Creates a new stat group. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandNewGroup(msg, id) { const game = hg.getGame(id); const name = msg.text.trim().slice(0, 24); game._stats.createGroup({name: name}, (group) =&gt; { let res = group.id; if (name) res = `${res}: ${name}`; game.statGroup = group.id; self.common.reply(msg, 'Created and selected new stat group', res); }); } /** * @description Selects an existing stat group. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandSelectGroup(msg, id) { const game = hg.getGame(id); let groupID = msg.text.match(/\\b([a-fA-F0-9]{4})\\b/); if (!groupID) { self.common.reply(msg, 'Disabled stat group'); game.statGroup = null; return; } groupID = groupID[1].toUpperCase(); game._stats.fetchGroup(groupID, (err, group) =&gt; { if (err) { self.common.reply( msg, 'I wasn\\'t able to find that group.', 'List groups with `' + msg.prefix + self.postPrefix + 'groups`'); return; } game.statGroup = groupID; let name; if (group.name) { name = `${group.name} (${group.id})`; } else { name = `${group.id}`; } self.common.reply(msg, 'Selected group', name); }); } /** * @description Renames an existing stat group. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandRenameGroup(msg, id) { const game = hg.getGame(id); const regex = /\\b([a-fA-F0-9]{4})\\b/; let groupID = msg.text.match(regex); if (!groupID) { self.common.reply( msg, 'Please specify a valid group ID to rename.', 'List groups with `' + msg.prefix + self.postPrefix + 'groups`'); return; } groupID = groupID[1].toUpperCase(); const newName = msg.text.replace(regex, '').trim().slice(0, 24); game._stats.fetchGroup(groupID, (err, group) =&gt; { if (err) { self.common.reply( msg, 'I wasn\\'t able to find that group.', 'List groups with `' + msg.prefix + self.postPrefix + 'groups`'); return; } group.setMetaName(newName); let name; if (newName) { name = `${group.id}: (${newName})`; } else { name = `${group.id}`; } self.common.reply(msg, 'Renamed group', name); }); } /** * @description Deletes an existing stat group. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandDeleteGroup(msg, id) { const game = hg.getGame(id); let groupID = msg.text.match(/\\b([a-fA-F0-9]{4})\\b/); if (!groupID) { self.common.reply( msg, 'Please specify a valid group ID to rename.', 'List groups with `' + msg.prefix + self.postPrefix + 'groups`'); return; } groupID = groupID[1].toUpperCase(); game._stats.fetchGroup(groupID, (err, group) =&gt; { if (err) { self.common.reply( msg, 'I wasn\\'t able to find that group.', 'List groups with `' + msg.prefix + self.postPrefix + 'groups`'); return; } let additional = null; if (game.statGroup === group.id) { additional = 'Disabled stat group'; game.statGroup = null; } group.reset(); self.common.reply(msg, `Deleted group ${group.id}`, additional); }); } /** * @description Ranks players by stat. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id Guild ID this command was called from. */ function commandLeaderboard(msg, id) { const game = hg.getGame(id); const regex = /\\b([a-fA-F0-9]{4})\\b/; let groupID = msg.text.match(regex); if (!groupID) { const prevList = ['last', 'previous', 'recent']; if (prevList.find((el) =&gt; msg.text.indexOf(el) &gt; -1)) { groupID = 'previous'; } else { groupID = 'global'; } } else { groupID = groupID[1].toUpperCase(); } const text = msg.text.toLocaleLowerCase(); const col = HungryGames.Stats.keys.find( (el) =&gt; text.indexOf(el.toLocaleLowerCase()) &gt; -1 || text.indexOf( self.common.camelToSpaces(el).toLocaleLowerCase()) &gt; -1) || 'wins'; game._stats.fetchGroup(groupID, (err, group) =&gt; { if (err) { self.common.reply( msg, 'I wasn\\'t able to find that group.', 'List groups with `' + msg.prefix + self.postPrefix + 'groups`, or say \"lifetime\" or \"previous\".'); return; } const opts = {}; opts.sort = col; const num = msg.text.replace(regex, '').match(/\\d+/); if (num &amp;&amp; num[0] * 1 &gt; 0) opts.limit = num[0] * 1; group.fetchUsers(opts, (err, rows) =&gt; { if (err) { self.error('Failed to fetch leaderboard: ' + id + '/' + groupID); console.error(err); self.common.reply( msg, 'Oops! Something went wrong while fetching the leaderboard...'); return; } const list = rows.map((el, i) =&gt; { let name; if (el.id.startsWith('NPC')) { const npc = game.includedNPCs.find((n) =&gt; n.id === el.id) || game.excludedNPCs.find((n) =&gt; n.id === el.id); name = npc ? npc.name : el.id; } else { const iU = game.currentGame.includedUsers.find((u) =&gt; u.id === el.id); if (iU) { name = game.options.useNicknames &amp;&amp; iU.nickname || iU.name; } else { const m = msg.guild.members.get(el.id); name = m ? (game.options.useNicknames &amp;&amp; m.nickname) || m.name : el.id; } } return `${i+1}) ${name}: ${el.get(col)}`; }); const embed = new self.Discord.MessageEmbed(); embed.setTitle(`Rank by ${col}`); const groupName = groupID === 'global' ? 'lifetime' : groupID; embed.setDescription(groupName); embed.setColor([255, 0, 255]); const numCols = calcColNum(1, list); const numTotal = list.length; const quarterLength = Math.ceil(numTotal / numCols); for (let i = 0; i &lt; numCols - 1; i++) { const thisMessage = list.splice(0, quarterLength).join('\\n').slice(0, 1024); embed.addField( `${i * quarterLength + 1}-${(i + 1) * quarterLength}`, thisMessage, true); } embed.addField( `${(numCols - 1) * quarterLength + 1}-${numTotal}`, list.join('\\n').slice(0, 1024), true); msg.channel.send(self.common.mention(msg), embed).catch((err) =&gt; { self.error( 'Failed to send leaderboard in channel: ' + msg.channel.id); console.error(err); self.common.reply( msg, 'Oops! I wasn\\'t able to send the leaderboard here for an ' + 'unknown reason.', err.code); }); }); }); } /** * @description Replies to the user with stats about all the currently loaded * games in this shard. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. */ function commandNums(msg) { if (self.client.shard) { self.client.shard.broadcastEval('this.getHGStats(true)') .then( (res) =&gt; { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Stats Across Shards'); res.forEach((el, i) =&gt; { embed.addField(`#${i}`, el, true); }); msg.channel.send(embed); }) .catch((err) =&gt; { self.common.reply( msg, 'Oops, something went wrong while fetching stats.'); self.error(err); }); } else { self.common.reply(msg, getStatsString()); } } /** * @description Get this shard's stats and format it into a human readable * string. * @private * @param {boolean} [short=false] Provide a short version. * @returns {string} The formatted string. */ function getStatsString(short = false) { const listenerBlockDuration = listenersEndTime - Date.now(); let message; if (short) { message = `${self.getNumSimulating()}/${Object.keys(hg._games).length}`; } else { message = 'There are ' + self.getNumSimulating() + ' games currently simulating of ' + Object.keys(hg._games).length + ' currently loaded.'; } if (!short &amp;&amp; listenerBlockDuration &gt; 0) { message += '\\nThe last listener will end in ' + (Math.round(listenerBlockDuration / 100 / 60) / 10) + ' minutes.'; } const web = self.bot.getSubmodule(webSM); if (web) { const numClients = web.getNumClients(); if (short) { message += ` (${numClients} web)`; } else { message += '\\n' + numClients + ' web client' + (numClients == 1 ? '' : 's') + ' connected.'; } } return message; } /** * @description Replies to the user with an image saying \"rigged\". That is * all. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. */ function commandRig(msg) { const embed = new self.Discord.MessageEmbed(); embed.setThumbnail('https://discordemoji.com/assets/emoji/rigged.png'); embed.setColor([187, 26, 52]); msg.channel.send(self.common.mention(msg), embed); } /** * @description Fetch an array of user IDs that are in the current game and * have been referenced in any way due to the given message from the user. * @private * @param {Discord~Message} msg The message that lead to this being called. * @param {HungryGames~GuildGame} game The game this is for. * @returns {string[]} Array of user IDs that are in the current game that * were mentioned. */ function parseGamePlayers(msg, game) { const mentionedRoleUsers = new self.Discord.UserStore( self.client, ...msg.mentions.roles.map((r) =&gt; r.members.map((m) =&gt; m.user))); const softRoleUsers = new self.Discord.UserStore( self.client, ...msg.softMentions.roles.map((r) =&gt; r.members.map((m) =&gt; m.user))); const mentions = msg.mentions.users.concat(msg.softMentions.users) .concat(mentionedRoleUsers.concat(softRoleUsers)); let firstWord = msg.text.trim().split(' ')[0]; if (firstWord) firstWord = firstWord.toLowerCase(); const specialWords = { everyone: ['everyone', '@everyone', 'all'], online: ['online', 'here'], offline: ['offline'], idle: ['idle', 'away', 'snooze', 'snoozed'], dnd: ['dnd', 'busy'], bots: ['bot', 'bots'], npcs: ['npc', 'npcs', 'ai', 'ais'], }; let players = []; const incU = game.currentGame.includedUsers; if (specialWords.everyone.includes(firstWord)) { players = game.currentGame.includedUsers.map((el) =&gt; el.id); } else if (specialWords.online.includes(firstWord)) { players = incU.filter((el) =&gt; { const member = msg.guild.members.get(el.id); if (!member) return false; return member.user.presence.status === 'online'; }).map((el) =&gt; el.id); } else if (specialWords.offline.includes(firstWord)) { players = incU.filter((el) =&gt; { const member = msg.guild.members.get(el.id); if (!member) return false; return member.user.presence.status === 'offline'; }).map((el) =&gt; el.id); } else if (specialWords.idle.includes(firstWord)) { players = incU.filter((el) =&gt; { const member = msg.guild.members.get(el.id); if (!member) return false; return member.user.presence.status === 'idle'; }).map((el) =&gt; el.id); } else if (specialWords.dnd.includes(firstWord)) { players = incU.filter((el) =&gt; { const member = msg.guild.members.get(el.id); if (!member) return false; return member.user.presence.status === 'dnd'; }).map((el) =&gt; el.id); } else if (specialWords.npcs.includes(firstWord)) { players = incU.filter((el) =&gt; el.isNPC).map((el) =&gt; el.id); } else if (specialWords.bots.includes(firstWord)) { players = incU.filter((el) =&gt; { const member = msg.guild.members.get(el.id); if (!member) return false; return member.user.bot; }).map((el) =&gt; el.id); } return players.concat( mentions .filter((u) =&gt; { if (players.includes(u.id)) return false; return game.currentGame.includedUsers.find((p) =&gt; p.id == u.id); }) .map((el) =&gt; el.id)); } /** * @description Allows the game creator to kill a player in the game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function commandKill(msg, id, game) { if (!game) game = hg.getGame(id); if (!game) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } commandKill(msg, id, game); }); return; } const players = parseGamePlayers(msg, game); if (!players || players.length == 0) { self.common.reply(msg, 'Please specify a player in the games to kill.'); return; } self.common.reply( msg, HungryGames.GuildGame.forcePlayerState( hg.getGame(id), players, 'dead', hg.messages, hg._defaultPlayerEvents)); } /** * @description Allows the game creator to heal or revive a player in the * game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function commandHeal(msg, id, game) { if (!game) game = hg.getGame(id); if (!game) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } commandHeal(msg, id, game); }); return; } const players = parseGamePlayers(msg, game); if (!players || players.length == 0) { self.common.reply(msg, 'Please specify a player in the games to heal.'); return; } self.common.reply( msg, HungryGames.GuildGame.forcePlayerState( hg.getGame(id), players, 'thriving', hg.messages, hg._defaultPlayerEvents)); } /** * @description Allows the game creator to wound a player in the game. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function commandWound(msg, id, game) { if (!game) game = hg.getGame(id); if (!game) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } commandWound(msg, id, game); }); return; } const players = parseGamePlayers(msg, game); if (!players || players.length == 0) { self.common.reply(msg, 'Please specify a player in the games to wound.'); return; } self.common.reply( msg, HungryGames.GuildGame.forcePlayerState( hg.getGame(id), players, 'wounded', hg.messages, hg._defaultPlayerEvents)); } /** * @description Rename the guild's game to the given custom name. * * @public * @param {string|number} id The guild id of which to change the game's name. * @param {string} name The custom name to change to. Must be 100 characters * or fewer. * @returns {boolean} True if successful, false if failed. Failure is probably * due to a game not existing or the name being longer than 100 characters. */ this.renameGame = function(id, name) { if (!hg.getGame(id) || !hg.getGame(id).currentGame) return false; if (name.length &gt; 100) return false; hg.getGame(id).currentGame.customName = name; hg.getGame(id).currentGame.name = name || (self.client.guilds.get(id).name + '\\'s Hungry Games'); return true; }; /** * @description Rename a guild's game to a custom name. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function commandRename(msg, id, game) { if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } commandRename(msg, id, game); }); return; } if (self.renameGame(id, msg.text.trim())) { self.common.reply( msg, 'Renamed game to', msg.text.trim() || self.client.guilds.get(id).name); } else { self.common.reply( msg, 'Oops! I couldn\\'t change the name to that. Please ensure ' + 'it is fewer than 100 characters long.'); } } /** * @description Start or stop allowing users to enter in to a game by clicking * on a reaction to a message. * * @private * @type {HungryGames~hgCommandHandler} * @param {Discord~Message} msg The message that lead to this being called. * @param {string} id The id of the guild this was triggered from. * @param {HungryGames~GuildGame} [game] The game object to modify. */ function commandReactJoin(msg, id, game) { if (!game) game = hg.getGame(id); if (!game || !game.currentGame) { createGame(msg, id, false, (game) =&gt; { if (!game) { self.common.reply(msg, 'Failed to create game for unknown reason.'); return; } commandReactJoin(msg, id, game); }); return; } if (game.reactMessage) { self.endReactJoinMessage(id, (err, info) =&gt; { if (err) { self.error(err); self.common.reply(msg, 'Reaction Join Failed', err); } else { self.common.reply(msg, 'Reaction Join', info); } }); } else { self.createReactJoinMessage(msg.channel); } } /** * @description Send a message with a reaction for users to click on. Records * message id and channel id in game data. * * @public * @param {Discord~TextChannel|string} channel The channel in the guild to * send the message, or the ID of the channel. */ this.createReactJoinMessage = function(channel) { if (typeof channel === 'string') { channel = self.client.channels.get(channel); } if (!channel || !channel.guild || !channel.guild.id || !hg.getGame(channel.guild.id)) { return; } const embed = new self.Discord.MessageEmbed(); embed.setColor(defaultColor); embed.setTitle(`React with any emoji to join!`); embed.setDescription( 'If you have reacted, you will be included in the next `' + hg.getGame(channel.guild.id).currentGame.name + '`'); channel.send(embed).then((msg) =&gt; { hg.getGame(channel.guild.id).reactMessage = { id: msg.id, channel: channel.id, }; msg.react(emoji.crossedSwords).catch(() =&gt; {}); }); }; /** * @description End the reaction join and update the included users to only * include those who reacted to the message. * * @public * @param {string} id The guild id of which to end the react join. * @param {Function} [cb] Callback once this is complete. First parameter is a * string if error, null otherwise, the second is a string with info if * success or null otherwise. */ this.endReactJoinMessage = function(id, cb) { if (typeof cb !== 'function') cb = function() {}; if (!hg.getGame(id) || !hg.getGame(id).reactMessage || !hg.getGame(id).reactMessage.id || !hg.getGame(id).reactMessage.channel) { hg.getGame(id).reactMessage = null; cb('Unable to find message with reactions. ' + 'Was a join via react started?'); return; } let numTotal = 0; let numDone = 0; let msg; const channel = self.client.guilds.get(id).channels.get( hg.getGame(id).reactMessage.channel); if (!channel) { hg.getGame(id).reactMessage = null; cb('Unable to find message with reactions. Was the channel deleted?'); return; } channel.messages.fetch(hg.getGame(id).reactMessage.id) .then((m) =&gt; { msg = m; if (!msg.reactions || msg.reactions.size == 0) { usersFetched([]); } else { msg.reactions.forEach((el) =&gt; { numTotal += el.count; el.users.fetch().then(usersFetched).catch((err) =&gt; { self.error('Failed to fetch user reactions: ' + msg.channel.id); console.error(err); usersFetched([]); }); }); } }) .catch((err) =&gt; { console.error(err); hg.getGame(id).reactMessage = null; cb('Unable to find message with reactions. Was it deleted?'); }); let list = new self.Discord.Collection(); /** * @description Adds fetched user reactions to buffer until all are * received, then ends react join. * * @private * @param {Discord.Collection.&lt;User&gt;|Discord.User[]} reactionUsers Array of * users for a single reaction. */ function usersFetched(reactionUsers) { if (reactionUsers &amp;&amp; (reactionUsers.length &gt; 0 || reactionUsers.size &gt; 0)) { list = list.concat( reactionUsers.filter((el) =&gt; el.id != self.client.user.id)); numDone += reactionUsers.length || reactionUsers.size; } if (numTotal != numDone) return; self.excludeUsers('everyone', id, () =&gt; { hg.getGame(id).reactMessage = null; msg.edit('`Ended`').catch(() =&gt; {}); if (list.length == 0) { cb(null, 'No users reacted.'); } else { self.includeUsers(list, id, (res) =&gt; cb(null, res)); } }); } }; /** * @description Sort the includedUsers and teams for the given game. * @private * @param {HungryGames~GuildGame} game The game to sort. */ function sortTeams(game) { game.currentGame.teams.sort((a, b) =&gt; b.id - a.id); game.currentGame.includedUsers.sort((a, b) =&gt; { const aTeam = game.currentGame.teams.find((team) =&gt; { return team.players.findIndex((player) =&gt; { return player == a.id; }) &gt; -1; }); const bTeam = game.currentGame.teams.find((team) =&gt; { return team.players.findIndex((player) =&gt; { return player == b.id; }) &gt; -1; }); if (!aTeam || !bTeam || aTeam.id == bTeam.id) { const aN = ((game.options.useNicknames &amp;&amp; a.nickname) || a.name) .toLocaleLowerCase(); const bN = ((game.options.useNicknames &amp;&amp; b.nickname) || b.name) .toLocaleLowerCase(); if (aN &lt; bN) return -1; if (aN &gt; bN) return 1; return 0; } else { return aTeam.id - bTeam.id; } }); } /** * @description Returns the number of games that are currently being shown to * users. * * @public * @returns {number} Number of games simulating. */ this.getNumSimulating = function() { const loadedEntries = Object.entries(hg._games); const inProgress = loadedEntries.filter((game) =&gt; { return game[1].currentGame &amp;&amp; game[1].currentGame.inProgress &amp;&amp; game[1].currentGame.day.state &gt; 1 &amp;&amp; !game[1].currentGame.isPaused; }); return inProgress.length; }; /** * @description Get a random word that means \"nothing\". * * @private * @returns {string} A word meaning \"nothing\". */ function nothing() { const nothings = [ 'nix', 'naught', 'nothing', 'zilch', 'void', 'zero', 'zip', 'zippo', 'diddly', emoji.x, ]; return nothings[Math.floor(Math.random() * nothings.length)]; } /** * Calculates the number of columns for the given player list. Assumes maximum * character count of 1024 per section. The number of columns also becomes * limited to 5, because we will run into the embed total character limit of * 6000 if we add any more. * [Discord API Docs]( * https://discordapp.com/developers/docs/resources/channel#embed-limits). * * @private * * @param {number} numCols Minimum number of columns. * @param {string[]} statusList List of text to check. * @returns {number} Number of columns the data shall be formatted as. */ function calcColNum(numCols, statusList) { if (numCols === statusList.length) return numCols; // if (numCols &gt; 25) return 25; if (numCols &gt; 5) return 5; const quarterLength = Math.ceil(statusList.length / numCols); for (let i = 0; i &lt; numCols; i++) { if (statusList.slice(quarterLength * i, quarterLength * (i + 1)) .join('\\n') .length &gt; 1024) { return calcColNum(numCols + 1, statusList); } } return numCols; } /** * Update {@link HungryGames~listenersEndTime} because a new listener was * registered with the given duration. * * @private * @param {number} duration The length of time the listener will be active. */ function newReact(duration) { if (Date.now() + duration &gt; listenersEndTime) { listenersEndTime = Date.now() + duration; } } /** * Attempt to fetch an image from a URL. Checks if the file has been cached to * the filesystem first. * * @private * * @param {string|Jimp|Buffer} url The url to fetch the image from, or * anything Jimp supports. * @returns {Promise} Promise from JIMP with image data. */ function readImage(url) { let fromCache = false; let filename; let dir; if (typeof url === 'string') { const splitURL = url.match(/\\/(avatars)\\/(\\w+)\\/([^?&amp;/]+)/); if (splitURL &amp;&amp; splitURL[1] == 'avatars') { dir = `${self.common.userSaveDir}avatars/${splitURL[2]}/`; filename = `${dir}${splitURL[3]}`; } if (filename &amp;&amp; fs.existsSync(filename)) { fromCache = true; return toJimp(filename); } } return toJimp(url).then((image) =&gt; { if (fromCache) return image; if (filename &amp;&amp; image) { mkdirp(dir, (err) =&gt; { if (err) { self.error( 'Failed to create user directory to cache avatar: ' + dir); console.error(err); return; } image.getBuffer(Jimp.MIME_PNG, (err, buffer) =&gt; { if (err) { self.error( 'Failed to convert image into buffer: ' + (filename || url)); console.error(err); return; } fs.writeFile(filename, buffer, (err) =&gt; { if (err) { self.error('Failed to cache avatar: ' + filename); console.error(err); } }); }); }); } return image; }); /** * Send the request to Jimp to handle. * * @private * * @param {string} path Or path that Jimp can handle. * @returns {Promise} Promise from Jimp with image data. */ function toJimp(path) { return Jimp.read(path).catch((err) =&gt; { if (fromCache) { self.error('Failed to read from cache: ' + path); console.error(err); fromCache = false; return toJimp(url); } }); } } // Util // /** * Save all game data to file. * * @override * @param {string} [opt='sync'] Can be 'async', otherwise defaults to * synchronous. * @param {boolean} [wait=false] If requested before subModule is * initialized, keep trying until it is initialized. */ this.save = function(opt, wait) { if (!self.initialized) { if (wait) { setTimeout(function() { self.save(opt, wait); }); } return; } hg.save(opt); }; /** * @description Register an event listener. Handlers are called in order they * are registered. Earlier events can modify event data. * * @public * @param {string} evt The name of the event to listen for. * @param {Function} handler The function to call when the event is fired. */ this.on = function(evt, handler) { if (!eventHandlers[evt]) eventHandlers[evt] = []; eventHandlers[evt].push(handler); }; /** * Remove an event listener;. * * @public * @param {string} evt The name of the event that was being listened for. * @param {Function} handler The currently registered handler. */ this.removeListener = function(evt, handler) { if (!eventHandlers[evt]) return; const i = eventHandlers[evt].findIndex((el) =&gt; el === handler); if (i &gt; -1) eventHandlers[evt].splice(i, 1); }; /** * Fire an event on all listeners. * * @private * @param {string} evt The event to fire. * @param {...*} args Arguments for the event. */ function fire(evt, ...args) { if (!eventHandlers[evt]) return; eventHandlers[evt].forEach((el) =&gt; { try { el(self, ...args); } catch (err) { self.error('Caught error during event firing: ' + evt); console.error(err); } }); } /** * Catch process exiting so we can save if necessary, and remove other * handlers to allow for another module to take our place. * * @private * @param {number} [code] The exit code. * @listens Process#exit */ function exit(code) { if (self.initialized) { self.log('Caught exit! ' + code); } else { console.log('Caught exit! ', code); } if (self.initialized /* &amp;&amp; code == -1 */) { self.save(); } try { self.end(); } catch (err) { self.error('Exception during end!'); console.log(err); } } /** * Same as exit(), but triggered via SIGINT, SIGHUP or SIGTERM. * * @private * @listens Process#SIGINT * @listens Process#SIGHUP * @listens Process#SIGTERM */ function sigint() { if (self.initialized) { self.log('Caught SIGINT!'); } else { console.log('HG: Caught SIGINT!'); } if (self.initialized) { try { self.save(); } catch (err) { self.error('FAILED TO SAVE ON SIGINT' + err); } } try { self.end(); } catch (err) { self.error('END failed on exit'); console.error(err); } process.removeListener('exit', exit); process.exit(); } // Catch reasons for exiting in order to save first. process.on('exit', exit); process.on('SIGINT', sigint); process.on('SIGHUP', sigint); process.on('SIGTERM', sigint); } module.exports = new HG(); × Search results Close "},"hg_StatGroup.js.html":{"id":"hg_StatGroup.js.html","title":"Source: hg/StatGroup.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/StatGroup.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const Stats = require('./Stats.js'); const common = require('../common.js'); const crypto = require('crypto'); const fs = require('fs'); const rimraf = require('rimraf'); /** * @description Metadata to store along with a {@link HungryGames~StatGroup} * object. These values are user-defined and are not necessarily correct and are * not trustworthy for any processing. * @typedef {object} HGStatMetadata * * @property {string=} name The user-defined name of this stats object. * @property {Date=} startTime The timestamp at which this stats object starts * to include information. * @property {Date=} endTime The timestamp of the last time this object includes * information for. * @property {Date} createDate The timestamp at which this stats object was * created. * @property {Date} modifiedDate The timestamp at which this stats object was * last modified. */ /** * @description HG stats for a single timeframe. * @memberof HungryGames * @inner */ class StatGroup { /** * @description Create group. * @param {GuildGame} parent The parent instance of this group. * @param {HGStatMetadata|string} [metadata] Additional information to store * with these stats, or ID if metadata should be read from file since this * group already exists. */ constructor(parent, metadata) { let id; if (typeof metadata === 'string') { id = metadata; metadata = null; } // Ensure SQL connection is established. common.connectSQL(); /** * @description The ID of this current bot. * @public * @type {string} * @constant */ this.bot = parent.bot; /** * @description The guild ID where this stat group resides. * @public * @type {string} * @constant */ this.guild = parent.id; /** * @description The unique ID for this stat group. Unique per-guild. * @public * @type {string} */ this.id = id; if (!this.id) this.id = StatGroup.createID(parent); /** * @description Queue of callbacks to fire once an object has been read from * file. This is used to ensure that if multiple manipulations are requested * on a single object at the same time, all modifications will take place on * the same instance instead of overwriting eachother. Mapped by ID being * fetched. * @private * @type {Object.&lt;Array.&lt;function&gt;&gt;} * @default */ this._fetchQueue = {}; /** * @description Cache of Stats objects that are to be saved to file, and the * Timeout until it will be saved. Prevents saving the same file multiple * times at once. * @private * @type {Object.&lt;{data: HungryGames~Stats, timeout: Timeout}&gt;} * @default */ this._saveQueue = {}; const dir = `${common.guildSaveDir}${parent.id}/hg/stats/`; /** * @description The directory where all of this group's information is * stored. * @private * @type {string} * @constant */ this._dir = `${dir}${this.id}/`; this._fetchUser = this._fetchUser.bind(this); this.fetchUser = this.fetchUser.bind(this); this.setValue = this.setValue.bind(this); this.fetchValue = this.fetchValue.bind(this); this._saveUser = this._saveUser.bind(this); this.setMetaName = this.setMetaName.bind(this); this.setMetaStart = this.setMetaStart.bind(this); this.setMetaEnd = this.setMetaEnd.bind(this); this._fetchMetadata = this._fetchMetadata.bind(this); this._saveMetadata = this._saveMetadata.bind(this); this.reset = this.reset.bind(this); if (metadata) { this._saveMetadata(this._parseMetadata(metadata)); } else { this._fetchMetadata((err, meta) =&gt; { if (err) { console.error(err); return; } this._saveMetadata(meta); }); } } /** * @description Fetch stats for a specific user in this group. Returned stats * are modifiable, but changes will not persist unless saved to file. * @private * @param {string} uId The user ID of which to lookup. * @param {Function} cb Callback with optional error as first argument, * otherwise has stats as second argument. */ _fetchUser(uId, cb) { if (typeof uId !== 'string' || (uId !== 'meta' &amp;&amp; !uId.match(/^(\\d{17,19}|NPC[A-F0-9]+)$/))) { throw new TypeError('uId (' + uId + ') is not a valid ID.'); } // Data is queued to be saved, and is still cached, return the cached // version instead of reading the stale version from file. if (this._saveQueue[uId]) { cb(null, this._saveQueue[uId].data); return; } if (!this._fetchQueue[uId]) { this._fetchQueue[uId] = [cb]; } else { this._fetchQueue[uId].push(cb); return; } const self = this; const done = function(err, data) { self._fetchQueue[uId].forEach((el) =&gt; { try { el(err, data); } catch (err) { console.error(err); } }); delete self._fetchQueue[uId]; }; if (uId === 'meta') { fs.readFile(`${this._dir}${uId}.json`, (err, data) =&gt; { if (err) { if (err.code === 'ENOENT') { data = '{}'; } else { done(err); return; } } try { done(null, this._parseMetadata(JSON.parse(data))); } catch (err) { done(err); } }); } else { const toSend = global.sqlCon.format( 'SELECT * FROM HGStats WHERE ' + 'botId=? AND guildId=? AND groupId=? AND userId=?', [this.bot, this.guild, this.id, uId]); global.sqlCon.query(toSend, (err, rows) =&gt; { if (err) { done(err); return; } if (!rows || rows.length == 0) { // Fallback to legacy filesytem. fs.readFile(`${this._dir}${uId}.json`, (err, data) =&gt; { if (err) { if (err.code === 'ENOENT') { data = '{}'; } else { done(err); return; } } try { const parsed = JSON.parse(data); parsed.id = uId; done(null, Stats.from(parsed)); } catch (err) { done(err); } }); } else { const data = rows[0] || {}; data.id = uId; done(null, Stats.from(data)); } }); } } /** * @description Fetch stats for a specific user in this group. Modified values * will not persist. Use functions to modify. * @todo Return immutable/frozen copy to enforce no-modify rule. * @public * @param {string} uId The user ID of which to lookup. * @param {Function} cb Callback with optional error as first argument, * otherwise has stats as second argument. */ fetchUser(uId, cb) { this._fetchUser(uId, (err, stats) =&gt; { if (err) { cb(err); return; } // cb(null, common.deepFreeze(stats)); cb(null, stats); }); } /** * @description Options for fetching a group of user stats. * @typedef {object} HGStatGroupUserSelectOptions * * @property {string} [sort='wins'] Column to sort data by. * @property {boolean} [ascending=false] Sort ascending or descending order. * @property {number} [limit=10] Limit the number of fetched users. * @property {number} [offset=0] Offset start index of found users. */ /** * @description Fetch stats for a group of users. If array of IDs is given, * data will not be sorted. * @public * @param {HGStatGroupUserSelectOptions|string[]} [opts] Options to specify * which users are fetched, or array of user IDs to fetch. * @param {Function} cb Callback with optional error as first argument, * otherwise has stats as second argument as array of * {@link HungryGames~Stats} objects. */ fetchUsers(opts, cb) { if (typeof opts === 'function') { cb = opts; opts = {}; } if (typeof cb !== 'function') { throw new TypeError('Callback must be a function'); } if (!opts || typeof opts !== 'object') { opts = {}; } const onReply = function(err, rows) { if (err) { cb(err); return; } try { cb(null, rows.map((el) =&gt; { el.id = el.userId; return new Stats(el); })); } catch (err) { cb(err); } }; if (Array.isArray(opts)) { if (opts.length === 0) { cb(null, []); return; } const userList = opts.map(() =&gt; `userId=?`).join(' OR '); const toSend = global.sqlCon.format( 'SELECT * FROM HGStats WHERE ' + 'botId=? AND guildId=? AND groupId=? AND (' + userList + ');', [this.bot, this.guild, this.id].concat(opts)); global.sqlCon.query(toSend, onReply); } else { if (typeof opts.sort === 'undefined') { opts.sort = 'wins'; } else if (typeof opts.sort !== 'string') { opts.sort = null; } if (typeof opts.limit === 'undefined') opts.limit = 10; if (!opts.offset || typeof opts.offset !== 'number' || isNaN(opts.offset)) { opts.offset = 0; } const sort = (typeof opts.sort === 'string' ? ' ORDER BY ?? ' + (opts.ascending ? '' : 'DESC ') : ''); const limit = typeof opts.limit === 'number' &amp;&amp; !isNaN(opts.limit) ? `LIMIT ${opts.limit}` + (opts.offset ? ` OFFSET ${opts.offset}` : '') : ''; const toSend = global.sqlCon.format( 'SELECT * FROM HGStats WHERE ' + 'botId=? AND guildId=? AND groupId=?' + sort + limit + ';', [this.bot, this.guild, this.id, opts.sort]); global.sqlCon.query(toSend, onReply); } } /** * @description Set a stat value for a single user. * @public * @param {string} uId The user ID of which to change. * @param {string} key The key of the value to change. * @param {*} value The value to store. * @param {Function} cb Callback with single optional error argument. */ setValue(uId, key, value, cb) { this._fetchUser(uId, (err, data) =&gt; { if (err &amp;&amp; err.code !== 'ENOENT') { cb(err); return; } data.set(key, value); this._saveUser(data); cb(); }); } /** * @description Fetch a stat value for a single user. Immutable. * @public * @param {string} uId The user ID of which to fetch. * @param {string} key The key of the value to fetch. * @param {Function} cb Callback with optional error argument, and matched * value. */ fetchValue(uId, key, cb) { this._fetchUser(uId, (err, data) =&gt; { if (err) { cb(err); return; } cb(null, data.get(key)); }); } /** * @description Increment a value by an amount. * @public * @param {string} uId The user ID of which to modify. * @param {string} key The key of the value to modify. * @param {number} [amount=1] Amount to increment by. Can be negative to * decrement. * @param {Function} [cb] Callback with single optional error argument. */ increment(uId, key, amount = 1, cb) { if (typeof amount !== 'number' || isNaN(amount)) { throw new TypeError('Amount is not a number.'); } this._fetchUser(uId, (err, data) =&gt; { if (err) { if (typeof cb !== 'function') { console.error(err); } else { cb(err); } return; } if (!data.get(key)) data.set(key, 0); if (typeof data.get(key) !== 'number') { const err = new TypeError('Fetched value is not a number.'); if (typeof cb !== 'function') { console.error(err); } else { cb(err); } return; } data.set(key, data.get(key) + amount); this._saveUser(data); if (typeof cb === 'function') cb(); }); } /** * @description Save a stats object to file. * @private * @param {HungryGames~Stats} data The stats object to save. * @param {boolean} [immediate=false] Force saving to happen immediately * instead of waiting until next event loop. */ _saveUser(data, immediate = false) { if (this._saveQueue[data.id]) { clearTimeout(this._saveQueue[data.id].timeout); this._saveQueue[data.id].timeout = null; } if (!immediate) { this._saveQueue[data.id] = { data: data, timeout: setTimeout( () =&gt; this._saveUser(this._saveQueue[data.id].data, true), 1000), }; return; } delete this._saveQueue[data.id]; const setList = 'botId=?,guildId=?,groupId=?,userId=?,' + data.keys.map((el) =&gt; `${el}=?`).join(','); const valueList = [this.bot, this.guild, this.id, data.id].concat( Object.values(data.serializable)); const toSend = global.sqlCon.format( 'INSERT INTO HGStats SET ' + setList + ' ON DUPLICATE KEY UPDATE ' + setList + ';', valueList.concat(valueList)); global.sqlCon.query(toSend, (err) =&gt; { if (err) { console.error(err); return; } const fn = `${this._dir}${data.id}.json`; if (fs.existsSync(fn)) { fs.unlink(fn, (err) =&gt; { if (err) { console.error('Failed to remove legacy user stat file:', fn); console.error(err); } }); } }); // common.mkAndWrite( // `${this._dir}${data.id}.json`, this._dir, data.serializable); } /** * @description Set the metadata name. * @public * @param {string} name The new value. */ setMetaName(name) { this.fetchMetadata((err, meta) =&gt; { if (err) { console.error(err); return; } meta.name = name; this._saveMetadata(meta); }); } /** * @description Set the metadata start time. * @public * @param {Date|number|string} startTime Date parsable time. */ setMetaStart(startTime) { this.fetchMetadata((err, meta) =&gt; { if (err) { console.error(err); return; } meta.startTime = new Date(startTime); this._saveMetadata(meta); }); } /** * @description Set the metadata end time. * @public * @param {Date|number|string} endTime Date parsable time. */ setMetaEnd(endTime) { this.fetchMetadata((err, meta) =&gt; { if (err) { console.error(err); return; } meta.endTime = new Date(endTime); this._saveMetadata(meta); }); } /** * @description Fetch the metadata for this group from file. * @private * @param {Function} cb Callback with optional error argument, otherwise * second argument is parsed {@link HGStatMetadata}. */ _fetchMetadata(cb) { this._fetchUser('meta', cb); } /** * @description Fetch the metadata for this group from file. Modified values * will not persist. Use functions to modify. * @private * @param {Function} cb Callback with optional error argument, otherwise * second argument is parsed {@link HGStatMetadata}. */ fetchMetadata(cb) { this.fetchUser('meta', cb); } /** * @description Parse the given object into a {@link HGStatMetadata} object. * @private * @param {object} data The data to parse. * @returns {HGStatMetadata} The parsed object. */ _parseMetadata(data) { const out = {}; if (!data) data = {}; if (data.name != null) out.name = data.name; if (data.startTime != null) out.startTime = new Date(data.startTime); if (data.endTime != null) out.endTime = new Date(data.endTime); out.createDate = data.createDate ? new Date(data.createDate) : new Date(); out.modifiedDate = data.modifiedDate ? new Date(data.modifiedDate) : new Date(); return out; } /** * @description Save the current metadata to file. * @private * @param {HGStatMetadata} meta The data to save. Overwrites existing data. * @param {boolean} [immediate=false] Force saving to perform immediately * instead of delaying until next event loop. */ _saveMetadata(meta, immediate = false) { if (this._saveQueue.meta) { clearTimeout(this._saveQueue.meta.timeout); this._saveQueue.meta.timeout = null; } if (!immediate) { this._saveQueue.meta = { data: meta, timeout: setTimeout( () =&gt; this._saveMetadata(this._saveQueue.meta.data, true), 1000), }; return; } const data = { name: meta.name, startTime: meta.startTime &amp;&amp; meta.startTime.getTime(), endTime: meta.endTime &amp;&amp; meta.endTime.getTime(), createDate: meta.createDate.getTime(), modifiedDate: Date.now(), }; delete this._saveQueue.meta; common.mkAndWrite(`${this._dir}meta.json`, this._dir, data); } /** * @description Delete all data associated with this group. * @public */ reset() { const self = this; const resetQueue = function() { const keys = Object.keys(self._saveQueue); for (const k of keys) { clearTimeout(self._saveQueue[k].timeout); delete self._saveQueue[k]; } }; resetQueue(); const toSend = global.sqlCon.format( 'DELETE FROM HGStats WHERE guildId=? AND groupID=?;', [this.guild, this.id]); global.sqlCon.query(toSend, (err) =&gt; { if (err) console.error(err); }); rimraf(this._dir, (err) =&gt; { if (err) console.error(err); resetQueue(); }); } /** * @description Check if a stat group with the given ID exists for the given * game. * @public * @static * @param {HungryGames~GuildGame} game The game of which the stats to look up. * @param {string} id The group ID to check for. * @returns {boolean} True if exists, false otherwise. */ static exists(game, id) { const dir = `${common.guildSaveDir}${game.id}/hg/stats/`; return fs.existsSync(`${dir}${id}/`); } /** * @description Fetch list of IDs for all created groups. * @public * @static * @param {HungryGames~GuildGame} game The game to get list for. * @param {Function} cb Callback with optional error argument, otherwise * second argument is array of IDs as strings. */ static fetchList(game, cb) { fs.readdir(`${common.guildSaveDir}${game.id}/hg/stats/`, cb); } /** * @description Create an ID for a new group. * @todo Limit number of IDs to prevent infinite loop finding new ID. * @public * @static * @param {HungryGames~GuildGame} game The game to create an ID for to ensure * no collisions. * @returns {string} Valid created ID. */ static createID(game) { const dir = `${common.guildSaveDir}${game.id}/hg/stats/`; let output; do { const id = crypto.randomBytes(2).toString('hex').toUpperCase(); output = `0000${id}`.slice(-4); } while (fs.existsSync(`${dir}${output}`)); return output; } } module.exports = StatGroup; × Search results Close "},"web_hg.js.html":{"id":"web_hg.js.html","title":"Source: web/hg.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: web/hg.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const http = require('http'); const socketIo = require('socket.io'); const auth = require('../../auth.js'); const crypto = require('crypto'); const HungryGames = require('../hg/HungryGames.js'); require('../subModule.js').extend(HGWeb); // Extends the SubModule class. /** * @classdesc Creates a web interface for managing the Hungry Games. Expects * ../hungryGames.js is loaded or will be loaded. * @class */ function HGWeb() { const self = this; this.myName = 'HGWeb'; let hg_ = null; let ioClient; /** * Buffer storing all current image uploads and their associated meta-data. * @private * @type {Object} */ const imageBuffer = {}; const app = http.createServer(handler); let io; app.on('error', function(err) { if (io) io.close(); if (app) app.close(); if (err.code === 'EADDRINUSE') { self.warn( 'HGWeb failed to bind to port because it is in use. (' + err.port + ')'); startClient(); } else { self.error('HGWeb failed to bind to port for unknown reason.', err); } }); /** * Start a socketio client connection to the primary running server. * * @private */ function startClient() { self.log( 'Restarting into client mode due to server already bound to port.'); ioClient = require('socket.io-client')( self.common.isRelease ? 'http://localhost:8011' : 'http://localhost:8013', {path: '/www.spikeybot.com/socket.io/hg/'}); clientSocketConnection(ioClient); } /** * Update the reference to HungryGames. * * @private * @returns {HG} Reference to the currently loaded HungryGames subModule. */ function hg() { const prev = hg_; hg_ = self.bot.getSubmodule('./hungryGames.js'); if (!hg_) return; if (prev !== hg_) { unlinkHG(); hg_.on('dayStateChange', dayStateChange); hg_.on('shutdown', unlinkHG); } return hg_; } /** * Unregister all event handlers from `hg_`. * * @private */ function unlinkHG() { if (!hg_) return; hg_.removeListener('dayStateChange', dayStateChange); hg_.removeListener('shutdown', unlinkHG); } /** @inheritdoc */ this.initialize = function() { io = socketIo( app, {path: '/www.spikeybot.com/socket.io/', serveClient: false}); app.listen(self.common.isRelease ? 8011 : 8013, '127.0.0.1'); io.on('connection', socketConnection); }; /** * Causes a full shutdown of all servers. * * @public */ this.shutdown = function() { if (io) io.close(); if (ioClient) { ioClient.close(); ioClient = null; } if (app) app.close(); unlinkHG(); }; /** * Handler for all http requests. Should never be called. * * @private * @param {http.IncomingMessage} req The client's request. * @param {http.ServerResponse} res Our response to the client. */ function handler(req, res) { res.writeHead(418); res.end('TEAPOT'); } /** * Map of all currently connected sockets. * * @private * @type {Object.&lt;Socket&gt;} */ const sockets = {}; /** * Returns the number of connected clients that are not siblings. * * @public * @returns {number} Number of sockets. */ this.getNumClients = function() { return Object.keys(sockets).length - Object.keys(siblingSockets).length; }; /** * Map of all sockets connected that are siblings. * * @private * @type {Object.&lt;Socket&gt;} */ const siblingSockets = {}; /** * Handler for a new socket connecting. * * @private * @param {socketIo~Socket} socket The socket.io socket that connected. */ function socketConnection(socket) { // x-forwarded-for is trusted because the last process this jumps through is // our local proxy. const ipName = self.common.getIPName( socket.handshake.headers['x-forwarded-for'] || socket.handshake.address); self.common.log( 'Socket connected (' + Object.keys(sockets).length + '): ' + ipName, socket.id); sockets[socket.id] = socket; // @TODO: Replace this authentication with gpg key-pairs; socket.on('vaderIAmYourSon', (verification, cb) =&gt; { if (verification === auth.hgWebSiblingVerification) { siblingSockets[socket.id] = socket; cb(auth.hgWebSiblingVerificationResponse); socket.on('_guildBroadcast', (gId, ...args) =&gt; { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit(...args); } } }); } else { self.common.error('Client failed to authenticate as child.', socket.id); } }); // Unrestricted Access // socket.on('fetchDefaultOptions', () =&gt; { socket.emit('defaultOptions', hg().defaultOptions.entries); }); socket.on('fetchDefaultEvents', () =&gt; { socket.emit('defaultEvents', hg().getDefaultEvents()); }); // End Unrestricted Access \\\\ // Restricted Access // socket.on('fetchGuilds', (...args) =&gt; { callSocketFunction(fetchGuilds, args, false); }); socket.on('fetchGuild', (...args) =&gt; { callSocketFunction(fetchGuild, args); }); socket.on('fetchMember', (...args) =&gt; { callSocketFunction(fetchMember, args); }); socket.on('fetchChannel', (...args) =&gt; { callSocketFunction(fetchChannel, args); }); socket.on('fetchGames', (...args) =&gt; { callSocketFunction(fetchGames, args); }); socket.on('fetchDay', (...args) =&gt; { callSocketFunction(fetchDay, args); }); socket.on('excludeMember', (...args) =&gt; { callSocketFunction(excludeMember, args); }); socket.on('includeMember', (...args) =&gt; { callSocketFunction(includeMember, args); }); socket.on('toggleOption', (...args) =&gt; { callSocketFunction(toggleOption, args); }); socket.on('createGame', (...args) =&gt; { callSocketFunction(createGame, args); }); socket.on('resetGame', (...args) =&gt; { callSocketFunction(resetGame, args); }); socket.on('startGame', (...args) =&gt; { callSocketFunction(startGame, args); }); socket.on('startAutoplay', (...args) =&gt; { callSocketFunction(startAutoplay, args); }); socket.on('nextDay', (...args) =&gt; { callSocketFunction(nextDay, args); }); socket.on('endGame', (...args) =&gt; { callSocketFunction(endGame, args); }); socket.on('pauseAutoplay', (...args) =&gt; { callSocketFunction(pauseAutoplay, args); }); socket.on('pauseGame', (...args) =&gt; { callSocketFunction(pauseGame, args); }); socket.on('editTeam', (...args) =&gt; { callSocketFunction(editTeam, args); }); socket.on('createEvent', (...args) =&gt; { callSocketFunction(createEvent, args); }); socket.on('createMajorEvent', (...args) =&gt; { callSocketFunction(createMajorEvent, args); }); socket.on('editMajorEvent', (...args) =&gt; { callSocketFunction(editMajorEvent, args); }); socket.on('removeEvent', (...args) =&gt; { callSocketFunction(removeEvent, args); }); socket.on('toggleEvent', (...args) =&gt; { callSocketFunction(toggleEvent, args); }); socket.on('forcePlayerState', (...args) =&gt; { callSocketFunction(forcePlayerState, args); }); socket.on('renameGame', (...args) =&gt; { callSocketFunction(renameGame, args); }); socket.on('removeNPC', (...args) =&gt; { callSocketFunction(removeNPC, args); }); socket.on('imageChunk', (...args) =&gt; { callSocketFunction(imageChunk, args); }); socket.on('imageInfo', (...args) =&gt; { callSocketFunction(imageInfo, args); }); // End Restricted Access \\\\ /** * Calls the functions with added arguments, and copies the request to all * sibling clients. * * @private * @param {Function} func The function to call. * @param {Array.&lt;*&gt;} args Array of arguments to send to function. * @param {boolean} [forward=true] Forward this request directly to all * siblings. */ function callSocketFunction(func, args, forward = true) { const noLog = ['fetchMember', 'fetchChannel', 'imageChunk']; if (!noLog.includes(func.name.toString())) { const logArgs = args.map((el) =&gt; { if (typeof el === 'function') { return (el.name || 'cb') + '()'; } else { return el; } }); self.common.logDebug(`${func.name}(${logArgs.join(',')})`, socket.id); } let cb; if (typeof args[args.length - 1] === 'function') { const origCB = args[args.length - 1]; let fired = false; cb = function(...args) { if (fired) { self.warn( 'Attempting to fire callback a second time! (' + func.name + ')'); } origCB(...args); fired = true; }; args[args.length - 1] = cb; } func.apply(func, [args[0], socket].concat(args.slice(1))); if (typeof cb === 'function') { args[args.length - 1] = {_function: true}; } if (forward) { Object.entries(siblingSockets).forEach((s) =&gt; { s[1].emit( 'forwardedRequest', args[0], socket.id, func.name, args.slice(1), (res) =&gt; { if (res._forward) socket.emit(...res.data); if (res._callback &amp;&amp; typeof cb === 'function') { cb(...res.data); } }); }); } } socket.on('disconnect', () =&gt; { self.common.log( 'Socket disconnected (' + (Object.keys(sockets).length - 1) + '): ' + ipName, socket.id); if (siblingSockets[socket.id]) delete siblingSockets[socket.id]; delete sockets[socket.id]; }); } /** * Handler for connecting as a client to the server. * * @private * @param {socketIo~Socket} socket The socket.io socket that connected. */ function clientSocketConnection(socket) { let authenticated = false; socket.on('connect', () =&gt; { socket.emit('vaderIAmYourSon', auth.hgWebSiblingVerification, (res) =&gt; { self.common.log('Sibling authenticated successfully.', socket.id); authenticated = res === auth.hgWebSiblingVerificationResponse; }); }); socket.on('fetchGuilds', (userData, id, cb) =&gt; { fetchGuilds(userData, {id: id}, cb); }); socket.on('forwardedRequest', (userData, sId, func, args, cb) =&gt; { if (!authenticated) return; const fakeSocket = { fake: true, emit: function(...args) { if (typeof cb == 'function') cb({_forward: true, data: args}); }, id: sId, }; if (args[args.length - 1]._function) { args[args.length - 1] = function(...a) { if (typeof cb === 'function') cb({_callback: true, data: a}); }; } if (!self[func]) { self.common.error(func + ': is not a function.', socket.id); } else { self[func].apply(self[func], [userData, fakeSocket].concat(args)); } }); } /** * This gets fired whenever the day state of any game changes in the hungry * games. This then notifies all clients that the state changed, if they care * about the guild. * * @private * @param {HungryGames} hg HG object firing the event. * @param {string} gId Guild id of the state change. * @listens HungryGames#dayStateChange */ function dayStateChange(hg, gId) { const keys = Object.keys(sockets); const game = hg.getHG().getGame(gId); let eventState = null; if (!game) return; if (game.currentGame.day.events[game.currentGame.day.state - 2] &amp;&amp; game.currentGame.day.events[game.currentGame.day.state - 2].battle) { eventState = game.currentGame.day.events[game.currentGame.day.state - 2].state; } for (const i in keys) { if (!sockets[keys[i]].cachedGuilds) continue; if (sockets[keys[i]].cachedGuilds.find((g) =&gt; g === gId)) { sockets[keys[i]].emit( 'dayState', gId, game.currentGame.day.num, game.currentGame.day.state, eventState); } } if (ioClient) { ioClient.emit( '_guildBroadcast', gId, 'dayState', gId, game.currentGame.day.num, game.currentGame.day.state, eventState); } } /** * Send a message to the given socket informing the client that the command * they attempted failed due to insufficient permission. * * @private * @param {Socket} socket The socket.io socket to reply on. * @param {string} cmd THe command the client attempted. */ function replyNoPerm(socket, cmd) { self.common.logDebug( 'Attempted ' + cmd + ' without permission.', socket.id); socket.emit( 'message', 'Failed to run command \"' + cmd + '\" because you don\\'t have permission for this.'); } /** * Checks if the current shard is responsible for the requested guild. * * @private * @param {number|string} gId The guild id to check. * @returns {boolean} True if this shard has this guild. */ function checkMyGuild(gId) { const g = self.client.guilds.get(gId); return (g &amp;&amp; true) || false; } /** * Check that the given user has permission to manage the games in the given * guild. * * @private * @param {UserData} userData The user to check. * @param {string} gId The guild id to check against. * @param {?string} cId The channel id to check against. * @param {string} cmd The command being attempted. * @returns {boolean} Whther the user has permission or not to manage the * hungry games in the given guild. */ function checkPerm(userData, gId, cId, cmd) { if (!userData) return false; const msg = makeMessage(userData.id, gId, cId, 'hg ' + cmd); if (!msg || !msg.author) return false; if (userData.id == self.common.spikeyId) return true; return !self.command.validate(null, msg); } /** * Check that the given user has permission to see and send messages in the * given channel, as well as manage the games in the given guild. * * @private * @param {UserData} userData The user to check. * @param {string} gId The guild id of the guild that contains the channel. * @param {string} cId The channel id to check against. * @param {string} cmd The command being attempted to check permisisons for. * @returns {boolean} Whther the user has permission or not to manage the * hungry games in the given guild and has permission to send messages in the * given channel. */ function checkChannelPerm(userData, gId, cId, cmd) { if (!checkPerm(userData, gId, cId, cmd)) return false; if (userData.id == self.common.spikeyId) return true; const g = self.client.guilds.get(gId); const channel = g.channels.get(cId); if (!channel) return false; const m = g.members.get(userData.id); const perms = channel.permissionsFor(m); if (!perms.has(self.Discord.Permissions.FLAGS.VIEW_CHANNEL)) return false; if (!perms.has(self.Discord.Permissions.FLAGS.SEND_MESSAGES)) return false; return true; } /** * Forms a Discord~Message similar object from given IDs. * * @private * @param {string} uId The id of the user who wrote this message. * @param {string} gId The id of the guild this message is in. * @param {?string} cId The id of the channel this message was 'sent' in. * @param {?string} msg The message content. * @returns { * { * author: Discord~User, * member: Discord~GuildMember, * guild: Discord~Guild, * channel: Discord~GuildChannel, * text: string, * content: string, * prefix: string * } * } The created message-like object. */ function makeMessage(uId, gId, cId, msg) { const g = self.client.guilds.get(gId); if (!g) return null; const prefix = self.bot.getPrefix(gId); return { member: g.members.get(uId), author: self.client.users.get(uId), guild: g, channel: g.channels.get(cId), text: msg, content: `${prefix}${msg}`, prefix: prefix, }; } /** * Strips a Discord~GuildMember to only the necessary data that a client will * need. * * @private * @param {Discord~GuildMember} m The guild member to strip the data from. * @returns {object} The minimal member. */ function makeMember(m) { if (typeof m !== 'object') { m = { roles: { array: function() { return []; }, }, guild: {}, permissions: {bitfield: 0}, user: self.client.users.get(m), }; } return { nickname: m.nickname, roles: m.roles.array(), color: m.displayColor, guild: {id: m.guild.id}, permissions: m.permissions.bitfield, user: { username: m.user.username, avatarURL: m.user.displayAvatarURL(), id: m.user.id, bot: m.user.bot, // m.user.descriminator seems to be broken and always returns // `undefined`. descriminator: m.user.tag.match(/#(\\d{4})$/)[1], }, joinedTimestamp: m.joinedTimestamp, }; } /** * Cancel and clean up a current image upload. * * @private * @param {string} iId Image upload ID to purge and abort. */ function cancelImageUpload(iId) { if (!imageBuffer[iId]) return; clearTimeout(imageBuffer[iId].timeout); delete imageBuffer[iId]; } /** * Create an upload ID and buffer for a client to send to. Automatically * cancelled after 60 seconds. * * @private * @param {string} uId The user ID that started this upload. * @returns {object} The metadata storing object. */ function beginImageUpload(uId) { let id; do { id = `${crypto.randomBytes(8).toString('hex').toUpperCase()}`; } while (imageBuffer[id]); imageBuffer[id] = {receivedBytes: 0, buffer: [], startTime: Date.now(), id: id, uId: uId}; imageBuffer[id].timeout = setTimeout(function() { cancelImageUpload(id); }, 60000); return imageBuffer[id]; } /** * Basic callback with single argument. The argument is null if there is no * error, or a string if there was an error. * @callback HGWeb~basicCB * * @param {?string} err The error response. */ /** * Fetch all relevant data for all mutual guilds with the user and send it to * the user. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchGuilds(userData, socket, cb) { if (!userData) { self.common.error('Fetch Guilds without userData', socket.id); if (typeof cb === 'function') cb('SIGNED_OUT'); return; } const numReplies = (Object.entries(siblingSockets).length || 0); let replied = 0; const guildBuffer = {}; let done; if (typeof cb === 'function') { done = cb; } else { /** * The callback for each response with the requested data. Replies to the * user once all requests have replied. * * @private * @param {string|object} guilds Either the guild data to send to the * user, or 'guilds' if this is a reply from a sibling client. * @param {?string} [err] The error that occurred, or null if no error. * @param {object} [response] The guild data if `guilds` equals 'guilds'. */ done = function(guilds, err, response) { if (guilds === 'guilds') { if (err) { guilds = null; } else { guilds = response; } } for (let i = 0; guilds &amp;&amp; i &lt; guilds.length; i++) { guildBuffer[guilds[i].id] = guilds[i]; } replied++; if (replied &gt; numReplies) { if (typeof cb === 'function') cb(guildBuffer); socket.emit('guilds', null, guildBuffer); socket.cachedGuilds = Object.keys(guildBuffer || {}); } }; } Object.entries(siblingSockets).forEach((obj) =&gt; { obj[1].emit('fetchGuilds', userData, socket.id, done); }); try { let guilds = []; if (userData.guilds &amp;&amp; userData.guilds.length &gt; 0) { userData.guilds.forEach((el) =&gt; { const g = self.client.guilds.get(el.id); if (!g) return; guilds.push(g); }); } else { guilds = self.client.guilds .filter((obj) =&gt; { return obj.members.get(userData.id); }) .array(); } const strippedGuilds = stripGuilds(guilds, userData); done(strippedGuilds); } catch (err) { self.common.error( 'Error while fetching guilds (Cached: ' + (userData.guilds &amp;&amp; true || false) + ')', socket.id); console.error(err); done(); } } this.fetchGuilds = fetchGuilds; /** * Strip a Discord~Guild to the basic information the client will need. * * @private * @param {Discord~Guild[]} guilds The array of guilds to strip. * @param {object} userData The current user's session data. * @returns {Array&lt;object&gt;} The stripped guilds. */ function stripGuilds(guilds, userData) { return guilds.map((g) =&gt; { let dOpts = self.command.getDefaultSettings() || {}; dOpts = Object.entries(dOpts) .filter((el) =&gt; { return el[1].getFullName().startsWith('hg'); }) .reduce( (p, c) =&gt; { p[c[0]] = c[1]; return p; }, {}); let uOpts = self.command.getUserSettings(g.id) || {}; uOpts = Object.entries(uOpts) .filter((el) =&gt; { return el[0].startsWith('hg'); }) .reduce( (p, c) =&gt; { p[c[0]] = c[1]; return p; }, {}); const member = g.members.get(userData.id); const newG = {}; newG.iconURL = g.iconURL(); newG.name = g.name; newG.id = g.id; newG.ownerId = g.ownerID; newG.members = g.members.map((m) =&gt; { return m.id; }); newG.defaultSettings = dOpts; newG.userSettings = uOpts; newG.channels = g.channels .filter((c) =&gt; { return userData.id == self.common.spikeyId || c.permissionsFor(member).has( self.Discord.Permissions.FLAGS.VIEW_CHANNEL); }) .map((c) =&gt; { return { id: c.id, permissions: userData.id == self.common.spikeyId ? self.Discord.Permissions.ALL : c.permissionsFor(member).bitfield, }; }); newG.myself = makeMember(member || userData.id); return newG; }); } /** * Fetch a single guild. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The ID of the guild that was requested. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchGuild(userData, socket, gId, cb) { if (!userData) { self.common.error('Fetch Guild without userData', socket.id); if (typeof cb === 'function') cb('SIGNED_OUT'); return; } if (typeof cb !== 'function') { self.common.logWarning( 'Fetch Guild attempted without callback', socket.id); return; } const guild = self.client.guilds.get(gId); if (!guild) { return; } if (userData.id != self.common.spikeyId &amp;&amp; !guild.members.get(userData.id)) { cb(null); return; } cb(stripGuilds([guild], userData)[0]); } this.fetchGuild = fetchGuild; /** * Fetch data about a member of a guild. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} mId The member's id to lookup. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchMember(userData, socket, gId, mId, cb) { if (!checkPerm(userData, gId, null, 'players')) return; const g = self.client.guilds.get(gId); if (!g) return; const m = g.members.get(mId); if (!m) return; const finalMember = makeMember(m); if (typeof cb === 'function') { cb(null, finalMember); } else { socket.emit('member', gId, mId, finalMember); } } this.fetchMember = fetchMember; /** * Fetch data about a channel of a guild. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} cId The channel's id to lookup. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchChannel(userData, socket, gId, cId, cb) { if (!checkChannelPerm(userData, gId, cId, '')) return; const g = self.client.guilds.get(gId); if (!g) return; const m = g.members.get(userData.id); const channel = g.channels.get(cId); const perms = channel.permissionsFor(m) || {bitfield: 0}; const stripped = {}; stripped.id = channel.id; stripped.permissions = perms.bitfield; stripped.name = channel.name; stripped.position = channel.position; if (channel.parent) stripped.parent = {position: channel.parent.position}; stripped.type = channel.type; if (typeof cb === 'function') { cb(null, stripped); } else { socket.emit('channel', gId, cId, stripped); } } this.fetchChannel = fetchChannel; /** * Fetch all game data within a guild. * * @see {@link HungryGames.getGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchGames(userData, socket, gId, cb) { if (!checkPerm(userData, gId, null, 'options') || !checkPerm(userData, gId, null, 'players')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'fetchGames'); return; } const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.fetchGames = fetchGames; /** * Fetch the updated game's day information. * * @see {@link HungryGames.getGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchDay(userData, socket, gId, cb) { let g; let m; if (!userData) { return; } else { g = self.client.guilds.get(gId); if (!g) { // Request is probably fulfilled by another sibling. return; } else { m = g.members.get(userData.id); if (!m) { self.common.log( 'Attempted fetchDay, but unable to find member in guild' + gId + '@' + userData.id, socket.id); return; } } } const game = hg().getHG().getGame(gId); if (!game || !game.currentGame || !game.currentGame.day) { if (typeof cb === 'function') { cb('NO_GAME_IN_GUILD'); } else { socket.emit( 'message', 'There doesn\\'t appear to be a game on this server yet.'); } return; } if (!g.channels.get(game.outputChannel) .permissionsFor(m) .has(self.Discord.Permissions.FLAGS.VIEW_CHANNEL)) { replyNoPerm(socket, 'fetchDay'); return; } if (typeof cb === 'function') { cb(null, game.currentGame.day, game.currentGame.includedUsers); } else { socket.emit( 'day', gId, game.currentGame.day, game.currentGame.includedUsers); } } this.fetchDay = fetchDay; /** * Exclude a member from the Games. * * @see {@link HungryGames.excludeUsers} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} mId The member id to exclude. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function excludeMember(userData, socket, gId, mId, cb) { if (!checkPerm(userData, gId, null, 'exclude')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'excludeMember'); return; } if (mId === 'everyone' || mId === 'online' || mId == 'offline' || mId == 'dnd' || mId == 'idle') { hg().excludeUsers(mId, gId, (res) =&gt; { if (typeof cb === 'function') cb(res); }); } else { hg().excludeUsers([mId], gId, (res) =&gt; { if (typeof cb === 'function') cb(res); }); } } this.excludeMember = excludeMember; /** * Include a member in the Games. * * @see {@link HungryGames.includeUsers} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} mId The member id to include. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function includeMember(userData, socket, gId, mId, cb) { if (!checkPerm(userData, gId, null, 'include')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'includeMember'); return; } if (mId === 'everyone' || mId === 'online' || mId == 'offline' || mId == 'dnd' || mId == 'idle') { hg().includeUsers(mId, gId, (res) =&gt; { if (typeof cb === 'function') cb(res); }); } else { hg().includeUsers([mId], gId, (res) =&gt; { if (typeof cb === 'function') cb(res); }); } } this.includeMember = includeMember; /** * Toggle an option in the Games. * * @see {@link HungryGames.setOption} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} option The option to change. * @param {string|number} value The value to set option to. * @param {string} extra The extra text if the option is in an object. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function toggleOption(userData, socket, gId, option, value, extra, cb) { if (!checkPerm(userData, gId, null, 'option')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'toggleOption'); return; } const response = hg().setOption(gId, option, value, extra || undefined); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, response, game &amp;&amp; game.options[option], game &amp;&amp; game.serializable); } else { if (game) { if (option === 'teamSize') { socket.emit('game', gId, game.serializable); } else { socket.emit('option', gId, option, game.options[option]); } } else { socket.emit('message', response); } } } this.toggleOption = toggleOption; /** * Create a Game. * * @see {@link HungryGames.createGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function createGame(userData, socket, gId, cb) { if (!checkPerm(userData, gId, null, 'create')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'createGame'); return; } hg().createGame(gId, (game) =&gt; { if (typeof cb === 'function') { cb(game ? null : 'ATTEMPT_FAILED', game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } }); } this.createGame = createGame; /** * Reset game data. * * @see {@link HungryGames.resetGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} cmd Command specifying what data to delete. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function resetGame(userData, socket, gId, cmd, cb) { if (!checkPerm(userData, gId, null, 'reset')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'resetGame'); return; } const response = hg().getHG().resetGame(gId, cmd); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, response, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.resetGame = resetGame; /** * Start the game. * * @see {@link HungryGames.startGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} cId Channel to start the game in. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function startGame(userData, socket, gId, cId, cb) { if (!checkChannelPerm(userData, gId, cId, 'start')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'startGame'); return; } hg().startGame(userData.id, gId, cId); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.startGame = startGame; /** * Enable autoplay. * * @see {@link HungryGames.startAutoplay} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} cId Channel to send the messages in. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function startAutoplay(userData, socket, gId, cId, cb) { if (!checkChannelPerm(userData, gId, cId, 'autoplay')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'startAutoplay'); return; } hg().startAutoplay(userData.id, gId, cId); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.startAutoplay = startAutoplay; /** * Start the next day. * * @see {@link HungryGames.nextDay} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} cId Channel to send the messages in. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function nextDay(userData, socket, gId, cId, cb) { if (!checkChannelPerm(userData, gId, cId, 'next')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'nextDay'); return; } hg().nextDay(userData.id, gId, cId); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.nextDay = nextDay; /** * End the game. * * @see {@link HungryGames.endGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function endGame(userData, socket, gId, cb) { if (!checkPerm(userData, gId, null, 'end')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'endGame'); return; } hg().endGame(userData.id, gId); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.endGame = endGame; /** * Disable autoplay. * * @see {@link HungryGames.pauseAutoplay} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function pauseAutoplay(userData, socket, gId, cb) { if (!checkPerm(userData, gId, null, 'autoplay')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'pauseAutoplay'); return; } hg().pauseAutoplay(userData.id, gId); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { cb(null, game &amp;&amp; game.serializable); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } this.pauseAutoplay = pauseAutoplay; /** * Pause game. * * @see {@link HungryGames.pauseGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function pauseGame(userData, socket, gId, cb) { if (!checkPerm(userData, gId, null, 'pause')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'pauseGame'); return; } const error = hg().pauseGame(gId); const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { if (error !== 'Success') { cb(error); } else { cb(null, game &amp;&amp; game.serializable); } } else { if (error !== 'Success') { socket.emit('message', error); } else { socket.emit('game', gId, game &amp;&amp; game.serializable); } } } this.pauseGame = pauseGame; /** * Edit the teams. * * @see {@link HungryGames.editTeam} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} cmd The command to run. * @param {string} one The first argument. * @param {string} two The second argument. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function editTeam(userData, socket, gId, cmd, one, two, cb) { if (!checkPerm(userData, gId, null, 'team')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'editTeam'); return; } const message = hg().editTeam(userData.id, gId, cmd, one, two); if (typeof cb === 'function') { cb(null, message); } else { if (message) socket.emit('message', message); } } this.editTeam = editTeam; /** * Create a game event. * * @see {@link HungryGames.createEvent} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} type The type of event. * @param {string} message The message of the event. * @param {string} nV Number of victims. * @param {string} nA Number of attackers. * @param {string} oV Outcome of victims. * @param {string} oA Outcome of attackers. * @param {string} kV Do the victims kill. * @param {string} kA Do the attackers kill. * @param {?object} wV The weapon information for this event. * @param {?object} wA The weapon information for this event. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function createEvent( userData, socket, gId, type, message, nV, nA, oV, oA, kV, kA, wV, wA, cb) { if (!checkPerm(userData, gId, null, 'event')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'createEvent'); return; } const err = hg().makeAndAddEvent( gId, type, message, nV, nA, oV, oA, kV, kA, wV, wA); if (err) { if (typeof cb === 'function') { cb('ATTEMPT_FAILED'); } else { socket.emit('message', 'Failed to create event: ' + err); } } else { const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { if (game) { cb(null, game.serializable); } else { cb(); } } else if (game) { socket.emit('game', gId, game.serializable); } } } this.createEvent = createEvent; /** * Create a larger game event. Either Arena or Weapon at this point. If * message or weapon name already exists, this will instead edit the event. * * @see {@link HungryGames.addMajorEvent} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} type The type of event. * @param {HungryGames~ArenaEvent|HungryGames~WeaponEvent} data The event * data. * @param {?string} name The name of the weapon if this is a weapon event. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function createMajorEvent(userData, socket, gId, type, data, name, cb) { if (!checkPerm(userData, gId, null, 'event')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'createMajorEvent'); return; } const err = hg().addMajorEvent(gId, type, data, name); if (err) { if (typeof cb === 'function') { cb('ATTEMPT_FAILED'); } else { socket.emit('message', 'Failed to create event: ' + err); } } else { const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { if (game) { cb(null, game.serializable); } else { cb(); } } else if (game) { socket.emit('game', gId, game.serializable); } } } this.createMajorEvent = createMajorEvent; /** * Delete a larger game event. Either Arena or Weapon at this point. * * @see {@link HungryGames.editMajorEvent} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} type The type of event. * @param {HungryGames~ArenaEvent|HungryGames~WeaponEvent} search The event * data to find to edit. * @param {HungryGames~ArenaEvent|HungryGames~WeaponEvent} data The event * data to set the matched searches to. * @param {?string} name The internal name of the weapon to find. * @param {?string} newName The new internal name of the weapon. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function editMajorEvent( userData, socket, gId, type, search, data, name, newName, cb) { if (!checkPerm(userData, gId, null, 'event')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'removeMajorEvent'); return; } const err = hg().editMajorEvent(gId, type, search, data, name, newName); if (err) { if (typeof cb === 'function') { cb('ATTEMPT_FAILED'); } else { socket.emit('message', 'Failed to edit event: ' + err); } } else { const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { if (game) { cb(null, game.serializable); } else { cb(); } } else if (game) { socket.emit('game', gId, game.serializable); } } } this.editMajorEvent = editMajorEvent; /** * Remove a game event. * * @see {@link HungryGames.removeEvent} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} type The type of event. * @param {HungryGames~Event} event The game event to remove. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function removeEvent(userData, socket, gId, type, event, cb) { if (!checkPerm(userData, gId, null, 'event')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'removeEvent'); return; } const err = hg().removeEvent(gId, type, event); if (err) { if (typeof cb === 'function') { cb('ATTEMPT_FAILED'); } else { socket.emit('message', 'Failed to remove event: ' + err); } } else { const game = hg().getHG().getGame(gId); if (typeof cb === 'function') { if (game) { cb(null, game.serializable); } else { cb(); } } else if (game) { socket.emit('game', gId, game.serializable); } } } this.removeEvent = removeEvent; /** * @description Enable or disable an event without deleting it. * @see {@link HungryGames.toggleEvent} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo-Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to run this command on. * @param {string} type The type of event that we are toggling. * @param {?string} subCat The subcategory if necessary. * @param { * HungryGames~Event| * HungryGames~ArenaEvent| * HungryGames~WeaponEvent * } event The event to toggle. * @param {?boolean} value Set the enabled value instead of toggling. * @param {basicCB} [cb] Callback that fires once the requested action is * complete. */ function toggleEvent(userData, socket, gId, type, subCat, event, value, cb) { if (!checkPerm(userData, gId, null, 'event')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'removeEvent'); return; } const err = hg().toggleEvent(gId, type, subCat, event, value); if (err) { if (typeof cb === 'function') { cb('ATTEMPT_FAILED'); } else { socket.emit('message', 'Failed to toggle event: ' + err); } } else { if (typeof cb === 'function') cb(); // socket.emit('message', 'Toggled event.'); // socket.emit('game', gId, hg().getHG().getGame(gId)); } } this.toggleEvent = toggleEvent; /** * Force a player in the game to end a day in a certain state. * * @see {@link HungryGames.forcePlayerState} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo-Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to run this command on. * @param {string[]} list The list of user IDs of the players to effect. * @param {string} state The forced state. * @param {string} [text] The message to show in the games as a result of this * command. * @param {boolean} [persists] Will this state be forced until the game ends. * @param {basicCB} [cb] Callback that fires once the requested action is * complete. */ function forcePlayerState( userData, socket, gId, list, state, text, persists, cb) { let cmdToCheck = state; switch (state) { case 'living': case 'thriving': cmdToCheck = 'heal'; break; case 'dead': cmdToCheck = 'kill'; break; case 'wounded': cmdToCheck = 'hurt'; break; } if (!checkPerm(userData, gId, null, cmdToCheck)) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'forcePlayerState'); return; } const game = hg().getHG().getGame(gId); if (!game) return; if (typeof text != 'string') text = hg().getHG()._defaultPlayerEvents; const response = HungryGames.GuildGame.forcePlayerState( game, list, state, hg().getHG().messages, text, persists); if (typeof cb === 'function') { cb(null, response, game.serializable); } else { socket.emit('message', response); } } this.forcePlayerState = forcePlayerState; /** * Rename the guild's game. * * @see {@link HungryGames.renameGame} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo-Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to run this command on. * @param {string} name The name to change the game to. * @param {basicCB} [cb] Callback that fires once the requested action is * complete. */ function renameGame(userData, socket, gId, name, cb) { if (!checkPerm(userData, gId, null, 'rename')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'renameGame'); return; } hg().renameGame(gId, name); if (typeof cb === 'function') { let name = null; let game = hg().getHG().getGame(gId); if (game) game = game.currentGame; if (game) name = game.name; cb(name); } } this.renameGame = renameGame; /** * Remove an NPC from a game. * * @see {@link HungryGames.removeNPC} * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo-Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to run this command on. * @param {string} npcId The ID of the NPC to remove. * @param {basicCB} [cb] Callback that fires once the requested action is * complete. */ function removeNPC(userData, socket, gId, npcId, cb) { if (!checkPerm(userData, gId, null, 'ai remove')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'removeNPC'); return; } const error = hg().removeNPC(gId, npcId); if (typeof cb === 'function') { cb(typeof error === 'string' ? error : null); } } this.removeNPC = removeNPC; /** * Handle receiving image data for avatar uploading. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {string} iId The image ID that is being uploaded. * @param {string} chunkId Id of the chunk being received. * @param {?Buffer} chunk Chunk of data received, or null if all data has been * sent. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function imageChunk(userData, socket, gId, iId, chunkId, chunk, cb) { const meta = imageBuffer[iId]; if (!meta) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'imageChunk'); return; } if (meta.uId != userData.id) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'imageChunk'); return; } if (meta.type == 'NPC') { if (!checkPerm(userData, gId, null, 'ai create')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'imageChunk'); cancelImageUpload(iId); return; } } else { self.common.logWarning( 'Unknown image type attempted to be uploaded: ' + meta.type, socket.id); cancelImageUpload(iId); } if (chunk) { chunk = Buffer.from(chunk); meta.receivedBytes += chunk.length; if (isNaN(chunkId * 1)) { cancelImageUpload(iId); if (typeof cb === 'function') cb('Malformed Data'); return; } else if (meta.receivedBytes &gt; hg().maxBytes) { cancelImageUpload(iId); if (typeof cb === 'function') cb('Data Overflow'); return; } meta.buffer[chunkId] = chunk; if (typeof cb === 'function') cb(chunkId); return; } if (meta.type == 'NPC') { const npcId = hg().NPC.createID(); const p = hg().NPC.saveAvatar(Buffer.concat(meta.buffer), npcId); if (!p) { cancelImageUpload(iId); if (typeof cb === 'function') cb('Malformed Data'); return; } p.then((url) =&gt; { const error = hg().createNPC(gId, meta.username, url, npcId); const game = hg().getHG().getGame(gId); cancelImageUpload(iId); if (typeof cb === 'function') { cb(error, game &amp;&amp; game.serializable); } else if (error) { socket.emit('message', error); } self.common.logDebug( 'NPC Created from upload with URL: ' + url, socket.id); }).catch(() =&gt; { cancelImageUpload(iId); if (typeof cb === 'function') cb('Malformed Data'); }); } else { self.common.logWarning( 'Unknown upload type completed. Data is being deleted. (' + meta.type + ')', socket.id); if (typeof cb === 'function') cb(); cancelImageUpload(iId); } } this.imageChunk = imageChunk; /** * Handle client requesting to begin image upload. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {object} meta Metadata to associate with this upload. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. If succeeded, an upload ID will be passed as the * second parameter. Any error will be the first parameter. */ function imageInfo(userData, socket, gId, meta, cb) { if (!meta || typeof meta.type !== 'string' || isNaN(meta.contentLength * 1)) { if (typeof cb === 'function') cb('Malformed Data'); return; } if (meta.type === 'NPC') { if (meta.contentLength &gt; hg().maxBytes) { if (typeof cb === 'function') cb('Excessive Payload'); return; } if (typeof meta.username !== 'string') { if (typeof cb === 'function') cb('Malformed Data'); return; } meta.username = hg().formatUsername(meta.username); if (meta.username.length &lt; 2) { if (typeof cb === 'function') cb('Malformed Data'); return; } if (!checkPerm(userData, gId, null, 'ai create')) { if (!checkMyGuild(gId)) return; if (typeof cb === 'function') cb('NO_PERM'); replyNoPerm(socket, 'imageInfo'); return; } const buf = beginImageUpload(userData.id); buf.username = meta.username; buf.type = meta.type; if (typeof cb === 'function') cb(null, buf.id); } else { if (typeof cb === 'function') cb('NO_PERM'); } } this.imageInfo = imageInfo; } module.exports = new HGWeb(); × Search results Close "},"hg_HungryGames.js.html":{"id":"hg_HungryGames.js.html","title":"Source: hg/HungryGames.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/HungryGames.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const mkdirp = require('mkdirp'); // mkdir -p const rimraf = require('rimraf'); // rm -rf const yj = require('yieldable-json'); /** * Contains a Hunger Games style simulation. */ class HungryGames { /** * @description HungryGames constructor. Currently requires a valid SubModule * as a parent. * @todo Remove reliance on SubModule. * @param {SubModule} parent Parent submodule used to hook logging into. */ constructor(parent) { /** * Parent subModule for logging and bot hooking. * @private * @type {HG} * @constant */ this._parent = parent; /** * Current {@link HungryGames~Messages} instance. * @public * @type {HungryGames~Messages} * @constant */ this.messages = new HungryGames.Messages(); /** * Default game options. * @public * @type {HungryGames~DefaultOptions} * @constant */ this.defaultOptions = new HungryGames.DefaultOptions(); /** * All currently tracked games. Mapped by guild ID. In most cases you should * NOT reference this directly. Use {@link HungryGames#getGame} to get the * game object for a guild. * @see {@link HungryGames#getGame} * * @private * @type {Object.&lt;HungryGames~GuildGame&gt;} * @default * @constant */ this._games = {}; /** * Stores the guilds we have looked for their data recently and the * timestamp at which we looked. Used to reduce filesystem requests and * blocking. * * @private * @type {Object.&lt;number&gt;} * @constant */ this._findTimestamps = {}; /** * The delay after failing to find a guild's data to look for it again. * * @private * @type {number} * @constant * @default 15 Seconds */ this._findDelay = 15000; /** * Maximum amount of milliseconds long running operations are allowed to * take to prevent cpu deadlock. * @public * @type {number} * @constant * @default */ this.maxDelta = 5; /** * The file path to save current state for a specific guild relative to * Common#guildSaveDir. * @see {@link Common#guildSaveDir} * @see {@link HungryGames#_games} * @see {@link HungryGames#_hgSaveDir} * * @private * @type {string} * @constant * @default */ this._saveFile = 'game.json'; /** * The file directory for finding saved data related to the hungry games * data of individual guilds. * @see {@link Common#guildSaveDir} * @see {@link HungryGames#_games} * @see {@link HungryGames#_saveFile} * * @private * @type {string} * @constant * @default */ this._hgSaveDir = '/hg/'; /** * Array of all events that can take place in the bloodbath by default. * * @private * @type {HungryGames~Event[]} * @default */ this._defaultBloodbathEvents = []; /** * Array of all events that can take place normally by default. * * @private * @type {HungryGames~Event[]} * @default */ this._defaultPlayerEvents = []; /** * Array of all arena events that can take place normally by default. * * @private * @type {HungryGames~ArenaEvent[]} * @default */ this._defaultArenaEvents = []; /** * Array of all battles that can take place normally by default. * * @private * @type {HungryGames~Battle[]} * @default */ this._defaultBattles = []; /** * Array of all weapons that can be used normally by default. * * @private * @type {HungryGames~Weapon[]} * @default */ this._defaultWeapons = []; } /** * @description The file path to save current state for a specific guild * relative to Common#guildSaveDir. * @see {@link Common#guildSaveDir} * @see {@link HungryGames#_games} * @see {@link HungryGames#_saveFile} * @see {@link HungryGames#_hgSaveDir} * * @public * @returns {string} Save file name. */ get saveFile() { return this._saveFile; } /** * @description The file directory for finding saved data related to the * hungry games data of individual guilds. * @see {@link Common#guildSaveDir} * @see {@link HungryGames#_games} * @see {@link HungryGames#_saveFile} * @see {@link HungryGames#_hgSaveDir} * * @public * @returns {string} Save dir path. */ get hgSaveDir() { return this._hgSaveDir; } /** * @description Returns a reference to the current games object for a given * guild. * * @public * @param {string} id The guild id to get the data for. * @returns {?HungryGames~GuildGame} The current object storing all data about * game in a guild. */ getGame(id) { return this._find(id); } /** * @description Similar to {@link HungryGames.getGame} except asyncronous and * fetched game is passed as callback argument. * * @public * @param {string} id The guild id to get the data for. * @param {Function} cb Callback with single argument. Null if unable to be * found, {@link HungryGames~GuildGame} if found. */ fetchGame(id, cb) { this._find(id, cb); } /** * @description Update the reference to the array storing default bloodbath * events. * * @public * @param {HungryGames~Event[]} list Array to reference. */ setDefaultBloodbathEvents(list) { this._defaultBloodbathEvents = list; } /** * @description Update the reference to the array storing default player * events. * * @public * @param {HungryGames~Event[]} list Array to reference. */ setDefaultPlayerEvents(list) { this._defaultPlayerEvents = list; } /** * @description Update the reference to the array storing default arena * events. * * @public * @param {HungryGames~ArenaEvent[]} list Array to reference. */ setDefaultArenaEvents(list) { this._defaultArenaEvents = list; } /** * @description Update the reference to the array storing default battles * events. * * @public * @param {HungryGames~Battle[]} list Array to reference. */ setDefaultBattles(list) { this._defaultBattles = list; } /** * @description Update the reference to the array storing default weapons * events. * * @public * @param {HungryGames~Weapon[]} list Array to reference. */ setDefaultWeapons(list) { this._defaultWeapons = list; } /** * @description Create a new GuildGame. * @public * @param {external:Discord~Guild|string} guild Guild object, or ID to create * a game for. * @param {Function} [cb] Callback once game has been fully created. Passes * the created game as the only argument. */ create(guild, cb) { if (!(guild instanceof this._parent.Discord.Guild)) { guild = this._parent.client.guilds.get(guild); } const optKeys = this.defaultOptions.keys; const opts = {}; for (const key of optKeys) { if (typeof key !== 'string') continue; if (typeof this.defaultOptions[key].value === 'object') { opts[key] = Object.assign({}, this.defaultOptions[key].value); } else { opts[key] = this.defaultOptions[key].value; } } if (guild.memberCount &gt; 100) { opts.excludeNewUsers = true; } this.getAllPlayers(guild.members, [], false, [], false, [], (res) =&gt; { this._games[guild.id] = new HungryGames.GuildGame( this._parent.client.user.id, guild.id, opts, `${guild.name}'s Hungry Games`, res); cb(this._games[guild.id]); }); } /** * @description Create a new Game for a guild, and refresh the player lists. * @public * @param {external:Discord~Guild|string} guild Guild object, or ID to refresh * a game for. * @param {Function} [cb] Callback once game has been fully refreshed. Passes * the refreshed game as the only argument, or null if unable to find the * game. */ refresh(guild, cb) { if (!(guild instanceof this._parent.Discord.Guild)) { guild = this._parent.client.guilds.get(guild); } this.fetchGame(guild.id, (game) =&gt; { if (!game) { cb(null); return; } const name = (game.currentGame &amp;&amp; game.currentGame.customName) || (`${guild.name}'s Hungry Games`); const teams = game.currentGame &amp;&amp; game.currentGame.teams; this.getAllPlayers( guild.members, game.excludedUsers, game.options.includeBots, game.includedUsers, game.options.excludeNewUsers, game.includedNPCs, (res) =&gt; { game.currentGame = new HungryGames.Game(name, res, teams); cb(game); }); }); } /** * Form an array of Player objects based on guild members, excluded members, * and whether to include bots. * * @public * @param {external:Discord~Collection&lt;external:Discord~GuildMember&gt;} members * All members in guild. * @param {string[]} excluded Array of ids of users that should not be * included in the games. * @param {boolean} bots Should bots be included in the games. * @param {string[]} included Array of ids of users that should be included in * the games. Used if excludeByDefault is true. * @param {boolean} excludeByDefault Should new users be excluded from the * game by default? * @param {NPC[]} [includedNPCs=[]] NPCs to include as players. * @param {basicCB} cb Callback on completion. Only argument is array of * {@link HungryGames~Player} to include in the games. */ getAllPlayers( members, excluded, bots, included, excludeByDefault, includedNPCs, cb) { const iTime = Date.now(); const finalMembers = []; const self = this; if (!Array.isArray(excluded)) excluded = []; const memList = Array.isArray(members) ? members : members.array(); const memberIterate = function(obj) { if (obj.isNPC) return; if (included &amp;&amp; excluded &amp;&amp; !included.includes(obj.user.id) &amp;&amp; !excluded.includes(obj.user.id)) { if (excludeByDefault) { excluded.push(obj.user.id); } else { included.push(obj.user.id); } } else if ( included &amp;&amp; excluded &amp;&amp; included.includes(obj.user.id) &amp;&amp; excluded.includes(obj.user.id)) { self._parent.error( 'User in both blacklist and whitelist: ' + obj.user.id + ' Guild: ' + obj.guild.id); if (excludeByDefault) { included.splice(included.findIndex((el) =&gt; el == obj.user.id), 1); } else { excluded.splice(excluded.findIndex((el) =&gt; el == obj.user.id), 1); } } const toInclude = !( (!bots &amp;&amp; obj.user.bot) || (excluded &amp;&amp; excluded.includes(obj.user.id) || (excludeByDefault &amp;&amp; included &amp;&amp; !included.includes(obj.user.id)))); if (toInclude) { finalMembers.push( new HungryGames.Player( obj.id, obj.user.username, obj.user.displayAvatarURL({format: 'png'}), obj.nickname)); } }; let iTime2 = 0; const done = function() { const now = Date.now(); const start = iTime2 - iTime; const total = now - iTime; if (start &gt; 10 || total &gt; 10) { self._parent.debug( `GetAllPlayers ${finalMembers.length} ${start} ${total}`); } cb(finalMembers); }; const memberStep = function(i) { const start = Date.now(); if (i &lt; memList.length) { for (i; Date.now() - start &lt; self.maxDelta &amp;&amp; i &lt; memList.length; i++) { memberIterate(memList[i]); } setTimeout(() =&gt; memberStep(i)); } else if (includedNPCs &amp;&amp; i - memList.length &lt; includedNPCs.length) { for (i; Date.now() - start &lt; self.maxDelta &amp;&amp; i - memList.length &lt; includedNPCs.length; i++) { const obj = includedNPCs[i - memList.length]; finalMembers.push( new self._parent.NPC(obj.name, obj.avatarURL, obj.id)); } setTimeout(() =&gt; memberStep(i)); } else { done(); } }; iTime2 = Date.now(); memberStep(0); } /** * Reset the specified category of data from a game. * * @public * @param {string} id The id of the guild to modify. * @param {string} command The category of data to reset. * @returns {string} The message explaining what happened. */ resetGame(id, command) { const game = this.getGame(id); if (!game) { return 'There is no data to reset.'; } if (game.currentGame &amp;&amp; game.currentGame.inProgress) { return 'A game is currently in progress. Please end it before ' + 'reseting game data.'; } if (command == 'all') { delete this._games[id]; rimraf(this._parent.common.guildSaveDir + id + this.hgSaveDir, (err) =&gt; { if (!err) return; this._parent.error( 'Failed to delete directory: ' + this._parent.common.guildSaveDir + id + this.hgSaveDir); console.error(err); }); return 'Resetting ALL Hungry Games data for this server!'; } else if (command == 'events') { game.customEvents = {bloodbath: [], player: [], arena: [], weapon: {}}; return 'Resetting ALL Hungry Games events for this server!'; } else if (command == 'current') { game.currentGame = null; return 'Resetting ALL data for current game!'; } else if (command == 'options') { const optKeys = this.defaultOptions.keys; game.options = {}; for (const key of optKeys) { game.options[key] = this.defaultOptions[key].value; } return 'Resetting ALL options!'; } else if (command == 'teams') { game.currentGame.teams = []; game.formTeams(); return 'Resetting ALL teams!'; } else if (command == 'users') { game.includedUsers = []; game.excludedUsers = []; this.refresh(id, () =&gt; {}); return 'Resetting ALL user data!'; } else if (command == 'npcs') { game.includedNPCs = []; game.excludedNPCs = []; this.refresh(id, () =&gt; {}); return 'Resetting ALL NPC data!'; } else { return 'Please specify what data to reset.\\nall {deletes all data ' + 'for this server},\\nevents {deletes all custom events},\\n' + 'current {deletes all data about the current game},\\noptions ' + '{resets all options to default values},\\nteams {delete all ' + 'teams and creates new ones},\\nusers {delete data about where to ' + 'put users when creating a new game},\\nnpcs {delete all NPCS}.'; } } /** * @description Returns a guild's game data. Returns cached version if that * exists, or searches the file system for saved data. Data will only be * checked from disk at most once every `HungryGames~findDelay` milliseconds. * Returns `null` if data could not be found, or an error occurred. * * @private * @param {number|string} id The guild id to get the data for. * @param {Function} [cb] Callback to fire once complete. This becomes * asyncronous if given, if not given this function is syncronous. Single * parameter is null if not found, or {@link HungryGames~GuildGame} if found. * @returns {?HungryGames~GuildGame} The game data, or null if no game could * be loaded or loading asyncronously because a callback was given. */ _find(id, cb) { const a = typeof cb === 'function'; if (!a) cb = function() {}; const now = Date.now(); if (this._games[id]) { this._findTimestamps[id] = now; cb(this._games[id]); return this._games[id]; } if (now - this._findTimestamps[id] &lt; this._findDelay) { cb(null); return null; } this._findTimestamps[id] = now; const self = this; const parse = function(game) { if (!game.bot) game.bot = self._parent.client.user.id; try { game = HungryGames.GuildGame.from(game); game.id = id; } catch (err) { self._parent.error('Failed to parse game data for guild ' + id); return null; } // Flush default and stale options. if (game.options) { for (const opt of self.defaultOptions.keys) { if (!(self.defaultOptions[opt] instanceof Object)) continue; if (typeof game.options[opt] !== typeof self.defaultOptions[opt].value) { if (self.defaultOptions[opt].value instanceof Object) { game.options[opt] = Object.assign({}, self.defaultOptions[opt].value); } else { game.options[opt] = self.defaultOptions[opt].value; } } else if (self.defaultOptions[opt].value instanceof Object) { const dKeys = Object.keys(self.defaultOptions[opt].value); dKeys.forEach((el) =&gt; { if (typeof game.options[opt][el] !== typeof self.defaultOptions[opt].value[el]) { game.options[opt][el] = self.defaultOptions[opt].value[el]; } }); } } for (const opt in game.options) { if (!(game.options[opt] instanceof Object)) continue; if (typeof self.defaultOptions[opt] === 'undefined') { delete game.options[opt]; } else if (game.options[opt].value instanceof Object) { const keys = Object.keys(game.options[opt].value); keys.forEach((el) =&gt; { if (typeof game.options[opt][el] !== typeof self.defaultOptions[opt].value[el]) { delete game.options[opt][el]; } }); } } } // If the bot stopped while simulating a day, just start over and try // again. if (game &amp;&amp; game.currentGame &amp;&amp; game.currentGame.day &amp;&amp; game.currentGame.day.state === 1) { game.currentGame.day.state = 0; } return game; }; const filename = this._parent.common.guildSaveDir + id + this.hgSaveDir + this.saveFile; if (a) { fs.readFile(filename, (err, data) =&gt; { if (err) { if (err.code === 'ENOENT') { cb(null); return; } else { this._parent.debug('Failed to load game data for guild:' + id); console.error(err); } } yj.parseAsync(data.toString(), (err, parsed) =&gt; { if (err) { this._parent.error( 'Failed to parse game data:' + id + ' Falling back to JSON.parse'); console.error(err); try { parsed = JSON.parse(data); } catch (err) { this._parent.error('Failed to parse using JSON.parse'); console.error(err); return; } } this._games[id] = parse(parsed); cb(this._games[id]); }); }); } else { try { const tmp = fs.readFileSync(filename); try { this._games[id] = JSON.parse(tmp); if (this._parent.initialized) { this._parent.debug('Loaded game from file ' + id); } } catch (e2) { this._parent.error('Failed to parse game data for guild ' + id); return null; } } catch (e) { if (e.code !== 'ENOENT') { this._parent.debug('Failed to load game data for guild:' + id); console.error(e); } return null; } return this._games[id] = parse(this._games[id]); } } /** * @description Save all HG related data to file. Purges old data from memory * as well. * @public * @param {string} [opt='sync'] Can be 'async', otherwise defaults to * synchronous. */ save(opt) { Object.entries(this._games).forEach((obj) =&gt; { const id = obj[0]; const data = obj[1].serializable; const dir = this._parent.common.guildSaveDir + id + this.hgSaveDir; const filename = dir + this.saveFile; const saveStartTime = Date.now(); if (opt == 'async') { mkdirp(dir, (err) =&gt; { if (err) { this._parent.error('Failed to create directory for ' + dir); console.error(err); return; } let stringified; try { stringified = JSON.stringify(data); } catch (err) { this._parent.error('Failed to stringify synchronously'); console.error(err); return; } fs.writeFile(filename, stringified, (err2) =&gt; { if (err2) { this._parent.error('Failed to save HG data for ' + filename); console.error(err2); } else if ( this._findTimestamps[id] - saveStartTime &lt; -15 * 60 * 1000) { delete this._games[id]; delete this._findTimestamps[id]; this._parent.debug(`Purged ${id}`); } }); }); } else { try { mkdirp.sync(dir); } catch (err) { this._parent.error('Failed to create directory for ' + dir); console.error(err); return; } try { fs.writeFileSync(filename, JSON.stringify(data)); } catch (err) { this._parent.error('Failed to save HG data for ' + filename); console.error(err); return; } if (this._findTimestamps[id] - Date.now() &lt; -15 * 60 * 1000) { delete this._games[id]; delete this._findTimestamps[id]; this._parent.debug('Purged ' + id); } } }); } /** * @description End all event listeners, intervals, and timeouts to prepare * for a full stop. * @public */ shutdown() { Object.values(this._games).forEach((el) =&gt; { el.clearIntervals(); }); this.messages.shutdown(); } } /** * @description Wrapper for normal `require()` but also deletes cache reference * to object before requiring. This forces the object to be updated. * * @memberof HungryGames * * @private * @param {string} name Name of module to require. * @returns {object} The required module. */ function tmpRequire(name) { delete require.cache[require.resolve(name)]; return require(name); } HungryGames.DefaultOptions = tmpRequire('./DefaultOptions.js'); HungryGames.ForcedOutcome = tmpRequire('./ForcedOutcome.js'); HungryGames.Grammar = tmpRequire('./Grammar.js'); HungryGames.FinalEvent = tmpRequire('./FinalEvent.js'); HungryGames.ArenaEvent = tmpRequire('./ArenaEvent.js'); HungryGames.WeaponEvent = tmpRequire('./WeaponEvent.js'); HungryGames.Battle = tmpRequire('./Battle.js'); HungryGames.OutcomeProbabilities = tmpRequire('./OutcomeProbabilities.js'); HungryGames.Day = tmpRequire('./Day.js'); HungryGames.Messages = tmpRequire('./Messages.js'); HungryGames.UserIconUrl = tmpRequire('./UserIconUrl.js'); HungryGames.Player = tmpRequire('./Player.js'); HungryGames.Team = tmpRequire('./Team.js'); HungryGames.Game = tmpRequire('./Game.js'); HungryGames.Event = tmpRequire('./Event.js'); HungryGames.Stats = tmpRequire('./Stats.js'); HungryGames.StatGroup = tmpRequire('./StatGroup.js'); HungryGames.StatManager = tmpRequire('./StatManager.js'); HungryGames.GuildGame = tmpRequire('./GuildGame.js'); HungryGames.Simulator = tmpRequire('./Simulator.js'); module.exports = HungryGames; × Search results Close "},"hg_ArenaEvent.js.html":{"id":"hg_ArenaEvent.js.html","title":"Source: hg/ArenaEvent.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/ArenaEvent.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description An Arena event storing Events. * @memberof HungryGames * @inner */ class ArenaEvent { /** * @param {string} message The message at the start of the arena event. * @param {HungryGames~Event[]} outcomes All possible events in this arena * event. * @param {?HungryGames~OutcomeProbabilities} outcomeProbs Overrides the * global setting for arena event outcome probabilities for this event. */ constructor(message, outcomes, outcomeProbs) { /** * Message sent at the start of the arena event. * @public * @type {string} */ this.message = message; /** * All possible events in this arena event. * @public * @type {HungryGames~Event[]} */ this.outcomes = outcomes; /** * Outcome probabilities specific to this arena event. Overrides the global * arena event outcome probability settings. Null to use global settings. * @public * @type {?HungryGames~OutcomeProbabilities} */ this.outcomeProbs = outcomeProbs; } } module.exports = ArenaEvent; × Search results Close "},"hg_Battle.js.html":{"id":"hg_Battle.js.html","title":"Source: hg/Battle.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Battle.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const Event = require('./Event.js'); /** * @description A single battle in an Event. * @memberof HungryGames * @inner */ class Battle { /** * @description Create a single battle. * @param {string} message The message of this battle event. * @param {number} attacker The damage done to the attacker. * @param {number} victim The damage done to the victim. */ constructor(message, attacker, victim) { /** * Message of this battle event. * @public * @type {string} */ this.message = message; /** * Information about attacker. * @public * @type {{damage: number}} */ this.attacker = {damage: attacker}; /** * Information about victim. * @public * @type {{damage: number}} */ this.victim = {damage: victim}; } } /** * The file path to read attacking left image. * * @private * @static * @type {string} * @constant * @default */ Battle._fistLeft = './img/fist_left.png'; /** * The file path to read attacking right image. * * @private * @static * @type {string} * @constant * @default */ Battle._fistRight = './img/fist_right.png'; /** * The file path to read attacking both directions image. * * @private * @static * @type {string} * @constant * @default */ Battle._fistBoth = './img/fist_both.png'; /** * Make an event that contains a battle between players before the main event * message. * * @public * @param {HungryGames~Player[]} affectedUsers All of the players involved in * the event. * @param {number} numVictim The number of victims in this event. * @param {number} numAttacker The number of attackers in this event. * @param {boolean} mention Should every player be mentioned when their name * comes up? * @param {HungryGames~GuildGame} game The GuildGame this battle is for. This is * for settings checking and fetching non-affected users. * @param {HungryGames~Battle[]} battles Array of all possible battle events to * choose from. * @returns {HungryGames~Event} The event that was created. */ Battle.finalize = function( affectedUsers, numVictim, numAttacker, mention, game, battles) { const useNicknames = game.options.useNicknames == 'all'; const outcomeMessage = battles.outcomes[Math.floor(Math.random() * battles.outcomes.length)]; const finalEvent = Event.finalize( outcomeMessage, affectedUsers.slice(0), numVictim, numAttacker, 'dies', 'nothing', game); finalEvent.attacker.killer = true; finalEvent.battle = true; finalEvent.state = 0; finalEvent.attacks = []; const userHealth = new Array(affectedUsers.length).fill(0); const maxHealth = game.options.battleHealth * 1; let numAlive = numVictim; let duplicateCount = 0; let lastAttack = {index: 0, attacker: 0, victim: 0, flipRoles: false}; const startMessage = battles.starts[Math.floor(Math.random() * battles.starts.length)]; const battleString = '**A battle has broken out!**'; let healthText = affectedUsers .map(function(obj, index) { return '`' + (useNicknames ? (obj.nickname || obj.name) : obj.name) + '`: ' + Math.max((maxHealth - userHealth[index]), 0) + 'HP'; }) .sort(function(a, b) { return a.id - b.id; }) .join(', '); finalEvent.attacks.push( Event.finalize( battleString + '\\n' + startMessage + '\\n' + healthText, affectedUsers.slice(0), numVictim, numAttacker, 'nothing', 'nothing', game)); let loop = 0; do { loop++; if (loop &gt; 1000) { throw new Error('INFINITE LOOP'); } const eventIndex = Math.floor(Math.random() * battles.attacks.length); const eventTry = battles.attacks[eventIndex]; const attackerEventDamage = eventTry.attacker.damage * 1; const victimEventDamage = eventTry.victim.damage * 1; const flipRoles = Math.random() &gt; 0.5; const attackerIndex = Math.floor(Math.random() * numAttacker) + numVictim; if (loop == 999) { console.log( 'Failed to find valid event for battle!\\n', eventTry, flipRoles, userHealth, '\\nAttacker:', attackerIndex, '\\nUsers:', affectedUsers.length, '\\nAlive:', numAlive, '\\nFINAL:', finalEvent); } if ((!flipRoles &amp;&amp; userHealth[attackerIndex] + attackerEventDamage &gt;= maxHealth) || (flipRoles &amp;&amp; userHealth[attackerIndex] + victimEventDamage &gt;= maxHealth)) { continue; } let victimIndex = Math.floor(Math.random() * numAlive); let count = 0; for (let i = 0; i &lt; numVictim; i++) { if (userHealth[i] &lt; maxHealth) count++; if (count == victimIndex + 1) { victimIndex = i; break; } } const victimDamage = (flipRoles ? attackerEventDamage : victimEventDamage); const attackerDamage = (!flipRoles ? attackerEventDamage : victimEventDamage); userHealth[victimIndex] += victimDamage; userHealth[attackerIndex] += attackerDamage; if (userHealth[victimIndex] &gt;= maxHealth) { numAlive--; } if (lastAttack.index == eventIndex &amp;&amp; lastAttack.attacker == attackerIndex &amp;&amp; lastAttack.victim == victimIndex &amp;&amp; lastAttack.flipRoles == flipRoles) { duplicateCount++; } else { duplicateCount = 0; } lastAttack = { index: eventIndex, attacker: attackerIndex, victim: victimIndex, flipRoles: flipRoles, }; healthText = affectedUsers .map(function(obj, index) { const health = Math.max((maxHealth - userHealth[index]), 0); const prePost = health === 0 ? '~~' : ''; return prePost + '`' + (useNicknames ? (obj.nickname || obj.name) : obj.name) + '`: ' + health + 'HP' + prePost; }) .sort(function(a, b) { return a.id - b.id; }) .join(', '); let messageText = eventTry.message; if (duplicateCount &gt; 0) { messageText += ' x' + (duplicateCount + 1); } const newEvent = Event.finalize( battleString + '\\n' + messageText + '\\n' + healthText, [ affectedUsers[flipRoles ? attackerIndex : victimIndex], affectedUsers[flipRoles ? victimIndex : attackerIndex], ], 1, 1, !flipRoles &amp;&amp; userHealth[victimIndex] &gt;= maxHealth ? 'dies' : 'nothing', flipRoles &amp;&amp; userHealth[victimIndex] &gt;= maxHealth ? 'dies' : 'nothing', game); if (victimDamage &amp;&amp; attackerDamage) { newEvent.icons.splice(1, 0, {url: Battle._fistBoth}); } else if (attackerDamage) { newEvent.icons.splice( 1, 0, {url: flipRoles ? Battle._fistLeft : Battle._fistRight}); } else if (victimDamage) { newEvent.icons.splice( 1, 0, {url: flipRoles ? Battle._fistRight : Battle._fistLeft}); } finalEvent.attacks.push(newEvent); } while (numAlive &gt; 0); return finalEvent; }; module.exports = Battle; × Search results Close "},"hg_Day.js.html":{"id":"hg_Day.js.html","title":"Source: hg/Day.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Day.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Information about a single game day that was simulated. * @memberof HungryGames * @inner */ class Day { /** * @description Create a basic game day. * @param {number} [num] The day number. * @param {HungryGames~Event[]} [events] The events that will take place * during * this day. */ constructor(num, events) { /** * The day number this is. (Bloodbath is 0) * @public * @type {number} * @default */ this.num = -1; if (typeof num === 'number') this.num = num; /** * The state index of this day. 0 is not yet simulated, 1 is currently * simulating, and 2-n are the index of the event to show if reduced by 2. * (2 = event #0, 3 = event #1) * @public * @type {number} * @default */ this.state = 0; /** * All events to take place during this day. * @public * @type {HungryGames~Event[]} * @default */ this.events = events || []; } } /** * Create a Day from an Object. Similar to copy-constructor. * * @public * @param {object} data Day like Object. * @returns {HungryGames~Day} Created Day. */ Day.from = function(data) { const day = new Day(data.num, data.events); day.state = data.state || 0; return day; }; module.exports = Day; × Search results Close "},"hg_DefaultOptions.js.html":{"id":"hg_DefaultOptions.js.html","title":"Source: hg/DefaultOptions.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/DefaultOptions.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * Option base. * @memberof HungryGames~DefaultOptions * @inner */ class Option { /** * @description Default option constructor. * @param {*} value Value of this option. * @param {?string} [comment=null] Comment/description for the user about this * option. * @param {?string} [category=null] Category this option falls under for * showing user. */ constructor(value, comment = null, category = null) { this._value = value; if (comment != null &amp;&amp; typeof comment !== 'string') { throw new Error('Comment is not a string'); } this._comment = comment; if (category != null &amp;&amp; typeof category !== 'string') { throw new Error('Category is not a string'); } this._category = category; } /** * @description Get the value of this option. * @public * @type {*} */ get value() { return this._value; } /** * @description Get the description of this option. * @public * @type {?string} */ get comment() { return this._comment; } /** * @description Get the category of this option. * @public * @type {?string} */ get category() { return this._category; } /** * @returns {string[]} Array of all keys for this option. */ get keys() { const all = Object.entries(Object.getOwnPropertyDescriptors(this)); const output = []; for (const one of all) { output.push(one[0].slice(1)); } return output; } /** * @returns {HungryGames~DefaultOptions~Option} All variables of this option * fetched through their getters. */ get entries() { const keys = this.keys; const output = {}; for (const k of keys) { output[k] = this[k]; } return output; } } /** * Number option. * @memberof HungryGames~DefaultOptions * @inner * @extends HungryGames~DefaultOptions~Option */ class NumberOption extends Option { /** * @description Stores a number value with optional range. * @param {number} value Value of this option. * @param {?string} [comment=null] Comment/description for the user about this * option. * @param {?string} [category=null] Category this option falls under for * showing user. * @param {{min: number, max: number}} [range] Allowed range of this value. */ constructor(value, comment, category, range) { if (typeof value !== 'number' || isNaN(value)) { throw new Error('Value is not a number'); } super(value, comment, category); if (range) { this._range = {min: range.min, max: range.max}; } else { this._range = null; } } /** * @description Get the range of allowable values for this option. * @returns {?{min: number, max: number}} Allowable range of values. */ get range() { return this._range; } } /** * Boolean option. * @memberof HungryGames~DefaultOptions * @inner * @extends HungryGames~DefaultOptions~Option */ class BooleanOption extends Option { /** * @description Stores a boolean. * @param {boolean} value Value of this option. * @param {?string} [comment=null] Comment/description for the user about this * option. * @param {?string} [category=null] Category this option falls under for * showing user. */ constructor(value, comment, category) { if (typeof value !== 'boolean') throw new Error('Value is not a boolean'); super(value, comment, category); } } /** * Object option. Shallow copies passed value and range. * @memberof HungryGames~DefaultOptions * @inner * @extends HungryGames~DefaultOptions~Option */ class ObjectOption extends Option { /** * @description Stores any object. Shallow copies the object using * Object.assign. * @param {object} value Value of this option. * @param {?string} [comment=null] Comment/description for the user about this * option. * @param {?string} [category=null] Category this option falls under for * showing user. * @param {{min: number, max: number}} [range] Range of allowable values for * this option. */ constructor(value, comment, category, range) { if (typeof value !== 'object') throw new Error('Value is not an object'); value = Object.assign({}, value); super(value, comment, category); if (range) { this._range = {min: range.min, max: range.max}; } else { this._range = null; } } /** * @description Get the range of allowable values for this option. * @returns {?{min: number, max: number}} Allowable range of values. */ get range() { return this._range; } } /** * One of multiple choices option. * @memberof HungryGames~DefaultOptions * @inner * @extends HungryGames~DefaultOptions~Option */ class SelectOption extends Option { /** * @description Allows an option from a set of possible values. * @param {string} value Value of this option. * @param {?string} [comment=null] Comment/description for the user about this * option. * @param {?string} [category=null] Category this option falls under for * showing user. * @param {string[]} values Possible values. */ constructor(value, comment, category, values) { if (!values || !Array.isArray(values)) { throw new Error('Values is not array of strings'); } let included = false; for (let i = 0; i &lt; values.length; i++) { if (typeof values[i] !== 'string') { throw new Error('Values is not array of strings'); } else if (values[i] === value) { included = true; } } if (!included) throw new Error('Value is not in given values'); super(value, comment, category); this._values = values.slice(0); } /** * @description Get possible values for this option. * @returns {string[]} Array of possible values. */ get values() { return this._values; } } /** * Default options for a HungryGames. * @memberof HungryGames * @inner */ class DefaultOptions { /** * @description Creates a set of default options for a HungryGames. */ constructor() { this._bloodbathOutcomeProbs = new ObjectOption( {kill: 30, wound: 6, thrive: 8, revive: 0, nothing: 56}, 'Relative probabilities of choosing an event with each outcome. This ' + 'is for the bloodbath events.', 'probabilities'); this._playerOutcomeProbs = new ObjectOption( {kill: 22, wound: 4, thrive: 8, revive: 6, nothing: 60}, 'Relative probabilities of choosing an event with each outcome. This ' + 'is for normal daily events.', 'probabilities'); this._arenaOutcomeProbs = new ObjectOption( {kill: 64, wound: 10, thrive: 5, revive: 6, nothing: 15}, 'Relative Probabilities of choosing an event with each outcome. This ' + 'is for the special arena events.', 'probabilities'); this._arenaEvents = new BooleanOption( true, 'Are arena events possible. (Events like wolf mutts, or a volcano ' + 'erupting.)', 'probabilities'); this._includeBots = new BooleanOption( false, 'Should bots be included in the games. If this is false, bots ' + 'cannot be added manually.', 'other'); this._excludeNewUsers = new BooleanOption( false, 'Should new users who join your server be excluded from the ' + 'games by default. True will add all new users to the blacklist, ' + 'false will put all new users into the next game automatically.', 'other'); this._allowNoVictors = new BooleanOption( false, 'Should it be possible to end a game without any winners. If true, ' + 'it is possible for every player to die, causing the game to end ' + 'with everyone dead. False forces at least one winner.', 'features'); this._bleedDays = new NumberOption( 2, 'Number of days a user can bleed before they can die.', 'other'); this._battleHealth = new NumberOption( 5, 'The amount of health each user gets for a battle.', 'other', {min: 1, max: 10}); this._teamSize = new NumberOption( 0, 'Maximum size of teams when automatically forming teams. 0 to ' + 'disable teams', 'other'); this._teammatesCollaborate = new SelectOption( 'always', 'Will teammates work together. If disabled, teammates can kill ' + 'eachother, and there will only be 1 victor. If enabled, ' + 'teammates cannot kill eachother, and the game ends when one TEAM' + ' is remaining, not one player. Untilend means teammates work ' + 'together until the end of the game, this means only there will ' + 'be only 1 victor.', 'features', ['disabled', 'always', 'untilend']); this._useEnemyWeapon = new BooleanOption( false, 'This will allow the attacker in an event to use the victim\\'s ' + 'weapon against them.', 'features'); this._mentionVictor = new BooleanOption( false, 'Should the victor of the game (can be team), be tagged/mentioned ' + 'so they get notified?', 'features'); this._mentionAll = new SelectOption( 'disabled', 'Should a user be mentioned every time something happens to them ' + 'in the game? (can be disabled, for all events, or for when the ' + 'user dies)', 'features', ['disabled', 'all', 'death']); this._mentionEveryoneAtStart = new BooleanOption( false, 'Should @everyone be mentioned when the game is started?', 'features'); this._useNicknames = new BooleanOption( false, 'Should we use user\\'s custom server nicknames instead of ' + 'their account username? Names only change when a new game is ' + 'created.', 'features'); this._delayEvents = new NumberOption( 3500, 'Delay in milliseconds between each event being printed.', 'other', {min: 1500, max: 30000}, 'time'); this._delayDays = new NumberOption( 7000, 'Delay in milliseconds between each day being printed.', 'other', {min: 2500, max: 129600000}, // 1.5 days 'time'); this._probabilityOfArenaEvent = new NumberOption( 0.25, 'Probability each day that an arena event will happen.', 'probabilities', {min: 0, max: 1}, 'percent'); this._probabilityOfBleedToDeath = new NumberOption( 0.5, 'Probability that after bleedDays a player will die. If they ' + 'don\\'t die, they will heal back to normal.', 'probabilities', {min: 0, max: 1}, 'percent'); this._probabilityOfBattle = new NumberOption( 0.05, 'Probability of an event being replaced by a battle between two ' + 'players.', 'probabilities', {min: 0, max: 1}, 'percent'); this._probabilityOfUseWeapon = new NumberOption( 0.75, 'Probability of each player using their weapon each day if they ' + 'have one.', 'probabilities', {min: 0, max: 1}, 'percent'); this._eventAvatarSizes = new ObjectOption( {avatar: 64, underline: 4, gap: 4}, 'The number of pixels each player\\'s avatar will be tall and wide, ' + 'the underline status height, and the gap between each avatar. ' + 'This is for all normal events and arena event messages.', 'other', {min: 0, max: 512}); this._battleAvatarSizes = new ObjectOption( {avatar: 32, underline: 4, gap: 4}, 'The number of pixels each player\\'s avatar will be tall and wide, ' + 'the underline status height, and the gap between each avatar. ' + 'This is for each battle turn.', 'other', {min: 0, max: 512}); this._victorAvatarSizes = new ObjectOption( {avatar: 80, underline: 4, gap: 4}, 'The number of pixels each player\\'s avatar will be tall and wide, ' + 'the underline status height, and the gap between each avatar. ' + 'This is when announcing the winners of the game.', 'other', {min: 0, max: 512}); this._numDaysShowDeath = new NumberOption( -1, 'The number of days after a player has died to show them as dead in' + ' the status list after each day. -1 will always show dead ' + 'players. 0 will never show dead players. 1 will only show them ' + 'for the day they died. 2 will show them for 2 days.', 'other', {min: -1, max: 100}); this._showLivingPlayers = new BooleanOption( true, 'Include the living players in the status updates. Instead of only ' + 'wounded or dead players.', 'other'); this._customEventWeight = new NumberOption( 2, 'The relative weight of custom events. 2 means custom events are ' + 'twice as likely to be chosen.', 'probabilities', {min: 0, max: 1000}); this._anonForceOutcome = new BooleanOption( false, 'Forced outcomes will use existing events instead of saying ' + '\"The game makers\" did it.', 'other'); this._disableOutput = new BooleanOption( false, 'Debugging purposes only. I mean, you can enable it, but it ma' + 'kes the games really boring. Up to you ¯\\\\_(ツ)_/¯', 'other'); } /** * @description Get bloodbathOutcomeProbs. * @returns {ObjectOption} Prob opts. */ get bloodbathOutcomeProbs() { return this._bloodbathOutcomeProbs; } /** * @description Get playerOutcomeProbs. * @returns {ObjectOption} Prob opts. */ get playerOutcomeProbs() { return this._playerOutcomeProbs; } /** * @description Get arenaOutcomeProbs. * @returns {ObjectOption} Prob opts. */ get arenaOutcomeProbs() { return this._arenaOutcomeProbs; } /** * @description Get arenaEvents. * @returns {BooleanOption} Option value. */ get arenaEvents() { return this._arenaEvents; } /** * @description Get includeBots. * @returns {BooleanOption} Option value. */ get includeBots() { return this._includeBots; } /** * @description Get excludeNewUsers. * @returns {BooleanOption} Option value. */ get excludeNewUsers() { return this._excludeNewUsers; } /** * @description Get allowNoVictors. * @returns {BooleanOption} Option value. */ get allowNoVictors() { return this._allowNoVictors; } /** * @description Get bleedDays. * @returns {NumberOption} Option value. */ get bleedDays() { return this._bleedDays; } /** * @description Get battleHealth. * @returns {NumberOption} Option value. */ get battleHealth() { return this._battleHealth; } /** * @description Get teamSize. * @returns {NumberOption} Option value. */ get teamSize() { return this._teamSize; } /** * @description Get teammatesCollaborate. * @returns {BooleanOption} Option value. */ get teammatesCollaborate() { return this._teammatesCollaborate; } /** * @description Get useEnemyWeapon. * @returns {BooleanOption} Option value. */ get useEnemyWeapon() { return this._useEnemyWeapon; } /** * @description Get mentionVictor. * @returns {BooleanOption} Option value. */ get mentionVictor() { return this._mentionVictor; } /** * @description Get mentionAll. * @returns {SelectOption} Option value. */ get mentionAll() { return this._mentionAll; } /** * @description Get mentionEveryoneAtStart. * @returns {BooleanOption} Option value. */ get mentionEveryoneAtStart() { return this._mentionEveryoneAtStart; } /** * @description Get useNicknames. * @returns {BooleanOption} Option value. */ get useNicknames() { return this._useNicknames; } /** * @description Get delayEvents. * @returns {NumberOption} Option value. */ get delayEvents() { return this._delayEvents; } /** * @description Get delayDays. * @returns {NumberOption} Option value. */ get delayDays() { return this._delayDays; } /** * @description Get probabilityOfArenaEvent. * @returns {NumberOption} Option value. */ get probabilityOfArenaEvent() { return this._probabilityOfArenaEvent; } /** * @description Get probabilityOfBleedToDeath. * @returns {NumberOption} Option value. */ get probabilityOfBleedToDeath() { return this._probabilityOfBleedToDeath; } /** * @description Get probabilityOfBattle. * @returns {NumberOption} Option value. */ get probabilityOfBattle() { return this._probabilityOfBattle; } /** * @description Get probabilityOfUseWeapon. * @returns {NumberOption} Option value. */ get probabilityOfUseWeapon() { return this._probabilityOfUseWeapon; } /** * @description Get eventAvatarSizes. * @returns {ObjectOption} Option value. */ get eventAvatarSizes() { return this._eventAvatarSizes; } /** * @description Get battleAvatarSizes. * @returns {ObjectOption} Option value. */ get battleAvatarSizes() { return this._battleAvatarSizes; } /** * @description Get victorAvatarSizes. * @returns {ObjectOption} Option value. */ get victorAvatarSizes() { return this._victorAvatarSizes; } /** * @description Get numDaysShowDeath. * @returns {NumberOption} Option value. */ get numDaysShowDeath() { return this._numDaysShowDeath; } /** * @description Get showLivingPlayers. * @returns {BooleanOption} Option value. */ get showLivingPlayers() { return this._showLivingPlayers; } /** * @description Get customEventWeight. * @returns {NumberOption} Option value. */ get customEventWeight() { return this._customEventWeight; } /** * @description Get anonForceOutcome. * @returns {BooleanOption} Option value. */ get anonForceOutcome() { return this._anonForceOutcome; } /** * @description Get disableOutput. * @returns {BooleanOption} Option value. */ get disableOutput() { return this._disableOutput; } /** * @returns {string[]} Array of all default option keys. */ get keys() { const all = Object.entries(Object.getOwnPropertyDescriptors(this)); const output = []; for (const one of all) { if (one[1].value instanceof Option) { output.push(one[0].slice(1)); } } return output; } /** * @returns {object&lt;HungryGames~DefaultOptions~Option&gt;} All options in this * object. */ get entries() { const keys = this.keys; const output = {}; for (const k of keys) { output[k] = this[k].entries; } return output; } } module.exports = DefaultOptions; × Search results Close "},"hg_Event.js.html":{"id":"hg_Event.js.html","title":"Source: hg/Event.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Event.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const FinalEvent = require('./FinalEvent.js'); const UserIconUrl = require('./UserIconUrl.js'); const Grammar = require('./Grammar.js'); const Simulator = require('./Simulator.js'); const funTranslator = require('../lib/funTranslators.js'); /** * Event that can happen in a game. * @memberof HungryGames * @inner */ class Event { /** * @description Creates a HungryGames Event. * @param {string} message The message to show. * @param {number} [numVictim=0] The number of victims in this event. * @param {number} [numAttacker=0] The number of attackers in this event. * @param {string} [victimOutcome=nothing] The outcome of the victims from * this event. * @param {string} [attackerOutcome=nothing] The outcome of the attackers from * this event. * @param {boolean} [victimKiller=false] Do the victims kill anyone in this * event. Used for calculating kill count. * @param {boolean} [attackerKiller=false] Do the attackers kill anyone in * this event. Used for calculating kill count. * @param {boolean} [battle] Is this event a battle? * @param {number} [state=0] State of event if there are multiple attacks * before the event. * @param {HungryGames~Event[]} [attacks=[]] Array of attacks that take place * before the event. */ constructor( message, numVictim = 0, numAttacker = 0, victimOutcome = 'nothing', attackerOutcome = 'nothing', victimKiller = false, attackerKiller = false, battle = false, state = 0, attacks = []) { /** * The message to show. * @public * @type {string} */ this.message = message; /** * The action to format into a message if this is a weapon event. * @public * @type {?string} * @default */ this.action = null; /** * Information about the victims in this event. * @public * @type {{count: number, outcome: string, killer: boolean, weapon: * ?Object}} * @property {?{name: string, count: number}} weapon The weapon information * to give to the player. */ this.victim = { count: numVictim, outcome: victimOutcome, killer: victimKiller, weapon: null, }; /** * Information about the attackers in this event. * @public * @type {{count: number, outcome: string, killer: boolean, weapon: * ?Object}} * @property {?{name: string, count: number}} weapon The weapon information * to * give to the player. */ this.attacker = { count: numAttacker, outcome: attackerOutcome, killer: attackerKiller, weapon: null, }; /** * Is this event a battle event. * @public * @type {boolean} * @default false */ this.battle = battle; /** * The current state of printing the battle messages. * @public * @type {number} * @default 0 */ this.state = state; /** * The attacks in a battle to show before the message. * @public * @type {HungryGames~Event[]} * @default [] */ this.attacks = attacks; /** * Amount of consumables used if this is a weapon event. * @public * @type {?number|string} * @default */ this.consumes = null; /** * If the event is created by the user. * @public * @type {boolean} * @default */ this.custom = true; } /** * @description Compare this Event to another to check if they are equivalent. * @example console.log(firstEvent.equal(otherEvent)); * @public * @param {HungryGames~Event} two Other Event to compare against. * @returns {boolean} If they are equivalent. */ equal(two) { return Event.equal(this, two); } /** * @description Make an event that doesn't affect any players and is just a * plain message. * @example Event.finalizeSimple('Something happens!', game); * @private * @param {string} message The message to show. * @param {HungryGames~GuildGame} [game] The GuildGame to make this event for. * This is to check options and fetch players that may be necessary. * @returns {HungryGames~FinalEvent} The event that was created. */ static finalizeSimple(message, game) { return Event.finalize(message, [], 0, 0, 'nothing', 'nothing', game); } /** * @description Format an event string based on specified users. * @public * @param {string} message The message to show. * @param {HungryGames~Player[]} affectedUsers An array of all users affected * by this event. * @param {number} numVictim Number of victims in this event. * @param {number} numAttacker Number of attackers in this event. * @param {string} victimOutcome The outcome of the victims from this event. * @param {string} attackerOutcome The outcome of the attackers from this * event. * @param {HungryGames~GuildGame} game The GuildGame to make this event for. * Used for settings and fetching other players not affected by this event if * necessary. * @returns {HungryGames~FinalEvent} The final event that was created and * formatted ready for display. */ static finalize( message, affectedUsers, numVictim, numAttacker, victimOutcome, attackerOutcome, game) { const useNickname = game.options.useNicknames ? 'nickname' : 'username'; const mention = game.options.mentionAll; let mentionString = ''; let translator = null; for (let i = 0; i &lt; affectedUsers.length; i++) { if (!affectedUsers.isNPC &amp;&amp; mention == 'all' || (mention == 'death' &amp;&amp; ((victimOutcome == 'dies' &amp;&amp; i &lt; numVictim) || (attackerOutcome == 'dies' &amp;&amp; i &gt;= numVictim)))) { mentionString += `&lt;@${affectedUsers[i].id}&gt;`; } if (affectedUsers[i].settings &amp;&amp; affectedUsers[i].settings['hg:fun_translators'] &amp;&amp; affectedUsers[i].settings['hg:fun_translators'] !== 'disabled') { translator = affectedUsers[i].settings['hg:fun_translators']; } } const affectedVictims = affectedUsers.splice(0, numVictim); const affectedAttackers = affectedUsers.splice(0, numAttacker); let finalMessage = message; finalMessage = finalMessage.replace( /\\[V([^|]*)\\|([^\\]]*)\\]/g, '$' + (affectedVictims.length &gt; 1 ? '2' : '1')); finalMessage = finalMessage.replace( /\\[A([^|]*)\\|([^\\]]*)\\]/g, '$' + (affectedAttackers.length &gt; 1 ? '2' : '1')); finalMessage = finalMessage .replace( /\\{victim\\}/g, Grammar.formatMultiNames(affectedVictims, useNickname)) .replace( /\\{attacker\\}/g, Grammar.formatMultiNames(affectedAttackers, useNickname)); if (finalMessage.indexOf('{dead}') &gt; -1) { const deadUsers = game.currentGame.includedUsers .filter(function(obj) { return !obj.living &amp;&amp; !affectedUsers.find(function(u) { return u.id == obj.id; }); }) .slice(0, Simulator.weightedUserRand()); const numDead = deadUsers.length; if (numDead === 0) { finalMessage = finalMessage.replace(/\\{dead\\}/g, 'an animal') .replace(/\\[D([^|]*)\\|([^\\]]*)\\]/g, '$1'); } else { finalMessage = finalMessage .replace(/\\[D([^|]*)\\|([^\\]]*)\\]/g, numDead === 1 ? '$1' : '$2') .replace( /\\{dead\\}/, Grammar.formatMultiNames(deadUsers, useNickname)); } } finalMessage = funTranslator.to(translator, finalMessage); const finalIcons = UserIconUrl.from(affectedVictims.concat(affectedAttackers)); return new FinalEvent( finalMessage, finalIcons, numVictim, victimOutcome, attackerOutcome, mentionString); } /** * @description Compare two events to check if they are equivalent. * @public * @param {HungryGames~Event} e1 First event. * @param {HungryGames~Event} e2 Second event to compare. * @returns {boolean} If the two given events are equivalent. */ static equal(e1, e2) { if (!e1 || !e2) return false; if (e1.message != e2.message) return false; if (e1.action != e2.action) return false; if (e1.consumes != e2.consumes) return false; if (!e1.battle != !e2.battle) return false; const v1 = e1.victim; const v2 = e2.victim; if (v1 &amp;&amp; v2) { if (v1.count != v2.count) return false; if (v1.outcome != v2.outcome) return false; if (!v1.killer != !v2.killer) return false; if (v1.weapon &amp;&amp; v2.weapon) { if (v1.weapon.name != v2.weapon.name) return false; if (v1.weapon.count != v2.weapon.count) return false; } else if (!(!v1.weapon &amp;&amp; !v2.weapon)) { return false; } } else if (!(!v1 &amp;&amp; !v2)) { return false; } const a1 = e1.attacker; const a2 = e2.attacker; if (a1 &amp;&amp; a2) { if (a1.count != a2.count) return false; if (a1.outcome != a2.outcome) return false; if (!a1.killer != !a2.killer) return false; if (a1.weapon &amp;&amp; a2.weapon) { if (a1.weapon.name != a2.weapon.name) return false; if (a1.weapon.count != a2.weapon.count) return false; } else if (!(!a1.weapon &amp;&amp; !a2.weapon)) { return false; } } else if (!(!a1 &amp;&amp; !a2)) { return false; } return true; } } module.exports = Event; × Search results Close "},"hg_FinalEvent.js.html":{"id":"hg_FinalEvent.js.html","title":"Source: hg/FinalEvent.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/FinalEvent.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Finalized event ready for display to users. * @memberof HungryGames * @inner */ class FinalEvent { /** * @description Create an event ready for display. * @param {string} message Text to send to users. * @param {HungryGames~UserIconUrl[]} [icons] Icons for this event. * @param {number} [numVictim=0] Number of victims in this event. * @param {string} [victimOutcome='nothing'] Victim outcome due to this event. * @param {string} [attackerOutcome='nothing'] Attacker outcome due to this * event. * @param {string} [mentionString=''] String of mentions to separate from the * message embeds so that users are properly pinged. */ constructor( message, icons = [], numVictim = 0, victimOutcome = 'nothing', attackerOutcome = 'nothing', mentionString = '') { /** * Message to send to users. * @public * @type {string} */ this.message = message; /** * Icons to include with sent message. * @public * @type {HungryGames~UserIconUrl[]} * @default [] */ this.icons = icons; /** * Number of victims in this event. * @public * @type {number} * @default 0 */ this.numVictim = numVictim; /** * Information about the victims in this event. * @public * @type {{outcome: string}} * @default {outcome: 'nothing'} */ this.victim = {outcome: victimOutcome}; /** * Information about the attackers in this event. * @public * @type {{outcome: string}} * @default {outcome: 'nothing'} */ this.attacker = {outcome: attackerOutcome}; /** * String mentions to ping users. * @public * @type {string} * @default '' */ this.mentionString = mentionString; } } module.exports = FinalEvent; × Search results Close "},"hg_ForcedOutcome.js.html":{"id":"hg_ForcedOutcome.js.html","title":"Source: hg/ForcedOutcome.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/ForcedOutcome.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description An outcome for one or more players in a game. * @memberof HungryGames * @inner */ class ForcedOutcome { /** * @description Create a single forced outcome. * @param {string} id The guild ID in which the users will be affected. * @param {string[]} list The array of player IDs of which to affect. * @param {string} state The outcome to force the players to have been * victims of by the end of the simulated day. (\"living\", \"dead\", \"wounded\", * or \"thriving\"). * @param {string} text Message to show when the user is affected. * @param {boolean} [persists=false] Does this outcome persist to the end of * the game, if false it only exists for the next day. */ constructor(id, list, state, text, persists = false) { if (typeof id === 'object') { persists = id.persists; text = id.text; state = id.state; list = id.list; id = id.id; } /** * The guild ID of which the users will be affected. * @public * @type {string} */ this.id = id; /** * The array of player IDs of which this concerns. * @public * @type {string[]} */ this.list = list; /** * The state to force the players to be in. * @public * @type {string} */ this.state = state; /** * Message to show when the user is affected. * @public * @type {string} */ this.text = text; /** * Does this outcome persist to the end of the game. False to only exist for * a * single day. * @public * @type {boolean} * @default false */ this.persists = persists; } } module.exports = ForcedOutcome; × Search results Close "},"hg_Game.js.html":{"id":"hg_Game.js.html","title":"Source: hg/Game.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Game.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const Day = require('./Day.js'); const Player = require('./Player.js'); /** * @description The container with current game state within a guild's game. * @memberof HungryGames * @inner */ class Game { /** * @description Create a game with basic game information. * @param {string} [name] The name of this game. * @param {HungryGames~Player[]} [includedUsers] Array of user players that * are included in this game. * @param {HungryGames~Team[]} [teams] Array of teams that have been formed * already. */ constructor(name, includedUsers, teams) { /** * The name of this game. * @public * @type {string} * @default 'Hungry Games' */ this.name = name || 'Hungry Games'; /** * Is the game currently in progress. * @public * @type {boolean} * @default */ this.inProgress = false; /** * Array of all users currently in the game. * @public * @type {HungryGames~Player[]} * @default */ this.includedUsers = includedUsers || []; /** * All teams in the game. * @public * @type {HungryGames~Team[]} * @default [] */ this.teams = teams || []; /** * List of outcomes and players to force before the end of the day. Does not * affect the simulation, outcomes are forced by appending events at the end * of the simulated day. * @public * @type {HungryGames~ForcedOutcome[]} * @default */ this.forcedOutcomes = []; /** * Has the game ended. * @public * @type {boolean} * @default */ this.ended = false; /** * Information about the day that was simulated. * @public * @type {HungryGames~Day} * @default */ this.day = new Day(); /** * The number of players still alive in this game. * @public * @type {number} */ this.numAlive = this.includedUsers.length; /** * Is this game currently paused. * @public * @type {boolean} * @default */ this.isPaused = false; } } /** * Create a new Game from an object. Similar to a copy constructor. * * @public * @param {object} data Game like object to copy. * @returns {HungryGames~Game} Created Game object. */ Game.from = function(data) { const game = new Game(data.name, data.includedUsers); game.inProgress = data.inProgress || false; game.teams = data.teams || []; game.forcedOutcomes = data.forcedOutcomes || []; game.ended = data.ended || false; game.day = Day.from(data.day); game.includedUsers = game.includedUsers.map((el) =&gt; Player.from(el)); if (!isNaN(data.numAlive)) { game.numAlive = data.numAlive; } game.isPaused = data.isPaused || false; return game; }; module.exports = Game; × Search results Close "},"hg_Grammar.js.html":{"id":"hg_Grammar.js.html","title":"Source: hg/Grammar.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Grammar.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Grammar related string formatting. * @memberof HungryGames * @inner */ class Grammar {} /** * Format an array of users into names based on options and grammar rules. * * @public * @param {HungryGames~Player[]} names An array of players to format the names * of. * @param {string} [format='username'] Setting of how to format the user's name. * `username` will use their account name, `mention` will use their ID to format * a mention tag, `nickname` will use their custom guild nickname. * @returns {string} The formatted string of names. */ Grammar.formatMultiNames = function(names, format = 'username') { let output = ''; for (let i = 0; i &lt; names.length; i++) { if (format === 'mention' &amp;&amp; !names[i].isNPC) { output += `&lt;@${names[i].id}&gt;`; } else if (format === 'nickname') { output += `\\`${names[i].nickname || names[i].name}\\``; } else { output += `\\`${names[i].name}\\``; } if (i == names.length - 2) { output += ' and '; } else if (i != names.length - 1) { output += ', '; } } return output; }; module.exports = Grammar; × Search results Close "},"hg_GuildGame.js.html":{"id":"hg_GuildGame.js.html","title":"Source: hg/GuildGame.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/GuildGame.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const Game = require('./Game.js'); const Event = require('./Event.js'); const Team = require('./Team.js'); const Simulator = require('./Simulator.js'); const StatManager = require('./StatManager.js'); /** * A single instance of a game in a guild. * @memberof HungryGames * @inner */ class GuildGame { /** * @description Create a game instance for a single guild. * @param {string} bot User id of the current bot instance. * @param {string} id Guild id of the Guild that this object is for. * @param {object&lt;number|boolean|string|object&gt;} options The game options. * @param {string} [name] Name of this game to be passed to the Game object. * @param {string[]|HungryGames~Player[]} [includedUsers] Array of user IDs * that will be included in the next game, or array of Players to include. * @param {string[]} [excludedUsers] Array of user IDs that have been * excluded from the games. * @param {HungryGames~NPC[]} [includedNPCs] Array of NPC objects to include * in the game. * @param {HungryGames~NPC[]} [excludedNPCs] Array of NPC objects to exclude * from the game. * @param {{ * bloodbath: HungryGames~Event[], * player: HungryGames~Event[], * weapon: object.&lt;HungryGames~WeaponEvent&gt;, * arena: HungryGames~ArenaEvent[] * }} [customEvents] All custom events for the guild. * @param {{ * bloodbath: HungryGames~Event[], * player: HungryGames~Event[], * weapon: object.&lt;Array.&lt;HungryGames~Event&gt;&gt;, * arena: object.&lt;Array.&lt;HungryGames~Event&gt;&gt; * }} [disabledEvents] All disabled events for the guild. */ constructor( bot, id, options, name, includedUsers, excludedUsers, includedNPCs, excludedNPCs, customEvents, disabledEvents) { /** * The ID of the current bot account. * @public * @type {string} * @constant */ this.bot = bot; /** * The ID of the Guild this is for. * @public * @type {string} * @constant */ this.id = id; /** * Array of user IDs that will be included in the next game. * @public * @type {string[]} * @default [] */ this.includedUsers = []; if (Array.isArray(includedUsers)) { for (let i = 0; i &lt; includedUsers.length; i++) { if (typeof includedUsers[i] === 'string') { this.includedUsers.push(includedUsers.splice(i, 1)[0]); i--; } else { this.includedUsers.push(includedUsers[i].id); } } } /** * Array of user IDs that will be excluded from the next game. * @public * @type {string[]} * @default [] */ this.excludedUsers = excludedUsers || []; /** * Array of NPCs that will be included in the game. * @public * @type {HungryGames~NPC[]} * @default [] */ this.includedNPCs = includedNPCs || []; /** * Array of NPCs that will be excluded from the game. * @public * @type {HungryGames~NPC[]} * @default [] */ this.excludedNPCs = excludedNPCs || []; /** * Game options. * @public * @type {Object} */ this.options = options; /** * Is this game autoplaying? * @public * @type {boolean} * @default false */ this.autoPlay = false; /** * Does this game currently have any long running operations being * performed. * @public * @type {boolean} * @default false */ this.loading = false; /** * Is this game automatically stepping, or are steps controlled manually. * @private * @type {boolean} * @default false */ this._autoStep = false; /** * All custom events for the guild. * @public * @type { * { * bloodbath: HungryGames~Event[], * player: HungryGames~Event[], * weapon: Object.&lt;HungryGames~WeaponEvent&gt;, * arena: HungryGames~ArenaEvent[] * } * } * @default {{bloodbath: [], player: [], arena: [], weapon: {}}} */ this.customEvents = customEvents || {bloodbath: [], player: [], arena: [], weapon: {}}; // Force custom events to have custom event flag. (This is here due to // updating from previous version without custom event flag). if (this.customEvents) { for (const cat of Object.values(this.customEvents)) { for (const evt of Object.values(cat)) { if (typeof evt === 'object') evt.custom = true; } } } /** * Current game information. * @public * @type {HungryGames~Game} * @default */ this.currentGame = new Game(name, includedUsers); /** * Disabled event information. These events are not allowed to show up in * the game. * @public * @type { * { * bloodbath: HungryGames~Event[], * player: HungryGames~Event[], * weapon: Object.&lt;Array.&lt;HungryGames~Event&gt;&gt;, * arena: Object.&lt;Array.&lt;HungryGames~Event&gt;&gt; * } * } * @default {{bloodbath: [], player: [], arena: {}, weapon: {}}} */ this.disabledEvents = disabledEvents || {bloodbath: [], player: [], arena: {}, weapon: {}}; /** * The channel id a command was last sent from that affected this guild * game. * @public * @type {?string} * @default */ this.channel = null; /** * The id of the user that last sent a command which interacted with this * guild game. * @public * @type {?string} * @default */ this.author = null; /** * The channel id where the game messages are currently being sent in. * @public * @type {?string} * @default */ this.outputChannel = null; /** * Message ID of the message to fetch reactions from for join via react. * @public * @type {?{id: string, channel: string}} * @default */ this.reactMessage = null; /** * The ID of the currently active {@link HungryGames~StatGroup} tracking * stats. * @public * @type {?string} * @default */ this.statGroup = null; /** * Interval for day events. * @private * @type {?Timeout} * @default */ this._dayEventInterval = null; /** * The timeout to continue autoplaying after the day ends. Used for * cancelling if user ends the game between days. * * @private * @type {?Timeout} * @default */ this._autoPlayTimeout = null; /** * Function to call when state is modified. * @private * @type {?HungryGames~GuildGame~StateUpdateCB} * @default */ this._stateUpdateCallback = null; /** * Manages all stats for all players. * @private * @type {HungryGames~StatManager} * @constant */ this._stats = new StatManager(this); this.step = this.step.bind(this); } /** * @description Get a serializable version of this class instance. Strips all * private variables, and all functions. Assumes all public variables are * serializable if they aren't a function. * @public * @returns {object} Serializable version of this instance. */ get serializable() { const all = Object.entries(Object.getOwnPropertyDescriptors(this)); const output = {}; for (const one of all) { if (typeof one[1].value === 'function' || one[0].startsWith('_')) { continue; } else if (one[1].value &amp;&amp; one[1].value.serializable) { output[one[0]] = one[1].value.serializable; } else { output[one[0]] = one[1].value; } } return output; } /** * @description Callback to fire when game state is about to be modified. * @callback HungryGames~GuildGame~StateUpdateCB * @param {boolean} dayComplete True if this update is after a day has ended, * false if the state is still during a day. * @param {boolean} doSim True if the next day should be simulated and * started. */ /** * @description Add users to teams, and remove excluded users from teams. * Deletes empty teams, and adds teams once all teams have teamSize of * players. * * @public * @returns {?string} Null if success, string if error. */ formTeams() { if (this.options.teamSize &lt; 0) this.options.teamSize = 0; if (this.options.teamSize == 0) { this.currentGame.teams = []; return; } let corruptTeam = false; const teamSize = this.options.teamSize; const numTeams = Math.ceil(this.currentGame.includedUsers.length / teamSize); // If teams already exist, update them. Otherwise, create new teams. if (this.currentGame.teams &amp;&amp; this.currentGame.teams.length &gt; 0) { this.currentGame.teams.forEach((obj) =&gt; { obj.players.forEach((p) =&gt; { if (typeof p !== 'string' &amp;&amp; typeof p !== 'number') { corruptTeam = true; console.error( '(PreTeamForm) Player in team is invalid: ' + typeof p + ' in team ' + obj.id + ' guild: ' + this.id + ' players: ' + JSON.stringify(obj.players)); } }); }); this.currentGame.teams.sort((a, b) =&gt; { return a.id - b.id; }); const notIncluded = this.currentGame.includedUsers.slice(0); // Remove players from teams if they are no longer included in game. for (let i = 0; i &lt; this.currentGame.teams.length; i++) { const team = this.currentGame.teams[i]; team.id = i; for (let j = 0; j &lt; team.players.length; j++) { if (this.currentGame.includedUsers.findIndex((obj) =&gt; { return obj.id === team.players[j]; }) &lt; 0) { team.players.splice(j, 1); j--; } else { notIncluded.splice( notIncluded.findIndex((obj) =&gt; { return obj.id === team.players[j]; }), 1); } } if (team.players.length == 0) { this.currentGame.teams.splice(i, 1); i--; } } // Add players who are not on a team, to a team. for (let i = 0; i &lt; notIncluded.length; i++) { let found = false; for (let j = 0; j &lt; this.currentGame.teams.length; j++) { const team = this.currentGame.teams[j]; if (team.players.length &lt; teamSize) { team.players.push(notIncluded[i].id); found = true; break; } } if (found) continue; // Add a team if all existing teams are full. this.currentGame.teams[this.currentGame.teams.length] = new Team( this.currentGame.teams.length, 'Team ' + (this.currentGame.teams.length + 1), [notIncluded[i].id]); } } else { // Create all teams for players. this.currentGame.teams = []; for (let i = 0; i &lt; numTeams; i++) { this.currentGame.teams[i] = new Team( i, 'Team ' + (i + 1), this.currentGame.includedUsers .slice(i * teamSize, i * teamSize + teamSize) .map((obj) =&gt; { return obj.id; })); } } // Reset team data. this.currentGame.teams.forEach((obj) =&gt; { obj.numAlive = obj.players.length; obj.rank = 1; obj.players.forEach((p) =&gt; { if (typeof p !== 'string' &amp;&amp; typeof p !== 'number') { corruptTeam = true; console.error( '(PostTeamForm) Player in team is invalid: ' + typeof p + ' in team ' + obj.id + ' guild: ' + this.id + ' players: ' + JSON.stringify(obj.players)); } }); }); if (corruptTeam) { return 'Teams appeared to be corrupted, teams may have been ' + 'rearranged.\\nThis error has been reported and is being ' + 'looked into.'; } return null; } /** * @description Force this current game to end immediately. * @public */ end() { this.currentGame.inProgress = false; this.currentGame.isPaused = false; this.currentGame.ended = true; this.autoPlay = false; this.clearIntervals(); } /** * @description Clear all timeouts and intervals. * @public */ clearIntervals() { if (this._dayEventInterval) { clearInterval(this._dayEventInterval); this._dayEventInterval = null; } if (this._autoPlayTimeout) { clearInterval(this._autoPlayTimeout); this._autoPlayTimeout = null; } this._autoStep = false; } /** * @description Create an interval for this guild. Calls the callback every * time the game state is about to be modified. State is updated immediately * after the callback completes. This also sets `_autoStep` to true. * @public * @param {HungryGames~GuildGame~StateUpdateCB} cb Callback to fire on the * interval. */ createInterval(cb) { if (typeof cb !== 'function') { throw new Error('Callback must be a function'); } if (this._dayEventInterval) { throw new Error( 'Attempted to register second listener for existing interval.'); } this._autoStep = true; this._stateUpdateCallback = cb; const delay = this.options.disableOutput ? 1 : this.options.delayEvents; this.step(); this._dayEventInterval = setInterval(this.step, delay); } /** * @description Progress to the next game state. Calls `_stateUpdateCallback` * prior to any action, if it's set. * @public */ step() { const day = this.currentGame.day; const index = day.state - 2; const dayOver = index &gt;= day.events.length; if (typeof this._stateUpdateCallback === 'function') { this._stateUpdateCallback(dayOver, index &lt; 0); } if (this._autoPlayTimeout) { clearTimeout(this._autoPlayTimeout); this._autoPlayTimeout = null; } if (dayOver) { if (this._dayEventInterval) { clearInterval(this._dayEventInterval); this._dayEventInterval = null; } if (this.autoPlay &amp;&amp; this._autoStep &amp;&amp; !this.currentGame.isPaused) { const delay = this.options.disableOutput ? 1 : this.options.delayDays; this._autoPlayTimeout = setTimeout(this.step, delay); } day.state = 0; this._stats.parseDay(); } else if (index &lt; 0) { return; } else if ( day.events[index].battle &amp;&amp; day.events[index].state &lt; day.events[index].attacks.length) { day.events[index].state++; } else { day.state++; } } } /** * @description Create a GuildGame from data parsed from file. Similar to copy * constructor. * * @public * @param {object} data GuildGame like object. * @returns {HungryGames~GuildGame} Created GuildGame. */ GuildGame.from = function(data) { const game = new GuildGame( data.bot, data.id, data.options, data.name, data.includedUsers, data.excludedUsers, data.includedNPCs, data.excludedNPCs, data.customEvents, data.disabledEvents); game.autoPlay = data.autoPlay || false; game.reactMessage = data.reactMessage || null; game.channel = data.channel || null; game.author = data.author || null; game.outputChannel = data.outputChannel || null; game.statGroup = data.statGroup || null; if (data.currentGame) { game.currentGame = Game.from(data.currentGame); } return game; }; /** * @description Force a player to have a certain outcome in the current day * being simulated, or the next day that will be simulated. This is acheived * by adding a custom event in which the player will be affected after their * normal event for the day. * * @public * @static * @param {HungryGames~GuildGame} game The game context. * @param {string[]} list The array of player IDs of which to affect. * @param {string} state The outcome to force the players to have been * victims of by the end of the simulated day. (\"living\", \"dead\", \"wounded\", * or \"thriving\"). * @param {HungryGames~Messages} messages Reference to current Messages * instance. * @param {string|HungryGames~Event[]} [text] Message to show when the user is * affected, or array of default events if not specifying a specific message. * @param {boolean} [persists=false] Does this outcome persist to the end of * the game, if false it only exists for the next day. * @returns {string} The output message to tell the user of the outcome of the * operation. */ GuildGame.forcePlayerState = function( game, list, state, messages, text, persists = false) { if (!Array.isArray(list)) { persists = list.persists; messages = state; text = list.text; state = list.state; list = list.list; } if (!Array.isArray(list) || list.length == 0) return 'No players given.'; if (typeof state !== 'string') return 'No outcome given.'; const players = []; list.forEach((p) =&gt; { const player = game.currentGame.includedUsers.find((el) =&gt; el.id == p); if (game.currentGame.day.state &gt; 0) { if (!player) return 'Unable to find player.'; let outcome; if (player.living &amp;&amp; state === 'dead') { outcome = 'dies'; Simulator._killUser(game, player, 0, null); } else if ( !player.living &amp;&amp; (state === 'living' || state === 'thriving')) { outcome = 'revived'; Simulator._reviveUser(game, player, 0, null); } else if (player.state === 'wounded' &amp;&amp; state === 'thriving') { outcome = 'thrives'; Simulator._restoreUser(game, player, 0, null); } else if ( player.living &amp;&amp; player.state !== 'wounded' &amp;&amp; state === 'wounded') { outcome = 'wounded'; Simulator._woundUser(game, player, 0, null); } else { return; } let evt; if (typeof text !== 'string' &amp;&amp; Array.isArray(text) &amp;&amp; game.options.anonForceOutcome) { let eventPool = text.concat(game.customEvents.player); eventPool = eventPool.filter((el) =&gt; { const checkOutcome = el.victim.outcome === outcome || el.attacker.outcome === outcome; const checkCount = Math.abs(el.victim.count * 1) + Math.abs(el.attacker.count * 1) === 1; const checkDisabled = !game.disabledEvents || !game.disabledEvents.player || !game.disabledEvents.player.find((d) =&gt; Event.equal(d, el)); return checkOutcome &amp;&amp; checkCount &amp;&amp; checkDisabled; }); if (eventPool.length &gt; 0) { const pick = eventPool[Math.floor(eventPool.length * Math.random())]; text = pick.message; evt = Event.finalize( text, [player], Math.abs(pick.victim.count * 1), Math.abs(pick.attacker.count * 1), outcome, outcome, game); } } if (typeof text !== 'string') { switch (state) { case 'dead': text = messages.get('forcedDeath'); break; case 'thriving': text = messages.get('forcedHeal'); break; case 'wounded': text = messages.get('forcedWound'); break; } } if (!evt) { evt = Event.finalize(text, [player], 1, 0, outcome, 'nothing', game); } // State - 2 = the event index, + 1 is the next index to get shown. let lastIndex = game.currentGame.day.state - 1; for (let i = game.currentGame.day.events.length - 1; i &gt; lastIndex; i--) { if (game.currentGame.day.events[i].icons.find((el) =&gt; el.id == p)) { lastIndex = i + 1; break; } } if (lastIndex &lt; game.currentGame.day.events.length) { game.currentGame.day.events.splice(lastIndex, 0, evt); } else { game.currentGame.day.events.push(evt); } } else { game.currentGame.forcedOutcomes.push({ id: game.id, list: list, state: state, text: typeof text === 'string' ? text : null, persists: persists, }); } if (player) players.push(player.name); }); if (players.length == 0) { return `No players found.`; } else if (players.length &lt; 5) { const names = players.map((el) =&gt; `\\`${el}\\``).join(', '); return `${names} will be ${state} by the end of the day.`; } else { return `${players.length} players will be ${state} by the end of the day.`; } }; module.exports = GuildGame; × Search results Close "},"hg_Messages.js.html":{"id":"hg_Messages.js.html","title":"Source: hg/Messages.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Messages.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); /** * @classdesc String text getter helper. * @class HungryGames~Messages */ class Messages { /** * Create the instance managing the filesystem. */ constructor() { /** * The file path to read messages. * * @private * @type {string} * @constant * @default */ this._messageFile = './save/hgMessages.json'; /** * All messages to show for games. Parsed from file. * * @private * @type {Object.&lt;string[]&gt;} * @default */ this._messages = {}; this._updateMessages(); fs.watchFile(this._messageFile, (curr, prev) =&gt; { if (curr.mtime == prev.mtime) return; this._updateMessages(); }); } /** * Stop watching for file changes. * * @public */ shutdown() { fs.unwatchFile(this._messageFile); } /** * Parse all messages from file. * * @private */ _updateMessages() { fs.readFile(this._messageFile, (err, data) =&gt; { if (err) return; try { const parsed = JSON.parse(data); if (parsed) { this._messages = parsed; } } catch (err) { console.log(err); } }); } /** * Get a random message of a given type from hgMessages.json. * * @public * @param {string} type The message type to get. * @returns {string} A random message of the given type. */ get(type) { const list = this._messages[type]; if (!list) return 'badtype'; const length = list.length; if (length == 0) return 'nomessage'; return list[Math.floor(Math.random() * length)]; } } module.exports = Messages; × Search results Close "},"hg_OutcomeProbabilities.js.html":{"id":"hg_OutcomeProbabilities.js.html","title":"Source: hg/OutcomeProbabilities.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/OutcomeProbabilities.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Probabilities of each possible outcome from an Event. All * probabilities are relative to eachother. For example, if `revive` is 6, and * `nothing` is 60, then `nothing` is 10x more likey to be chosen than `revive`. * Similarly, if `revive` is 0.6 and `nothing` is 6, `nothing` is still 10x more * likely. * @memberof HungryGames * @inner */ class OutcomeProbabilities { /** * @description Create an object storing relative probabilities. * @param {number} [kill] Kill probability. * @param {number} [wound] Wound probability. * @param {number} [thrive] Thrive probability. * @param {number} [revive] Revive probability. * @param {number} [nothing] Probability of no outcome change. */ constructor(kill, wound, thrive, revive, nothing) { /** * The probability of an event being chosen that kills players. * @public * @type {number} * @default */ this.kill = kill || 22; /** * The probability of an event being chosen that wounds players. * @public * @type {number} * @default */ this.wound = wound || 4; /** * The probability of an event being chosen that heals players. * @public * @type {number} * @default */ this.thrive = thrive || 8; /** * The probability of an event being chosen that revives players. * @public * @type {number} * @default */ this.revive = revive || 6; /** * The probability of an event being chosen that does not have any effect on * players. * @public * @type {number} * @default */ this.nothing = nothing || 60; } } module.exports = OutcomeProbabilities; × Search results Close "},"hg_Player.js.html":{"id":"hg_Player.js.html","title":"Source: hg/Player.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Player.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const Discord = require('discord.js'); /** * @description Serializable container for data pertaining to a single user. * @memberof HungryGames * @inner */ class Player { /** * @description Create a player object for a game. Requires a unique ID and a * username. * @param {string} id The id of the user this object is representing. * @param {string} username The name of the user to show in the game. * @param {string} avatarURL URL to avatar to show for the user in the game. * @param {?string} [nickname=null] The nickname for this user usually * assigned by the guild. If the user does not have a nickname, this will have * the same value as `name`. */ constructor(id, username, avatarURL = '', nickname = null) { // Replace backtick with Unicode 1FEF Greek Varia because it looks the same, // but it wont ruin formatting. username = username.replace(/`/g, '`'); if (typeof nickname === 'string') nickname = nickname.replace(/`/g, '`'); /** * The id of the User this Player represents. * @type {string} * @public */ this.id = id; /** * The name of this Player. * @type {string} * @public */ this.name = username; /** * The URL to the discord avatar of the User. * @type {string} * @public * @default '' */ this.avatarURL = avatarURL || ''; /** * The nickname for this user usually assigned by the guild. If the user * does * not have a nickname, this will have the same value as `name`. * @type {string} */ this.nickname = nickname || username; /** * Is the player still alive. * @type {boolean} * @public * @default */ this.living = true; /** * How many days has the player been wounded. * @type {number} * @public * @default */ this.bleeding = 0; /** * The current rank of the player in the game. * @type {number} * @public * @default */ this.rank = 1; /** * The current player state (normal, wounded, dead, zombie). * @type {string} * @public * @default */ this.state = 'normal'; /** * The number of players this player has caused to die. * @type {number} * @public * @default */ this.kills = 0; /** * The weapons the player currently has and how many of each. * @type {Object.&lt;number&gt;} * @public * @default */ this.weapons = {}; /** * Custom settings for this user associated with the games. * @type {Object} * @public * @default */ this.settings = {}; /** * The day at which the player last died in the game. Only a valid number if * the player is currently dead. Otherwise a garbage value will be * available. * @type {number} * @public * @default */ this.dayOfDeath = -1; } } /** * @description Create a Player from a given Discord.User or Player-like Object. * Can be used as a copy-constructor. * * @public * @static * @param { * Discord~User|Discord~GuildMember|object * } member Object, User or GuildMember to make a Player from. * @returns {HungryGames~Player} Player object created. */ Player.from = function(member) { let player; if (typeof member === 'string') { player = new Player(member, member); } else { const isDiscord = (member instanceof Discord.GuildMember) || (member instanceof Discord.User); const user = isDiscord ? member.user || member : member; const avatar = isDiscord ? user.displayAvatarURL({format: 'png'}) : user.avatarURL; const name = isDiscord ? user.username : member.name; player = new Player(user.id, name, avatar, member.nickname); if (!isDiscord) { if (typeof player.living === 'boolean' || player.living === 'true' || player.living === 'false') { if (typeof player.living !== 'boolean') { player.living = player.living === 'true' ? true : false; } player.living = member.living; } player.bleeding = member.bleeding || 0; player.rank = member.rank || 1; player.state = member.state || 'normal'; player.kills = member.kills || 0; player.weapons = member.weapons || {}; player.settings = member.settings || {}; if (!isNaN(member.dayOfDeath)) { player.dayOfDeath = member.dayOfDeath; } } } return player; }; module.exports = Player; × Search results Close "},"hg_Simulator.js.html":{"id":"hg_Simulator.js.html","title":"Source: hg/Simulator.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Simulator.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const {Worker} = require('worker_threads'); const Game = require('./Game.js'); /** * Wrapper for logging functions that normally reference SubModule.error and * similar. * @todo Obtain reference to SubModule to be able to remove this. * @private * @constant */ const self = { error: function(...args) { console.error(`ERR:${('00000' + process.pid).slice(-5)}`, ...args); }, }; /** * @description Manages HG day simulation. * @memberof HungryGames * @inner */ class Simulator { /** * @description Create a simulator instance. * @param {HungryGames~GuildGame} game The GuildGame to simulate. * @param {HungryGames} hg Parent game manager for logging and SubModule * references. * @param {Discord~Message} [msg] Message to reply to if necessary. */ constructor(game, hg, msg) { this.setGame(game); this.setParent(hg); this.setMessage(msg); } /** * @description Change the GuildGame to simulate. * * @param {HungryGames~GuildGame} game The new GuildGame. */ setGame(game) { this.game = game; } /** * @description Update the reference to the parent {@link HungryGames}. * * @param {HungryGames} hg New parent reference. */ setParent(hg) { this.hg = hg; } /** * @description Update the message to reply to. * * @param {Discord~Message} msg New message to reference. */ setMessage(msg) { this.msg = msg; } /** * @description Simulate a day with the current GuildGame. * * @param {Function} cb Callback that always fires on completion. The only * parameter is a possible error string, null if no error. */ go(cb) { if (this.game.currentGame.day.state == 1) { this.hg._parent.error( 'Unable to start simulating because simulation is already in ' + 'progress.'); return; } const data = { game: this.game.serializable, events: { bloodbath: this.hg._defaultBloodbathEvents, player: this.hg._defaultPlayerEvents, arena: this.hg._defaultArenaEvents, weapons: this.hg._defaultWeapons, battles: this.hg._defaultBattles, }, messages: this.hg.messages._messages, }; this.game.currentGame.day.state = 1; const worker = new Worker(Simulator._workerPath, {workerData: data}); worker.on('message', (msg) =&gt; { if (!msg) { cb(); return; } if (msg.reply &amp;&amp; this.msg) { this.hg._parent.common.reply( this.msg, msg.reply.replace( /\\{prefix\\}/g, this.msg.prefix + this.hg._parent.postPrefix), msg.reply2.replace( /\\{prefix\\}/g, this.msg.prefix + this.hg._parent.postPrefix)); } if (msg.endGame) { this.game.end(); } if (msg.reason) { cb(msg.reason); } if (msg.game) { this.game.currentGame = Game.from(msg.game.currentGame); cb(); } }); worker.on('stdout', (msg) =&gt; { this.hg._parent.debug(msg); }); worker.on('stderr', (msg) =&gt; { this.hg._parent.error(msg); }); worker.on('error', (err) =&gt; { this.hg._parent.error('Simulation worker errored'); console.error(err); }); worker.on('exit', (code) =&gt; { if (code != 0) this.hg._parent.debug('Worker exited with code ' + code); }); } } /** * @description Probability of each amount of people being chosen for an event. * Must total to 1.0 * * @private * @static * @type {Object.&lt;number&gt;} * @constant * @default */ Simulator._multiEventUserDistribution = { 1: 0.66, 2: 0.259, 3: 0.03, 4: 0.02, 5: 0.01, 6: 0.015, 7: 0.005, 8: 0.0005, 9: 0.0005, }; /** * @description If a larger percentage of people die in one day than this value, * then show a relevant message. * * @private * @static * @type {number} * @constant * @default */ Simulator._lotsOfDeathRate = 0.75; /** * @description If a lower percentage of people die in one day than this value, * then show a relevant message. * * @private * @static * @type {number} * @constant * @default */ Simulator._littleDeathRate = 0.15; /** * Produce a random number that is weighted by multiEventUserDistribution. * * @see {@link multiEventUserDistribution} * * @public * @static * @returns {number} The weighted number outcome. */ Simulator.weightedUserRand = function() { let sum = 0; const r = Math.random(); for (const i in Simulator._multiEventUserDistribution) { if (typeof Simulator._multiEventUserDistribution[i] !== 'number') { throw new Error( 'Invalid value for multiEventUserDistribution:' + Simulator._multiEventUserDistribution[i]); } else { sum += Simulator._multiEventUserDistribution[i]; if (r &lt;= sum) return i * 1; } } }; /** * Pick the players to put into an event. * * @private * @static * @param {number} numVictim Number of victims in this event. * @param {number} numAttacker Number of attackers in this event. * @param {string} victimOutcome Outcome of victims. If \"revived\", uses deadPool * instead of userPool. * @param {string} attackerOutcome Outcome of attackers. If \"revived\", uses * deadPool instead of userPool. * @param {object} options Options for this game. * @param {HungryGames~Player[]} userPool Pool of all remaining players to put * into an event. * @param {HungryGames~Player[]} deadPool Pool of all dead players that can be * revived. * @param {HungryGames~Team[]} teams All teams in this game. * @param {?Player} weaponWielder A player that is using a weapon in this event, * or null if no player is using a weapon. * @returns {HungryGames~Player[]} Array of all players that will be affected by * this event. */ Simulator._pickAffectedPlayers = function( numVictim, numAttacker, victimOutcome, attackerOutcome, options, userPool, deadPool, teams, weaponWielder) { const affectedUsers = []; const victimRevived = victimOutcome === 'revived'; const attackerRevived = attackerOutcome === 'revived'; let numTeams = 0; teams.forEach((el) =&gt; { if (el.numAlive &gt; 0) numTeams++; }); const collab = options.teammatesCollaborate == 'always' || (options.teammatesCollaborate == 'untilend' &amp;&amp; numTeams &gt; 1); if (collab &amp;&amp; options.teamSize &gt; 0) { let isAttacker = false; const validTeam = teams.findIndex((team) =&gt; { if (weaponWielder) { isAttacker = options.useEnemyWeapon ? (Math.random() &gt; 0.5) : true; return team.players.findIndex((p) =&gt; { return p === weaponWielder.id; }) &gt; -1; } let canBeVictim = false; if (attackerRevived) { if (numAttacker &lt;= team.players.length - team.numAlive &amp;&amp; numVictim &lt;= (victimRevived ? deadPool.length - (team.players.length - team.numAlive) : userPool.length - team.numPool)) { isAttacker = true; } } else if ( numAttacker &lt;= team.numPool &amp;&amp; numVictim &lt;= (victimRevived ? deadPool.length - (team.players.length - team.numAlive) : userPool.length - team.numPool)) { isAttacker = true; } if (victimRevived) { if (numVictim &lt;= team.players.length - team.numAlive &amp;&amp; numAttacker &lt;= (attackerRevived ? deadPool.length - (team.players.length - team.numAlive) : userPool.length - team.numPool)) { canBeVictim = true; } } else if ( numVictim &lt;= team.numPool &amp;&amp; numAttacker &lt;= (attackerRevived ? deadPool.length - (team.players.length - team.numAlive) : userPool.length - team.numPool)) { canBeVictim = true; } if (!isAttacker &amp;&amp; !canBeVictim) { return false; } if (isAttacker &amp;&amp; canBeVictim) { isAttacker = Math.random() &gt; 0.5; } return true; }); const findMatching = function(match, mainPool) { return mainPool.findIndex((pool) =&gt; { const teamId = teams.findIndex((team) =&gt; { return team.players.findIndex((player) =&gt; { return player == pool.id; }) &gt; -1; }); return match ? (teamId == validTeam) : (teamId != validTeam); }); }; for (let i = 0; i &lt; numAttacker + numVictim; i++) { if (victimRevived &amp;&amp; i &lt; numVictim) { const userIndex = findMatching(!isAttacker, deadPool); affectedUsers.push(deadPool.splice(userIndex, 1)[0]); } else if (attackerRevived &amp;&amp; i &gt;= numVictim) { const userIndex = findMatching(isAttacker, deadPool); affectedUsers.push(deadPool.splice(userIndex, 1)[0]); } else { const userIndex = findMatching( (i &lt; numVictim &amp;&amp; !isAttacker) || (i &gt;= numVictim &amp;&amp; isAttacker), userPool); affectedUsers.push(userPool.splice(userIndex, 1)[0]); } if (!affectedUsers[i]) { console.error( 'AFFECTED USER IS INVALID:', victimRevived, attackerRevived, i, '/', numVictim, numAttacker, 'Pool:', userPool.length, deadPool.length, teams[validTeam].players.length - teams[validTeam].numAlive); } } } else { let i = weaponWielder ? 1 : 0; for (i; i &lt; numAttacker + numVictim; i++) { if (i &lt; numVictim &amp;&amp; victimRevived) { const userIndex = Math.floor(Math.random() * deadPool.length); affectedUsers.push(deadPool.splice(userIndex, 1)[0]); } else if (i &gt;= numVictim &amp;&amp; attackerRevived) { const userIndex = Math.floor(Math.random() * deadPool.length); affectedUsers.push(deadPool.splice(userIndex, 1)[0]); } else { const userIndex = Math.floor(Math.random() * userPool.length); if (weaponWielder &amp;&amp; weaponWielder.id == userPool[userIndex].id) { i--; continue; } affectedUsers.push(userPool.splice(userIndex, 1)[0]); } } if (weaponWielder) { const wielderIndex = userPool.findIndex((u) =&gt; { return u.id == weaponWielder.id; }); affectedUsers.push(userPool.splice(wielderIndex, 1)[0]); } } return affectedUsers; }; /** * Base of all actions to perform on a player. * * @private * @static * @param {HungryGames~GuildGame} game Current GuildGame being affected. * @param {HungryGames~Player} affected The player to affect. * @param {number} kills The number of kills the player gets in this action. * @param {HungryGames~Weapon[]} [weapon] The weapon being used if any. */ Simulator._effectUser = function(game, affected, kills, weapon) { if (weapon) { if (!isNaN(affected.weapons[weapon.name])) { affected.weapons[weapon.name] = affected.weapons[weapon.name] * 1 + weapon.count * 1; } else { affected.weapons[weapon.name] = weapon.count * 1; } if (affected.weapons[weapon.name] &lt;= 0) { delete affected.weapons[weapon.name]; } } affected.kills += kills; }; /** * Kill the given player in the given guild game. * * @private * @static * @param {HungryGames~GuildGame} game Current GuildGame being affected. * @param {HungryGames~Player} a The player to affect. * @param {number} k The number of kills the player gets in this action. * @param {HungryGames~Weapon[]} [w] The weapon being used if any. */ Simulator._killUser = function(game, a, k, w) { Simulator._effectUser(game, a, k, w); a.living = false; a.bleeding = 0; a.state = 'dead'; a.weapons = {}; a.rank = game.currentGame.numAlive--; a.dayOfDeath = game.currentGame.day.num; if (game.options.teamSize &gt; 0) { const team = game.currentGame.teams.find((team) =&gt; { return team.players.findIndex((obj) =&gt; { return a.id == obj; }) &gt; -1; }); if (!team) { console.log('FAILED TO FIND ADEQUATE TEAM FOR USER', a.id); } else { team.numAlive--; if (team.numAlive === 0) { let teamsLeft = 0; game.currentGame.teams.forEach((obj) =&gt; { if (obj.numAlive &gt; 0) teamsLeft++; }); team.rank = teamsLeft + 1; } } } }; /** * Wound the given player in the given guild game. * * @private * @static * @param {HungryGames~GuildGame} game Current GuildGame being affected. * @param {HungryGames~Player} a The player to affect. * @param {number} k The number of kills the player gets in this action. * @param {HungryGames~Weapon[]} [w] The weapon being used if any. */ Simulator._woundUser = function(game, a, k, w) { Simulator._effectUser(game, a, k, w); a.state = 'wounded'; }; /** * Heal the given player in the given guild game. * * @private * @static * @param {HungryGames~GuildGame} game Current GuildGame being affected. * @param {HungryGames~Player} a The player to affect. * @param {number} k The number of kills the player gets in this action. * @param {HungryGames~Weapon[]} [w] The weapon being used if any. */ Simulator._restoreUser = function(game, a, k, w) { Simulator._effectUser(game, a, k, w); a.state = 'normal'; a.bleeding = 0; }; /** * Revive the given player in the given guild game. * * @private * @static * @param {HungryGames~GuildGame} game Current GuildGame being affected. * @param {HungryGames~Player} a The player to affect. * @param {number} k The number of kills the player gets in this action. * @param {HungryGames~Weapon[]} [w] The weapon being used if any. */ Simulator._reviveUser = function(game, a, k, w) { Simulator._effectUser(game, a, k, w); game.currentGame.numAlive++; game.currentGame.includedUsers.forEach((obj) =&gt; { if (!obj.living &amp;&amp; obj.rank &lt; a.rank) obj.rank++; }); if (game.options.teamSize &gt; 0) { const team = game.currentGame.teams.find((obj) =&gt; { return obj.players.findIndex((obj) =&gt; { return a.id == obj; }) &gt; -1; }); team.numAlive++; game.currentGame.teams.forEach((obj) =&gt; { if (obj.numAlive === 0 &amp;&amp; obj.rank &lt; team.rank) obj.rank++; }); team.rank = 1; } a.state = 'zombie'; a.living = true; a.bleeding = 0; a.rank = 1; }; /** * Pick event that satisfies all requirements and settings. * * @private * @static * @param {HungryGames~Player[]} userPool Pool of players left to chose from * in this day. * @param {HungryGames~Event[]} eventPool Pool of all events available to * choose at this time. * @param {object} options The options set in the current game. * @param {number} numAlive Number of players in the game still alive. * @param {number} numTotal Number of players in the game total. * @param {HungryGames~Team[]} teams Array of teams in this game. * @param {HungryGames~OutcomeProbabilities} probOpts Death rate weights. * @param {?Player} weaponWielder A player that is using a weapon in this * event, or null if no player is using a weapon. * @param {string} chosenWeapon Name of the weapon the player is trying to use. * @returns {?HungryGames~Event} The chosen event that satisfies all * requirements, or null if something went wrong. */ Simulator._pickEvent = function( userPool, eventPool, options, numAlive, numTotal, teams, probOpts, weaponWielder, chosenWeapon) { if (eventPool) eventPool = eventPool.filter((el) =&gt; el); // const fails = []; let loop = 0; while (loop &lt; 100) { loop++; if (!eventPool || eventPool.length == 0) { // fails.push('No Events'); break; } const eventIndex = Simulator._probabilityEvent( eventPool, probOpts, options.customEventWeight); const eventTry = eventPool[eventIndex]; if (!eventTry) { /* if (fails.length &lt; 3) { console.error('Invalid Event:', eventTry); } fails.push('Invalid Event'); */ eventPool.splice(eventIndex, 1); continue; } let numAttacker = eventTry.attacker.count * 1; let numVictim = eventTry.victim.count * 1; const victimRevived = eventTry.victim.outcome === 'revived'; const attackerRevived = eventTry.attacker.outcome === 'revived'; let eventEffectsNumMin = 0; let eventRevivesNumMin = 0; victimRevived ? (eventRevivesNumMin += Math.abs(numVictim)) : (eventEffectsNumMin += Math.abs(numVictim)); attackerRevived ? (eventRevivesNumMin += Math.abs(numAttacker)) : (eventEffectsNumMin += Math.abs(numAttacker)); // If the chosen event requires more players than there are remaining, // pick a new event. if (eventEffectsNumMin &gt; userPool.length) { /* fails.push( 'Event too large (' + eventEffectsNumMin + ' &gt; ' + userPool.length + '): ' + eventIndex + ' V:' + eventTry.victim.count + ' A:' + eventTry.attacker.count + ' M:' + eventTry.message); */ continue; } else if (eventRevivesNumMin &gt; numTotal - numAlive) { /* fails.push( 'Event too large (' + eventRevivesNumMin + ' &gt; ' + (numTotal - numAlive) + '): ' + eventIndex + ' V:' + eventTry.victim.count + ' A:' + eventTry.attacker.count + ' M:' + eventTry.message); */ continue; } const consumes = Math.abs( Simulator._parseConsumeCount( eventTry.consumes, numVictim, numAttacker)); if (weaponWielder &amp;&amp; chosenWeapon) { if (consumes &gt; weaponWielder.weapons[chosenWeapon]) { /* fails.push( 'Not enough consumables (' + consumes + ' &gt; ' + weaponWielder.weapons[chosenWeapon] + '): ' + eventIndex + ' V:' + eventTry.victim.count + ' A:' + eventTry.attacker.count + ' M:' + eventTry.message); */ continue; } } const multiAttacker = numAttacker &lt; 0; const multiVictim = numVictim &lt; 0; const attackerMin = -numAttacker; const victimMin = -numVictim; if (multiAttacker || multiVictim) { let count = 0; while (count++ &lt; 100) { if (multiAttacker) { numAttacker = Simulator.weightedUserRand() + (attackerMin - 1); } if (multiVictim) { numVictim = Simulator.weightedUserRand() + (victimMin - 1); } if (weaponWielder &amp;&amp; chosenWeapon &amp;&amp; Simulator._parseConsumeCount( eventTry.consumes, numVictim, numAttacker) &gt; weaponWielder.weapons[chosenWeapon]) { continue; } else if (victimRevived &amp;&amp; attackerRevived) { if (numAttacker + numVictim &lt;= numTotal - numAlive) break; } else if (victimRevived) { if (numAttacker &lt;= userPool.length &amp;&amp; numVictim &lt;= numTotal - numAlive) { break; } } else if (attackerRevived) { if (numAttacker &lt;= numTotal - numAlive &amp;&amp; numVictim &lt;= userPool.length) { break; } } else if (numAttacker + numVictim &lt;= userPool.length) { break; } } if (count &gt;= 100) { self.error('Infinite loop while picking player count.'); // fails.push('Infinite loop while picking player count.'); continue; } } const failReason = Simulator._validateEventRequirements( victimRevived ? 0 : numVictim, attackerRevived ? 0 : numAttacker, userPool, numAlive, teams, options, eventTry.victim.outcome == 'dies', eventTry.attacker.outcome == 'dies', weaponWielder); if (failReason) { /* fails.push( 'Fails event requirement validation: ' + eventIndex + ' ' + failReason); */ continue; } const finalEvent = JSON.parse(JSON.stringify(eventPool[eventIndex])); finalEvent.attacker.count = numAttacker; finalEvent.victim.count = numVictim; return finalEvent; } return null; }; /** * Ensure teammates don't attack each other. * * @private * @static * @param {number} numVictim The number of victims in the event. * @param {number} numAttacker The number of attackers in the event. * @param {HungryGames~Player[]} userPool Pool of all remaining players to put * into an event. * @param {HungryGames~Team[]} teams All teams in this game. * @param {object} options Options for this game. * @param {boolean} victimsDie Do the victims die in this event? * @param {boolean} attackersDie Do the attackers die in this event? * @param {?Player} weaponWielder A player that is using a weapon in this * event, or null if no player is using a weapon. * @returns {?string} String describing failing check, or null of pass. */ Simulator._validateEventTeamConstraint = function( numVictim, numAttacker, userPool, teams, options, victimsDie, attackersDie, weaponWielder) { let numTeams = 0; teams.forEach((el) =&gt; { if (el.numAlive &gt; 0) numTeams++; }); const collab = options.teammatesCollaborate == 'always' || (options.teammatesCollaborate == 'untilend' &amp;&amp; numTeams &gt; 1); if (collab &amp;&amp; options.teamSize &gt; 0) { if (weaponWielder) { let numTeams = 0; for (let i = 0; i &lt; teams.length; i++) { const team = teams[i]; let numPool = 0; team.players.forEach((player) =&gt; { if (userPool.findIndex((pool) =&gt; { return pool.id == player &amp;&amp; pool.living; }) &gt; -1) { numPool++; } }); team.numPool = numPool; if (numPool &gt; 0) numTeams++; } if (numTeams &lt; 2) { if (attackersDie || victimsDie) { return 'TEAM_WEAPON_NO_OPPONENT'; } } const attackerTeam = teams.find((team) =&gt; { return team.players.findIndex((p) =&gt; { return p === weaponWielder.id; }) &gt; -1; }); if (!attackerTeam) { self.error(weaponWielder.id + ' not on any team'); return 'TEAM_WEAPON_NO_TEAM'; } return !(numAttacker &lt;= attackerTeam.numPool &amp;&amp; numVictim &lt;= userPool.length - attackerTeam.numPool) &amp;&amp; 'TEAM_WEAPON_TOO_LARGE' || null; } else { let largestTeam = {index: 0, size: 0}; let numTeams = 0; for (let i = 0; i &lt; teams.length; i++) { const team = teams[i]; let numPool = 0; team.players.forEach((player) =&gt; { if (userPool.findIndex((pool) =&gt; { return pool.id == player &amp;&amp; pool.living; }) &gt; -1) { numPool++; } }); team.numPool = numPool; if (numPool &gt; largestTeam.size) { largestTeam = {index: i, size: numPool}; } if (numPool &gt; 0) numTeams++; } if (numTeams &lt; 2) { if (attackersDie || victimsDie) { return 'TEAM_NO_OPPONENT'; } } return !((numAttacker &lt;= largestTeam.size &amp;&amp; numVictim &lt;= userPool.length - largestTeam.size) || (numVictim &lt;= largestTeam.size &amp;&amp; numAttacker &lt;= userPool.length - largestTeam.size)) &amp;&amp; 'TEAM_TOO_LARGE' || null; } } return null; }; /** * Ensure the event we choose will not force all players to be dead. * * @private * @static * @param {number} numVictim Number of victims in this event. * @param {number} numAttacker Number of attackers in this event. * @param {number} numAlive Total number of living players left in the game. * @param {object} options The options set for this game. * @param {boolean} victimsDie Do the victims die in this event? * @param {boolean} attackersDie Do the attackers die in this event? * @returns {boolean} Will this event follow current options set about number * of victors required. */ Simulator._validateEventVictorConstraint = function( numVictim, numAttacker, numAlive, options, victimsDie, attackersDie) { if (!options.allowNoVictors) { let numRemaining = numAlive; if (victimsDie) numRemaining -= numVictim; if (attackersDie) numRemaining -= numAttacker; return numRemaining &gt;= 1; } return true; }; /** * Ensure the number of users in an event is mathematically possible. * * @private * @static * @param {number} numVictim Number of victims in this event. * @param {number} numAttacker Number of attackers in this event. * @param {HungryGames~Player[]} userPool Pool of all remaining players to put * into an event. * @param {number} numAlive Total number of living players left in the game. * @returns {boolean} If the event requires a number of players that is valid * from the number of players left to choose from. */ Simulator._validateEventNumConstraint = function( numVictim, numAttacker, userPool, numAlive) { return numVictim + numAttacker &lt;= userPool.length &amp;&amp; numVictim + numAttacker &lt;= numAlive; }; /** * Ensure the event chosen meets all requirements for actually being used in * the current game. * * @private * @static * @param {number} numVictim Number of victims in this event. * @param {number} numAttacker Number of attackers in this event. * @param {HungryGames~Player[]} userPool Pool of all remaining players to put * into an event. * @param {number} numAlive Total number of living players left in the game. * @param {HungryGames~Team[]} teams All teams in this game. * @param {object} options The options set for this game. * @param {boolean} victimsDie Do the victims die in this event? * @param {boolean} attackersDie Do the attackers die in this event? * @param {?Player} weaponWielder A player that is using a weapon in this * event, or null if no player is using a weapon. * @returns {?string} String of failing constraint check, or null if passes. */ Simulator._validateEventRequirements = function( numVictim, numAttacker, userPool, numAlive, teams, options, victimsDie, attackersDie, weaponWielder) { if (!Simulator._validateEventNumConstraint( numVictim, numAttacker, userPool, numAlive)) { return 'NUM_CONSTRAINT'; } const failReason = Simulator._validateEventTeamConstraint( numVictim, numAttacker, userPool, teams, options, victimsDie, attackersDie, weaponWielder); if (failReason) { return 'TEAM_CONSTRAINT-' + failReason; } if (!Simulator._validateEventVictorConstraint( numVictim, numAttacker, numAlive, options, victimsDie, attackersDie)) { return 'VICTOR_CONSTRAINT'; } return null; }; /** * Produce a random event that using probabilities set in options. * * @private * @static * @param {HungryGames~Event[]} eventPool The pool of all events to consider. * @param {{ * kill: number, wound: number, thrive: number, nothing: number * }} probabilityOpts The probabilities of each type of event being used. * @param {number} [customWeight=1] The weight of custom events. * @param {number} [recurse=0] The current recursive depth. * @returns {number} The index of the event that was chosen. */ Simulator._probabilityEvent = function( eventPool, probabilityOpts, customWeight = 1, recurse = 0) { let probTotal = 0; if (typeof probabilityOpts.kill === 'number') { probTotal += probabilityOpts.kill; } else { probabilityOpts.kill = 0; } if (typeof probabilityOpts.nothing === 'number') { probTotal += probabilityOpts.nothing; } else { probabilityOpts.nothing = 0; } if (typeof probabilityOpts.revive === 'number') { probTotal += probabilityOpts.revive; } else { probabilityOpts.revive = 0; } if (typeof probabilityOpts.thrive === 'number') { probTotal += probabilityOpts.thrive; } else { probabilityOpts.thrive = 0; } if (typeof probabilityOpts.wound === 'number') { probTotal += probabilityOpts.wound; } else { probabilityOpts.wound = 0; } const value = Math.random() * probTotal; let type; if (value &gt; (probTotal -= probabilityOpts.nothing)) type = null; else if (value &gt; (probTotal -= probabilityOpts.revive)) type = 'revived'; else if (value &gt; (probTotal -= probabilityOpts.thrive)) type = 'thrives'; else if (value &gt; (probTotal -= probabilityOpts.wound)) type = 'wounded'; else type = 'dies'; const finalPool = []; for (let i = 0; i &lt; eventPool.length; i++) { if (type &amp;&amp; (eventPool[i].attacker.outcome == type || eventPool[i].victim.outcome == type)) { finalPool.push(i); } else if ( !type &amp;&amp; eventPool[i].attacker.outcome == 'nothing' &amp;&amp; eventPool[i].victim.outcome == 'nothing') { finalPool.push(i); } } if (finalPool.length == 0) { if (recurse &lt; 10) { return Simulator._probabilityEvent( eventPool, probabilityOpts, customWeight, recurse + 1); } else { self.error( 'Failed to find event with probabilities: ' + JSON.stringify(probabilityOpts) + ' from ' + eventPool.length + ' events.'); return Math.floor(Math.random() * eventPool.length); } } else { let total = finalPool.length; if (customWeight != 1) { finalPool.forEach((el) =&gt; { if (eventPool[el].custom) total += customWeight - 1; }); } const pick = Math.random() * total; return finalPool.find((el) =&gt; { total -= eventPool[el].custom ? customWeight : 1; if (total &lt; pick) return true; return false; }); // return finalPool[Math.floor(Math.random() * finalPool.length)]; } }; /** * Parse the number of items consumed from the given consumed value, and number * of victims and attackers. * * @private * @static * @param {string} consumeString The consumes value for the event. * @param {number} numVictim The number of victims in the event. * @param {number} numAttacker The number of attackers in the event. * @returns {number} The number of consumed items. */ Simulator._parseConsumeCount = function(consumeString, numVictim, numAttacker) { const consumedMatch = (consumeString + '').match(/^(\\d*)(V|A)?$/); if (!consumedMatch) { return 0; } else if (consumedMatch[2] == 'V') { return numVictim * (consumedMatch[1] || 1); } else if (consumedMatch[2] == 'A') { return numAttacker * (consumedMatch[1] || 1); } else { return consumedMatch[1]; } }; /** * Relative path from CWD where the simulation worker is located. * @private * @static * @type {string} * @default * @constant */ Simulator._workerPath = './src/hg/simulator/worker.js'; module.exports = Simulator; × Search results Close "},"hg_simulator_worker.js.html":{"id":"hg_simulator_worker.js.html","title":"Source: hg/simulator/worker.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/simulator/worker.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const {workerData, parentPort} = require('worker_threads'); const Event = require('../Event.js'); const Battle = require('../Battle.js'); const Grammar = require('../Grammar.js'); const Simulator = require('../Simulator.js'); const GuildGame = require('../GuildGame.js'); /** * @description Asyncronous worker that does the actual simulating. * @memberof HungryGames~Simulator * @inner */ class Worker { /** * @description Create and start simulating. * @param {{ * game: object, * messages: object.&lt;string&gt; * }} sim Simulation data. * @param {boolean} [retry=true] Whether to try again if there is an error. */ constructor(sim, retry = true) { sim.game.currentGame.day.state = 1; sim.game.currentGame.day.num++; sim.game.currentGame.day.events = []; sim.messages = { _messages: sim.messages, /** * Get a random message of a given type. * * @public * @param {string} type The message type to get. * @returns {string} A random message of the given type. */ get(type) { const list = this._messages[type]; if (!list) return 'badtype'; const length = list.length; if (length == 0) return 'nomessage'; return list[Math.floor(Math.random() * length)]; }, }; const id = sim.game.id; const userPool = sim.game.currentGame.includedUsers.filter((obj) =&gt; obj.living); // Shuffle user order because games may have been rigged :thonk:. for (let i = 0; i &lt; userPool.length; i++) { const index = Math.floor(Math.random() * (userPool.length - i)) + i; const tmp = userPool[i]; userPool[i] = userPool[index]; userPool[index] = tmp; } const teams = sim.game.currentGame.teams; // Shuffle team order because games may have been rigged :hyperthonk:. for (let i = 0; i &lt; teams.length; i++) { const index = Math.floor(Math.random() * (teams.length - i)) + i; const tmp = teams[i]; teams[i] = teams[index]; teams[index] = tmp; } const startingAlive = userPool.length; let userEventPool; let doArenaEvent = false; let arenaEvent; if (sim.game.currentGame.day.num === 0) { userEventPool = sim.events.bloodbath.concat(sim.game.customEvents.bloodbath); if (sim.game.disabledEvents &amp;&amp; sim.game.disabledEvents.bloodbath) { userEventPool = userEventPool.filter((el) =&gt; { return !sim.game.disabledEvents.bloodbath.find((d) =&gt; { return Event.equal(d, el); }); }); } if (userEventPool.length == 0) { this.cb({ reply: 'All bloodbath events have been disabled! Please enable ' + 'events so that something can happen in the games!', endGame: true, reason: 'No Bloodbath Events', }); return; } } else { doArenaEvent = startingAlive &gt; 2 &amp;&amp; sim.game.options.arenaEvents &amp;&amp; Math.random() &lt; sim.game.options.probabilityOfArenaEvent; if (doArenaEvent) { const arenaEventPool = sim.events.arena.concat(sim.game.customEvents.arena); do { let total = arenaEventPool.length; if (sim.game.options.customEventWeight != 1) { arenaEventPool.forEach((el) =&gt; { if (el.custom) { total += sim.game.options.customEventWeight - 1; } }); } const pick = Math.random() * total; const index = arenaEventPool.findIndex((el) =&gt; { total -= el.custom ? sim.game.options.customEventWeight : 1; if (total &lt; pick) return true; return false; }); arenaEvent = arenaEventPool[index]; userEventPool = arenaEvent.outcomes; if (sim.game.disabledEvents &amp;&amp; sim.game.disabledEvents.arena &amp;&amp; sim.game.disabledEvents.arena[arenaEvent.message]) { userEventPool = userEventPool.filter((el) =&gt; { return !sim.game.disabledEvents.arena[arenaEvent.message].find( (d) =&gt; Event.equal(d, el)); }); } if (userEventPool.length == 0) { arenaEventPool.splice(index, 1); } else { sim.game.currentGame.day.events.push( Event.finalizeSimple(sim.messages.get('eventStart'), sim.game)); sim.game.currentGame.day.events.push( Event.finalizeSimple( `**___${arenaEvent.message}___**`, sim.game)); break; } } while (arenaEventPool.length &gt; 0); if (arenaEventPool.length == 0) doArenaEvent = false; } if (!doArenaEvent) { userEventPool = sim.events.player.concat(sim.game.customEvents.player); if (sim.game.disabledEvents &amp;&amp; sim.game.disabledEvents.player) { userEventPool = userEventPool.filter((el) =&gt; { return !sim.game.disabledEvents.player.find((d) =&gt; { return Event.equal(d, el); }); }); } if (userEventPool.length == 0) { this.cb({ reply: 'All player events have been disabled! Please enable events' + ' so that something can happen in the games!', endGame: true, reason: 'No Player Events', }); return; } } } const weapons = Object.assign({}, sim.events.weapons); if (sim.game.customEvents.weapon) { const entries = Object.entries(sim.game.customEvents.weapon); for (let i = 0; i &lt; entries.length; i++) { if (weapons[entries[i][0]]) { weapons[entries[i][0]].outcomes = weapons[entries[i][0]].outcomes.concat(entries[i][1].outcomes); } else { weapons[entries[i][0]] = entries[i][1]; } if (sim.game.disabledEvents &amp;&amp; sim.game.disabledEvents.weapon &amp;&amp; sim.game.disabledEvents.weapon[entries[i][0]]) { weapons[entries[i][0]].outcomes = weapons[entries[i][0]].outcomes.filter((el) =&gt; { return !sim.game.disabledEvents.weapon[entries[i][0]].find( (d) =&gt; { return Event.equal(d, el); }); }); } } } const probOpts = sim.game.currentGame.day.num === 0 ? sim.game.options.bloodbathOutcomeProbs : (doArenaEvent ? (arenaEvent.outcomeProbs || sim.game.options.arenaOutcomeProbs) : sim.game.options.playerOutcomeProbs); const nameFormat = sim.game.options.useNicknames ? 'nickname' : 'username'; while (userPool.length &gt; 0) { let eventTry; let affectedUsers; let numAttacker; let numVictim; let subMessage = ''; const deadPool = sim.game.currentGame.includedUsers.filter((obj) =&gt; { return !obj.living; }); let userWithWeapon = null; if (!doArenaEvent) { const usersWithWeapon = []; for (let i = 0; i &lt; userPool.length; i++) { if (userPool[i].weapons &amp;&amp; Object.keys(userPool[i].weapons).length &gt; 0) { usersWithWeapon.push(userPool[i]); } } if (usersWithWeapon.length &gt; 0) { userWithWeapon = usersWithWeapon[Math.floor( Math.random() * usersWithWeapon.length)]; } } let useWeapon = userWithWeapon &amp;&amp; Math.random() &lt; sim.game.options.probabilityOfUseWeapon; if (useWeapon) { const userWeapons = Object.keys(userWithWeapon.weapons); const chosenWeapon = userWeapons[Math.floor(Math.random() * userWeapons.length)]; if (!weapons[chosenWeapon]) { useWeapon = false; // console.log('No event pool with weapon', chosenWeapon); } else { eventTry = Simulator._pickEvent( userPool, weapons[chosenWeapon].outcomes, sim.game.options, sim.game.currentGame.numAlive, sim.game.currentGame.includedUsers.length, teams, probOpts, userWithWeapon, chosenWeapon); if (!eventTry) { useWeapon = false; /* self.error( 'No event with weapon \"' + chosenWeapon + '\" for available players ' + id); */ } else { numAttacker = eventTry.attacker.count; numVictim = eventTry.victim.count; affectedUsers = Simulator._pickAffectedPlayers( numVictim, numAttacker, eventTry.victim.outcome, eventTry.attacker.outcome, sim.game.options, userPool, deadPool, teams, userWithWeapon, chosenWeapon); const consumed = Simulator._parseConsumeCount( eventTry.consumes, numVictim, numAttacker); userWithWeapon.weapons[chosenWeapon] -= consumed; if (userWithWeapon.weapons[chosenWeapon] &lt;= 0) { delete userWithWeapon.weapons[chosenWeapon]; const weaponName = chosenWeapon; let consumableName = weaponName; if (weapons[weaponName]) { if (weapons[weaponName].consumable) { consumableName = weapons[weaponName].consumable.replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, '$2'); } else if (weapons[weaponName].name) { consumableName = weapons[weaponName].name.replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, '$2'); } else { consumableName += 's'; } } else { consumableName += 's'; } subMessage += Grammar.formatMultiNames([userWithWeapon], nameFormat) + ' runs out of ' + consumableName + '.'; } else if (consumed != 0) { const weaponName = chosenWeapon; let consumableName = weaponName; const count = consumed; if (weapons[weaponName].consumable) { consumableName = weapons[weaponName].consumable.replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, (count == 1 ? '$1' : '$2')); } else if (weapons[weaponName].name) { consumableName = weapons[weaponName].name.replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, (count == 1 ? '$1' : '$2')); } else if (count != 1) { consumableName += 's'; } subMessage += Grammar.formatMultiNames([userWithWeapon], nameFormat) + ' lost ' + count + ' ' + consumableName + '.'; } let owner = 'their'; if (numAttacker &gt; 1 || (numAttacker == 1 &amp;&amp; affectedUsers[numVictim].id != userWithWeapon.id)) { owner = Grammar.formatMultiNames([userWithWeapon], nameFormat) + '\\'s'; } if (!eventTry.message) { const weaponName = weapons[chosenWeapon].name || chosenWeapon; eventTry.message = weapons.message .replace(/\\{weapon\\}/g, owner + ' ' + weaponName) .replace(/\\{action\\}/g, eventTry.action) .replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, (consumed == 1 ? '$1' : '$2')); } else { eventTry.message = eventTry.message.replace(/\\{owner\\}/g, owner); } } } } const doBattle = ((!useWeapon &amp;&amp; !doArenaEvent) || !eventTry) &amp;&amp; userPool.length &gt; 1 &amp;&amp; (Math.random() &lt; sim.game.options.probabilityOfBattle || sim.game.currentGame.numAlive == 2) &amp;&amp; !Simulator._validateEventRequirements( 1, 1, userPool, sim.game.currentGame.numAlive, teams, sim.game.options, true, false); if (doBattle) { do { numAttacker = Simulator.weightedUserRand(); numVictim = Simulator.weightedUserRand(); } while (Simulator._validateEventRequirements( numVictim, numAttacker, userPool, sim.game.currentGame.numAlive, teams, sim.game.options, true, false)); affectedUsers = Simulator._pickAffectedPlayers( numVictim, numAttacker, 'dies', 'nothing', sim.game.options, userPool, deadPool, teams, null); eventTry = Battle.finalize( affectedUsers, numVictim, numAttacker, sim.game.options.mentionAll, sim.game, sim.events.battles); } else if (!useWeapon || !eventTry) { eventTry = Simulator._pickEvent( userPool, userEventPool, sim.game.options, sim.game.currentGame.numAlive, sim.game.currentGame.includedUsers.length, teams, probOpts); if (!eventTry) { console.error( 'No event for ' + userPool.length + ' from ' + userEventPool.length + ' events. No weapon, Arena Event: ' + (doArenaEvent ? arenaEvent.message : 'No') + ', Day: ' + sim.game.currentGame.day.num + ' Guild: ' + id + ' Retrying: ' + retry); sim.game.currentGame.day.state = 0; sim.game.currentGame.day.num--; if (retry) { return new Worker(sim, false); } this.cb({ reply: 'Oops! I wasn\\'t able to find a valid event for the ' + 'remaining players.\\nThis is usually because too many ' + 'events are disabled.\\nIf you think this is a bug, ' + 'please tell SpikeyRobot#0971', reply2: 'Try again with `{prefix}next`.\\n(Failed to find valid ' + 'event for \\'' + (doArenaEvent ? arenaEvent.message : 'player events') + '\\' suitable for ' + userPool.length + ' remaining players)', reason: 'Bad Configuration', }); return; } numAttacker = eventTry.attacker.count; numVictim = eventTry.victim.count; affectedUsers = Simulator._pickAffectedPlayers( numVictim, numAttacker, eventTry.victim.outcome, eventTry.attacker.outcome, sim.game.options, userPool, deadPool, teams, null); } let numKilled = 0; let weapon = eventTry.victim.weapon; if (weapon &amp;&amp; !weapons[weapon.name]) { weapon = null; eventTry.victim.weapon = null; } for (let i = 0; i &lt; numVictim; i++) { let numKills = 0; if (eventTry.victim.killer) numKills = numAttacker; const affected = affectedUsers[i]; switch (eventTry.victim.outcome) { case 'dies': numKilled++; Simulator._killUser(sim.game, affected, numKills, weapon); break; case 'wounded': Simulator._woundUser(sim.game, affected, numKills, weapon); break; case 'thrives': Simulator._restoreUser(sim.game, affected, numKills, weapon); break; case 'revived': Simulator._reviveUser(sim.game, affected, numKills, weapon); break; default: Simulator._effectUser(sim.game, affected, numKills, weapon); break; } if (affected.state == 'wounded') { affected.bleeding++; } else { affected.bleeding = 0; } } weapon = eventTry.attacker.weapon; if (weapon &amp;&amp; !weapons[weapon.name]) { weapon = null; eventTry.attacker.weapon = null; } for (let i = numVictim; i &lt; numVictim + numAttacker; i++) { let numKills = 0; if (eventTry.attacker.killer) numKills = numVictim; const affected = affectedUsers[i]; switch (eventTry.attacker.outcome) { case 'dies': numKilled++; Simulator._killUser(sim.game, affected, numKills, weapon); break; case 'wounded': Simulator._woundUser(sim.game, affected, numKills, weapon); break; case 'thrives': Simulator._restoreUser(sim.game, affected, numKills, weapon); break; case 'revived': Simulator._reviveUser(sim.game, affected, numKills, weapon); break; default: Simulator._effectUser(sim.game, affected, numKills, weapon); break; } if (affected.state == 'wounded') { affected.bleeding++; } else { affected.bleeding = 0; } } let finalEvent = eventTry; if (eventTry.attacker.weapon) { for (let i = 0; i &lt; numAttacker; i++) { const user = affectedUsers[numVictim + i]; const consumableList = Object .entries(user.weapons || {[eventTry.attacker.weapon.name]: 0}) .map((el) =&gt; { const weaponName = el[0]; let consumableName = weaponName; const count = el[1]; if (!weapons[weaponName]) { console.error('1 Failed to find weapon: ' + weaponName); return `(Unknown weapon ${weaponName}. This is a bug.)`; } if (weapons[weaponName].consumable) { consumableName = weapons[weaponName].consumable.replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, '$' + (count == 1 ? '1' : '2')); } else if (count != 1) { consumableName += 's'; } return (count || 0) + ' ' + consumableName; }) .join(', '); subMessage += '\\n' + Grammar.formatMultiNames([user], nameFormat) + ' now has ' + consumableList + '.'; } } if (eventTry.victim.weapon) { for (let i = 0; i &lt; numVictim; i++) { const user = affectedUsers[i]; const consumableList = Object .entries(user.weapons || {[eventTry.victim.weapon.name]: 0}) .map((el) =&gt; { const weaponName = el[0]; let consumableName = weaponName; const count = el[1]; if (!weapons[weaponName]) { console.error('2 Failed to find weapon: ' + weaponName); return `(Unknown weapon ${weaponName}. This is a bug.)`; } if (weapons[weaponName].consumable) { consumableName = weapons[weaponName].consumable.replace( /\\[C([^|]*)\\|([^\\]]*)\\]/g, '$' + (count == 1 ? '1' : '2')); } else if (count != 1) { consumableName += 's'; } return (count || 0) + ' ' + consumableName; }) .join(', '); subMessage += '\\n' + Grammar.formatMultiNames([user], nameFormat) + ' now has ' + consumableList + '.'; } } if (doBattle) { affectedUsers = []; } else { finalEvent = Event.finalize( eventTry.message, affectedUsers, numVictim, numAttacker, eventTry.victim.outcome, eventTry.attacker.outcome, sim.game); finalEvent.subMessage = subMessage; } /* if (eventTry.attacker.killer &amp;&amp; eventTry.victim.killer) { finalEvent.icons.splice(numVictim, 0, {url: fistBoth}); } else if (eventTry.attacker.killer) { finalEvent.icons.splice(numVictim, 0, {url: fistRight}); } else if (eventTry.victim.killer) { finalEvent.icons.splice(numVictim, 0, {url: fistLeft}); } */ sim.game.currentGame.day.events.push(finalEvent); if (affectedUsers.length !== 0) { console.log('Affected users remain! ' + affectedUsers.length); } if (numKilled &gt; 4) { sim.game.currentGame.day.events.push( Event.finalizeSimple(sim.messages.get('slaughter'), sim.game)); } } if (doArenaEvent) { sim.game.currentGame.day.events.push( Event.finalizeSimple(sim.messages.get('eventEnd'), sim.game)); } if (!sim.game.currentGame.forcedOutcomes) { sim.game.currentGame.forcedOutcomes = []; } else { sim.game.currentGame.forcedOutcomes = sim.game.currentGame.forcedOutcomes.filter((el) =&gt; { if (typeof el.text !== 'string') el.text = sim.events.player; GuildGame.forcePlayerState( sim.game, el, sim.messages, sim.events.player); return el.persists; }); } const usersBleeding = []; const usersRecovered = []; sim.game.currentGame.includedUsers.forEach((obj) =&gt; { if (obj.bleeding &gt; 0 &amp;&amp; obj.bleeding &gt;= sim.game.options.bleedDays &amp;&amp; obj.living) { if (Math.random() &lt; sim.game.options.probabilityOfBleedToDeath &amp;&amp; (sim.game.options.allowNoVictors || sim.game.currentGame.numAlive &gt; 1)) { usersBleeding.push(obj); obj.living = false; obj.bleeding = 0; obj.state = 'dead'; obj.rank = sim.game.currentGame.numAlive--; obj.dayOfDeath = sim.game.currentGame.day.num; if (sim.game.options.teamSize &gt; 0) { const team = teams.find((team) =&gt; { return team.players.findIndex((player) =&gt; { return obj.id == player; }) &gt; -1; }); team.numAlive--; if (team.numAlive === 0) { let teamsLeft = 0; teams.forEach((obj) =&gt; { if (obj.numAlive &gt; 0) teamsLeft++; }); team.rank = teamsLeft + 1; } } } else { usersRecovered.push(obj); obj.bleeding = 0; obj.state = 'normal'; } } }); if (usersRecovered.length &gt; 0) { sim.game.currentGame.day.events.push( Event.finalize( sim.messages.get('patchWounds'), usersRecovered, usersRecovered.length, 0, 'thrives', 'nothing', sim.game)); } if (usersBleeding.length &gt; 0) { sim.game.currentGame.day.events.push( Event.finalize( sim.messages.get('bleedOut'), usersBleeding, usersBleeding.length, 0, 'dies', 'nothing', sim.game)); } const deathPercentage = 1 - (sim.game.currentGame.numAlive / startingAlive); if (deathPercentage &gt; Simulator._lotsOfDeathRate) { sim.game.currentGame.day.events.splice( 0, 0, Event.finalizeSimple(sim.messages.get('lotsOfDeath'), sim.game)); } else if (deathPercentage === 0) { sim.game.currentGame.day.events.push( Event.finalizeSimple(sim.messages.get('noDeath'), sim.game)); } else if (deathPercentage &lt; Simulator._littleDeathRate) { sim.game.currentGame.day.events.splice( 0, 0, Event.finalizeSimple(sim.messages.get('littleDeath'), sim.game)); } sim.game.currentGame.day.state = 2; this.cb({game: sim.game}); } /** * @description Pass a message back to the parent. * @public * @param {*} [data] Data to send to the parent. */ cb(data) { parentPort.postMessage(data); } } module.exports = new Worker(workerData); × Search results Close "},"hg_StatManager.js.html":{"id":"hg_StatManager.js.html","title":"Source: hg/StatManager.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/StatManager.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const StatGroup = require('./StatGroup.js'); /** * @description Manages stats and leaderboard information for all of HG. * @memberof HungryGames * @inner */ class StatManager { /** * @description Constructor. * @param {HungryGames~GuildGame} game Parent game. */ constructor(game) { /** * @description Parent game to reference by default. * @public * @type {HungryGames~GuildGame} * @constant */ this.game = game; this.parseDay = this.parseDay.bind(this); } /** * @description Update stats based on the current day data of the given game. * @public */ parseDay() { const game = this.game; const current = game &amp;&amp; game.currentGame; const events = current &amp;&amp; current.day &amp;&amp; current.day.events; if (!events || !Array.isArray(events)) { throw new Error('GuildGame does not have event data to parse.'); } else if (events.length == 0) { return; } const lifetime = new StatGroup(game, 'global'); const previous = new StatGroup(game, 'previous'); const group = game.statGroup ? new StatGroup(game, game.statGroup) : null; if (current.day.num == 0) previous.reset(); const inc = function(...args) { try { lifetime.increment(...args); previous.increment(...args); if (group) group.increment(...args); } catch (err) { console.error(err); } }; for (const e of events) { if (!e || !e.icons) continue; for (let i = 0; i &lt; e.icons.length; i++) { const id = e.icons[i].id; if (!id) continue; const outcome = i &lt; e.numVictim ? e.victim.outcome : e.attacker.outcome; switch (outcome) { case 'dies': inc(id, 'deaths'); break; case 'wounded': inc(id, 'wounds'); break; case 'thrives': inc(id, 'heals'); break; case 'revived': inc(id, 'revives'); break; } } } const aliveTeams = game.options.teamSize ? current.teams.filter((t) =&gt; t.numAlive &gt; 0) : []; const collab = game.options.teammatesCollaborate == 'always' || (game.options.teammatesCollaborate == 'untilend' &amp;&amp; aliveTeams.length &gt; 1); const winners = (collab &amp;&amp; aliveTeams.length == 1) ? aliveTeams[0].players : (current.numAlive == 1 ? [current.includedUsers.find((el) =&gt; el.living).id] : []); const ended = winners.length &gt; 0 || current.numAlive == 0; for (const p of current.includedUsers) { const id = p.id; if (!id) continue; if (p.living) { inc(id, 'daysAlive'); if (p.state === 'wounded') { inc(id, 'daysWounded'); } } else { inc(id, 'daysDead'); } if (ended) { inc(id, 'kills', p.kills); if (winners.includes(id)) { inc(id, 'wins'); } else { inc(id, 'losses'); } } } } /** * @description Fetch a {@HungryGames~StatGroup} reference. * @public * @param {string} [id='global'] The ID of the group to fetch. * @param {Function} cb Callback with optional error argument, otherwise * second argument is the group reference. */ fetchGroup(id = 'global', cb) { if (typeof cb !== 'function') { cb = id; if (typeof cb !== 'function') { throw new TypeError('Callback must be a function'); } id = 'global'; } if (typeof id !== 'string') { throw new TypeError('ID must be a string'); } if (StatGroup.exists(this.game, id)) { cb(null, new StatGroup(this.game, id)); } else { cb('Group doesn\\'t exist'); } } /** * @description Create a new stat group. * @public * @param {HGStatMetadata} [metadata] Metadata to store with stat group. * @param {Function} [cb] Callback function once completed. Only argument is * the created group. */ createGroup(metadata, cb) { if (typeof metadata === 'function') { cb = metadata; metadata = null; } const created = new StatGroup(this.game, metadata); if (typeof cb === 'function') cb(created); } /** * @description Fetch IDs of all created groups. * @public * @param {Function} cb Callback with optional error argument, otherwise * second argument is array of IDs as strings. */ fetchGroupList(cb) { StatGroup.fetchList(this.game, cb); } } module.exports = StatManager; × Search results Close "},"hg_Stats.js.html":{"id":"hg_Stats.js.html","title":"Source: hg/Stats.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Stats.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description HG stats for a single user in a single timeframe. * @memberof HungryGames * @inner */ class Stats { /** * @description Create object. * @param {HungryGames~Stats|string} data Data to initialize this stats object * with, or ID of user this instance represents. */ constructor(data) { if (!data || typeof data !== 'object') data = {id: data}; if (typeof data.id !== 'string' || !data.id.match(/^(\\d{17,19}|NPC[A-F0-9]+)$/)) { throw new TypeError(`ID is not a valid user ID. (${data.id})`); } /** * @description The ID of the user this object represents. * @public * @type {string} * @constant */ this._id = data.id; /** * @description Cache of all datapoints. All properties must match SQL * database excluding `groupId`, `guildId` and `userId` which must not be * included. * @private * @type {Object} * * @property {number} kills Number of kills. * @property {number} deaths Number of deaths. * @property {number} wounds Number of times wounded. * @property {number} heals Number of times wounds have healed. * @property {number} revives Number of times revived. * @property {number} wins Number of games won. * @property {number} losses Number of games lost. * @property {number} daysAlive Number of days spent alive (includes * wounded). * @property {number} daysDead Number of days spent dead. * @property {number} daysWounded Number of days spent wounded. */ this._data = { kills: typeof data.kills === 'number' &amp;&amp; data.kills || 0, deaths: typeof data.deaths === 'number' &amp;&amp; data.deaths || 0, wounds: typeof data.wounds === 'number' &amp;&amp; data.wounds || 0, heals: typeof data.heals === 'number' &amp;&amp; data.heals || 0, revives: typeof data.revives === 'number' &amp;&amp; data.revives || 0, wins: typeof data.wins === 'number' &amp;&amp; data.wins || 0, losses: typeof data.losses === 'number' &amp;&amp; data.losses || 0, daysAlive: typeof data.daysAlive === 'number' &amp;&amp; data.daysAlive || 0, daysDead: typeof data.daysDead === 'number' &amp;&amp; data.daysDead || 0, daysWounded: typeof data.daysWounded === 'number' &amp;&amp; data.daysWounded || 0, }; this.get = this.get.bind(this); } /** * @description The ID this of the user this object represents. * @public * @returns {string} User ID. */ get id() { return this._id; } /** * @description Fetch the value of a certain data point. * @public * @param {string} key The name of the datapoint. * @returns {?number} The value, or undefined if unable to be found. */ get(key) { return this._data[key]; } /** * @description Get array of all keys stored by this object. * @public * @returns {string[]} Array of all keys. */ get keys() { return Object.keys(this._data); } /** * @description Get array of all keys stored by this object when requested * from a static scope. * @public * @static * @returns {string[]} Array of all keys. */ static get keys() { return new Stats('0000000000000000000').keys; } /** * @description Set a value for a certain datapoint. * @public * @param {string} key The name of this datapoint. * @param {number} value The new value to set. */ set(key, value) { if (typeof value !== 'number') throw new TypeError('Value is not a number'); if (typeof this._data[key] === 'undefined') throw new Error('Unknown key'); this._data[key] = value; } /** * @description Fetch the data stored here as a serializable object. * @public * @returns {object} Reference to serializable data. */ get serializable() { return this._data; } /** * @description Create a Stats object instance from a Stats-like object. * @public * @static * @param {object} obj The object to create a Stats instance of. * @returns {HungryGames~Stats} The created instance. */ static from(obj) { return new Stats(obj); } } module.exports = Stats; × Search results Close "},"hg_Team.js.html":{"id":"hg_Team.js.html","title":"Source: hg/Team.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/Team.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Serializable container for data about a team in a game. * @memberof HungryGames * @inner */ class Team { /** * @description Create a team for a game. * @param {string|number} id The id unique to a guild for this team. * @param {string} name The name of this team. * @param {string[]} players Array of player ids on the team. */ constructor(id, name, players) { /** * The unique id unique to a guild for this team. * @type {string} * @public */ this.id = id; /** * The name of this team. Truncates to 100 characters. * @type {string} * @pubilic */ this.name = name.slice(0, 101); /** * Array of player ids on the team. * @type {string[]} * @public */ this.players = players; /** * The current team rank. * @type {number} * @public * @default */ this.rank = 1; /** * The number of players on the team still alive. * @type {number} * @public * @default players.length */ this.numAlive = players.length; } } module.exports = Team; × Search results Close "},"hg_UserIconUrl.js.html":{"id":"hg_UserIconUrl.js.html","title":"Source: hg/UserIconUrl.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/UserIconUrl.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Container for a user's avatar at icon size, with their id. * @memberof HungryGames * @inner */ class UserIconUrl { /** * @description Create a container for an icon to show. * @param {string} url Url of icon. * @param {string} id Id of the user the icon belongs to. * @param {string[]} [settings] Possible settings for the user related to how * this icon should be displayed. * @param {number} [fetchSize] Size of icon to fetch from Discord. */ constructor(url, id, settings, fetchSize) { url = typeof url === 'string' ? url : ''; /** * Size of the icon to request from Discord. * @public * @type {number} */ this.fetchSize = fetchSize || UserIconUrl.fetchSize; /** * Icon URL. * @public * @type {string} */ this.url = `${url.replace(/\\?size=[0-9]*/, '')}?size=${this.fetchSize}`; /** * User ID. * @public * @type {string} */ this.id = id; /** * Optional user settings for displaying this icon. * @public * @type {?string[]} */ this.settings = settings; } } /** * The default size of the icon to request from discord. * * @public * @static * @type {number} * @constant * @default */ UserIconUrl.fetchSize = 128; /** * Get an array of icons urls from an array of users. * * @public * @static * @param {HungryGames~Player[]|HungryGames~Player} users Array of users to * process, or single user. Output will always be an array. * @returns {HungryGames~UserIconUrl[]} The user ids and urls for all users * avatars. */ UserIconUrl.from = function(users) { if (!Array.isArray(users)) users = [users]; return users.map(function(obj) { return new UserIconUrl(obj.avatarURL, obj.id, obj.settings); }); }; module.exports = UserIconUrl; × Search results Close "},"hg_WeaponEvent.js.html":{"id":"hg_WeaponEvent.js.html","title":"Source: hg/WeaponEvent.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: hg/WeaponEvent.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description An Arena event storing Events. * @memberof HungryGames * @inner */ class WeaponEvent { /** * @description Create a basic weapon. * @param {HungryGames~Event[]} outcomes All possible events in this weapon * event. * @param {string} [consumable] The formattable string for what to call this * weapons consumable items. */ constructor(outcomes, consumable) { /** * All possible events for this weapon event. * @public * @type {HungryGames~Event[]} */ this.outcomes = outcomes; /** * The formattable string for what to call this weapon's consumable items. * @public * @type {?string} */ this.consumable = consumable || null; } } module.exports = WeaponEvent; × Search results Close "},"web_proxy.js.html":{"id":"web_proxy.js.html","title":"Source: web/proxy.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: web/proxy.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (web@campbellcrowley.com) const fs = require('fs'); const http = require('http'); const https = require('https'); const socketIo = require('socket.io'); const sIOClient = require('socket.io-client'); const querystring = require('querystring'); const auth = require('../../auth.js'); const crypto = require('crypto'); const dateFormat = require('dateformat'); const clientId = '444293534720458753'; const clientSecret = auth.webSecret; require('../subModule.js').extend(WebProxy); // Extends the SubModule class. /** * @classdesc Proxy for account authentication. * @class * @augments SubModule */ function WebProxy() { const self = this; /** @inheritdoc */ this.myName = 'Proxy'; /** * The url to send a received `code` to via `POST` to receive a user's * tokens. * * @private * @default * @type {{host: string, path: string, protocol: string}} * @constant */ const tokenHost = { protocol: 'https:', host: 'discordapp.com', path: '/api/oauth2/token', method: 'POST', }; /** * The url to send a request to the discord api. * * @private * @default * @type {{host: string, path: string, protocol: string}} * @constant */ const apiHost = { protocol: 'https:', host: 'discordapp.com', path: '/api', method: 'GET', }; const pathPorts = { '/www.spikeybot.com/socket.io/dev/hg/': 8013, '/www.spikeybot.com/socket.io/hg/': 8011, '/www.spikeybot.com/socket.io/dev/account/': 8015, '/www.spikeybot.com/socket.io/account/': 8014, '/www.spikeybot.com/socket.io/dev/control/': 8021, '/www.spikeybot.com/socket.io/control/': 8020, }; /** * The current OAuth2 access information for a single session. * @typedef loginState * * @property {string} access_token The current token for api requests. * @property {string} token_type The type of token. (Usually 'Bearer') * @property {number} expires_in Number of seconds after the token is * authorized at which it becomes invalid. * @property {string} refresh_token Token used to refresh the expired * access_token. * @property {string} scope The scopes that the access_token has access to. * @property {number} expires_at The unix timestamp when the access_token * expires. * @property {number} expiration_date The unix timestamp when we consider the * session to have expired, and the session is deleted. * @property {string} session The 64 byte base64 string that identifies this * session to the client. * @property {?Timeout} refreshTimeout The current timeout registered for * refreshing the access_token. */ /** * Stores the tokens and associated data for all clients connected while data * is valid. Mapped by session id. * * @private * @type {Object.&lt;loginState&gt;} */ let loginInfo = {}; const currentSessions = {}; /** * File storing website rate limit specifications. * @private * @type {string} */ const rateLimitFile = './save/webRateLimits.json'; /** * Object storing parsed rate limit info from {@link rateLimitFile}. * * @private * @type {Object} * @default */ let rateLimits = { commands: { 'restore': 'auth', 'authorize': 'auth', }, groups: { auth: {num: 1, delta: 2}, }, global: { num: 2, delta: 2, }, }; /** @inheritdoc */ this.initialize = function() { app.listen(self.common.isRelease ? 8010 : 8012, '127.0.0.1'); self.common.connectSQL(); }; /** * Causes a full shutdown of all servers. * * @public */ this.shutdown = function() { if (io) io.close(); if (app) app.close(); clearInterval(purgeInterval); fs.unwatchFile(rateLimitFile); loginInfo = {}; }; /** @inheritdoc */ this.save = function(opt) { const toSave = {}; for (const i in loginInfo) { if (!loginInfo[i]) continue; toSave[i] = Object.assign({}, loginInfo[i]); if (toSave[i].refreshTimeout) delete toSave[i].refreshTimeout; } if (opt === 'async') { fs.writeFile('./save/webClients.json', JSON.stringify(toSave), (err) =&gt; { if (!err) return; self.error('Failed to write webClients.json'); console.error(err); }); } else { fs.writeFileSync('./save/webClients.json', JSON.stringify(toSave)); } }; /** @inheritdoc */ this.unloadable = function() { return true; }; /** * Parse rate limits from file. * * @private */ function updateRateLimits() { fs.readFile(rateLimitFile, (err, data) =&gt; { if (err) { self.error('Failed to read ' + rateLimitFile); return; } try { const parsed = JSON.parse(data); if (!parsed) return; rateLimits = parsed; } catch (e) { console.error(e); } }); } updateRateLimits(); fs.watchFile(rateLimitFile, (curr, prev) =&gt; { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.debug('Re-reading rate limits from file'); } else { console.log('WebProxy: Re-reading rate limits from file'); } updateRateLimits(); }); // TODO: Move loginInfo into multiple files to prevent all sessions being kept // in memory at all times across all shards. fs.readFile('./save/webClients.json', (err, data) =&gt; { if (aborted) return; if (err) { if (err.code !== 'ENOENT') { console.error(err); } loginInfo = {}; return; } try { loginInfo = JSON.parse(data); self.debug(Object.keys(loginInfo).length + ' sessions loaded from file.'); } catch (err) { console.error('Failed to parse webClients.json', err); } }); const purgeInterval = setInterval(purgeSessions, 60 * 60 * 1000); /** * Purge stale data from loginInfo. * * @private */ function purgeSessions() { const keys = Object.keys(loginInfo); const now = Date.now(); for (const i in keys) { if (loginInfo[keys[i]].expiration_date &lt; now) { clearTimeout(loginInfo[keys[i]].refreshTimeout); delete loginInfo[keys[i]]; } } } const app = http.createServer(handler); const io = socketIo( app, {path: '/www.spikeybot.com/socket.io/', serveClient: false}); let aborted = false; app.on('error', function(err) { if (err.code === 'EADDRINUSE') { aborted = true; self.shutdown(true); self.warn( 'Proxy failed to bind to port because it is in use. (' + err.port + ')'); } else { self.error('Proxy failed to bind to port for unknown reason.', err); } }); /** * Handler for all http requests. Should never be called. * * @private * @param {http.IncomingMessage} req The client's request. * @param {http.ServerResponse} res Our response to the client. */ function handler(req, res) { res.writeHead(418); res.end('TEAPOT'); } /** * Map of all currently connected sockets. * * @private * @type {Object.&lt;Socket&gt;} */ const sockets = {}; io.on('connection', socketConnection); /** * Handler for a new socket connecting. * * @private * @param {socketIo~Socket} socket The socket.io socket that connected. */ function socketConnection(socket) { // x-forwarded-for is trusted because the last process this jumps through is // our local proxy. const ipName = self.common.getIPName( socket.handshake.headers['x-forwarded-for'] || socket.handshake.address); const reqPath = socket.handshake.url.split('?')[0]; let userData = {}; let session; do { session = crypto.randomBytes(64).toString('base64'); } while (loginInfo[session]); let restoreAttempt = false; /** * A number representing how abusive the client is being. This is the * previous calculated value. * * At different levels we will react to messages differently. * Level 0: All requests will be handled normally. * Level 1: Requests will be handled normally, with an additional warning. * Level 2: All request will receive a http 429 equivalent reply. * Level 3: All requests are ignored and no response will be provided. * Level 4: The connection will be closed immediately. * * @private * @type {number} * @default */ let rateLevel = 0; /** * All requests from the client that are still relevant to a rate limit * group. * * @private * @type {Array.&lt;{time: number, cmd: string}&gt;} */ const history = []; /** * The historic quantities for each rate limit group. * * @private * @type {Object.&lt;number&gt;} */ const rateHistory = {}; self.common.logDebug( 'Socket connected (' + Object.keys(sockets).length + '): ' + ipName, socket.id); sockets[socket.id] = socket; if (!pathPorts[reqPath]) { self.common.error( 'Client requested unknown endpoint: ' + reqPath, socket.id); socket.disconnect(); return; } const server = sIOClient('http://localhost:' + pathPorts[reqPath], { path: reqPath, extraHeaders: {'x-forwarded-for': socket.handshake.headers['x-forwarded-for']}, }); // Add custom semi-wildcard listeners. const sonevent = server.onevent; server.onevent = function(packet) { const args = packet.data || []; if (server.listeners(args[0]).length) { sonevent.call(this, packet); } else { packet.data = ['*'].concat(args); sonevent.call(this, packet); } }; server.on('connect', () =&gt; { socket.on('*', (...args) =&gt; { server.emit(...[args[0], userData].concat(args.slice(1))); }); }); server.on('*', (...args) =&gt; { socket.emit(...args); }); server.on('disconnect', () =&gt; { socket.disconnect(); }); const onevent = socket.onevent; socket.onevent = function(packet) { const args = packet.data || []; rateLevel = updateRateLevel(args[0]); if (rateLevel &gt; 1) return; if (socket.listenerCount(args[0])) { onevent.call(this, packet); } else { packet.data = ['*'].concat(args); onevent.call(this, packet); } }; socket.on('restore', (sess) =&gt; { if (restoreAttempt /* || currentSessions[sess]*/) { socket.emit('authorized', 'Restore Failed', null); // console.error(restoreAttempt, sess); return; } currentSessions[sess] = true; restoreAttempt = true; if (loginInfo[sess]) { session = sess; // Temporarily refreshing the token on (nearly) every restore. This // seems to work fine, but I receive a 401 invalid_grant when I don't do // this... if (loginInfo[session].expires_at - 6 * 24 * 60 * 60 * 1000 &lt; Date.now()) { refreshToken(loginInfo[session].refresh_token, (err, data) =&gt; { if (!err) { let parsed; try { parsed = JSON.parse(data); self.log('Refreshed token'); } catch (err) { self.error( 'Failed to parse request from discord token refresh: ' + err); console.error('Parsing failed', sess); socket.emit('authorized', 'Restore Failed', null); return; } receivedLoginInfo(parsed); fetchIdentity(loginInfo[session], (identity) =&gt; { userData = identity; if (userData) { socket.emit('authorized', null, userData); self.common.logDebug('Authorized ' + userData.id, socket.id); } else { socket.emit('authorized', 'Getting user data failed', null); self.common.logWarning('Failed to authorize', socket.id); logout(); } }); } else { self.warn('Refreshing token failed'); console.error(err, loginInfo[session]); socket.emit('authorized', 'Restore Failed', null); } }); } else { fetchIdentity(loginInfo[session], (identity) =&gt; { userData = identity; if (userData) { socket.emit('authorized', null, userData); self.common.logDebug('Authorized ' + userData.id, socket.id); } else { socket.emit('authorized', 'Getting user data failed', null); self.common.logWarning('Failed to fetch identity', socket.id); logout(); } }); } } else { self.common.logWarning('Nothing to restore ' + sess, socket.id); socket.emit('authorized', 'Restore Failed', null); } }); socket.on('authorize', (code) =&gt; { currentSessions[session] = true; authorizeRequest(code, (err, res) =&gt; { if (err) { socket.emit('authorized', 'Failed to authorize', null); console.error(err); logout(); } else { receivedLoginInfo(JSON.parse(res)); fetchIdentity(loginInfo[session], (identity) =&gt; { userData = identity; socket.emit('authorized', null, userData); if (userData) { self.common.logDebug('Authorized ' + userData.id, socket.id); } else { self.common.logWarning('Failed to authorize', socket.id); logout(); } }); } }); }); socket.on('logout', logout); socket.on('disconnect', () =&gt; { self.common.logDebug( 'Socket disconnected (' + (Object.keys(sockets).length - 1) + '): ' + ipName, socket.id); if (loginInfo[session]) clearTimeout(loginInfo[session].refreshTimeout); delete sockets[socket.id]; if (server) server.close(); }); /** * Cause the current user session to logout. * * @private */ function logout() { if (loginInfo[session]) { clearTimeout(loginInfo[session].refreshTimeout); const token = loginInfo[session].refresh_token; delete loginInfo[session]; revokeToken(token, (err) =&gt; { delete currentSessions[session]; if (err) { self.warn( 'Failed to revoke refresh token, but user has already ' + 'signed out: ' + err, socket.id); } }); } else { delete currentSessions[session]; } socket.disconnect(); } /** * Received the login credentials for user, lets store it for this * session, and refresh the tokens when necessary. * * @private * @param {object} data User data. */ function receivedLoginInfo(data) { if (data) { /* eslint-disable @typescript-eslint/camelcase */ data.expires_at = data.expires_in * 1000 + Date.now(); data.expiration_date = Date.now() + (1000 * 60 * 60 * 24 * 30); /* eslint-enable @typescript-eslint/camelcase */ data.session = session; if (loginInfo[session] &amp;&amp; loginInfo[session].refresh_token &amp;&amp; !data.refresh_token) { self.debug( 'New oauth data does not contain refresh token, but loginInfo ' + 'still contains a refresh token.'); } loginInfo[session] = Object.assign(loginInfo[session] || {}, data); if (!loginInfo[session].refresh_token) { self.debug('loginInfo did not have a refresh token.'); } makeRefreshTimeout(loginInfo[session], receivedLoginInfo); } } /** * Check if this current connection or user is being rate limited. * * @see {@link rateLevel} * * Level 0: &lt;75% of limit. * Level 1: &gt;75% &lt;100% * Level 2: &gt;100% &lt;125% * Level 3: &gt;125% &lt;200% * Level 4: &gt;200% * * @private * @param {string} [cmd] The command being attempted. Otherwise uses global * rate limits. * @returns {number} Current rate level for the given command. */ function updateRateLevel(cmd) { const now = Date.now(); const group = rateLimits.commands[cmd] || 'global'; if (!rateHistory[group]) rateHistory[group] = 0; rateHistory[group]++; for (let i = 0; i &lt; history.length; i++) { const group = rateLimits.commands[history[i].cmd] || 'global'; const limits = rateLimits.groups[group] || rateLimits.groups['global']; if (now - history[i].time &gt; limits.delta * 1000) { rateHistory[group]--; history.splice(i, 1); i--; } } history.push({time: now, cmd: cmd}); const limit = rateLimits.groups[group].num; const percent = rateHistory[group] / limit; if (percent &lt;= 0.75) { return 0; } else if (percent &lt;= 1) { socket.emit('rateLimit', { limit: limit, current: rateHistory[group], request: cmd, group: group, level: 1, }); return 1; } else if (percent &lt;= 1.25) { socket.emit('rateLimit', { limit: limit, current: rateHistory[group], request: cmd, group: group, level: 2, }); return 2; } else if (percent &lt;= 2) { return 3; } else { logout(); return 4; } } } /** * Fetches the identity of the user we have the token of. * * @private * @param {LoginInfo} loginInfo The credentials of the session user. * @param {singleCB} cb The callback storing the user's data, or null if * something went wrong. */ function fetchIdentity(loginInfo, cb) { apiRequest(loginInfo, '/users/@me', (err, data) =&gt; { if (!err) { const parsed = JSON.parse(data); parsed.session = { id: loginInfo.session, /* eslint-disable-next-line @typescript-eslint/camelcase */ expiration_date: loginInfo.expiration_date, }; const now = dateFormat(new Date(), 'yyyy-mm-dd\\'T\\'HH:MM:ss.l\\'Z\\''); const toSend = global.sqlCon.format( 'INSERT INTO Discord (id) values (?) ON DUPLICATE KEY UPDATE ?', [parsed.id, {lastLogin: now}]); global.sqlCon.query(toSend, (err) =&gt; { if (err) { self.error(err); } }); if (loginInfo.scope &amp;&amp; loginInfo.scope.indexOf('guilds') &gt; -1) { fetchGuilds(loginInfo, (data) =&gt; { parsed.guilds = data; cb(parsed); }); } else { cb(parsed); } } else { cb(null); } }); } /** * Fetches the guild information of the user we have the token of. * * @private * @param {LoginInfo} loginInfo The credentials of the session user. * @param {singleCB} cb The callback storing the user's data, or null if * something went wrong. */ function fetchGuilds(loginInfo, cb) { apiRequest(loginInfo, '/users/@me/guilds', (err, data) =&gt; { if (!err) { const parsed = JSON.parse(data); cb(parsed); } else { cb(null); } }); } /** * Formats a request to the discord api at the given path. * * @private * @param {LoginInfo} loginInfo The credentials of the user we are sending the * request for. * @param {string} path The path for the api request to send. * @param {basicCallback} cb The response from the https request with error * and data arguments. */ function apiRequest(loginInfo, path, cb) { const host = apiHost; host.path = `/api${path}`; host.headers = { 'Authorization': `${loginInfo.token_type} ${loginInfo.access_token}`, }; discordRequest('', cb, host); } /** * Send a https request to discord. * * @private * @param {?object|string} data The data to send in the request. * @param {basicCallback} cb Callback with error, and data arguments. * @param {?object} host Request object to override the default with. */ function discordRequest(data, cb, host) { host = host || tokenHost; const req = https.request(host, (response) =&gt; { let content = ''; response.on('data', function(chunk) { content += chunk; }); response.on('end', function() { if (response.statusCode == 200) { cb(null, content); } else { self.error(response.statusCode + ': ' + content); console.error(host, data); cb(response.statusCode + ' from discord'); } }); }); req.setHeader('Content-Type', 'application/x-www-form-urlencoded'); if (data) { req.end(querystring.stringify(data)); } else { req.end(); } req.on('error', console.error); } /** * Refreshes the given token once it expires. * * @private * @param {LoginInfo} loginInfo The credentials to refresh. * @param {singleCB} cb The callback that is fired storing the new credentials * once they are refreshed. */ function makeRefreshTimeout(loginInfo, cb) { clearTimeout(loginInfo.refreshTimeout); const maxDelay = 2 * 7 * 24 * 60 * 60 * 1000; const delay = loginInfo.expires_at - Date.now(); if (delay &gt; maxDelay) { loginInfo.refreshTimeout = setTimeout(function() { makeRefreshTimeout(loginInfo, cb); }, maxDelay); } else { loginInfo.refreshTimeout = setTimeout(function() { self.debug('Refreshing token for session: ' + loginInfo.session); refreshToken(loginInfo.refresh_token, (err, data) =&gt; { let parsed; if (!err) { try { parsed = JSON.parse(data); } catch (err) { self.error( 'Failed to parse request from discord token refresh: ' + err); } } cb(parsed); }); }, delay); } } /** * Request new credentials with refresh token from discord. * * @private * @param {string} refreshToken_ The refresh token used for refreshing * credentials. * @param {basicCallback} cb The callback from the https request, with an * error argument, and a data argument. */ function refreshToken(refreshToken_, cb) { const data = { /* eslint-disable @typescript-eslint/camelcase */ client_id: clientId, client_secret: clientSecret, grant_type: 'refresh_token', refresh_token: refreshToken_, redirect_uri: 'https://www.spikeybot.com/redirect', /* eslint-enable @typescript-eslint/camelcase */ }; discordRequest(data, cb); } /** * Revoke a current refresh token from discord. * * @private * @param {string} token The refresh token to revoke. * @param {basicCallback} cb The callback from the https request, with an * error argument, and a data argument. */ function revokeToken(token, cb) { const host = Object.assign({}, tokenHost); host.path += '/revoke'; const data = { /* eslint-disable @typescript-eslint/camelcase */ client_id: clientId, client_secret: clientSecret, token_type_hint: 'refresh_token', token: token, /* eslint-enable @typescript-eslint/camelcase */ }; discordRequest(data, cb, host); } /** * Authenticate with the discord server using a login code. * * @private * @param {string} code The login code received from our client. * @param {basicCallback} cb The response from the https request with error * and data arguments. */ function authorizeRequest(code, cb) { const data = { /* eslint-disable @typescript-eslint/camelcase */ client_id: clientId, client_secret: clientSecret, grant_type: 'authorization_code', code: code, redirect_uri: 'https://www.spikeybot.com/redirect', /* eslint-enable @typescript-eslint/camelcase */ }; discordRequest(data, cb); } } module.exports = new WebProxy(); × Search results Close "},"main.js.html":{"id":"main.js.html","title":"Source: main.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: main.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const dateFormat = require('dateformat'); const mathjs = require('mathjs'); const algebra = require('algebra.js'); const Jimp = require('jimp'); const fs = require('fs'); const mkdirp = require('mkdirp'); const childProcess = require('child_process'); require('./subModule.js').extend(Main); // Extends the SubModule class. const math = mathjs.create(mathjs.all, {matrix: 'Array'}); /** * @classdesc Basic commands and features for the bot. * @class * @augments SubModule * @listens Discord~Client#guildCreate * @listens Discord~Client#guildDelete * @listens Discord~Client#guildBanAdd * @listens Discord~Client#message * @listens Command#addMe * @listens Command#invite * @listens Command#add * @listens Command#simplify * @listens Command#solve * @listens Command#eval * @listens Command#evaluate * @listens Command#graph * @listens Command#derive * @listens Command#timer * @listens Command#timers * @listens Command#remind * @listens Command#reminder * @listens Command#reminders * @listens Command#createDate * @listens Command#joinDate * @listens Command#server * @listens Command#serverInfo * @listens Command#pmMe * @listens Command#dmMe * @listens Command#pmSpikey * @listens Command#dmSpikey * @listens Command#thotPm * @listens Command#pmUser * @listens Command#flip * @listens Command#coin * @listens Command#flipcoin * @listens Command#coinflip * @listens Command#purge * @listens Command#prune * @listens Command#fuckYou * @listens Command#ban * @listens Command#smite * @listens Command#profile * @listens Command#avatar * @listens Command#ping * @listens Command#uptime * @listens Command#game * @listens Command#version * @listens Command#roll * @listens Command#dice * @listens Command#die * @listens Command#d * @listens Command#toggleMute * @listens Command#toggleBanMessages * @listens Command#toggleRigged * @listens Command#perms * @listens Command#stats * @listens Command#lookup * @listens Command#sendto * @listens Command#thanks * @listens Command#thx * @listens Command#thank * @listens Command#thankyou * @listens Command#listCommands * @listens Command#getPrefix * @listens Command#git * @listens Command#gettime * @listens Command#update */ function Main() { const self = this; /** @inheritdoc */ this.myName = 'Main'; /** * The current bot version parsed from package.json. * * @private * @type {string} */ let version = 'Unknown'; /** * The current commit hash at HEAD. * * @private * @type {string} */ let commit = 'Unknown'; fs.readFile('package.json', function(err, data) { if (err) { console.log(err); return; } try { version = JSON.parse(data).version; } catch (e) { console.log(e); } }); childProcess.exec('git rev-parse HEAD', (err, stdout) =&gt; { commit = stdout.toString().trim(); }); /* * Stores the required permissions for smiting a user. Defined at * initialize(). * * @private * @type {number} */ let smitePerms; /** * Array of all timers currently set. * * @private * @type {Main~Timer[]} */ let timers = []; /** * All guilds that have disabled the auto-smite feature. * * @private * @type {Object.&lt;boolean&gt;} */ const disabledAutoSmite = {}; /** * All guilds that have disabled sending messages when someone is banned. * * @private * @type {Object.&lt;boolean&gt;} */ const disabledBanMessage = {}; /** * The guilds that have disabled the rigged messages. * * @private * @type {Object.&lt;boolean&gt;} */ const disabledRiggedCounter = {}; /** * The guilds with auto-smite enabled, and members who have mentioned * @everyone, and the timestamps of these mentions. * * @private * @type {Object.&lt;Object.&lt;string&gt;&gt;} */ const mentionAccumulator = {}; /** * Previous ping values and their associated timestamps. Stores up to the * previous {@link oldestPing} worth of pings since a reboot. * * @private * @type {Array.&lt;{time: number, delta: number}&gt;} * @default */ let pingHistory = []; fs.readFile('./save/pingHistory.json', (err, data) =&gt; { if (err) return; try { pingHistory = JSON.parse(data); } catch (err) { self.error('Failed to parse pingHistory.json'); console.error(err); } }); /** * Oldest ping value to store. * * @private * @type {number} * @default 24 hours */ const oldestPing = 24 * 60 * 60 * 1000; /** * The introduction message the bots sends when pmme is used. * * @private * @type {string} * @constant */ const introduction = '\\nHello! My name is {username}.\\nI was created by ' + 'SpikeyRobot#0971, so if you wish to add any features, feel free to PM ' + 'him! (Tip: Use **{prefix}pmspikey**)\\n\\nThe prefix for commands can ' + 'be changed with `{prefix}changeprefix`.\\nIf you\\'d like to know what ' + 'I can do, type **{prefix}help** in a PM to me and I\\'ll let you know!' + '\\nThe help is also available on my web page: https://www.spikeybot.com/'; /** * The message sent to the channel where the user asked to be DM'd, but we * were unable to deliver the DM. * * @private * @type {string} * @constant */ const blockedmessage = 'I couldn\\'t send you a message, you probably blocked me :('; /** * The message with instructions of how to add the bot to a server. * * @private * @type {string} * @constant */ const addmessage = 'Want me on your server or want to join my server?\\nMy website has the' + ' links for you: &lt;https://www.spikeybot.com&gt;.'; /** * All of the possible messages to show when using the ban command. * * @private * @type {string[]} * @constant */ const banMsgs = [ 'It was really nice meeting you!', 'You\\'re a really great person, I\\'m sorry I had to do this.', 'See you soon!', 'And they were never heard from again...', 'Poof! Gone like magic!', 'Does it seem quiet in here? Or is it just me?', 'And like the trash, they\\'re were taken out!', 'Looks like they made like a tree, and leaf-ed. (sorry)', 'Oof! Looks like my boot to their behind left a mark!', 'Between you and me, I didn\\'t like them anyways.', 'Everyone rejoice! The world has been eradicated of one more person that ' + 'no one liked anyways.', 'The ban hammer has spoken!', ]; /** @inheritdoc */ this.helpMessage = 'Loading...'; /** * The object that stores all data to be formatted into the help message. * * @private * @constant */ const helpObject = JSON.parse(fs.readFileSync('./docs/mainHelp.json')); /** * The object that stores all data to be formatted into the help message for * admin commands. * * @private * @constant */ const adminHelpObject = JSON.parse(fs.readFileSync('./docs/adminHelp.json')); /** @inheritdoc */ this.initialize = function() { smitePerms = self.Discord.Permissions.FLAGS.CONNECT | self.Discord.Permissions.FLAGS.VIEW_CHANNEL; const adminOnlyOpts = new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD | self.Discord.Permissions.FLAGS.BAN_MEMBERS, }); self.command.on(['addme', 'invite'], commandAddMe); self.command.on('add', commandAdd); self.command.on('simplify', commandSimplify); self.command.on('solve', commandSolve); self.command.on(['eval', 'evaluate'], commandEvaluate); self.command.on('graph', commandGraph); self.command.on('derive', commandDerive); self.command.on( ['timer', 'timers', 'remind', 'reminder', 'reminders'], commandTimer); self.command.on('createdate', commandCreateDate); self.command.on('joindate', commandJoinDate, true); self.command.on(['server', 'serverinfo'], commandServerInfo, true); self.command.on(['pmme', 'dmme'], commandPmMe); self.command.on(['pmspikey', 'dmspikey'], commandPmSpikey); self.command.on('thotpm', commandThotPm); self.command.on('pmuser', commandPmUser); self.command.on(['flip', 'coin', 'coinflip', 'flipcoin'], commandFlip); self.command.on( new self.command.SingleCommand(['purge', 'prune'], commandPurge, { validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_MESSAGES, })); self.command.on( new self.command.SingleCommand(['ban', 'fuckyou'], commandBan, { validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.BAN_MEMBERS, })); self.command.on(new self.command.SingleCommand(['smite'], commandSmite, { validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES, })); self.command.on(['profile', 'avatar'], commandAvatar); self.command.on('ping', commandPing); self.command.on('uptime', commandUptime); self.command.on('game', commandGame); self.command.on('version', commandVersion); self.command.on(['dice', 'die', 'roll', 'd'], commandRollDie); self.command.on( new self.command.SingleCommand( 'togglemute', commandToggleMute, adminOnlyOpts)); self.command.on('perms', commandPerms, true); self.command.on('stats', commandStats); self.command.on('lookup', commandLookup); self.command.on( new self.command.SingleCommand( 'togglebanmessages', commandToggleBanMessages, adminOnlyOpts)); self.command.on( new self.command.SingleCommand( 'togglerigged', commandToggleRiggedCounter, adminOnlyOpts)); self.command.on('sendto', commandSendTo); self.command.on(['thanks', 'thx', 'thankyou', 'thank'], commandThankYou); self.command.on('listcommands', commandListCommands); self.command.on('getprefix', commandGetPrefix); self.command.on('git', commandGit); self.command.on('gettime', commandGetTime); self.command.on('update', commandUpdate); self.client.on('debug', onDebug); self.client.on('warn', onWarn); self.client.on('error', onError); self.client.on('guildCreate', onGuildCreate); self.client.on('guildDelete', onGuildDelete); self.client.on('guildBanAdd', onGuildBanAdd); self.client.on('message', onMessage); // Catch reasons for exiting in order to save first. process.on('exit', sigint); process.on('SIGINT', sigint); process.on('SIGHUP', sigint); process.on('SIGTERM', sigint); if (self.client.shard) { process.on('message', shardMessage); } if (!self.client.shard || !self.client.shard.ids || self.client.shard.ids[0] == 0) { fs.readdir(self.common.userSaveDir, function(err, items) { if (err) return; for (let i = 0; i &lt; items.length; i++) { const dir = self.common.userSaveDir + items[i] + '/timers/'; fs.readdir(dir, function(dir) { return function(err2, timerItems) { if (err2) return; for (let j = 0; j &lt; timerItems.length; j++) { const filename = dir + timerItems[j]; fs.readFile(filename, function(filename) { return function(err3, file) { if (err3) return; let parsed; try { parsed = JSON.parse(file); } catch (e) { self.error( 'Failed to parse timer file: ' + filename, 'Main'); console.error(e); return; } setTimer(parsed); fs.unlink(filename, function(err4) { if (err4) { self.error( 'Failed to delete timer save file: ' + filename, 'Main'); console.error(err4); } }); }; }(filename)); } }; }(dir)); } }); } self.client.guilds.forEach(function(g) { fs.readFile( self.common.guildSaveDir + g.id + '/main-config.json', function(err, file) { if (err) return; let parsed; try { parsed = JSON.parse(file); } catch (e) { return; } disabledAutoSmite[g.id] = parsed.disabledAutoSmite || false; disabledBanMessage[g.id] = parsed.disabledBanMessage || false; disabledRiggedCounter[g.id] = parsed.disabledRiggedCounter || false; }); }); fs.readFile('./save/rigged-counter.txt', function(err, file) { if (err) { self.client.riggedCounter = 0; console.log(err); return; } const tmp = file * 1; if (!isNaN(tmp)) self.client.riggedCounter = tmp; else console.log(tmp, 'is not a number'); }); // Format help message into rich embed. const tmpHelp = new self.Discord.MessageEmbed(); tmpHelp.setTitle( helpObject.title.replaceAll('{prefix}', self.bot.getPrefix())); tmpHelp.setURL(self.common.webURL); tmpHelp.setDescription( helpObject.description.replaceAll('{prefix}', self.bot.getPrefix())); helpObject.sections.forEach(function(obj) { const titleID = encodeURIComponent(obj.title.replace(/\\s/g, '_')); const titleURL = '[web](' + self.common.webHelp + '#' + titleID + ')'; tmpHelp.addField( obj.title, titleURL + '```js\\n' + obj.rows .map(function(row) { if (typeof row === 'string') { return self.bot.getPrefix() + row.replaceAll('{prefix}', self.bot.getPrefix()); } else if (typeof row === 'object') { return self.bot.getPrefix() + row.command.replaceAll( '{prefix}', self.bot.getPrefix()) + ' // ' + row.description.replaceAll( '{prefix}', self.bot.getPrefix()); } }) .join('\\n') + '\\n```', true); }); tmpHelp.setFooter( 'Note: If a custom prefix is being used, replace `' + self.bot.getPrefix() + '` with the custom prefix.\\nNote 2: Custom prefixes will not have a ' + 'space after them.'); self.helpMessage = tmpHelp; // Format admin help message into rich embed. const tmpAdminHelp = new self.Discord.MessageEmbed(); tmpAdminHelp.setTitle( adminHelpObject.title.replaceAll('{prefix}', self.bot.getPrefix())); tmpAdminHelp.setURL(self.common.webURL); tmpAdminHelp.setDescription( adminHelpObject.description.replaceAll( '{prefix}', self.bot.getPrefix())); adminHelpObject.sections.forEach(function(obj) { const titleID = encodeURIComponent(obj.title.replace(/\\s/g, '_')); const titleURL = '[web](' + self.common.webHelp + '#' + titleID + ')'; tmpAdminHelp.addField( obj.title, titleURL + '```js\\n' + obj.rows .map(function(row) { if (typeof row === 'string') { return self.bot.getPrefix() + row.replaceAll('{prefix}', self.bot.getPrefix()); } else if (typeof row === 'object') { return self.bot.getPrefix() + row.command.replaceAll( '{prefix}', self.bot.getPrefix()) + ' // ' + row.description.replaceAll( '{prefix}', self.bot.getPrefix()); } }) .join('\\n') + '\\n```', true); }); tmpAdminHelp.setFooter( 'Note: If a custom prefix is being used, replace `' + self.bot.getPrefix() + '` with the custom prefix.\\nNote 2: Custom prefixes will not have a ' + 'space after them.'); self.helpMessage = [self.helpMessage, tmpAdminHelp]; if (self.client.shard) { /* eslint-disable no-unused-vars */ /** * Receive message from another shard telling us to update our \"rigged\" * counter. * * @private * @param {number} newNum The new value to set the counter to. */ self.client.updateRiggedCounter = function(newNum) { /* eslint-enable no-unused-vars */ if (newNum &lt; this.riggedCounter) { this.shard.broadcastEval( 'this.updateRiggedCounter(' + this.riggedCounter + ')'); } else { this.riggedCounter = newNum; } }; /* eslint-disable no-unused-vars */ /** * Receive message from another shard asking for our statistics. * @see {@link Main~getStats} * * @private * @returns {Object} The statistics we collected. */ self.client.getStats = getStats; /** * Receive message from another shard asking for our permissions in a * channel or guild. * @see {@link Main~fetchShardPerms} * * @private * @returns {?{0: number, 1: number}} The bitfield numbers, or null if not * our guild. */ self.client.fetchPerms = fetchShardPerms; /** * Receive message from another shard asking for us to lookup an ID. * @see {@link Main~lookupId} * * @private * @returns {?string} User-formatted string, or null if unable to find. */ self.client.lookupId = lookupId; /** * Receive message from another shard asking for us to send a message to a * specific channel. * @see {@link Main~sendTo} * * @private * @returns {boolean} True if found channel, false otherwise. */ self.client.sendTo = sendTo; /* eslint-enable no-unused-vars */ } self.bot.getStats = getAllStats; }; /** @inheritdoc */ this.shutdown = function() { self.command.removeListener('addme'); self.command.removeListener('add'); self.command.removeListener('simplify'); self.command.removeListener('solve'); self.command.removeListener('eval'); self.command.removeListener('graph'); self.command.removeListener('derive'); self.command.removeListener('timer'); self.command.removeListener('createdate'); self.command.removeListener('joindate'); self.command.removeListener('serverinfo'); self.command.removeListener('pmme'); self.command.removeListener('pmspikey'); self.command.removeListener('thotpm'); self.command.removeListener('pmuser'); self.command.removeListener('flip'); self.command.removeListener('purge'); self.command.removeListener('fuckyou'); self.command.removeListener('smite'); self.command.removeListener('profile'); self.command.removeListener('ping'); self.command.removeListener('uptime'); self.command.removeListener('game'); self.command.removeListener('version'); self.command.removeListener('dice'); self.command.removeListener('togglemute'); self.command.removeListener('perms'); self.command.removeListener('stats'); self.command.removeListener('lookup'); self.command.removeListener('togglebanmessages'); self.command.removeListener('togglerigged'); self.command.removeListener('sendto'); self.command.removeListener('thanks'); self.command.removeListener('listcommands'); self.command.removeListener('getprefix'); self.command.removeListener('git'); self.command.removeListener('gettime'); self.command.removeListener('update'); self.client.removeListener('debug', onDebug); self.client.removeListener('warn', onWarn); self.client.removeListener('error', onError); self.client.removeListener('guildCreate', onGuildCreate); self.client.removeListener('guildDelete', onGuildDelete); self.client.removeListener('guildBanAdd', onGuildBanAdd); self.client.removeListener('message', onMessage); process.removeListener('exit', sigint); process.removeListener('SIGINT', sigint); process.removeListener('SIGHUP', sigint); process.removeListener('SIGTERM', sigint); if (self.client.shard) { process.removeListener('message', shardMessage); self.client.updateRiggedCounter = null; self.client.getStats = null; self.client.fetchPerms = null; self.client.lookupId = null; self.client.sendTo = null; } }; /** * Save all data to file. * * @override * @inheritdoc */ this.save = function(opt) { if (!self.initialized) return; timers.forEach(function(obj) { const dir = self.common.userSaveDir + obj.id + '/timers/'; const filename = dir + obj.time + '.json'; if (opt == 'async') { mkAndWrite(filename, dir, JSON.stringify(obj)); } else { mkAndWriteSync(filename, dir, JSON.stringify(obj)); } }); self.client.guilds.forEach(function(g) { const dir = self.common.guildSaveDir + g.id; const filename = dir + '/main-config.json'; const obj = { disabledAutoSmite: disabledAutoSmite[g.id], disabledBanMessage: disabledBanMessage[g.id], disabledRiggedCounter: disabledRiggedCounter[g.id], }; if (opt == 'async') { mkAndWrite(filename, dir, JSON.stringify(obj)); } else { mkAndWriteSync(filename, dir, JSON.stringify(obj)); } }); if (!self.client.shard || self.client.shard.ids[0] == 0) { const dir = './save/'; const filename = dir + 'rigged-counter.txt'; if (opt == 'async') { mkAndWrite(filename, dir, self.client.riggedCounter + ''); } else { mkAndWriteSync(filename, dir, self.client.riggedCounter + ''); } } if (opt == 'async') { mkAndWrite( './save/pingHistory.json', './save/', JSON.stringify(pingHistory)); } else { mkAndWriteSync( './save/pingHistory.json', './save/', JSON.stringify(pingHistory)); } }; /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Async. * * @see {@link Main~mkAndWriteSync} * * @private * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ function mkAndWrite(filename, dir, data) { mkdirp(dir, function(err) { if (err) { self.error('Failed to make directory: ' + dir, 'Main'); console.error(err); return; } fs.writeFile(filename, data, function(err2) { if (err2) { self.error('Failed to save timer: ' + filename, 'Main'); console.error(err2); return; } }); }); } /** * Write data to a file and make sure the directory exists or create it if it * doesn't. Synchronous. * * @see {@link Main~mkAndWrite} * * @private * @param {string} filename The name of the file including the directory. * @param {string} dir The directory path without the file's name. * @param {string} data The data to write to the file. */ function mkAndWriteSync(filename, dir, data) { try { mkdirp.sync(dir); } catch (err) { self.error('Failed to make directory: ' + dir, 'Main'); console.error(err); return; } try { fs.writeFileSync(filename, data); } catch (err) { self.error('Failed to save timer: ' + filename, 'Main'); console.error(err); return; } } /** * A general debug message was produced. * * @private * @param {string} info The information. * @listens Discord~Client#debug */ function onDebug(info) { const hbRegex = new RegExp( '^(\\\\[ws\\\\] \\\\[connection\\\\] Heartbeat acknowledged|' + '\\\\[connection\\\\] \\\\[shard \\\\d\\\\] Sending a heartbeat|' + '\\\\[connection\\\\] \\\\[shard \\\\d\\\\] Heartbeat acknowledged, latency of|' + '\\\\[Shard \\\\d+\\\\] Sending a heartbeat|' + '\\\\[Shard \\\\d+\\\\] Heartbeat acknowledged, latency of|' + '\\\\[ws\\\\] \\\\[connection\\\\] Sending a heartbeat|' + '\\\\[WS =&gt; Shard \\\\d+\\\\] Sending a heartbeat|' + '\\\\[WS =&gt; Shard \\\\d+\\\\] Heartbeat acknowledged|' + '\\\\[WS =&gt; Manager\\\\] There are \\\\d+ unavailable guilds.|' + '\\\\[VOICE)'); if (info.match(hbRegex)) { pingHistory.push({time: Date.now(), delta: self.client.ws.ping}); while (pingHistory[0] &amp;&amp; Date.now() - pingHistory[0].time &gt; oldestPing) { pingHistory.splice(0, 1); } return; } self.common.logDebug('Discord Debug: ' + info); } /** * A general warning was produced. * * @private * @param {string} info The information. * @listens Discord~Client#warn */ function onWarn(info) { self.common.logWarning('Discord Warning: ' + info); } /** * An error occurred with our websocket connection to Discord. * * @private * @param {Discord~Error} err The websocket error object. * @listens Discord~Client#error */ function onError(err) { self.common.error('Websocket encountered an error!'); console.error(err); } /** * Handle being added to a guild. * * @private * @param {Discord~Guild} guild The guild that we just joined. * @listens Discord~Client#guildCreate */ function onGuildCreate(guild) { self.log('ADDED TO NEW GUILD: ' + guild.id + ': ' + guild.name); if (guild.memberCount &gt; 100) return; let channel = null; let pos = -1; try { guild.channels.forEach((val) =&gt; { if (val.type == 'text') { const perms = val.permissionsFor(self.client.user); if ((pos == -1 || val.position &lt; pos) &amp;&amp; perms &amp;&amp; perms.has(self.Discord.Permissions.FLAGS.SEND_MESSAGES)) { pos = val.position; channel = val; } } }); if (!channel || pos &lt; 0) { self.error( 'Unable to send welcome message in new guild due to no ' + 'available channel: ' + guild.id); return; } channel.send( introduction.replaceAll('{prefix}', self.bot.getPrefix(guild)) .replaceAll('{username}', self.client.user.username)); } catch (err) { self.error('Failed to send welcome to guild:' + guild.id); console.log(err); } } /** * Handle being removed from a guild. * * @private * @param {Discord~Guild} guild The guild that we just left. * @listens Discord~Client#guildDelete */ function onGuildDelete(guild) { self.log('REMOVED FROM GUILD: ' + guild.id + ': ' + guild.name); } /** * Handle user banned on a guild. * * @private * @param {Discord~Guild} guild The guild on which the ban happened. * @param {Discord~User} user The user that was banned. * @listens Discord~Client#guildBanAdd */ function onGuildBanAdd(guild, user) { if (user.id == self.client.id) return; if (disabledBanMessage[guild.id]) return; if (!guild.me.hasPermission( self.Discord.Permissions.FLAGS.VIEW_AUDIT_LOG)) { return; } const modLog = self.bot.getSubmodule('./modLog.js'); if (!modLog) return; guild.fetchAuditLogs({limit: 1}) .then((logs) =&gt; { const executor = logs.entries.first().executor; if (executor.id !== self.client.user.id) { modLog.output( guild, 'ban', user, executor, '`Poof! ' + executor.username + ' has ensured ' + user.username + ' will never be seen again...'); } }) .catch((err) =&gt; { modLog.output( guild, 'ban', user, null, '`Poof! ' + user.username + ' was never seen again...`'); self.error('Failed to find executor of ban.'); console.log(err); }); } /** * Toggles auto-muting a user for using @everyone too much. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#toggleMute */ function commandToggleMute(msg) { if (disabledAutoSmite[msg.guild.id]) { disabledAutoSmite[msg.guild.id] = false; self.common.reply( msg, 'Enabled banning mentioning everyone automatically.'); } else { disabledAutoSmite[msg.guild.id] = true; self.common.reply( msg, 'Disabled banning mentioning everyone automatically.'); } } /** * Toggles sending a message when a user is banned from a guild. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#toggleBanMessages */ function commandToggleBanMessages(msg) { if (disabledBanMessage[msg.guild.id]) { disabledBanMessage[msg.guild.id] = false; self.common.reply( msg, 'Enabled showing a message when a user is banned.'); } else { disabledBanMessage[msg.guild.id] = true; self.common.reply( msg, 'Disabled showing a message when a user is banned.'); } } /** * Toggles sending a message when a user says 'rigged'. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#toggleRigged */ function commandToggleRiggedCounter(msg) { if (disabledRiggedCounter[msg.guild.id]) { disabledRiggedCounter[msg.guild.id] = false; self.common.reply(msg, 'Enabled showing rigged counter.'); } else { disabledRiggedCounter[msg.guild.id] = true; self.common.reply(msg, 'Disabled showing rigged counter.'); } } /** * Handle receiving a message for use on auto-muting users who spam @everyone. * * @private * @param {Discord~Message} msg The message that was sent. * @listens Discord~Client#message */ function onMessage(msg) { if (!msg.guild) return; if (msg.author.bot || msg.author.id == self.client.user.id) return; if (msg.author.id != self.common.spikeyId) { let riggedSimilarity = 0; const matchedRigged = msg.content.toLowerCase().replace(/\\W/g, '').match( /r[^i]*i[^g]*g[^g]*g[^e]*e[^d]*d/g); if (matchedRigged) { // let startCount = self.client.riggedCounter; let matchCount = 0; for (let i = 0; i &lt; matchedRigged.length; i++) { const check = matchedRigged[i].replace(/([\\S])\\1+/g, '$1'); riggedSimilarity = checkSimilarity('riged', check); const similarityCheck = riggedSimilarity &gt; 0.6667 &amp;&amp; riggedSimilarity &gt; checkSimilarity('trigered', check); if (similarityCheck) { matchCount++; } } if (matchCount &gt; 0) { if (msg.content !== 'rigged') { self.debug( 'Rigged count: ' + self.client.riggedCounter + ' + ' + matchCount + ': ' + msg.content.replace(/\\n/g, '\\\\n')); } // Disabled multple because people were spamming it. /* if (false &amp;&amp; matchCount &gt; 1) { msg.channel .send( '#' + (startCount + 1) + ' - ' + (self.client.riggedCounter += matchCount)) .catch(() =&gt; {}); } else { */ self.client.riggedCounter++; if (!disabledRiggedCounter[msg.guild.id]) { msg.channel.send('#' + self.client.riggedCounter).catch(() =&gt; {}); } // } if (self.client.shard) { self.client.shard.broadcastEval( 'this.updateRiggedCounter(' + self.client.riggedCounter + ',' + matchCount + ')'); } } } } const word = msg.content.match(/\\bi'?m\\s+(.*)/i); if (word) { const dadId = '503720029456695306'; if (msg.channel.members.get(dadId)) { msg.channel .awaitMessages( (m) =&gt; m.author.id === dadId, {max: 1, time: 10000, errors: ['time']}) .then(() =&gt; { msg.channel.send('Hi Dad, I\\'m Spikey!'); }) .catch(() =&gt; {}); } } if (!disabledAutoSmite[msg.guild.id]) { if (msg.mentions.everyone) { if (!mentionAccumulator[msg.guild.id]) { mentionAccumulator[msg.guild.id] = {}; } if (!mentionAccumulator[msg.guild.id][msg.author.id]) { mentionAccumulator[msg.guild.id][msg.author.id] = []; } mentionAccumulator[msg.guild.id][msg.author.id].push( msg.createdTimestamp); const timestamps = mentionAccumulator[msg.guild.id][msg.author.id]; let count = 0; const now = Date.now(); for (let i = timestamps.length - 1; i &gt;= 0; i--) { if (now - timestamps[i] &lt; 2 * 60 * 1000) { count++; } else { timestamps.splice(i, 1); } } if (count == 3) { let hasMuteRole = false; let muteRole; const toMute = msg.member; msg.guild.roles.forEach((val) =&gt; { if (val.name == 'MentionAbuser') { hasMuteRole = true; muteRole = val; } }); const mute = function(role, member) { try { member.roles.add(role).then(() =&gt; { self.common.reply( msg, 'I think you need a break from mentioning everyone.'); }); member.guild.channels.forEach(function(channel) { if (channel.permissionsLocked) return; const overwrites = channel.permissionOverwrites.get(role.id); if (overwrites) { if (channel.type == 'category') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.MENTION_EVERYONE)) { return; } } else if (channel.type == 'text') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.MENTION_EVERYONE)) { return; } } } channel.updateOverwrite(role, {MENTION_EVERYONE: false}) .catch(console.error); }); } catch (err) { self.common.reply( msg, 'Oops! I wasn\\'t able to mute ' + member.user.username + '! I\\'m not sure why though!'); console.log(err); } }; if (!hasMuteRole) { msg.guild.roles .create({ data: { name: 'MentionAbuser', position: 0, hoist: true, color: '#2f3136', permissions: 0, mentionable: true, }, }) .then((role) =&gt; { mute(role, toMute); }) .catch(() =&gt; { self.common.reply( msg, 'I couldn\\'t mute ' + toMute.user.username + ' because there isn\\'t a \"MentionAbuser\" role and ' + 'I couldn\\'t make it!'); }); } else { mute(muteRole, toMute); } } else if (count &gt; 3) { msg.channel.send(self.common.mention(msg) + ' Please stop.'); } } } if (msg.content.match(/^[0-9]*[dD][0-9]+\\b/)) { msg.prefix = self.bot.getPrefix(msg.guild); msg.content = `${msg.prefix}d ${msg.content}`; self.command.trigger('d', msg); } } /** * @description Returns the percentage of how similar the two given strings * are. * * @private * @param {string} s1 First string. * @param {string} s2 Second string to compare. * @returns {number} Number from 0 to 1 of how similar the two strings are. */ function checkSimilarity(s1, s2) { let longer = s1; let shorter = s2; if (s1.length &lt; s2.length) { longer = s2; shorter = s1; } const longerLength = longer.length; if (longerLength == 0) { return 1.0; } return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength); } /** * @description Calculates the edit distance between the two strings. * * @private * @param {string} s1 First string. * @param {string} s2 Second string to compare to the first. * @returns {number} Number of characters distance between the two strings. */ function editDistance(s1, s2) { s1 = s1.toLowerCase(); s2 = s2.toLowerCase(); const costs = []; for (let i = 0; i &lt;= s1.length; i++) { let lastValue = i; for (let j = 0; j &lt;= s2.length; j++) { if (i == 0) { costs[j] = j; } else { if (j &gt; 0) { let newValue = costs[j - 1]; if (s1.charAt(i - 1) != s2.charAt(j - 1)) { newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1; } costs[j - 1] = lastValue; lastValue = newValue; } } } if (i &gt; 0) costs[s2.length] = lastValue; } return costs[s2.length]; } /** * Replies to message with URL for inviting the bot to a guild. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#addMe * @listens Command#invite */ function commandAddMe(msg) { self.common.reply(msg, addmessage); } /** * Parses message and adds given numbers. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#add */ function commandAdd(msg) { const splitstring = msg.text.replaceAll('-', ' -') .replaceAll(' ', ' ') .replaceAll('\\\\+', ' ') .split(' '); if (splitstring.join('').match(/[^0-9-]/g)) { self.common.reply( msg, 'This command only adds and subtracts numbers. Use \"' + msg.prefix + 'solve\" or \"' + msg.prefix + 'simplify\" for more complex math.', 'The following characters are not allowed: ' + JSON.stringify(splitstring.join('').match(/[^0-9-]/g).join(''))); return; } let number = 0; let numNonNumber = 0; for (const i in splitstring) { if (typeof(splitstring[i] * 1) !== 'number') { numNonNumber++; } else { number += splitstring[i] * 1; } } let ending = ''; let anotherEnding = ''; if (numNonNumber &gt; 0) { ending = 'But you entered the numbers oddly, so I am not sure if I ' + 'understood you properly.'; } if (number == 69) { anotherEnding = ':wink:'; } else if (number == 420) { anotherEnding = ':four_leaf_clover:'; } else if (number == 666) { anotherEnding = ':smiling_imp:'; } else if (number == 9001) { anotherEnding = ':fire:'; } else if (number == 80085 || number == 58008) { anotherEnding = ':ok_hand:'; } self.common.reply(msg, number + '\\n' + ending, anotherEnding); } /** * Simplifies equation given in message. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#simplify */ function commandSimplify(msg) { try { const formula = msg.text; const simplified = simplify(formula); const hasVar = simplified.match(/[A-Za-z]/); self.common.reply(msg, (hasVar ? '0 = ' : '') + simplified); } catch (err) { self.common.reply(msg, err.message); } } /** * Simplifies given formula. * * @private * @param {string} formula The formula to attempt to simplify. * @returns {string} Simplified formula. */ function simplify(formula) { if (formula.indexOf('=') &gt; -1) { const split = formula.split('='); formula = split[1] + ' - (' + split[0] + ')'; } const simplified = math.simplify(formula).toString(); return simplified; } /** * Solve an equation. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#solve */ function commandSolve(msg) { if (msg.content.lastIndexOf('=') != msg.content.indexOf('=')) { self.common.reply( msg, 'Please ensure your equation has exactly 1 equals sign.'); return; } const equation = msg.text; const variables = equation.match(/[A-Za-z]+/gm); const equals = equation.match(/=/g); if (!variables || variables.length &lt; 1) { self.common.reply( msg, 'Please ensure you have at least one variable in the equation.'); return; } else if (!equals || equals.length &lt; 1) { self.common.reply( msg, 'Please ensure your equation has exactly 1 equals sign.'); return; } let error = ''; const messages = []; for (let i = 0; i &lt; variables.length; i++) { let parsed; try { parsed = algebra.parse(equation); } catch (err) { error += 'For ' + variables[i] + ': ' + err.message + '\\n'; continue; } try { messages.push(parsed.solveFor(variables[i]).toString()); } catch (err) { error += 'For ' + variables[i] + ': ' + err.message + '\\n'; continue; } } const outMessage = messages .map(function(obj, i) { return variables[i] + ' = ' + obj; }) .join('\\n'); self.common.reply( msg, outMessage || 'Oops, something didn\\'t work!', error); } /** * Evaluate a string as an equation with units. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#eval * @listens Command#evaluate */ function commandEvaluate(msg) { try { let formula = msg.text; if (formula.indexOf('=') &gt; -1) { const split = formula.split('='); formula = split[1] + ' - (' + split[0] + ')'; } let simplified = math.evaluate(formula).toString(); simplified = simplified.replace(/ \\* ([A-Za-z])/g, '$1'); self.common.reply(msg, simplified); } catch (err) { self.common.reply(msg, err.message); } } /** * Graph a given equation by plugging in values for X and creating an image * based off values. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#graph */ function commandGraph(msg) { const graphSize = 200; const dotSize = 2; let xVal; let yVal; let ypVal; let domainMin; let domainMax; let rangeMin; let rangeMax; const cmd = msg.text; let expression = cmd.replace(/\\[.*\\]|\\n/gm, ''); try { const expr = math.compile(expression); const domainTemp = cmd.match(/\\[([^,]*),([^\\]]*)\\]/m); const rangeTemp = cmd.match(/\\[[^\\]]*\\][^[]*\\[([^,]*),([^\\]]*)\\]/m); if (domainTemp !== null &amp;&amp; domainTemp.length == 3) { domainMin = math.evaluate(domainTemp[1]); domainMax = math.evaluate(domainTemp[2]); } else { domainMin = -10; domainMax = 10; } if (rangeTemp !== null &amp;&amp; rangeTemp.length == 3) { rangeMin = math.evaluate(rangeTemp[1]); rangeMax = math.evaluate(rangeTemp[2]); } xVal = math.range( domainMin, domainMax, (domainMax - domainMin) / graphSize / dotSize); yVal = xVal.map(function(x) { return expr.evaluate({x: x}); }); try { let formula = expression; if (formula.indexOf('=') &gt; -1) { const split = formula.split('='); formula = split[1] + ' - (' + split[0] + ')'; } const exprSlope = math.derivative(formula, 'x'); ypVal = xVal.map(function(x) { return exprSlope.evaluate({x: x}); }); } catch (err) { console.log(err); msg.channel.send('Failed to derive given equation. ' + err.message); return; } } catch (err) { self.common.reply(msg, err.message); return; } const finalImage = new Jimp(graphSize, graphSize, 0xFFFFFFFF); let minY = 0; let maxY = 0; if (typeof rangeMin === 'undefined') { yVal.forEach(function(obj) { if (minY &gt; obj) minY = obj; if (maxY &lt; obj) maxY = obj; }); minY += minY * 0.05; maxY += maxY * 0.05; } else { minY = rangeMin; maxY = rangeMax; } const zeroY = Math.round(-minY / (maxY - minY) * graphSize); const zeroX = Math.round(-domainMin / (domainMax - domainMin) * graphSize); finalImage.blit(new Jimp(dotSize, graphSize, 0xDDDDDDFF), zeroX, 0); finalImage.blit( new Jimp(graphSize, dotSize, 0xDDDDDDFF), 0, graphSize - zeroY); let lastSlope; const turningPoints = []; for (let i = 0; i &lt; xVal.length; i++) { const y = graphSize - Math.round((yVal[i] - minY) / (maxY - minY) * graphSize); if (y &gt;= graphSize || y &lt; 0) continue; let myColor = 0x000000FF; let mySize = dotSize; if ((lastSlope &lt; 0 &amp;&amp; ypVal[i] &gt;= 0) || (lastSlope &gt; 0 &amp;&amp; ypVal[i] &lt;= 0)) { myColor = 0xFF0000FF; turningPoints.push({x: xVal[i], y: yVal[i]}); mySize = dotSize * 2; } lastSlope = ypVal[i]; finalImage.blit( new Jimp(mySize, mySize, myColor), i / xVal.length * graphSize, y); } const expMatch = expression.match(/^\\s?[yY]\\s*=(.*)/); if (!expMatch) { expression = 'y = ' + simplify(expression); } else { expression = 'y = ' + simplify(expMatch[1]); } finalImage.getBuffer(Jimp.MIME_PNG, function(err, out) { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Graph of ' + expression); embed.setDescription( 'Plot Domain: [' + domainMin + ', ' + domainMax + ']\\nPlot Range: [' + minY + ', ' + maxY + ']'); embed.attachFiles([new self.Discord.MessageAttachment(out, 'graph.png')]); embed.setColor([255, 255, 255]); if (turningPoints.length &gt; 0) { embed.addField( 'Approximate Turning Points', turningPoints .map(function(obj) { return '(' + obj.x + ', ' + obj.y + ')'; }) .join('\\n'), false); } msg.channel.send(embed); }); } /** * Take the derivative of a given equation in terms of dy/dx. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#derive */ function commandDerive(msg) { try { let formula = msg.text; if (formula.indexOf('=') &gt; -1) { const split = formula.split('='); formula = split[1] + ' - (' + split[0] + ')'; } let simplified = math.derivative(formula, 'x').toString(); simplified = simplified.replace(/ \\* ([A-Za-z])/g, '$1'); self.common.reply(msg, simplified); } catch (err) { self.common.reply(msg, err.message); } } /** * Set a timer for a certain about of time. After which, the bot will DM the * user the message they specified. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#timer * @listens Command#timers * @listens Command#remind * @listens Command#reminder * @listens Command#reminders */ function commandTimer(msg) { const split = msg.content.split(' ').slice(1); if (split.length == 0) { let num = 0; const messages = timers .filter(function(obj) { return obj.id == msg.author.id; }) .map(function(obj) { num++; return 'In ' + Math.floor((obj.time - Date.now()) / 1000 / 60 * 10) / 10 + ' minutes: ' + obj.message; }); self.common.reply( msg, 'You have ' + num + ' timers set.\\n' + messages.join('\\n')); return; } let time = split.splice(0, 1); let unit = (split[0] || '').toLowerCase(); let skipSplice = false; const matchUnit = (time + '').match(/(\\d+)([a-zA-Z]+)\\b/); if (matchUnit) { time = matchUnit[1]; unit = matchUnit[2]; skipSplice = true; } switch (unit) { case 's': case 'sec': case 'secs': case 'second': case 'seconds': time /= 60; if (!skipSplice) split.splice(0, 1); break; case 'm': case 'min': case 'minute': case 'minutes': break; case 'h': case 'hr': case 'hour': case 'hours': time *= 60; if (!skipSplice) split.splice(0, 1); break; case 'd': case 'day': case 'days': time *= 60 * 24; if (!skipSplice) split.splice(0, 1); break; case 'w': case 'week': time *= 60 * 24 * 7; if (!skipSplice) split.splice(0, 1); break; case 'mon': case 'month': case 'months': time *= 60 * 24 * 7 * 30; if (!skipSplice) split.splice(0, 1); break; } const origMessage = split.join(' '); const message = origMessage || 'Your timer for ' + time + ' minute' + (time == '1' ? '' : 's') + ' is over!'; if (time &gt; 0) { if (time &gt; 2147483647 / 1000 / 60) { time = 2147483647 / 1000 / 60; } setTimer({ id: msg.author.id, message: message, time: Date.now() + time * 1000 * 60, }); self.common.reply( msg, 'Set timer for ' + time + ' minutes.', origMessage); } else { self.common.reply( msg, 'Oops! Please make sure your time is larger than 0.'); } } /** * Tell the user the date when they created their Discord account. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#createDate */ function commandCreateDate(msg) { const mention = msg.mentions.users.first() || msg.softMentions.users.first() || msg.author; const perms = msg.channel.permissionsFor &amp;&amp; msg.channel.permissionsFor(self.client.user); const time = mention.createdAt; if (!perms || perms.has('EMBED_LINKS')) { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Account create date'); embed.setColor([255, 0, 255]); embed.setDescription(`&lt;@${mention.id}&gt;: ${time.toUTCString()}`); embed.setTimestamp(time); msg.channel.send(`&lt;@${msg.author.id}&gt;`, embed); } else { self.common.reply( msg, `${mention.tag} created ${time.toUTCString()}`, mention.id); } } /** * Tell the user the date when they joined the server the message was sent * from. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#joinDate */ function commandJoinDate(msg) { const mention = msg.mentions.members.first() || msg.softMentions.members.first() || msg.member; const reply = function(member) { const perms = msg.channel.permissionsFor &amp;&amp; msg.channel.permissionsFor(self.client.user); const time = member.joinedAt; if (!perms || perms.has('EMBED_LINKS')) { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Server join date'); embed.setColor([255, 0, 255]); embed.setDescription(`&lt;@${member.id}&gt;: ${time.toUTCString()}`); embed.setTimestamp(time); return msg.channel.send(`&lt;@${msg.author.id}&gt;`, embed); } else { return self.common.reply( msg, `${member.tag} joined ${time.toUTCString()}`, member.id); } }; if (!mention.joinedAt) { mention.fetch().then(reply).catch((err) =&gt; { self.error('Failed to send join date: ' + msg.channel.id); console.error(err); if (err.message != 'No Perms') { self.common.reply(msg, 'Oops! Something went wrong...', err.message); } }); } else { reply(mention).catch((err) =&gt; { self.error('Failed to send join date: ' + msg.channel.id); console.error(err); if (err.message != 'No Perms') { self.common.reply(msg, 'Oops! Something went wrong...', err.message); } }); } } /** * Send information about the current server. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#server * @listens Command#serverInfo */ function commandServerInfo(msg) { const perms = msg.channel.permissionsFor &amp;&amp; msg.channel.permissionsFor(self.client.user); const guild = msg.guild; const icon = guild.iconURL(); const banner = guild.banner &amp;&amp; guild.bannerURL(); const splash = guild.splash &amp;&amp; guild.splashURL(); const vanity = guild.vanityURLCode; if (!perms || perms.has('EMBED_LINKS')) { const embed = new self.Discord.MessageEmbed(); embed.setColor([255, 0, 255]); embed.setTitle(guild.name); if (splash) { embed.setImage(splash); } else if (banner) { embed.setImage(banner); } if (icon) embed.setThumbnail(icon); if (guild.description) embed.setDescription(guild.description); embed.addField( 'Numbers', 'Members: ' + guild.memberCount + '\\nChannels: ' + guild.channels.size + '\\nRoles: ' + guild.roles.size + '\\nEmojis: ' + guild.emojis.size, true); embed.addField( 'Server', 'Created: ' + guild.createdAt.toUTCString() + '\\nOwner: &lt;@' + guild.owner.id + '&gt;\\nRegion: ' + guild.region + '\\nVerification: ' + guild.verificationLevel + ' (' + guild.verfied + ')', true); embed.addField( 'Links', (icon ? `Icon: ${icon}\\n` : '') + (banner ? `Banner: ${banner}\\n` : '') + (splash ? `Splash: ${splash}\\n` : '') + (vanity ? `Vanity: discord.gg/${vanity}\\n` : ''), true); if (guild.shard) embed.setFooter(`Shard #${guild.shard.id}`); msg.channel.send(`&lt;@${msg.author.id}&gt;`, embed); } else { self.commit.reply( msg, 'Please allow me to embed links to use this command here.'); } } /** * Send the user a PM with a greeting introducing who the bot is. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#pmMe * @listens Command#dmMe */ function commandPmMe(msg) { msg.author .send( introduction.replaceAll('{prefix}', msg.prefix) .replaceAll('{username}', self.client.user.username)) .then(() =&gt; { if (msg.guild !== null) { self.common.reply(msg, 'I sent you a message.', ':wink:'); } }) .catch(() =&gt; { self.common.reply(msg, blockedmessage); }); } /** * Send a PM to SpikeyRobot with a message. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#pmSpikey * @listens Command#pmSpikey */ function commandPmSpikey(msg) { if (!msg.text || msg.text.trim().length == 0) { self.common.reply( msg, 'Please write a message to send after the command.\\n' + 'Reminder: this will send the message to my creator.', msg.prefix + 'pmspikey The bot is on fire!'); return; } self.client.users.fetch(self.common.spikeyId) .then((user) =&gt; { user.send(msg.author.id + ': ' + msg.author.tag + ': ' + msg.content) .then(() =&gt; { self.common.reply(msg, 'I sent your message to SpikeyRobot.'); }); }) .catch((err) =&gt; { console.log(err); self.common.reply( msg, 'Something went wrong and I couldn\\'t send your message. Sorry ' + 'that\\'s all I know :('); }); } /** * @description Send a PM to a mentioned user semi-anonymously. Messages are * copied to SpikeyRobot to monitor for abuse. This command only works for 3 * people. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#thotPm */ function commandThotPm(msg) { if (msg.author.id == self.common.spikeyId || msg.author.id == '265418316120719362' || msg.author.id == '126464376059330562') { if (msg.guild !== null) msg.delete(); if (msg.mentions.users.size === 0) return; msg.mentions.users.first().send(msg.text); self.client.users.fetch(self.common.spikeyId).then((user) =&gt; { user.send(msg.author.tag + ': ' + msg.content); }); } } /** * Send a PM to a specific user via a given id or name and descriminator. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#pmUser */ function commandPmUser(msg) { const userString = (msg.text.split(' ')[1] || '').replace(/^@|^&lt;@|&gt;$/g, ''); if (!userString) { self.common.reply(msg, 'Please specify a user and a message.'); return; } self.client.users.fetch(userString) .then((user) =&gt; { if (user) { sendPm(msg, user, msg.text.split(' ').slice(2).join(' ')); } else { lookupByName(); } }) .catch(() =&gt; { lookupByName(); }); /** * Lookup a user by their tag name. * * @private */ function lookupByName() { const userObject = self.client.users.find((user) =&gt; { return user.tag.toLowerCase() == userString.toLowerCase(); }); if (userObject) { sendPm(msg, userObject, msg.text.split(' ').slice(2).join(' ')); } else { self.common.reply( msg, 'I was unable to find that user: ' + userString + '\\nYou may use their account ID or Username with the ' + '# and number.'); } } /** * Send a pm to the user. * * @private * @param {Discord~Message} msg Message that triggered command. * @param {Discord~User} user The user to send the pm to. * @param {string} message The message to send to the user. */ function sendPm(msg, user, message) { user.send( msg.author.tag + ' has asked me to send you this message:\\n' + message) .then(() =&gt; { self.common.reply( msg, 'Message sent to ' + user.tag, msg.author.tag + ' has asked me to send you this message:\\n' + message); }) .catch((err) =&gt; { self.common.reply( msg, 'Something sent wrong in sending the message.\\n' + 'This probably wasn\\'t your fault.', err.message); self.error( 'Failed to send pm to user: ' + user.username + ' ' + user.id); self.comon.error(err); }); } } /** * Send an image of a coin, either Heads or Tails. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#flip */ function commandFlip(msg) { const rand = Math.round(Math.random()); let url = 'https://www.spikeybot.com/heads.png'; let text = 'Heads!'; if (rand) { url = 'https://www.spikeybot.com/tails.png'; text = 'Tails!'; } const embed = new self.Discord.MessageEmbed({title: text}); embed.setImage(url); msg.channel.send(embed); } /** * Delete a given number of messages from a text channel. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#purge */ function commandPurge(msg) { if (!msg.channel.permissionsFor(self.client.user) .has(self.Discord.Permissions.FLAGS.MANAGE_MESSAGES)) { self.common .reply( msg, 'I\\'m sorry, but I don\\'t have permission to delete messages ' + 'in this channel.\\nTo allow me to do this, please give me ' + 'permission to Manage Messages.') .catch(() =&gt; { self.warn( 'Unable to reply to user without perms attemping purge: ' + msg.channel); }); return; } const numString = msg.text.replace(/&lt;[^&gt;]*&gt;|\\s/g, ''); let num = (numString * 1) + 1; if (numString.length === 0 || isNaN(num)) { self.common.reply( msg, 'You must specify the number of messages to purge. (ex: ?purge 5)'); } else { const limited = num &gt; 101; if (limited || num == 101) { num = 100; } if (msg.mentions.users.size &gt; 0) { if (!limited) num--; const toDelete = msg.channel.messages.filter(function(obj) { return msg.mentions.users.find(function(mention) { return obj.author.id === mention.id; }); }); msg.channel.bulkDelete(toDelete.first(num)) .then(() =&gt; { self.common .reply( msg, 'Deleted ' + num + ' messages by ' + msg.mentions.users .map(function(obj) { return obj.username; }) .join(', ')) .then((msg_) =&gt; { msg_.delete({timeout: 5000}); }); }) .catch((err) =&gt; { self.common.reply( msg, 'Oops! Discord didn\\'t like that...', err.message); }); } else { msg.channel.bulkDelete(num) .then(() =&gt; { if (limited) { self.common.reply( msg, 'Number of messages deleted limited to 100.'); } }) .catch((err) =&gt; { self.common.reply( msg, 'Oops! Discord didn\\'t like that...', err.message); }); } } } /** * Ban a mentioed user (or role from ID) and send a message saying they were * banned. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#ban * @listens Command#fuckyou */ function commandBan(msg) { const uIds = msg.text.match(/\\d{17,19}/g); if (!uIds) { self.common.reply( msg, 'You must mention someone to ban or specify an ID of ' + 'someone on the server.'); return; } const banList = []; uIds.forEach((el) =&gt; { const u = msg.guild.members.get(el); if (u) { if (!banList.includes(u.id)) banList.push(u); } else { const r = msg.guild.roles.get(el); if (r) { r.members.forEach((m) =&gt; { if (!banList.includes(m.id)) banList.push(m); }); } } }); if (banList.length == 0) { self.common.reply( msg, 'You must mention someone to ban or specify an ID of ' + 'someone on the server.'); return; } let reason = msg.text.replace(self.Discord.MessageMentions.USERS_PATTERN, '') .replace(self.Discord.MessageMentions.ROLES_PATTERN, '') .replace(/\\d{17,19}/g) .replace(/\\s{2,}/g, ' ') .trim(); if (reason == 'undefined') reason = null; banList.forEach(function(toBan) { if (msg.guild.ownerID !== msg.author.id &amp;&amp; msg.member.roles.highest.comparePositionTo(toBan.roles.highest) &lt;= 0) { self.common .reply( msg, 'You can\\'t ban ' + toBan.user.username + '! You are not stronger than them!') .catch(() =&gt; {}); } else { const me = msg.guild.me; const myRole = me.roles.highest; const highest = toBan.roles.highest; if (!myRole || (highest &amp;&amp; myRole.comparePositionTo(highest) &lt;= 0)) { self.common .reply( msg, 'I can\\'t ban ' + toBan.user.username + '! I am not strong enough!') .catch(() =&gt; {}); } else { const banMsg = banMsgs[Math.floor(Math.random() * banMsgs.length)]; toBan.ban({reason: reason || banMsg}) .then(() =&gt; { self.common.reply(msg, banMsg, 'Banned ' + toBan.user.username) .catch(() =&gt; {}); const modLog = self.bot.getSubmodule('./modLog.js'); if (modLog) { modLog.output( msg.guild, 'ban', toBan.user, msg.author, reason || banMsg); } }) .catch((err) =&gt; { self.common .reply( msg, 'Oops! I wasn\\'t able to ban ' + toBan.user.username + '! I\\'m not sure why though!') .catch(() =&gt; {}); self.error('Failed to ban user.'); console.error(err); }); } } }); } /** * Remove all roles from a user and give them a role that prevents them from * doing anything. Checks if all parties involved have permission to do this * without the bot's help. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#smite */ function commandSmite(msg) { if (msg.mentions.members.size === 0) { self.common.reply( msg, 'You must mention someone to smite after the command.'); } else { const toSmite = msg.mentions.members.first(); if (msg.guild.ownerID !== msg.author.id &amp;&amp; msg.member.roles.highest.comparePositionTo(toSmite.roles.highest) &lt;= 0) { self.common.reply( msg, 'You can\\'t smite ' + toSmite.user.username + '! You are not stronger than them!', 'Your role is not higher than theirs.'); } else { msg.guild.members.fetch(self.client.user).then((me) =&gt; { const myRole = me.roles.highest; if (toSmite.roles.highest &amp;&amp; self.Discord.Role.comparePositions( myRole, toSmite.roles.highest) &lt;= 0) { self.common.reply( msg, 'I can\\'t smite ' + toSmite.user.username + '! I am not strong enough!', 'I need permission to have a higher role.'); } else { let hasSmiteRole = false; let smiteRole; msg.guild.roles.forEach((val) =&gt; { if (val.name == 'Smited') { hasSmiteRole = true; smiteRole = val; } }); const smite = function(role, member) { try { member.roles.set([role]) .then(() =&gt; { self.common.reply( msg, 'The gods have struck ' + member.user.username + ' with lightning!'); const modLog = self.bot.getSubmodule('./modLog.js'); if (modLog) { modLog.output( msg.guild, 'smite', member.user, msg.author); } }) .catch((err) =&gt; { self.common.reply( msg, 'Oops! I wasn\\'t able to smite ' + member.user.username + '! I wasn\\'t able to give them the \"Smited\" ' + 'role!'); self.error( 'Failed to give smited role: ' + msg.guild.id + '@' + member.id); console.log(err); }); member.guild.channels.forEach(function(channel) { if (channel.permissionsLocked) return; const overwrites = channel.permissionOverwrites.get(role.id); if (overwrites) { if (channel.type == 'category') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.SPEAK) &amp;&amp; overwrites.deny.has( self.Discord.Permissions.FLAGS.SEND_MESSAGES)) { return; } } else if (channel.type == 'voice') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.SPEAK)) { return; } } else if (channel.type == 'text') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.SEND_MESSAGES)) { return; } } } channel .updateOverwrite( role, {SEND_MESSAGES: false, SPEAK: false}) .catch(console.error); }); } catch (err) { self.common.reply( msg, 'Oops! I wasn\\'t able to smite ' + member.user.username + '! I\\'m not sure why though!'); self.error('Failed to smite for unknown reason'); console.log(err); } }; if (!hasSmiteRole) { msg.guild.roles .create({ data: { name: 'Smited', position: 0, hoist: true, color: '#2f3136', permissions: smitePerms, mentionable: true, }, }) .then((role) =&gt; { smite(role, toSmite); }) .catch((err) =&gt; { self.error('Failed to create Smited role: ' +msg.guild.id); console.error(err); self.common.reply( msg, 'I couldn\\'t smite ' + toSmite.user.username + ' because there isn\\'t a \"Smited\" role and I ' + 'couldn\\'t make it!'); }); } else { smite(smiteRole, toSmite); } } }); } } } /** * Send a larger resolution version of the mentioned user's avatar. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#avatar */ function commandAvatar(msg) { const embed = new self.Discord.MessageEmbed(); if (msg.mentions.users.size &gt; 0) { embed.setDescription( msg.mentions.users.first().username + '\\'s profile picture'); embed.setImage(msg.mentions.users.first().displayAvatarURL({size: 2048})); } else { embed.setDescription(msg.author.username + '\\'s profile picture'); embed.setImage(msg.author.displayAvatarURL({size: 2048})); } msg.channel.send(embed); } /** * Reply to user with my ping to the Discord servers. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#ping */ function commandPing(msg) { const graph = []; if (pingHistory.length &gt; 0) { const cols = 40; const rows = 10; const td = oldestPing / cols; const now = Date.now(); let index = pingHistory.length - 1; const values = []; let max = 500; let min = 0; for (let c = 0; c &lt; cols; c++) { let total = 0; let num = 0; for (index; index &gt;= 0 &amp;&amp; now - pingHistory[index].time &lt; td * (c + 1); index--) { total += pingHistory[index].delta * 1; num++; } total /= num || 1; values.push(total); max = Math.max(max, total); if (total != 0) min = Math.min(min, total); } max *= 1.1; min *= 0.9; const step = (max - min) / rows; for (let r = 0; r &lt;= rows; r++) { graph[r] = []; for (let c = cols - 1; c &gt;= 0; c--) { if (r == rows) { graph[r].push('_'); continue; } const inRange = min + step * (rows - r - 1) &lt;= values[c] &amp;&amp; min + step * (rows - r) &gt; values[c]; let char = ' '; if (inRange) { if (min + step * (rows - r - 0.5) &lt;= values[c]) { char = '-'; } else { char = '_'; } } graph[r].push(char); } graph[r].push('|'); if (r == 0 || r == rows - 1 || r == Math.floor(rows / 2)) { graph[r].push(Math.round(step * (rows - r) + min)); } graph[r] = graph[r].join(''); } /* const dfmt = 'mmm-dd HH:MM Z'; graph[rows] = ' ' + dateFormat(pingHistory[0].time, dfmt) + ' ---&gt; ' + dateFormat(pingHistory[pingHistory.length - 1].time, dfmt); */ } const finalGraph = '24 hour history ```' + graph.join('\\n') + '```'; if (self.client.ping) { self.common.reply( msg, 'My ping is ' + Math.round(self.client.ping * 10) / 10 + 'ms', finalGraph); } else { self.common.reply( msg, 'My current ping ' + Math.round(self.client.ws.ping * 10) / 10 + 'ms', finalGraph); } } /** * Reply to message with the amount of time since the bot has been running. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#uptime */ function commandUptime(msg) { const ut = self.client.uptime; const formattedUptime = Math.floor(ut / 1000 / 60 / 60 / 24) + ' Days, ' + Math.floor(ut / 1000 / 60 / 60) % 24 + ' Hours, ' + Math.floor(ut / 1000 / 60) % 60 + ' Minutes, ' + Math.floor((ut / 1000) % 60) + ' Seconds.'; self.common.reply(msg, 'I have been running for ' + formattedUptime); } /** * Reply to message saying what game the mentioned user is playing and * possibly other information about their profile. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#game */ function commandGame(msg) { let user = msg.author; if (msg.mentions.users.size !== 0) { user = msg.mentions.users.first(); } const p = user.presence; if (p.activity) { let finalString = p.activity.type + ': ' + p.activity.name + '(' + p.activity.url + ')\\nDetails: ' + (p.activity.details || 'none') + ' (' + (JSON.stringify( (p.activity.party &amp;&amp; p.activity.party.size) || 'No party')) + ')'; if (p.assets) { if (p.assets.largeText) { finalString += '\\n' + p.assets.largeText; } if (p.assets.smallText) { finalString += '\\n' + p.assets.smallText; } } self.common.reply( msg, user.username + ': ' + p.status, finalString); } else { self.common.reply(msg, user.username + ': ' + p.status, p.activity); } } /** * Read the current version from package.json and show it to the user. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#version */ function commandVersion(msg) { self.common.reply( msg, 'My current version is ' + version + '\\nCommit: ' + commit + '\\nDiscord.js: ' + (self.Discord.version || 'Unknown') + '\\n\\nSubModules:\\n' + self.bot.getSubmoduleCommits() .map((el) =&gt; { return el.name + ': ' + el.commit; }) .join('\\n')); } /** * An object storing information about a timer. * * @typedef {Object} Main~Timer * @property {string} id The id of the user who set the timer. * @property {string} message The message for when the timer ends. * @property {number} time The time since epoch at which the timer will end. */ /** * Sets a timer for an amount of time with a message. * * @private * @param {Main~Timer} timer The settings for the timer. */ function setTimer(timer) { timers.push(timer); const now = Date.now(); self.client.setTimeout(function() { self.client.users.fetch(timer.id).then((user) =&gt; { user.send(timer.message); const now = Date.now(); timers = timers.filter(function(obj) { return obj.time &gt; now; }); }); }, timer.time - now); } /** * Roll a die with the given number of sides. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#roll * @listens Command#dice * @listens Command#die * @listens Command#d */ function commandRollDie(msg) { const embed = new self.Discord.MessageEmbed(); let numbers = msg.text.split(/\\s+/).splice(1); let allSame = true; if (numbers.length === 0) { numbers = [6]; } else { let matchNum = 0; for (let i = 0; i &lt; numbers.length; i++) { const el = numbers[i]; const match = el.match(/(\\d*)([xXdD*])(\\d+)/); if (!match) { const firstNum = el.match(/(\\d+)/); if (!firstNum) { numbers.splice(i, 1); i--; continue; } numbers[i] = firstNum[1]; if (i == 0) { matchNum = firstNum[1]; } else if (firstNum[1] != matchNum) { allSame = false; } } else { if (match[2].toLowerCase() == 'd') { const temp = match[3]; match[3] = match[1]; match[1] = temp; } if (!match[1] || match[1] &lt;= 0 || isNaN(Number(match[1]))) { match[1] = 1; } if (i == 0) { matchNum = match[1]; } else if (match[1] != matchNum) { allSame = false; } numbers.splice(i, 1, match[1]); for (let j = 0; j &lt; match[3] - 1; j++) { numbers.splice(i, 0, match[1]); } } } } if (numbers.length &gt; 500) { embed.setTitle('Sorry, but you may only roll at most 500 dice.'); msg.channel.send(self.common.mention(msg), embed); return; } const outcomes = []; numbers.forEach((el, i) =&gt; { outcomes[i] = Math.ceil(Math.random() * el); }); if (allSame) { embed.setTitle( 'Rolling ' + numbers.length + ' (' + numbers[0] + ' sided) di' + (numbers.length == 1 ? 'e' : 'ce')); } else { embed.setTitle( 'Rolling ' + numbers.length + ' di' + (numbers.length == 1 ? 'e' : 'ce')); } if (allSame &amp;&amp; numbers.length &gt; 1) { let sum = 0; let max = 0; let min = outcomes[0]; const outList = outcomes.slice(0); numbers.forEach((el, i) =&gt; { sum += outcomes[i]; max = Math.max(max, outcomes[i]); min = Math.min(min, outcomes[i]); }); embed.setDescription(outList.join(', ')); if (outList.length &gt; 3) { embed.setFooter( 'Sum: ' + sum + ', Max: ' + max + ', Min: ' + min + ', Avg: ' + (sum / outList.length)); } else { embed.setFooter('Sum: ' + sum); } } else if (!allSame &amp;&amp; numbers.length &gt; 1) { let sum = 0; let max = 0; let min = outcomes[0]; const outList = numbers.map((el, i) =&gt; { sum += outcomes[i]; max = Math.max(max, outcomes[i]); min = Math.min(min, outcomes[i]); return el + ' --&gt; ' + outcomes[i]; }); embed.setDescription('{sides} --&gt; {rolled}\\n' + outList.join('\\n')); if (outList.length &gt; 3) { embed.setFooter( 'Sum: ' + sum + ', Max: ' + max + ', Min: ' + min + ', Avg: ' + (sum / outList.length)); } else { embed.setFooter('Sum: ' + sum); } } else { embed.setDescription('Rolled: ' + outcomes[0]); } msg.channel.send(self.common.mention(msg), embed).catch((e) =&gt; { if (e.code == 50035) { self.common.reply( msg, 'Oops! I wasn\\'t able to fit all of the outcomes ' + 'into a message.\\nPlease try again with fewer dice.'); } else { console.error(e); } }); } /** * Send information about permissions for debugging. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#perms */ function commandPerms(msg) { let chan = msg.channel; let guild = msg.guild; let mem = msg.member; let author = msg.author; const idList = msg.text.match(/\\b\\d{17,19}\\b/g); if (self.common.trustedIds.includes(msg.author.id) &amp;&amp; idList) { const id = idList[0]; const id2 = idList[1]; chan = self.client.channels.get(id) || self.client.channels.get(id2); guild = (chan &amp;&amp; chan.guild) || self.client.guilds.get(id) || self.client.guilds.get(id2); mem = guild &amp;&amp; (guild.members.get(id) || guild.members.get(id2)); author = mem &amp;&amp; mem.user; if (!guild) { if (self.client.shard) { const toEval = `this.fetchPerms('${id}', '${id2}')`; self.client.shard.broadcastEval(toEval).then((res) =&gt; { const index = res.findIndex((el) =&gt; el); const match = res[index]; if (!match) { self.common.reply( msg, 'Failed to find channel or guild with that ID.', msg.text); return; } const cId = match.cId; const cY = match.cY; const cM = match.cM; const gId = match.gId; const gY = match.gY; const gM = match.gM; const uId = match.uId; const embed = new self.Discord.MessageEmbed(); embed.setTitle(`Permissions (Shard #${index})`); replyPerms(msg, gId, gM, gY, cId, cM, cY, uId, embed); }); } else { self.common.reply( msg, 'Failed to find channel or guild with that ID.', msg.text); } return; } } const cY = chan &amp;&amp; author &amp;&amp; chan.permissionsFor(author).bitfield; const cM = chan &amp;&amp; chan.permissionsFor(self.client.user).bitfield; const gY = author &amp;&amp; mem.permissions.bitfield; const gM = guild.members.get(self.client.user.id).permissions.bitfield; const uId = author &amp;&amp; author.id; replyPerms(msg, guild.id, gM, gY, chan.id, cM, cY, uId); } /** * @description Reply to the given message with the permission information of * the given guild, channel, and user. * @private * @param {external:Discord~Message} msg Message to reply to. * @param {string} gId Guild ID for displaying. * @param {number} gM Bitfield for self in the guild. * @param {number} [gY] Bitfield for user in guild. * @param {string} [cId] Channel ID for displaying. * @param {number} [cM] Bitfield for self in channel. * @param {number} [cY] Bitfield for user in channel. * @param {string} [uId] User id to show. * @param {external:Discord~MessageEmbed} [embed] Embed object to modify * instead of creating a new one. */ function replyPerms(msg, gId, gM, gY, cId, cM, cY, uId, embed) { if (!embed) { embed = new self.Discord.MessageEmbed(); embed.setTitle('Permissions'); } const you = uId || 'You'; if ((cY != null &amp;&amp; !isNaN(cY)) || (cM != null &amp;&amp; !isNaN(cM))) { embed.addField( `Channel ${cId}`, '```css\\n' + (cY == null || isNaN(cY) ? '' : `${prePad(cY.toString(2), 31)} ${you}\\n`) + prePad(cM.toString(2), 31) + ' Me```'); } embed.addField( `Guild ${gId}`, '```css\\n' + (gY == null || isNaN(gY) ? '' : `${prePad(gY.toString(2), 31)} ${you}\\n`) + prePad(gM.toString(2), 31) + ' Me```'); const allPermPairs = Object.entries(self.Discord.Permissions.FLAGS); const formatted = allPermPairs .map((el) =&gt; { const cYou = (cY &amp; el[1]) ? 'Y' : ' '; const cMe = (cM &amp; el[1]) ? 'M' : ' '; const gYou = (gY &amp; el[1]) ? 'Y' : ' '; const gMe = (gM &amp; el[1]) ? 'M' : ' '; const bits = prePad(el[1].toString(2), 31); const flags = `${cYou}${cMe}/${gYou}${gMe}`; return `${bits} ${flags} ${el[0]}`; }) .join('\\n'); embed.setDescription('```css\\n' + formatted + '```'); embed.setFooter( 'To see permissions for each command type: `' + msg.prefix + 'show`'); msg.channel.send(embed); } /** * @description Fetch the bitfield of permissions for our self or a given user * id in the guild or channel with the given id. * * @this external:Discord~Client * @private * @param {string} id The channel or guild id or user id to lookup permissions * for. * @param {string} [id2] The channel or guild id or user id to lookup * permissions for. * @returns {?{ * cId: ?string, * cY: ?number, * cM: ?number, * gId: string, * gY: ?number, * gM: number, * uId: ?string * }} Null if unable to find, or an object with found data. Element`cId` is * channel id, `gId` is guild id, `cY` is bitfield permissions for user in * channel, `cM` is bitfield permissions for self in channel, `gY` is bitfield * permissions for user in guild, `gM` is bitfield permissions for self in * guild, `uId` is id of matched user. */ function fetchShardPerms(id, id2) { const chan = this.channels.get(id) || this.channels.get(id2); const guild = (chan &amp;&amp; chan.guild) || this.guilds.get(id) || this.guilds.get(id2); if (guild) { const mem = guild.members.get(id) || guild.members.get(id2); const cMPerms = chan &amp;&amp; chan.permissionsFor(this.user); const cM = cMPerms &amp;&amp; cMPerms.bitfield; const cYPerms = chan &amp;&amp; chan.permissionsFor(mem); const cY = cYPerms &amp;&amp; cYPerms.bitfield; const gM = guild.members.get(this.user.id).permissions.bitfield; const gY = mem &amp;&amp; mem.permissions.bitfield; return { cId: chan &amp;&amp; chan.id, cY: cY, cM: cM, gId: guild.id, gY: gY, gM: gM, uId: mem &amp;&amp; mem.id, }; } else { return null; } } /** * Pad a number with leading zeroes so that it is `digits` long. * * @private * @param {string|number} num The number to pad with zeroes. * @param {number} digits The minimum number of digits to make the output * have. * @returns {string} The padded string. */ function prePad(num, digits) { let str = num + ''; while (str.length &lt; digits) { str = '0' + str; } return str; } /** * Send information about the bot. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#stats */ function commandStats(msg) { msg.channel.startTyping(); self.bot.getStats((values) =&gt; { const embed = new self.Discord.MessageEmbed(); embed.setTitle('SpikeyBot Stats'); embed.setDescription( 'These statistics are collected from the entire bot, ' + 'across all shards.'); const guildString = 'Number of servers: ' + values.numGuilds + '\\nLargest Server: ' + values.numLargestGuild + ' members\\nNumber of channels: ' + values.numChannels; embed.addField('Guilds', guildString, true); const userString = 'Users: ' + values.numMembers + '\\nCached users: ' + values.numUsers + '\\nUsers that are bots: ' + values.numBots + '\\nOnline users: ' + values.numUsersOnline; embed.addField('Users', userString, true); const actString = 'Activities people are doing: ' + Object.keys(values.activities).length + '\\nMost popular activity:\\n`' + values.largestActivity.name + '`\\n with ' + values.largestActivity.count + ' people.'; embed.addField('Activities/Games', actString, true); const shardUptimes = values.uptimes.map((el, i) =&gt; { const mem = values.memory[i]; return `Shard #${i} (${values.versions[i]})\\n- up ${el}\\n- ${mem}`; }); const shardString = 'Number of shards: ' + values.numShards + '\\nThis guild/channel is in shard #' + values.reqShard + '\\n' + shardUptimes.join('\\n'); embed.addField('Shards', shardString, true); const systemString = 'Storage used: ' + values.saveData.match(/^\\S+/)[0] + '\\nPing: ' + Math.round(self.client.ws.ping) + 'ms'; embed.addField('System', systemString, true); /* embed.addField( 'This Shard Version', 'Shard: ' + version + '\\nCommit: ' + commit.slice(0, 7) + '\\nDiscord.js: ' + (self.Discord.version || 'Unknown') + '\\n' + self.bot.getSubmoduleCommits() .map((el) =&gt; { return el.name + ': ' + el.commit; }) .join('\\n'), true); */ embed.setColor([0, 100, 255]); msg.channel.stopTyping(); msg.channel.send(self.common.mention(msg), embed); }); } /** * @description Fetch the bot's stats from all shards, then combine the data. * Public as SpikeyBot.getStats after SubModule.initialize. * * @private * @param {Function} cb One parameter that is guarunteed to have an array of * stats objeccts. */ function getAllStats(cb) { const startTime = Date.now(); /** * The stats object that is the result of this function. * @private * @default */ const values = { numGuilds: 0, numLargestGuild: 0, shardGuilds: {}, numUsers: 0, numMembers: 0, numBots: 0, numUsersOnline: 0, numChannels: 0, uptimes: [], memory: [], activities: {}, largestActivity: {name: 'Nothing', count: 0}, versions: [], numShards: 0, reqShard: 0, fullDelta: 0, }; if (self.client.shard) { values.numShards = self.client.shard.count; values.reqShard = self.client.shard.ids[0]; if (Array.isArray(values.reqShard)) values.reqShard = values.reqShard[0]; } /** * Callback once all shards have replied with their stats. * * @private * @param {Array&lt;object&gt;} res Array of each response object. */ function statsResponse(res) { const parseStart = Date.now(); const delays = new Array(res.length); values.uptimes = new Array(res.length); values.versions = new Array(res.length); const tempActs = {}; const tempOffline = {}; for (let i = 0; i &lt; res.length; i++) { values.numGuilds += res[i].numGuilds; values.shardGuilds[i] = res[i].numGuilds; values.numLargestGuild = Math.max(res[i].numLargestGuild, values.numLargestGuild); values.numUsers += res[i].numUsers; values.numMembers += res[i].numMembers; values.numBots += res[i].numBots; values.numUsersOnline += res[i].numUsersOnline; values.numChannels += res[i].numChannels; values.uptimes[i] = res[i].uptime; values.versions[i] = res[i].version; const mem = res[i].memory; const used = Math.round(mem.heapUsed / 100000) / 10; const heapTotal = Math.round(mem.heapTotal / 100000) / 10; const rss = Math.round(mem.rss / 100000) / 10; values.memory[i] = `${used}/${heapTotal}MB (${rss}MB)`; const actVals = Object.entries(res[i].activities); for (let j = 0; j &lt; actVals.length; j++) { if (tempActs[actVals[j][0]]) { Object.assign(tempActs[actVals[j][0]], actVals[j][1]); } else { tempActs[actVals[j][0]] = actVals[j][1]; } } Object.assign(tempOffline, res[i].usersOffline); delays[i] = res[i].deltaString; } values.numUsersOnline = values.numUsers - Object.keys(tempOffline).length; const tmpVals = Object.entries(tempActs); for (let i = 0; i &lt; tmpVals.length; i++) { const count = Object.keys(tmpVals[i][1]).length; values.activities[tmpVals[i][0]] = count; if (count &gt; values.largestActivity.count) { values.largestActivity = { name: tmpVals[i][0], count: count, }; } } values.fullDelta = Date.now() - startTime; self.debug( 'Full getStats() delta (ms): ' + values.fullDelta + ' Parse: ' + (Date.now() - parseStart) + ' Shards: ' + JSON.stringify(delays)); cb(values); } childProcess.exec('du -sh ./save/', (err, stdout) =&gt; { if (err) { self.error('Failed to fetch save directory size.'); console.error(err); } else { values.saveData = stdout.toString().trim(); } if (self.client.shard) { self.client.shard.broadcastEval('this.getStats()') .then(statsResponse) .catch((err) =&gt; { self.error('Failed to fetch stats from shards.'); console.error(err); statsResponse([]); }); } else { statsResponse([getStats()]); } }); } /** * Fetch our statistics about the bot on this shard. * * @private * @returns {object} The statistics we collected. */ function getStats() { const startTime = Date.now(); const out = { numGuilds: 0, numLargestGuild: 0, numUsers: 0, numMembers: 0, numBots: 0, numChannels: 0, usersOffline: {}, uptime: '0 days', memory: process.memoryUsage(), activities: {}, version: `${version}#${commit.slice(0, 7)}`, shardId: (self.client.shard || {id: 0}).id, }; out.numGuilds = self.client.guilds.size; let maxNum = 0; let totalNum = 0; let iTime = Date.now(); self.client.guilds.forEach((g) =&gt; { maxNum = Math.max(g.memberCount, maxNum); totalNum += g.memberCount; g.presences.forEach((p) =&gt; { if (p.status === 'offline') { out.usersOffline[p.userID] = 1; return; } if (!p.activity || p.user.bot) return; const name = p.activity.name; if (!out.activities[name]) out.activities[name] = {}; out.activities[name][p.userID] = 1; }); }); const guildDelta = Date.now() - iTime; out.numMembers = totalNum; out.numLargestGuild = maxNum; iTime = Date.now(); self.client.users.forEach((u) =&gt; { if (u.bot) out.numBots++; }); const userDelta = Date.now() - iTime; out.numUsers = self.client.users.size; out.numChannels = self.client.channels.size; const ut = self.bot.startTimestamp ? Date.now() - self.bot.startTimestamp : self.client.uptime; out.uptime = Math.floor(ut / 1000 / 60 / 60 / 24) + ' Days, ' + Math.floor(ut / 1000 / 60 / 60) % 24 + ' Hours'; out.delta = Date.now() - startTime; out.deltaString = `a${out.delta}g${guildDelta}u${userDelta}`; return out; } /** * Lookup an ID and give information about what it represents. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#lookup */ function commandLookup(msg) { const id = msg.text.split(' ')[1]; const trusted = self.common.trustedIds.includes(msg.author.id); if (self.client.shard) { self.client.shard.broadcastEval(`this.lookupId('${id}',${trusted})`) .then((res) =&gt; { if (!res.find((el) =&gt; el)) { self.error(`Failed to lookup id: ${id}`); msg.channel.send(`${id} Failed to be looked up.`); return; } const embed = new self.Discord.MessageEmbed(); embed.setTitle(id); res.forEach((el, i) =&gt; { if (el) embed.addField(`Shard #${i}`, el, true); }); msg.channel.send(embed); }) .catch((err) =&gt; { self.error('Failed to broadcast lookupId command.'); console.error(err); }); } else { const message = lookupId.call(self.client, id, trusted); if (!message) { self.error('Failed to lookup id: ' + id); msg.channel.send(id + ' Failed to be looked up.'); } else { msg.channel.send(message); } } } /** * @description Lookup an ID for any data associated with it. This checks * guilds, channels, and users. * @this external:Discord~Client * @private * @param {string} id The ID to lookup. * @param {boolean} [trusted=false] Include possibly sensitive information in * result. * @returns {?string} A Discord formatted string to send. */ function lookupId(id, trusted = false) { const user = this.users.get(id); const guild = this.guilds.get(id); const channel = this.channels.get(id); const output = []; if (user) { const guilds = []; this.guilds.forEach((g) =&gt; { if (g.members.get(id)) guilds.push(g.id); }); if (trusted) { output.push( 'User: `' + user.tag.replace(/`/g, '\\\\`') + '`' + (user.bot ? ' (bot)' : '') + ' has ' + guilds.length + ' mutual guilds: ' + guilds.join(', ')); } else { output.push( 'User: `' + user.tag.replace(/`/g, '\\\\`') + '`' + (user.bot ? ' (bot)' : '') + ' has ' + guilds.length + ' mutual guilds.'); } } if (channel) { if (channel.guild) { let additional = ''; if (trusted) { if (channel.members.size &gt; 15) { additional = '\\nMany Members'; } else { additional = '\\nMembers: ' + channel.members.map((m) =&gt; m.id + (m.user.bot ? ' (bot)' : '')) .join(', '); } } output.push( 'Guild ' + channel.type + ' Channel: `' + channel.name.replace(/`/g, '\\\\`') + '` with ' + channel.members.size + ' members, in guild `' + channel.guild.name.replace(/`/g, '\\\\`') + '` (' + channel.guild.id + ')' + additional); } else { output.push('Channel: `' + channel.name.replace(/`/g, '\\\\`') + '`'); } } if (guild) { output.push( 'Guild: `' + guild.name.replace(/`/g, '\\\\`') + '` has ' + guild.members.size + ' members.'); } if (output.length &gt; 0) { return output.join('\\n'); } else { return null; } } /** * Lookup an ID and send a message to the given channel or user without * telling the recipient who sent the message. Only looks up cached users and * channels on the same shard. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#sendto */ function commandSendTo(msg) { if (!self.common.trustedIds.includes(msg.author.id)) { return; } const idString = (msg.text.split(' ')[1] || '').replace(/^@|^&lt;@|&gt;$/g, ''); if (!idString) { self.common.reply(msg, 'Please specify a channel and a message.'); return; } const channel = self.client.channels.get(idString); const user = self.client.users.get(idString); const message = msg.text.split(' ').slice(2).join(' '); if (channel) { channel.send(message) .then(() =&gt; { self.common.reply(msg, 'Message sent!'); }) .catch((err) =&gt; { self.common.reply( msg, 'Oops! I am unable to send a message to that channel!', err.message); }); } else if (user) { user.send(message) .then(() =&gt; { self.common.reply(msg, 'Message sent!'); }) .catch((err) =&gt; { self.common.reply( msg, 'Oops! I am unable to send a message to that user!', err.message); }); } else { if (self.client.shard) { const toSend = encodeURIComponent(message); self.client.shard .broadcastEval(`this.sendTo('${idString}',\"${toSend}\")`) .then((res) =&gt; { const success = res.find((el) =&gt; el); if (success) { self.common.reply( msg, 'Attempted to send from another shard.', 'Possibly succeeded, unable to verify.'); } else { self.common.reply( msg, 'I am unable to find that user or channel. :('); } }); } else { self.common.reply(msg, 'I am unable to find that user or channel. :('); } } } /** * @description Send a message to a certain channel id. * @private * @this external:Discord~ClientUser * @param {string} id The channel ID to send the message to. * @param {string} message The message to send. Will have decodeURIComponent * run on before processing. * @returns {boolean} True if found channel, false otherwise. */ function sendTo(id, message) { message = decodeURIComponent(message); const channel = this.channels.get(id); const user = this.users.get(id); if (channel) { const perms = channel.permissionsFor(this.user); if (perms &amp;&amp; !perms.has('SEND_MESSAGES')) return false; channel.send(message).catch(console.error); return true; } else if (user) { user.send(message).catch(console.error); } else { return false; } } /** * Reply saying \"you're welcome\" unless another user was mentioned, then thank * them instead. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#thanks * @listens Command#thank * @listens Command#thx * @listens Command#thankyou */ function commandThankYou(msg) { if (msg.mentions.members &amp;&amp; msg.mentions.members.size &gt; 0) { const mentions = msg.mentions.members.map((el) =&gt; { return '`' + (el.nickname || el.user.username).replace(/`/g, '`') + '`'; }); let mentionString = mentions[0]; for (let i = 1; i &lt; mentions.length; i++) { mentionString += ', '; if (i == mentions.length - 1) mentionString += 'and '; mentionString += mentions[i]; } msg.channel.send('Thanks ' + mentionString + '!'); } else { msg.channel.send('You\\'re welcome! 😀'); } } /** * Fetch all registered commands and send them to the user. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#listCommands */ function commandListCommands(msg) { const list = self.command.getAllNames().sort(); self.common.reply(msg, JSON.stringify(list), list.length); } /** * User has requested to view the current prefix for their guild. This is * intended to be fired internally, usually through chatbot.js due to no other * way to reference this if the user has forgotten the prefix. * * @private * * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. * @listens Command#getPrefix */ function commandGetPrefix(msg) { self.common.reply( msg, 'The current prefix for this guild is', self.bot.getPrefix(msg.guild)); } /** * Get the graph of the last few git commits. * * @private * * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. * @listens Command#git */ function commandGit(msg) { if (msg.author.id === self.common.spikeyId &amp;&amp; msg.text.length &gt; 1) { childProcess.exec( 'git' + msg.text, (err, stdout) =&gt; { if (err) { msg.channel.send(`&lt;@${msg.author.id}&gt; ${err.message}`); } else { stdout = stdout.toString().trim().substr(0, 1900); const out = `&lt;@${msg.author.id}&gt; \\`\\`\\`md\\n${stdout}\\`\\`\\``; msg.channel.send(out); } }); } else { childProcess.exec( 'git remote -v &amp;&amp; echo \"\" &amp;&amp; ' + 'git log --oneline --decorate=short --graph --all -20', (err, stdout) =&gt; { if (err) { self.error('Failed to fetch the current git status.'); console.error(err); self.common.reply( msg, 'Failed to get the current Git status.', err.message); } else { msg.channel.send(`&lt;@${msg.author.id}&gt; \\`\\`\\`md\\n${stdout}\\`\\`\\``); } }); } } /** * Reply with server time and GMT. * * @private * * @type {Command~commandHandler} * @param {Discord~Message} msg The message that triggered this command. * @listens Command#gettime */ function commandGetTime(msg) { const now = new Date(); const nowPST = dateFormat(now, 'default'); const tz = dateFormat(now, 'Z'); const nowGMT = dateFormat(now, 'GMT:ddd mmm dd yyyy HH:MM:ss'); self.common.reply( msg, `Server Time: ${tz}`, `${tz}: ${nowPST}\\nGMT: ${nowGMT}`); } /** * Trigger fetching the latest version of the bot from git, then tell all * shards to reload the changes. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#update */ function commandUpdate(msg) { if (!self.common.trustedIds.includes(msg.author.id)) { self.common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); return; } self.log( `Triggered update: ${__dirname} &lt;-- DIR | CWD --&gt;${process.cwd()}`); self.common.reply(msg, 'Updating from git...').then((msg_) =&gt; { childProcess.exec('npm run update', function(err, stdout, stderr) { if (!err) { if (stdout &amp;&amp; stdout !== 'null') console.log('STDOUT:', stdout); if (stderr &amp;&amp; stderr !== 'null') console.error('STDERR:', stderr); const noReload = msg.content.indexOf('--noreload') &gt; -1; if (!noReload) { self.bot.reloadCommon(); if (self.client.shard) { self.client.shard.broadcastEval('this.reloadUpdatedMainModules'); } else { self.client.reloadUpdatedMainModules(); } } try { childProcess.execSync( 'git diff-index --quiet ' + (self.bot.version.split('#')[1] || commit) + ' -- ./src/SpikeyBot.js'); const embed = new self.Discord.MessageEmbed(); embed.setTitle('Bot update complete!'); embed.setColor([255, 0, 255]); if (noReload) embed.setDescription('Modules not reloaded.'); msg_.edit(self.common.mention(msg), embed); } catch (err) { if (err.status === 1) { const embed = new self.Discord.MessageEmbed(); embed.setTitle( 'Bot update complete, but requires manual reboot.'); embed.setDescription(err.message); embed.setColor([255, 0, 255]); msg_.edit(self.common.mention(msg), embed); } else { self.error( 'Checking for SpikeyBot.js changes failed: ' + err.status); console.error('STDOUT:', err.stdout.toString()); console.error('STDERR:', err.stderr.toString()); const embed = new self.Discord.MessageEmbed(); embed.setTitle( 'Bot update complete, but failed to check if ' + 'reboot is necessary.'); embed.setColor([255, 0, 255]); msg_.edit(self.common.mention(msg), embed); } } } else { self.error('Failed to pull latest update.'); console.error(err); if (stdout &amp;&amp; stdout !== 'null') console.log('STDOUT:', stdout); if (stderr &amp;&amp; stderr !== 'null') console.error('STDERR:', stderr); const embed = new self.Discord.MessageEmbed(); embed.setTitle('Bot update FAILED!'); embed.setColor([255, 0, 255]); msg_.edit(self.common.mention(msg), embed); } }); }); } /** * Triggered via SIGINT, SIGHUP or SIGTERM. Saves data before exiting. * * @private * @listens Process#SIGINT * @listens Process#SIGHUP * @listens Process#SIGTERM */ function sigint() { if (self.initialized) { self.log('Caught exit!', 'Main'); } else { console.log('Main: Caught exit!'); } try { self.save(); } catch (err) { console.log('Main: Failed to save', err); } try { self.end(); } catch (err) { console.log('Main: Failed to shutdown', err); } process.removeListener('exit', sigint); process.exit(); } /** * @description Received a message from the shard manager. * @private * @param {*} args Message received. */ function shardMessage(...args) { if (args[0] == 'reboot') { process.kill(process.pid, 'SIGINT'); } } } module.exports = new Main(); × Search results Close "},"moderation.js.html":{"id":"moderation.js.html","title":"Source: moderation.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: moderation.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const SubModule = require('./subModule.js'); /** * @description Handle all moderator related commands and control. * @extends SubModule */ class Moderation extends SubModule { /** * Instantiate Moderation SubModule. */ constructor() { super(); /** @inheritdoc */ this.myName = 'Moderation'; /** * All guilds that have disabled the auto-smite feature. * * @private * @type {Object.&lt;boolean&gt;} */ this._disabledAutoSmite = {}; /** * All guilds that have disabled sending messages when someone is banned. * * @private * @type {Object.&lt;boolean&gt;} */ this._disabledBanMessage = {}; /** * The guilds with auto-smite enabled, and members who have mentioned * @everyone, and the timestamps of these mentions. * * @private * @type {Object.&lt;Object.&lt;string&gt;&gt;} */ this._mentionAccumulator = {}; /** * All of the possible messages to show when using the ban command. * * @private * @type {string[]} * @constant */ this._banMsgs = [ 'It was really nice meeting you!', 'You\\'re a really great person, I\\'m sorry I had to do this.', 'See you soon!', 'And they were never heard from again...', 'Poof! Gone like magic!', 'Does it seem quiet in here? Or is it just me?', 'And like the trash, they\\'re were taken out!', 'Looks like they made like a tree, and leaf-ed. (sorry)', 'Oof! Looks like my boot to their behind left a mark!', 'Between you and me, I didn\\'t like them anyways.', 'Everyone rejoice! The world has been eradicated of one more person ' + 'that no one liked anyways.', 'The ban hammer has spoken!', ]; this.save = this.save.bind(this); this.muteMember = this.muteMember.bind(this); this._onMessageDelete = this._onMessageDelete.bind(this); this._onMessageDeleteBulk = this._onMessageDeleteBulk.bind(this); this._onGuildMemberRemove = this._onGuildMemberRemove.bind(this); this._onGuildMemberAdd = this._onGuildMemberAdd.bind(this); this._commandKick = this._commandKick.bind(this); } /** @inheritdoc */ initialize() { /** * Permissions required to to use the smite command. Bitfield. * @private * @type {number} * @constant */ this._smitePerms = this.Discord.Permissions.FLAGS.CONNECT | this.Discord.Permissions.FLAGS.VIEW_CHANNEL; /* const adminOnlyOpts = new this.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_ROLES | this.Discord.Permissions.FLAGS.MANAGE_GUILD | this.Discord.Permissions.FLAGS.BAN_MEMBERS, }); this.command.on( new this.command.SingleCommand(['purge', 'prune'], commandPurge, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_MESSAGES, })); this.command.on( new this.command.SingleCommand(['ban', 'fuckyou'], commandBan, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.BAN_MEMBERS, })); this.command.on(new this.command.SingleCommand(['smite'], commandSmite, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_ROLES, })); this.command.on( new this.command.SingleCommand( 'togglemute', commandToggleMute, adminOnlyOpts)); this.command.on( new this.command.SingleCommand( 'togglebanmessages', commandToggleBanMessages, adminOnlyOpts)); */ this.command.on( new this.command.SingleCommand(['kick'], this._commandKick, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.KICK_MEMBERS, })); this.client.guilds.forEach((g) =&gt; { if (!fs.existsSync( `${this.common.guildSaveDir}${g.id}/moderation.json`)) { // This is here to upgrade to new file-system. After first load // main-config.json does not need to be read anymore. fs.readFile( `${this.common.guildSaveDir}${g.id}/main-config.json`, (err, file) =&gt; { if (err) return; let parsed; try { parsed = JSON.parse(file); } catch (e) { return; } if (typeof parsed.disabledAutoSmite === 'boolean') { this._disabledAutoSmite[g.id] = parsed.disabledAutoSmite; } if (typeof parsed.disabledBanMessage === 'boolean') { this._disabledBanMessage[g.id] = parsed.disabledBanMessage; } }); } else { fs.readFile( `${this.common.guildSaveDir}${g.id}/moderation.json`, (err, file) =&gt; { if (err) return; let parsed; try { parsed = JSON.parse(file); } catch (e) { return; } if (typeof parsed.disabledAutoSmite === 'boolean') { this._disabledAutoSmite[g.id] = parsed.disabledAutoSmite; } if (typeof parsed.disabledBanMessage === 'boolean') { this._disabledBanMessage[g.id] = parsed.disabledBanMessage; } }); } }); this.client.on('messageDelete', this._onMessageDelete); this.client.on('messageDeleteBulk', this._onMessageDeleteBulk); this.client.on('guildMemberRemove', this._onGuildMemberRemove); this.client.on('guildMemberAdd', this._onGuildMemberAdd); } /** @inheritdoc */ shutdown() { /* this.command.removeListener('purge'); this.command.removeListener('fuckyou'); this.command.removeListener('smite'); this.command.removeListener('togglemute'); this.command.removeListener('togglebanmessages'); */ this.command.removeListener('kick'); this.client.removeListener('messageDelete', this._onMessageDelete); this.client.removeListener('messageDeleteBulk', this._onMessageDeleteBulk); this.client.removeListener('guildMemberRemove', this._onGuildMemberRemove); this.client.removeListener('guildMemberAdd', this._onGuildMemberAdd); } /** @inheritdoc */ save(opt) { if (!this.initialized) return; this.client.guilds.forEach((obj) =&gt; { const dir = `${this.common.guildSaveDir}${obj.id}/`; const filename = `${dir}moderation.json`; const data = { disabledBanMessage: this._disabledBanMessage[obj.id], disabledAutoSmite: this._disabledAutoSmite[obj.id], }; if (opt == 'async') { this.common.mkAndWrite(filename, dir, JSON.stringify(data)); } else { this.common.mkAndWriteSync(filename, dir, JSON.stringify(data)); } }); } /** * @description Handle logging when a message is deleted. * @private * @param {external:Discord~Message} msg The deleted message. */ _onMessageDelete(msg) { if (!msg.guild) return; const modLog = this.bot.getSubmodule('./modLog.js'); if (!modLog) return; const tag = msg.author.tag; const id = msg.author.id; const channel = msg.channel.name; if ((id == this.client.user.id || id == '318552464356016131') &amp;&amp; msg.content === '`Autoplaying...`') { return; } modLog.output( msg.guild, 'messageDelete', null, null, `${tag}'s (${id}) message in #${channel}`, msg.content); } /** * @description Handle logging when multiple messages are deleted. * @private * @param {external:Discord~Collection&lt;external:Discord~Message&gt;} msgs The * deleted messages. */ _onMessageDeleteBulk(msgs) { const modLog = this.bot.getSubmodule('./modLog.js'); if (!modLog) return; if (!modLog.getSettings(msgs.first().guild.id).check('messagePurge')) { return; } let channels = []; msgs.forEach((m) =&gt; { if (!channels.includes(`#${m.channel.name}`)) { channels.push(`#${m.channel.name}`); } }); if (channels.length &gt; 3) { channels = `${channels.length} channels`; } else { channels = channels.join(', '); } modLog.output( msgs.first().guild, 'messagePurge', null, null, `${msgs.size} messages deleted from ${channels}.`); } /** * @description Handle a guild member leaving the guild. * @private * @param {external:Discord~GuildMember} member The member that left or was * kicked. */ _onGuildMemberRemove(member) { const modLog = this.bot.getSubmodule('./modLog.js'); if (!modLog) return; modLog.output(member.guild, 'memberLeave', member.user); } /** * @description Handle someone joining the guild. * @private * @param {external:Discord~GuildMember} member The member that joined. */ _onGuildMemberAdd(member) { const modLog = this.bot.getSubmodule('./modLog.js'); if (!modLog) return; if (!modLog.getSettings(member.guild.id).check('memberJoin')) return; let num = -1; if (this.client.shard) { const toEval = `this.guilds.filter((g) =&gt; g.members.get('${member.id}')).size`; this.client.shard.broadcastEval(toEval) .then((res) =&gt; { res.forEach((el) =&gt; num += el); const additional = num &gt; 0 ? `${num} other mutual server${num &gt; 1 ? 's' : ''}.` : null; modLog.output( member.guild, 'memberJoin', member.user, null, additional); }) .catch((err) =&gt; { this.error( 'Failed to get mutual guild count: ' + member.guild.id + '@' + member.user.id); console.error(err); modLog.output(member.guild, 'memberJoin', member.user); }); } else { this.client.guilds.forEach((g) =&gt; { if (g.members.get(member.id)) num++; }); const additional = num &gt; 0 ? `${num} other mutual server${num &gt; 1 ? 's' : ''}.` : null; modLog.output(member.guild, 'memberJoin', member.user, null, additional); } } /** * @description Give a guild member a muted role that prevents them from * talking in any channel in the guild. * @public * @param {external:Discord~GuildMember} member The member of the guild to * mute. * @param {Function} cb Callback function with a single argument which is a * string if there was an error, or null if success. */ muteMember(member, cb) { let hasMuteRole = false; let muteRole; const toMute = member; member.guild.roles.forEach((val) =&gt; { if (val.name == 'Muted') { hasMuteRole = true; muteRole = val; } }); const self = this; const mute = function(role, member) { try { member.roles.add(role) .then(() =&gt; { cb(); }) .catch((err) =&gt; { self.error( 'Failed to mute member: ' + member.guild.id + '@' + member.id); console.error(err); cb('Failed to give role'); }); member.guild.channels.forEach((channel) =&gt; { if (channel.permissionsLocked) return; const overwrites = channel.permissionOverwrites.get(role.id); if (overwrites) { if (channel.type == 'category') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.SEND_MESSAGES) &amp;&amp; overwrites.deny.has(self.Discord.Permissions.FLAGS.SPEAK)) { return; } } else if (channel.type == 'text') { if (overwrites.deny.has( self.Discord.Permissions.FLAGS.SEND_MESSAGES)) { return; } } else if (channel.type == 'voice') { if (overwrites.deny.has(self.Discord.Permissions.FLAGS.SPEAK)) { return; } } } channel.updateOverwrite(role, {SEND_MESSAGES: false, SPEAK: false}) .catch(console.error); }); } catch (err) { console.log(err); cb('Failed to manage role'); } }; if (!hasMuteRole) { member.guild.roles .create({ data: { name: 'Muted', position: member.guild.me.roles.highest.position - 1, permissions: 0, }, }) .then((role) =&gt; { mute(role, toMute); }) .catch((err) =&gt; { this.error( 'Failed to create mute role in guild: ' + member.guild.id); console.error(err); cb('Failed to create role'); }); } else { mute(muteRole, toMute); } } /** * Kick a mentioed user (or role from ID) and send a message saying they were * banned. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#kick */ _commandKick(msg) { const uIds = msg.text.match(/\\d{17,19}/g); if (!uIds) { this.common.reply( msg, 'You must mention someone to kick or specify an ID of ' + 'someone on the server.'); return; } const banList = []; uIds.forEach((el) =&gt; { const u = msg.guild.members.get(el); if (u) { if (!banList.includes(u.id)) banList.push(u); } else { const r = msg.guild.roles.get(el); if (r) { r.members.forEach((m) =&gt; { if (!banList.includes(m.id)) banList.push(m); }); } } }); if (banList.length == 0) { this.common.reply( msg, 'You must mention someone to kick or specify an ID of ' + 'someone on the server.'); return; } let reason = msg.text.replace(this.Discord.MessageMentions.USERS_PATTERN, '') .replace(this.Discord.MessageMentions.ROLES_PATTERN, '') .replace(/\\d{17,19}/g) .replace(/\\s{2,}/g, ' ') .trim(); if (reason == 'undefined') reason = null; banList.forEach((toBan) =&gt; { if (msg.guild.ownerID !== msg.author.id &amp;&amp; msg.member.roles.highest.comparePositionTo(toBan.roles.highest) &lt;= 0) { this.common .reply( msg, 'You can\\'t kick ' + toBan.user.username + '! You are not stronger than them!') .catch(() =&gt; {}); } else { const me = msg.guild.me; const myRole = me.roles.highest; const highest = toBan.roles.highest; if (!myRole || (highest &amp;&amp; myRole.comparePositionTo(highest) &lt;= 0)) { this.common .reply( msg, 'I can\\'t kick ' + toBan.user.username + '! I am not strong enough!') .catch(() =&gt; {}); } else { // const banMsg = banMsgs[Math.floor(Math.random() * banMsgs.length)]; const banMsg = 'Kicked'; toBan.kick({reason: reason || banMsg}) .then(() =&gt; { this.common.reply(msg, banMsg, 'Kicked ' + toBan.user.username) .catch(() =&gt; {}); const modLog = this.bot.getSubmodule('./modLog.js'); if (modLog) { modLog.output( msg.guild, 'kick', toBan.user, msg.author, reason || banMsg); } }) .catch((err) =&gt; { this.common .reply( msg, 'Oops! I wasn\\'t able to kick ' + toBan.user.username + '! I\\'m not sure why though!') .catch(() =&gt; {}); this.error('Failed to kick user.'); console.error(err); }); } } }); } } module.exports = new Moderation(); × Search results Close "},"modLog.js.html":{"id":"modLog.js.html","title":"Source: modLog.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: modLog.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const SubModule = require('./subModule.js'); /** * @description Manages moderator logging on guilds. * @listens Command#setLogChannel * @listens Command#logChannel */ class ModLog extends SubModule { /** * @description Creates subModule. */ constructor() { super(); /** @inheritdoc */ this.myName = 'ModLog'; /** * Guild settings for raids mapped by their guild id. * * @private * @type {Object.&lt;ModLog~Settings&gt;} * @default */ this._settings = {}; this.save = this.save.bind(this); this.getSettings = this.getSettings.bind(this); this._commandSetLogChannel = this._commandSetLogChannel.bind(this); } /** @inheritdoc */ initialize() { this.command.on( new this.command.SingleCommand( ['setlogchannel', 'logchannel'], this._commandSetLogChannel, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_ROLES | this.Discord.Permissions.FLAGS.MANAGE_GUILD | this.Discord.Permissions.FLAGS.BAN_MEMBERS | this.Discord.Permissions.FLAGS.KICK_MEMBERS, })); this.client.guilds.forEach((g) =&gt; { fs.readFile( `${this.common.guildSaveDir}${g.id}/modLog.json`, (err, file) =&gt; { if (err) return; let parsed; try { parsed = Settings.from(JSON.parse(file)); } catch (e) { return; } this._settings[g.id] = parsed; }); }); } /** @inheritdoc */ shutdown() { this.command.removeListener('setlogchannel'); } /** @inheritdoc */ save(opt) { if (!this.initialized) return; Object.entries(this._settings).forEach((obj) =&gt; { const dir = `${this.common.guildSaveDir}${obj[0]}/`; const filename = `${dir}modLog.json`; if (opt == 'async') { this.common.mkAndWrite(filename, dir, JSON.stringify(obj[1])); } else { this.common.mkAndWriteSync(filename, dir, JSON.stringify(obj[1])); } }); } /** * @description Command to set the output logging channel. Changes to the * channel the command was run in, or toggles if ran in the same channel. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#setLogChannel * @listens Command#logChannel */ _commandSetLogChannel(msg) { if (this._settings[msg.guild.id] &amp;&amp; this._settings[msg.guild.id].channel == msg.channel.id) { this.setLogChannel(msg.guild.id, null); this.common.reply(msg, 'Disabled Log Channel'); } else { this.setLogChannel(msg.guild.id, msg.channel.id); this.common.reply(msg, 'Set Log Channel', msg.channel.name); } } /** * @description Set the log channel for a guild. * @public * @param {string} gId ID of the guild to change the setting for. * @param {?string} cId The ID of the channel to set as the output channel. */ setLogChannel(gId, cId) { const s = this.getSettings(gId); s.channel = cId || null; } /** * @description Obtain reference to settings object for a guild. * @public * @param {string} gId The ID of the guild to fetch the settings for. * @returns {ModLog~Settings} Settings object, creates one with default * settings first if it doesn't exist. */ getSettings(gId) { if (!this._settings[gId]) this._settings[gId] = new Settings(); return this._settings[gId]; } /** * @description Fetch the human readable action string. * @private * @param {string} action The action to find the human readable format of. * @returns {string} Human readable string. */ _actionString(action) { switch (action) { case 'kick': return 'Kicked'; case 'ban': return 'Banned'; case 'mute': return 'Muted'; case 'warnAndMute': return 'Warned and Muted'; case 'smite': return 'Smited'; case 'mentionAbuse': return 'Mention Abuser'; case 'messagePurge': return 'Purged Messages'; case 'messageDelete': return 'Deleted a Message'; case 'memberJoin': return 'Joined the Server'; case 'memberLeave': return 'Left the Server'; case 'lockdown': return 'Raid Lockdown Started'; default: return `${action[0].toLocaleUpperCase()}${action.slice(1)}`; } } /** * @description Fetch the color for the given action. * @private * @param {string} action The action to lookup. * @returns {external:Discord~ColorResolvable} The color for the given action. */ _actionColor(action) { switch (action) { case 'kick': return 'ORANGE'; case 'ban': return 'RED'; case 'mute': return 'YELLOW'; case 'warnAndMute': return 'GOLD'; case 'smite': return 'DARK_GOLD'; case 'mentionAbuse': return 'DARK_PURPLE'; case 'messagePurge': return 'BLUE'; case 'messageDelete': return 'DARK_BLUE'; case 'memberJoin': return 'GREEN'; case 'memberLeave': return 'GREY'; case 'lockdown': return 'DARK_NAVY'; default: return 'DEFAULT'; } } /** * @description Log a message in a guild. * @public * @param {external:Discord~Guild} guild The guild the action took place in. * @param {string} action The action that was performed. * @param {?external:Discord~User} [user=null] User that was affected, or null * of no user was affected. * @param {?external:Discord~User} [owner=null] User that performed the * action. Null is for ourself. * @param {string} [message=null] Additional information to attach to the log * message. * @param {string} [message2=null] Additional information to attach to the log * message. */ output(guild, action, user, owner, message, message2) { const s = this._settings[guild.id]; if (!s || !s.channel) return; if (!s.check(action)) return; const channel = guild.channels.get(s.channel); if (!channel) return; const embed = new this.Discord.MessageEmbed(); embed.setTitle(this._actionString(action)); embed.setColor(this._actionColor(action)); embed.setFooter(new Date().toString()); if (user) { embed.setThumbnail(user.displayAvatarURL({size: 32})); embed.addField(user.tag, `&lt;@${user.id}&gt;\\n${user.id}`, true); } if (owner) embed.addField('Moderator', owner.tag, true); if (message) { if (message2) { embed.addField(message, message2, true); } else if (!user &amp;&amp; !owner) { embed.setDescription(message); } else { embed.addField('Additional', message, true); } } embed.setTimestamp(); channel.send(embed); } } /** * @description Settings for moderation logging. * @memberof ModLog * @inner */ class Settings { /** * @description Create default settings. */ constructor() { /** * @description The channel ID of where to send log messages. * @public * @type {?string} * @default */ this.channel = null; /** * @description Should the bot log when users are kicked? * @public * @type {boolean} * @default */ this.logKicks = false; /** * @description Should the bot log when users are banned? * @public * @type {boolean} * @default */ this.logBans = false; /** * @description Should the bot log when users are muted? * @public * @type {boolean} * @default */ this.logMutes = false; /** * @description Should the bot log when users abuse mentions? * @public * @type {boolean} * @default */ this.logMentionAbuse = false; /** * @description Should the bot log when messages are purged? * @public * @type {boolean} * @default */ this.logMessagePurge = false; /** * @description Should the bot log when a message is deleted? * @public * @type {boolean} * @default */ this.logMessageDelete = false; /** * @description Should the bot log when a lockdown is started? * @public * @type {boolean} * @default */ this.logRaidLockdown = false; /** * Log other actions that have not been classified. * @public * @type {boolean} * @default */ this.logOther = false; } /** * @description Check if the given action should be logged. Ignores if channel * is set. * @public * @param {string} action The action to check if should log. * @returns {boolean} True if should log. */ check(action) { switch (action) { case 'kick': return this.logKicks; case 'ban': return this.logBans; case 'mute': case 'warnAndMute': case 'smite': return this.logMutes; case 'mentionAbuse': return this.logMentionAbuse; case 'messagePurge': return this.logMessagePurge; case 'messageDelete': return this.logMessageDelete; case 'memberLeave': return this.logMemberLeave; case 'memberJoin': return this.logMemberJoin; case 'lockdown': return this.logRaidLockdown; default: return this.logOther; } } } /** * @description Create a Settings object from a Settings-like object. Similar to * copy-constructor. * @public * @static * @param {object} obj Object to create a Settings object from. * @returns {ModLog~Settings} The created object. */ Settings.from = function(obj) { const output = new Settings(); output.channel = obj.channel || null; output.logKicks = obj.logKicks || false; output.logBans = obj.logBans || false; output.logMutes = obj.logMutes || false; output.logMentionAbuse = obj.logMentionAbuse || false; output.logMessagePurge = obj.logMessagePurge || false; output.logMessageDelete = obj.logMessageDelete || false; output.logMemberLeave = obj.logMemberLeave || false; output.logMemberJoin = obj.logMemberJoin || false; output.logRaidLockdown = obj.logRaidLockdown || false; output.logOther = obj.logOther || false; return output; }; ModLog.Settings = Settings; module.exports = new ModLog(); × Search results Close "},"lib_twemojiChcker.js.html":{"id":"lib_twemojiChcker.js.html","title":"Source: lib/twemojiChcker.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: lib/twemojiChcker.js /** @module lib/twemojiChecker */ /** * RegExp based on emoji's official Unicode standards * http://www.unicode.org/Public/UNIDATA/EmojiSources.txt * https://github.com/twitter/twemoji/blob/27fe654b2bed5331cf1730bb4fbba1efa40af626/2/twemoji.js#L228 * @private * @constant * @type {RegExp} */ const re = /(?:\\ud83d[\\udc68\\udc69])(?:\\ud83c[\\udffb-\\udfff])?\\u200d(?:\\u2695\\ufe0f|\\u2696\\ufe0f|\\u2708\\ufe0f|\\ud83c[\\udf3e\\udf73\\udf93\\udfa4\\udfa8\\udfeb\\udfed]|\\ud83d[\\udcbb\\udcbc\\udd27\\udd2c\\ude80\\ude92]|\\ud83e[\\uddb0-\\uddb3])|(?:\\ud83c[\\udfcb\\udfcc]|\\ud83d[\\udd74\\udd75]|\\u26f9)((?:\\ud83c[\\udffb-\\udfff]|\\ufe0f)\\u200d[\\u2640\\u2642]\\ufe0f)|(?:\\ud83c[\\udfc3\\udfc4\\udfca]|\\ud83d[\\udc6e\\udc71\\udc73\\udc77\\udc81\\udc82\\udc86\\udc87\\ude45-\\ude47\\ude4b\\ude4d\\ude4e\\udea3\\udeb4-\\udeb6]|\\ud83e[\\udd26\\udd35\\udd37-\\udd39\\udd3d\\udd3e\\uddb8\\uddb9\\uddd6-\\udddd])(?:\\ud83c[\\udffb-\\udfff])?\\u200d[\\u2640\\u2642]\\ufe0f|(?:\\ud83d\\udc68\\u200d\\u2764\\ufe0f\\u200d\\ud83d\\udc8b\\u200d\\ud83d\\udc68|\\ud83d\\udc68\\u200d\\ud83d\\udc68\\u200d\\ud83d\\udc66\\u200d\\ud83d\\udc66|\\ud83d\\udc68\\u200d\\ud83d\\udc68\\u200d\\ud83d\\udc67\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc68\\u200d\\ud83d\\udc69\\u200d\\ud83d\\udc66\\u200d\\ud83d\\udc66|\\ud83d\\udc68\\u200d\\ud83d\\udc69\\u200d\\ud83d\\udc67\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc69\\u200d\\u2764\\ufe0f\\u200d\\ud83d\\udc8b\\u200d\\ud83d[\\udc68\\udc69]|\\ud83d\\udc69\\u200d\\ud83d\\udc69\\u200d\\ud83d\\udc66\\u200d\\ud83d\\udc66|\\ud83d\\udc69\\u200d\\ud83d\\udc69\\u200d\\ud83d\\udc67\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc68\\u200d\\u2764\\ufe0f\\u200d\\ud83d\\udc68|\\ud83d\\udc68\\u200d\\ud83d\\udc66\\u200d\\ud83d\\udc66|\\ud83d\\udc68\\u200d\\ud83d\\udc67\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc68\\u200d\\ud83d\\udc68\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc68\\u200d\\ud83d\\udc69\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc69\\u200d\\u2764\\ufe0f\\u200d\\ud83d[\\udc68\\udc69]|\\ud83d\\udc69\\u200d\\ud83d\\udc66\\u200d\\ud83d\\udc66|\\ud83d\\udc69\\u200d\\ud83d\\udc67\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc69\\u200d\\ud83d\\udc69\\u200d\\ud83d[\\udc66\\udc67]|\\ud83c\\udff3\\ufe0f\\u200d\\ud83c\\udf08|\\ud83c\\udff4\\u200d\\u2620\\ufe0f|\\ud83d\\udc41\\u200d\\ud83d\\udde8|\\ud83d\\udc68\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc69\\u200d\\ud83d[\\udc66\\udc67]|\\ud83d\\udc6f\\u200d\\u2640\\ufe0f|\\ud83d\\udc6f\\u200d\\u2642\\ufe0f|\\ud83e\\udd3c\\u200d\\u2640\\ufe0f|\\ud83e\\udd3c\\u200d\\u2642\\ufe0f|\\ud83e\\uddde\\u200d\\u2640\\ufe0f|\\ud83e\\uddde\\u200d\\u2642\\ufe0f|\\ud83e\\udddf\\u200d\\u2640\\ufe0f|\\ud83e\\udddf\\u200d\\u2642\\ufe0f)|[\\u0023\\u002a\\u0030-\\u0039]\\ufe0f?\\u20e3|(?:[\\u00a9\\u00ae\\u2122\\u265f]\\ufe0f)|(?:\\ud83c[\\udc04\\udd70\\udd71\\udd7e\\udd7f\\ude02\\ude1a\\ude2f\\ude37\\udf21\\udf24-\\udf2c\\udf36\\udf7d\\udf96\\udf97\\udf99-\\udf9b\\udf9e\\udf9f\\udfcd\\udfce\\udfd4-\\udfdf\\udff3\\udff5\\udff7]|\\ud83d[\\udc3f\\udc41\\udcfd\\udd49\\udd4a\\udd6f\\udd70\\udd73\\udd76-\\udd79\\udd87\\udd8a-\\udd8d\\udda5\\udda8\\uddb1\\uddb2\\uddbc\\uddc2-\\uddc4\\uddd1-\\uddd3\\udddc-\\uddde\\udde1\\udde3\\udde8\\uddef\\uddf3\\uddfa\\udecb\\udecd-\\udecf\\udee0-\\udee5\\udee9\\udef0\\udef3]|[\\u203c\\u2049\\u2139\\u2194-\\u2199\\u21a9\\u21aa\\u231a\\u231b\\u2328\\u23cf\\u23ed-\\u23ef\\u23f1\\u23f2\\u23f8-\\u23fa\\u24c2\\u25aa\\u25ab\\u25b6\\u25c0\\u25fb-\\u25fe\\u2600-\\u2604\\u260e\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262a\\u262e\\u262f\\u2638-\\u263a\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267b\\u267f\\u2692-\\u2697\\u2699\\u269b\\u269c\\u26a0\\u26a1\\u26aa\\u26ab\\u26b0\\u26b1\\u26bd\\u26be\\u26c4\\u26c5\\u26c8\\u26cf\\u26d1\\u26d3\\u26d4\\u26e9\\u26ea\\u26f0-\\u26f5\\u26f8\\u26fa\\u26fd\\u2702\\u2708\\u2709\\u270f\\u2712\\u2714\\u2716\\u271d\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u2764\\u27a1\\u2934\\u2935\\u2b05-\\u2b07\\u2b1b\\u2b1c\\u2b50\\u2b55\\u3030\\u303d\\u3297\\u3299])(?:\\ufe0f|(?!\\ufe0e))|(?:(?:\\ud83c[\\udfcb\\udfcc]|\\ud83d[\\udd74\\udd75\\udd90]|[\\u261d\\u26f7\\u26f9\\u270c\\u270d])(?:\\ufe0f|(?!\\ufe0e))|(?:\\ud83c[\\udf85\\udfc2-\\udfc4\\udfc7\\udfca]|\\ud83d[\\udc42\\udc43\\udc46-\\udc50\\udc66-\\udc69\\udc6e\\udc70-\\udc78\\udc7c\\udc81-\\udc83\\udc85-\\udc87\\udcaa\\udd7a\\udd95\\udd96\\ude45-\\ude47\\ude4b-\\ude4f\\udea3\\udeb4-\\udeb6\\udec0\\udecc]|\\ud83e[\\udd18-\\udd1c\\udd1e\\udd1f\\udd26\\udd30-\\udd39\\udd3d\\udd3e\\uddb5\\uddb6\\uddb8\\uddb9\\uddd1-\\udddd]|[\\u270a\\u270b]))(?:\\ud83c[\\udffb-\\udfff])?|(?:\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40\\udc65\\udb40\\udc6e\\udb40\\udc67\\udb40\\udc7f|\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40\\udc73\\udb40\\udc63\\udb40\\udc74\\udb40\\udc7f|\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40\\udc77\\udb40\\udc6c\\udb40\\udc73\\udb40\\udc7f|\\ud83c\\udde6\\ud83c[\\udde8-\\uddec\\uddee\\uddf1\\uddf2\\uddf4\\uddf6-\\uddfa\\uddfc\\uddfd\\uddff]|\\ud83c\\udde7\\ud83c[\\udde6\\udde7\\udde9-\\uddef\\uddf1-\\uddf4\\uddf6-\\uddf9\\uddfb\\uddfc\\uddfe\\uddff]|\\ud83c\\udde8\\ud83c[\\udde6\\udde8\\udde9\\uddeb-\\uddee\\uddf0-\\uddf5\\uddf7\\uddfa-\\uddff]|\\ud83c\\udde9\\ud83c[\\uddea\\uddec\\uddef\\uddf0\\uddf2\\uddf4\\uddff]|\\ud83c\\uddea\\ud83c[\\udde6\\udde8\\uddea\\uddec\\udded\\uddf7-\\uddfa]|\\ud83c\\uddeb\\ud83c[\\uddee-\\uddf0\\uddf2\\uddf4\\uddf7]|\\ud83c\\uddec\\ud83c[\\udde6\\udde7\\udde9-\\uddee\\uddf1-\\uddf3\\uddf5-\\uddfa\\uddfc\\uddfe]|\\ud83c\\udded\\ud83c[\\uddf0\\uddf2\\uddf3\\uddf7\\uddf9\\uddfa]|\\ud83c\\uddee\\ud83c[\\udde8-\\uddea\\uddf1-\\uddf4\\uddf6-\\uddf9]|\\ud83c\\uddef\\ud83c[\\uddea\\uddf2\\uddf4\\uddf5]|\\ud83c\\uddf0\\ud83c[\\uddea\\uddec-\\uddee\\uddf2\\uddf3\\uddf5\\uddf7\\uddfc\\uddfe\\uddff]|\\ud83c\\uddf1\\ud83c[\\udde6-\\udde8\\uddee\\uddf0\\uddf7-\\uddfb\\uddfe]|\\ud83c\\uddf2\\ud83c[\\udde6\\udde8-\\udded\\uddf0-\\uddff]|\\ud83c\\uddf3\\ud83c[\\udde6\\udde8\\uddea-\\uddec\\uddee\\uddf1\\uddf4\\uddf5\\uddf7\\uddfa\\uddff]|\\ud83c\\uddf4\\ud83c\\uddf2|\\ud83c\\uddf5\\ud83c[\\udde6\\uddea-\\udded\\uddf0-\\uddf3\\uddf7-\\uddf9\\uddfc\\uddfe]|\\ud83c\\uddf6\\ud83c\\udde6|\\ud83c\\uddf7\\ud83c[\\uddea\\uddf4\\uddf8\\uddfa\\uddfc]|\\ud83c\\uddf8\\ud83c[\\udde6-\\uddea\\uddec-\\uddf4\\uddf7-\\uddf9\\uddfb\\uddfd-\\uddff]|\\ud83c\\uddf9\\ud83c[\\udde6\\udde8\\udde9\\uddeb-\\udded\\uddef-\\uddf4\\uddf7\\uddf9\\uddfb\\uddfc\\uddff]|\\ud83c\\uddfa\\ud83c[\\udde6\\uddec\\uddf2\\uddf3\\uddf8\\uddfe\\uddff]|\\ud83c\\uddfb\\ud83c[\\udde6\\udde8\\uddea\\uddec\\uddee\\uddf3\\uddfa]|\\ud83c\\uddfc\\ud83c[\\uddeb\\uddf8]|\\ud83c\\uddfd\\ud83c\\uddf0|\\ud83c\\uddfe\\ud83c[\\uddea\\uddf9]|\\ud83c\\uddff\\ud83c[\\udde6\\uddf2\\uddfc]|\\ud83c[\\udccf\\udd8e\\udd91-\\udd9a\\udde6-\\uddff\\ude01\\ude32-\\ude36\\ude38-\\ude3a\\ude50\\ude51\\udf00-\\udf20\\udf2d-\\udf35\\udf37-\\udf7c\\udf7e-\\udf84\\udf86-\\udf93\\udfa0-\\udfc1\\udfc5\\udfc6\\udfc8\\udfc9\\udfcf-\\udfd3\\udfe0-\\udff0\\udff4\\udff8-\\udfff]|\\ud83d[\\udc00-\\udc3e\\udc40\\udc44\\udc45\\udc51-\\udc65\\udc6a-\\udc6d\\udc6f\\udc79-\\udc7b\\udc7d-\\udc80\\udc84\\udc88-\\udca9\\udcab-\\udcfc\\udcff-\\udd3d\\udd4b-\\udd4e\\udd50-\\udd67\\udda4\\uddfb-\\ude44\\ude48-\\ude4a\\ude80-\\udea2\\udea4-\\udeb3\\udeb7-\\udebf\\udec1-\\udec5\\uded0-\\uded2\\udeeb\\udeec\\udef4-\\udef9]|\\ud83e[\\udd10-\\udd17\\udd1d\\udd20-\\udd25\\udd27-\\udd2f\\udd3a\\udd3c\\udd40-\\udd45\\udd47-\\udd70\\udd73-\\udd76\\udd7a\\udd7c-\\udda2\\uddb4\\uddb7\\uddc0-\\uddc2\\uddd0\\uddde-\\uddff]|[\\u23e9-\\u23ec\\u23f0\\u23f3\\u267e\\u26ce\\u2705\\u2728\\u274c\\u274e\\u2753-\\u2755\\u2795-\\u2797\\u27b0\\u27bf\\ue50a])|\\ufe0f/g; // eslint-disable-line max-len /** * Check a string for any emoji matches. * * @public * * @param {string} input The string to run the regex against. * @returns {null|string[]} The matched return value. */ function match(input) { return input.match(re); } module.exports = { match: match, }; × Search results Close "},"music.js.html":{"id":"music.js.html","title":"Source: music.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: music.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const ytdl = require('youtube-dl'); // Music thread uses separate require. const fs = require('fs'); // Music thread uses separate require. const ogg = require('ogg'); const opus = require('node-opus'); const spawn = require('threads').spawn; const Readable = require('stream').Readable; require('./subModule.js').extend(Music); /** * @classdesc Music and audio related commands. * @class * @augments SubModule * @listens Discord~Client#voiceStateUpdate * @listens Command#play * @listens Command#pause * @listens Command#resume * @listens Command#leave * @listens Command#stop * @listens Command#stfu * @listens Command#skip * @listens Command#q * @listens Command#queue * @listens Command#playing * @listens Command#remove * @listens Command#dequeue * @listens Command#lyrics * @listens Command#record * @listens Command#follow * @listens Command#unfollow * @listens Command#stalk * @listens Command#unstalk * @listens Command#musicstats * @listens Command#volume * @fires Command#stop */ function Music() { const self = this; this.myName = 'Music'; /** * The Genuius client token we use to fetch information from their api * * @private * @type {string} * @constant */ const geniusClient = 'l5zrX9XIDrJuz-kS1u7zS5sE81KzrH3qxZL5tAvprE9GG-L1KYlZklQDXL6wf3sn'; /** * The request headers to send to genius. * * @private * @type {Object} * @default * @constant */ const geniusRequest = { hostname: 'api.genius.com', path: '/search/', headers: { 'Accept': 'application/json', 'Authorization': 'Bearer ' + geniusClient, }, method: 'GET', }; const https = require('https'); /** * Information about a server's music and queue. * @typedef {Object} Music~Broadcast * * @property {string[]} queue Requests that have been queued. * @property {Object.&lt;boolean&gt;} skips Stores user id's and whether * they have voted to skip. Non-existent user means they have not voted to * skip. * @property {boolean} isPlaying Is audio currntly being streamed to the * channel. * @property {?Discord~VoiceBroadcast} broadcast The Discord voice broadcast * actually playing the audio. * @property {?Discord~VoiceConnection} voice The current voice connection * audio is being streamed to. * @property {?Discord~StreamDispatcher} dispatcher The Discord dispatcher for * the current audio channel. * @property {?Object} current The current broadcast information including * thread, readable stream, and song information. */ /** * All current audio broadcasts to voice channels. Stores all relavent data. * Stored by guild id. * * @private * @type {Object.&lt;Music~Broadcast&gt;} */ const broadcasts = {}; /** * The current user IDs of the users to follow into new voice channels. This * is mapped by guild id. * * @private * @type {Object.&lt;string&gt;} */ const follows = {}; /** * Special cases of requests to handle seperately. * * @private * @type {Object.&lt;Object.&lt;{cmd: string, url: ?string, file: string}&gt;&gt;} * @constant */ const special = { 'nice try vi': { cmd: 'vi', url: 'https://www.youtube.com/watch?v=c1NoTNCiomU', file: './sounds/viRap.ogg', }, 'airhorn': { cmd: 'airhorn', url: '', file: './sounds/airhorn.ogg', }, 'rickroll': { cmd: 'rickroll', url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ', file: './sounds/rickRoll.ogg', }, 'kokomo': { cmd: 'kokomo', url: 'https://www.youtube.com/watch?v=bOyJUF0p9Wc', file: './sounds/kokomo.ogg', }, }; /** * Options passed to youtube-dl for fetching videos. * * @private * @type {string[]} * @default * @constant */ const ytdlOpts = ['-f', 'bestaudio/worst', '--no-playlist', '--default-search=auto']; /** * Options to pass into the primary stream dispatcher (The one in charge of * volume control). * [StreamOptions]( * https://discord.js.org/#/docs/main/master/typedef/StreamOptions) * * @private * @constant * @type {Discord~StreamOptions} * @default */ const primaryStreamOptions = { passes: 1, fec: true, bitrate: 'auto', volume: 0.5, plp: 0.0, highWaterMark: 5, }; /** * Options to pass into the secondary stream dispatcher (The one buffering for * Discord). * [StreamOptions]( * https://discord.js.org/#/docs/main/master/typedef/StreamOptions) * * @private * @constant * @type {Discord~StreamOptions} * @default */ const secondaryStreamOptions = { passes: 1, fec: true, bitrate: 'auto', volume: 0.5, plp: 0.05, highWaterMark: 1000, }; /** @inheritdoc */ this.helpMessage = 'Loading...'; /** * The object that stores all data to be formatted into the help message. * * @private * @constant */ const helpObject = JSON.parse(fs.readFileSync('./docs/musicHelp.json')); /** @inheritdoc */ this.initialize = function() { self.command.on('join', commandJoin, true); self.command.on('play', commandPlay, true); self.command.on('pause', commandPause, true); self.command.on('resume', commandResume, true); self.command.on(['leave', 'stop', 'stfu'], commandLeave, true); self.command.on('skip', commandSkip, true); self.command.on(['queue', 'q', 'playing'], commandQueue, true); self.command.on(['remove', 'dequeue'], commandRemove, true); self.command.on('lyrics', commandLyrics); self.command.on('record', commandRecord, true); self.command.on( ['follow', 'unfollow', 'stalk', 'stalkme'], commandFollow, true); self.command.on('musicstats', commandStats); self.command.on(['volume', 'vol', 'v'], commandVolume, true); self.command.on(['clear', 'empty'], commandClearQueue, true); self.command.on('kokomo', (msg) =&gt; { msg.content = msg.prefix + 'play kokomo'; self.command.trigger(msg); }); self.command.on('vi', (msg) =&gt; { msg.content = msg.prefix + 'play nice try vi'; self.command.trigger(msg); }); self.command.on('airhorn', (msg) =&gt; { msg.content = msg.prefix + 'play airhorn'; self.command.trigger(msg); }); self.command.on('rickroll', (msg) =&gt; { msg.content = msg.prefix + 'play rickroll'; self.command.trigger(msg); }); self.client.on('voiceStateUpdate', handleVoiceStateUpdate); // Format help message into rich embed. const tmpHelp = new self.Discord.MessageEmbed(); tmpHelp.setTitle( helpObject.title.replaceAll('{prefix}', self.bot.getPrefix())); tmpHelp.setURL(self.common.webURL); tmpHelp.setDescription( helpObject.description.replaceAll('{prefix}', self.bot.getPrefix())); helpObject.sections.forEach(function(obj) { const titleID = encodeURIComponent(obj.title.replace(/\\s/g, '_')); const titleURL = '[web](' + self.common.webHelp + '#' + titleID + ')'; tmpHelp.addField( obj.title, titleURL + '```js\\n' + obj.rows .map(function(row) { if (typeof row === 'string') { return self.bot.getPrefix() + row.replaceAll('{prefix}', self.bot.getPrefix()); } else if (typeof row === 'object') { return self.bot.getPrefix() + row.command.replaceAll( '{prefix}', self.bot.getPrefix()) + ' // ' + row.description.replaceAll( '{prefix}', self.bot.getPrefix()); } }) .join('\\n') + '\\n```', true); }); tmpHelp.setFooter( 'Note: If a custom prefix is being used, replace `' + self.bot.getPrefix() + '` with the custom prefix.\\nNote 2: Custom prefixes will not have a ' + 'space after them.'); self.helpMessage = tmpHelp; }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('join'); self.command.deleteEvent('play'); self.command.deleteEvent('pause'); self.command.deleteEvent('resume'); self.command.deleteEvent('leave'); self.command.deleteEvent('skip'); self.command.deleteEvent('q'); self.command.deleteEvent('remove'); self.command.deleteEvent('lyrics'); self.command.deleteEvent('record'); self.command.deleteEvent('kokomo'); self.command.deleteEvent('vi'); self.command.deleteEvent('airhorn'); self.command.deleteEvent('rickroll'); self.command.deleteEvent('follow'); self.command.deleteEvent('musicstats'); self.command.deleteEvent('volume'); self.command.deleteEvent('clear'); self.client.removeListener('voiceStateUpdate', handleVoiceStateUpdate); for (const b in broadcasts) { if (broadcasts[b] &amp;&amp; broadcasts[b].voice) { try { broadcasts[b].voice.disconnect(); } catch (err) { self.error( 'Failed to disconenct from voice channel: ' + broadcasts[b].voice &amp;&amp; broadcasts[b].voice.channel.id); console.error(err); } } } }; /** @inheritdoc */ this.save = function() { if (!self.initialized) return; // Purge broadcasts that have been paused for more than 15 minutes. const entries = Object.entries(broadcasts); const now = Date.now(); for (let i = 0; i &lt; entries.length; i++) { if (!entries[i][1].broadcast || !entries[i][1].broadcast.dispatcher) { delete broadcasts[entries[i][0]]; continue; } const pauseTime = entries[i][1].broadcast.dispatcher.pausedSince; if (pauseTime &amp;&amp; now - pauseTime &gt; 15 * 60 * 1000) { self.debug(entries[i][0] + ' purged: ' + (now - pauseTime)); if (entries[i][1].voice &amp;&amp; entries[i][1].voice.disconnect) { entries[i][1].voice.disconnect(); } delete broadcasts[entries[i][0]]; } } }; /** @inheritdoc */ this.unloadable = function() { // If a broadcast has been paused for more than 5 minutes, it is okay to // reload this submodule. const entries = Object.entries(broadcasts); let numAlive = entries.length; const now = Date.now(); for (let i = 0; i &lt; entries.length; i++) { if (!entries[i][1].broadcast || !entries[i][1].broadcast.dispatcher) { continue; } const pauseTime = entries[i][1].broadcast.dispatcher.pausedSince; if (pauseTime &amp;&amp; now - pauseTime &gt; 5 * 60 * 1000) { numAlive--; } } return numAlive &lt;= 0; }; /** * Creates formatted string for mentioning the author of msg. * * @private * @param {Discord~Message} msg Message to format a mention for the author of. * @returns {string} Formatted mention string. */ function mention(msg) { return `&lt;@${msg.author.id}&gt;`; } /** * Replies to the author and channel of msg with the given message. * * @deprecated Use {@link Common.reply} instead. * * @private * @param {Discord~Message} msg Message to reply to. * @param {string} text The main body of the message. * @param {string} post The footer of the message. * @returns {Promise} Promise of Discord~Message that we attempted to send. */ function reply(msg, text, post) { return self.common.reply(msg, text, post); } /** * Leave a voice channel if all other users have left. Should also cause music * and recordings to stop. * * @private * @param {Discord~VoiceState} oldState State before status update. * @param {Discord~VoiceState} newState State after status update. * @listens Discord~Client#voiceStateUpdate */ function handleVoiceStateUpdate(oldState, newState) { // User set to follow has changed channel. if (follows[oldState.guild.id] == oldState.id &amp;&amp; newState.channelID) { newState.channel.join().catch(() =&gt; {}); return; } const broadcast = broadcasts[oldState.guild.id]; if (broadcast) { if (oldState.id === self.client.user.id &amp;&amp; !newState.channel) { self.error( 'Forcibly ejected from voice channel: ' + oldState.guild.id + ' ' + oldState.channelID); delete broadcasts[oldState.guild.id]; if (broadcast.request &amp;&amp; broadcast.request.channel) { broadcast.request.channel.send( '`I was forcibly ejected from the voice channel for an unknown ' + 'reason!`'); } return; } if (oldState.channel &amp;&amp; oldState.channel.members) { const numMembers = oldState.channel.members.filter((el) =&gt; !el.user.bot).size; if (numMembers === 0 &amp;&amp; oldState.channel.members.get(self.client.user.id)) { if (broadcast.subjugated) { if (broadcast.voice) { broadcast.voice.disconnect(); if (broadcast.voice) broadcast.voice.removeAllListeners(); } delete broadcasts[oldState.guild.id]; return; } else if (pauseBroadcast(broadcast)) { if (broadcast.current.request &amp;&amp; broadcast.current.request.channel) { const prefix = self.bot.getPrefix(oldState.guild.id); let followInst = ''; if (oldState.channelID &amp;&amp; newState.channelID) { followInst = '\\n`' + prefix + 'join` to join your channel.'; } self.common.reply( broadcast.current.request, 'Music paused because everyone left me alone :(\\nType `' + prefix + 'resume`, to unpause the music.' + followInst); } } } } // If the bot changed channel, continue playing previous music. if (oldState.id === self.client.user.id &amp;&amp; broadcast.voice &amp;&amp; broadcast.voice.channel.id != newState.channelID &amp;&amp; oldState.channelID != newState.channelID &amp;&amp; oldState.channelID &amp;&amp; newState.channelID &amp;&amp; newState.channel &amp;&amp; newState.channel.connection) { if (broadcast.voice) broadcast.voice.removeAllListeners(); broadcast.voice = newState.channel.connection; broadcast.dispatcher = broadcast.voice.play(broadcast.broadcast, secondaryStreamOptions); } } } /** * Format the info response from ytdl into a human readable format. * * @private * @param {object} info The info received from ytdl about the song. * @param {Discord~StreamDispatcher} [dispatcher] The broadcast dispatcher * that is currently broadcasting audio. If defined, this will be used to * determine remaining play time. * @param {number} [seek=0] The offset to add to totalStreamTime to correct * for starting playback somewhere other than the beginning. * @returns {Discord~MessageEmbed} The formatted song info. */ function formatSongInfo(info, dispatcher, seek) { if (!seek) seek = 0; let remaining = ''; let currentTime = ''; if (dispatcher) { currentTime = '[' + formatPlaytime( Math.round( ((seek * 1000 + dispatcher.totalStreamTime) - dispatcher.pausedTime) / 1000)) + '] / '; remaining = ' (' + formatPlaytime(getRemainingSeconds(info, dispatcher) - seek) + ' left)'; } const output = new self.Discord.MessageEmbed(); output.setDescription( info.title + '\\nUploaded by ' + info.uploader + '\\n[👍 ' + formNum(info.like_count) + ' 👎 ' + formNum(info.dislike_count) + '][👁️ ' + formNum(info.view_count) + ']\\n' + currentTime + '[' + formatPlaytime(info._duration_raw) + ']' + remaining); if (info.thumbnail) output.setThumbnail(info.thumbnail); output.setURL(info.webpage_url); output.setColor([50, 200, 255]); return output; } /** * Get the remaining playtime in the given song info and broadcast. * * @private * @param {object} info The song info received from ytdl. * @param {Discord~StreamDispatcher} dispatcher The dispatcher playing the * song currently. * @returns {number} Number of seconds remaining in the song playtime. */ function getRemainingSeconds(info, dispatcher) { if (!dispatcher.totalStreamTime) return info._duration_raw; return info._duration_raw - Math.round((dispatcher.totalStreamTime - dispatcher.pausedTime) / 1000); } /** * Get the current progress into the song in the given context. * * @public * @param {Discord~Message} msg The context to use to fetch the info. * @returns {?number} Time in seconds, or null if nothing is playing. */ this.getProgress = function(msg) { const broadcast = broadcasts[msg.guild.id]; if (!broadcast) return null; if (!broadcast.broadcast) return null; if (!broadcast.broadcast.dispatcher) return null; return Math.round( ((broadcast.broadcast.dispatcher.totalStreamTime || 0) - (broadcast.broadcast.dispatcher.pausedTime || 0)) / 1000) + (broadcast.current.seek || 0); }; /** * Get the song's length of the song playing in the given context. * * @public * @param {Discord~Message} msg The context to use to fetch the info. * @returns {?number} Time in seconds, or null if nothing is playing. */ this.getDuration = function(msg) { const broadcast = broadcasts[msg.guild.id]; if (!broadcast) return null; if (!broadcast.current) return null; if (!broadcast.current.info) return null; return broadcast.current.info._duration_raw; }; /** * Format the given number of seconds into the playtime format. * * @private * @param {number} seconds The duration in seconds. * @returns {string} The formatted string in minutes and seconds. */ function formatPlaytime(seconds) { return Math.floor(seconds / 60) + 'm ' + seconds % 60 + 's'; } /** * Add commas between digits on large numbers. * * @private * @param {number|string} num The number to format. * @returns {string} The formatted number. */ function formNum(num) { const numString = (num + ''); const tmpString = []; for (let i = 0; i &lt; numString.length; i++) { if (i &gt; 0 &amp;&amp; i % 3 === 0) tmpString.push(','); tmpString.push(numString.substr(-i - 1, 1)); } return tmpString.reverse().join(''); } /** * Add a song to the given broadcast's queue and start playing it not already. * * @private * @param {Music~Broadcast} broadcast The broadcast storage container. * @param {string} song The song that was requested. * @param {Discord~Message} msg The message that requested the song. * @param {object} [info] The info from ytdl about the song. * @param {number} [seek=0] The number of seconds into a song to start * playing. * @fires Command#stop */ function enqueueSong(broadcast, song, msg, info, seek) { broadcast.queue.push({request: msg, song: song, info: info, seek: seek}); if (broadcast.voice &amp;&amp; broadcast.voice.channel) { try { startPlaying(broadcast); } catch (err) { console.log(err); reply(msg, 'Failed to start music stream!'); self.command.trigger('stop', msg); } } else { msg.member.voice.channel.join() .then((conn) =&gt; { if (broadcast.voice) broadcast.voice.removeAllListeners(); broadcast.voice = conn; try { startPlaying(broadcast); } catch (err) { console.log(err); reply(msg, 'Failed to start music stream!'); self.command.trigger('stop', msg); } }) .catch((err) =&gt; { reply(msg, 'I am unable to join your voice channel.', err.message); }); } } /** * Start playing the first item in the queue of the broadcast. * * @private * @param {Music~Broadcast} broadcast The container storing all information * about the song. */ function startPlaying(broadcast) { if (!broadcast || broadcast.isPlaying || broadcast.isLoading || (broadcast.current &amp;&amp; !broadcasts[broadcast.current.request.guild.id])) { return; } if (broadcast.queue.length === 0) { if (!broadcast.subjugated) { self.client.setTimeout(function() { if (broadcast.voice) { broadcast.voice.disconnect(); if (broadcast.voice) broadcast.voice.removeAllListeners(); } delete broadcasts[broadcast.current.request.guild.id]; }, 500); broadcast.current.request.channel.send('`Queue is empty!`'); } return; } broadcast.isLoading = true; broadcast.skips = {}; if (broadcast.current &amp;&amp; broadcast.current.thread) { broadcast.current.thread.kill(); } broadcast.current = broadcast.queue.splice(0, 1)[0]; try { makeBroadcast(broadcast); // broadcast.voice.play(broadcast.broadcast); } catch (err) { console.log(err); endSong(broadcast); broadcast.isLoading = false; } broadcast.isPlaying = true; if (broadcast.current.info) { if (!broadcast.subjugated &amp;&amp; broadcast.current.request) { const embed = formatSongInfo(broadcast.current.info); embed.setTitle( 'Now playing [' + broadcast.queue.length + ' left in queue]'); broadcast.current.request.channel.send(embed); } broadcast.current.oninfo = function() { broadcast.isLoading = false; }; } else { if (special[broadcast.current.song]) { if (!special[broadcast.current.song].url) { broadcast.isLoading = false; if (!broadcast.subjugated &amp;&amp; broadcast.current.request) { const embed = new self.Discord.MessageEmbed(); embed.setTitle( 'Now playing [' + broadcast.queue.length + ' left in queue]'); embed.setColor([50, 200, 255]); embed.setDescription(broadcast.current.song); broadcast.current.request.channel.send(embed); } } else { ytdl.getInfo( special[broadcast.current.song].url, ytdlOpts, (err, info) =&gt; { broadcast.isLoading = false; if (err) { self.error(err.message.split('\\n')[1]); if (broadcast.current.request) { broadcast.current.request.channel.send( '```Oops, something went wrong while getting info ' + 'for this song!```\\n' + err.message.split('\\n')[1]); } } else { broadcast.current.info = info; if (!broadcast.subjugated &amp;&amp; broadcast.current.request) { const embed = formatSongInfo(broadcast.current.info); embed.setTitle( 'Now playing [' + broadcast.queue.length + ' left in queue]'); broadcast.current.request.channel.send(embed); } } }); } } else { broadcast.current.oninfo = function(info) { broadcast.isLoading = false; broadcast.current.info = info; if (!broadcast.subjugated &amp;&amp; broadcast.current.request) { const embed = formatSongInfo(broadcast.current.info); embed.setTitle( 'Now playing [' + broadcast.queue.length + ' left in queue]'); broadcast.current.request.channel.send(embed); } }; } } } /** * Create a voice channel broadcast based off of the media source, and start * playing the audio. * * @private * @param {Music~Broadcast} broadcast The object storing all relevant * information. */ function makeBroadcast(broadcast) { // Setup voice connection listeners. if (!broadcast.voice || !broadcast.voice.channel) return; // This isn't normally a good idea, but there are no other disconnect // listeners on this voice connection ever so this will work fine until that // changes. broadcast.voice.removeAllListeners('disconnect'); broadcast.voice.on('disconnect', onDC); /** * Fires on when voice connection is disconnected. Cleans up anything that * could be left behind. * * @private */ function onDC() { if (broadcast.current.readable) broadcast.current.readable.destroy(); if (broadcast.current.thread) broadcast.current.thread.kill(); if (broadcast.dispatcher) broadcast.dispatcher.destroy(); if (broadcast.broadcast &amp;&amp; broadcast.broadcast.dispatcher) { broadcast.broadcast.dispatcher.destroy(); } } // Setup readable stream for audio data. broadcast.current.readable = new Readable(); broadcast.current.readable._read = function() {}; broadcast.broadcast = self.client.voice.createBroadcast(); primaryStreamOptions.seek = broadcast.current.seek; broadcast.broadcast.play(broadcast.current.readable, primaryStreamOptions); broadcast.dispatcher = broadcast.voice.play(broadcast.broadcast, secondaryStreamOptions); broadcast.broadcast.dispatcher.on('end', function() { endSong(broadcast); }); broadcast.broadcast.dispatcher.on('close', function() { endSong(broadcast); }); broadcast.dispatcher.on('error', function(err) { self.error('Error in starting broadcast: ' + broadcast.current.song); console.log(err); if (broadcast.current.request) { broadcast.current.request.channel.send( '```An error occured while attempting to play ' + broadcast.current.song + '.```'); } broadcast.isLoading = false; skipSong(broadcast); }); // Spawn thread for starting audio stream. const input = { song: broadcast.current.song, special: special, ytdlOpts: ytdlOpts, }; if (broadcast.current.info) { input.song = broadcast.current.info.url; } broadcast.current.thread = spawn(startStream); broadcast.current.thread.send(input); broadcast.current.thread.on('progress', function(data) { if (data.ytdlinfo) { broadcast.current.oninfo(data.ytdlinfo); return; } if (data.data) data.data = Buffer.from(data.data); broadcast.current.readable.push(data.data); }); broadcast.current.thread.on('done', function() { broadcast.current.thread.kill(); }); broadcast.current.thread.on('error', function(err) { self.error('Error in thread: ' + broadcast.current.song); console.log(err); if (broadcast.current.request) { broadcast.current.request.channel.send( '```An error occured while attempting to play ' + broadcast.current.song + '.```'); } broadcast.isLoading = false; skipSong(broadcast); }); } /** * Starts the streams as a thread and reports done with the streams. * * @private * @param {object} input Input vars. * @param {Function} done Done callback. * @param {Function} progress Progress callback. */ function startStream(input, done, progress) { let stream; if (input.special[input.song]) { stream = require('fs').createReadStream(input.special[input.song].file); } else { stream = require('youtube-dl')(input.song, input.ytdlOpts); stream.on('info', function(info) { progress({ytdlinfo: info}); }); // youtube-dl npm module emits `end` and not `close`. stream.on('end', function() { progress({data: null}); done(); }); } stream.on('data', function(chunk) { progress({data: chunk}); }); stream.on('close', function() { progress({data: null}); done(); }); } /** * Triggered when a song has finished playing. * * @private * @param {Music~Broadcast} broadcast The object storing all relevant * information. */ function endSong(broadcast) { if (broadcast.isLoading) return; if (broadcast.isPlaying) skipSong(broadcast); } /** * Skip the current song, then attempt to play the next. * * @private * @param {Music~Broadcast} broadcast The object storing all relevant * information. */ function skipSong(broadcast) { broadcast.isPlaying = false; startPlaying(broadcast); } /** * Skip the current song with the given context. * * @public * @param {Discord~Message} msg The context storing guild information for * looking up. */ this.skipSong = function(msg) { if (!broadcasts[msg.guild.id]) return; skipSong(broadcasts[msg.guild.id]); }; /** * Join a voice channel that the user is in. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#join */ function commandJoin(msg) { if (msg.member.voice.channel === null) { reply(msg, 'You aren\\'t in a voice channel!'); } else { msg.member.voice.channel.join().catch((err) =&gt; { reply(msg, 'I am unable to join your voice channel.', err.message); }); } } /** * Pause the currently playing music broadcast. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#pause */ function commandPause(msg) { if (!broadcasts[msg.guild.id]) { self.common.reply(msg, 'Nothing is playing!'); } else if (!broadcasts[msg.guild.id].dispatcher) { self.common.reply(msg, 'Nothing is playing!'); } else if ( broadcasts[msg.guild.id] &amp;&amp; broadcasts[msg.guild.id].subjugated) { reply(msg, 'Music is currently being controlled automatically.'); } else { if (pauseBroadcast(broadcasts[msg.guild.id])) { self.common.reply(msg, 'Music paused.'); } else { self.common.reply(msg, 'Music was already paused!'); } } } /** * Attempt to pause the current broadcast in a guild. * * @public * @param {Discord~Message} msg The context to lookup guild info. * @returns {boolean} True if success, false if failed. */ this.pause = function(msg) { return pauseBroadcast(broadcasts[msg.guild.id]); }; /** * Cause the given broadcast to be paused. * * @private * @param {Music~Broadcast} broadcast The object storing all relevant * information. * @returns {boolean} If the music was actully paused. False if the music is * already paused or nothing is playing. */ function pauseBroadcast(broadcast) { if (!broadcast) return false; if (!broadcast.broadcast) return false; if (!broadcast.broadcast.dispatcher) return false; if (!broadcast.broadcast.dispatcher.pause) return false; if (broadcast.broadcast.dispatcher.paused) return false; broadcast.broadcast.dispatcher.pause(true); return true; } /** * Resume the currently paused music broadcast. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#resume */ function commandResume(msg) { if (!broadcasts[msg.guild.id]) { self.common.reply(msg, 'Nothing is playing!'); } else if (!broadcasts[msg.guild.id].dispatcher) { self.common.reply(msg, 'Nothing is playing!'); } else if ( broadcasts[msg.guild.id] &amp;&amp; broadcasts[msg.guild.id].subjugated) { reply(msg, 'Music is currently being controlled automatically.'); } else { if (resumeBroadcast(broadcasts[msg.guild.id])) { self.common.reply(msg, 'Music resumed.'); } else { self.common.reply( msg, 'I am unable to resume. I need music to play to somebody.'); } } } /** * Attempt to resume the current broadcast in a guild. * * @public * @param {Discord~Message} msg The context to lookup guild info. * @returns {boolean} True if success, false if failed. */ this.resume = function(msg) { return resumeBroadcast(broadcasts[msg.guild.id]); }; /** * Cause the given broadcast to be resumed. * * @private * @param {Music~Broadcast} broadcast The object storing all relevant * information. * @returns {boolean} If the music was actully resumed. False if the music is * already playing or nothing is playing or the bot is alone in a channel. */ function resumeBroadcast(broadcast) { if (!broadcast) return false; if (!broadcast.broadcast) return false; if (!broadcast.broadcast.dispatcher) return false; if (!broadcast.broadcast.dispatcher.resume) return false; if (!broadcast.broadcast.dispatcher.paused) return false; if (!broadcast.voice || (broadcast.voice.channel.members.size === 1 &amp;&amp; broadcast.voice.channel.members.get(self.client.user.id))) { return false; } broadcast.broadcast.dispatcher.resume(); return true; } /** * Search for a song to play based off user request. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#play */ function commandPlay(msg) { if (broadcasts[msg.guild.id] &amp;&amp; broadcasts[msg.guild.id].subjugated) { reply(msg, 'Music is currently being controlled automatically.'); } else if (msg.member.voice.channel === null) { reply(msg, 'You aren\\'t in a voice channel!'); } else { let song = msg.text; let seek = 0; if (!song.startsWith(' ')) { reply(msg, 'Please specify a song to play.'); return; } else { seek = song.match(/&amp;&amp; seek\\D*(\\d+)\\D*$/); if (seek) seek = seek[1]; song = song.replace(/^\\s|\\s*&amp;&amp;\\s*seek.*$/g, ''); } self.playSong(msg, song, seek); } } /** * Start playing or enqueue the requested song. * * @public * @param {Discord~Message} msg The message that triggered command, used for * context. * @param {string} song The song search criteria. * @param {number} [seek] The time in seconds to seek to. * @param {?boolean} [subjugate] Force all control be via external sources * using public function calls. All queue control commands are disabled. Also * suppresses most information messages that would otherwise be sent to the * user. Null means leave as current value. */ this.playSong = function(msg, song, seek, subjugate) { if (!broadcasts[msg.guild.id]) { if (!subjugate) { self.common.reply(msg, 'Loading ' + song + '\\nPlease wait...') .then((msg) =&gt; msg.delete({timeout: 10000})); } broadcasts[msg.guild.id] = { queue: [], skips: {}, isPlaying: false, subjugated: subjugate || false, }; enqueueSong(broadcasts[msg.guild.id], song, msg, null, seek); } else { if (subjugate != null) { broadcasts[msg.guild.id].subjugated = subjugate; } if (special[song]) { if (!broadcasts[msg.guild.id].subjugated) { const embed = new self.Discord.MessageEmbed(); embed.setTitle( 'Enqueuing ' + song + ' [' + (broadcasts[msg.guild.id].queue.length + 1) + ' in queue]'); embed.setColor([50, 200, 255]); msg.channel.send(mention(msg), embed); } enqueueSong(broadcasts[msg.guild.id], song, msg, null, seek); } else { let loadingMsg; if (!broadcasts[msg.guild.id].subjugated) { reply(msg, 'Loading ' + song + '\\nPlease wait...') .then((msg) =&gt; loadingMsg = msg); } ytdl.getInfo(song, ytdlOpts, (err, info) =&gt; { if (err) { self.error(err.message.split('\\n')[1]); reply( msg, 'Oops, something went wrong while searching for that song!', err.message.split('\\n')[1]); } else if (info._duration_raw === 0) { reply(msg, 'Sorry, but I can\\'t play live streams currently.'); } else { if (broadcasts[msg.guild.id] &amp;&amp; (broadcasts[msg.guild.id].isPlaying || broadcasts[msg.guild.id].subjugated)) { if (!broadcasts[msg.guild.id].subjugated) { const embed = formatSongInfo(info); embed.setTitle( 'Enqueuing ' + song + ' [' + (broadcasts[msg.guild.id].queue.length + 1) + ' in queue]'); msg.channel.send(mention(msg), embed); } enqueueSong(broadcasts[msg.guild.id], song, msg, info, seek); } } if (loadingMsg) loadingMsg.delete(); }); } } }; /** * Release subjugation. Does not modify any current queue or playing * information. * * @public * @param {Discord~Message} msg The context to lookup the information. */ this.release = function(msg) { if (broadcasts[msg.guild.id]) { broadcasts[msg.guild.id].subjugated = false; } }; /** * Begin subjugation. Does not modify any current queue or playing * information. * * @public * @param {Discord~Message} msg The context to lookup the information. */ this.subjugate = function(msg) { if (broadcasts[msg.guild.id]) { broadcasts[msg.guild.id].subjugated = true; } }; /** * Check if music is being subjugated by another script. * * @public * @param {Discord~Message} msg The context to lookup the information. * @returns {?boolean} Null if nothing is playing, true if subjugated, false * if not subjugated. */ this.isSubjugated = function(msg) { if (broadcasts[msg.guild.id]) { return broadcasts[msg.guild.id].subjugated; } else { return null; } }; /** * Cause the bot to leave the voice channel and stop playing music. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#leave * @listens Command#stop * @listens Command#stfu */ function commandLeave(msg) { if (msg.guild.me.voice.channel) { const followMsg = follows[msg.guild.id] ? 'No longer following &lt;@' + follows[msg.guild.id] + '&gt;' : null; delete follows[msg.guild.id]; msg.guild.me.voice.channel.leave(); reply(msg, 'Goodbye!', followMsg); } else { reply(msg, 'I\\'m not playing anything.'); } delete broadcasts[msg.guild.id]; } /** * Skip the currently playing song and continue to the next in the queue. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#skip */ function commandSkip(msg) { if (!broadcasts[msg.guild.id]) { reply(msg, 'I\\'m not playing anything, I can\\'t skip nothing!'); } else if ( broadcasts[msg.guild.id] &amp;&amp; broadcasts[msg.guild.id].subjugated) { reply(msg, 'Music is currently being controlled automatically.'); } else { reply(msg, 'Skipping current song...'); skipSong(broadcasts[msg.guild.id]); } } /** * Show the user what is in the queue. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#q * @listens Command#queue * @listens Command#playing */ function commandQueue(msg) { if (!broadcasts[msg.guild.id]) { reply( msg, 'I\\'m not playing anything. Use \"' + msg.prefix + 'play Kokomo\" to start playing something!'); } else if (msg.text.trim().match(/^clear|^empty|^reset/)) { commandClearQueue(msg); } else { let embed; if (broadcasts[msg.guild.id].current) { if (broadcasts[msg.guild.id].current.info) { embed = formatSongInfo( broadcasts[msg.guild.id].current.info, broadcasts[msg.guild.id].broadcast.dispatcher, broadcasts[msg.guild.id].current.seek); } else { embed = new self.Discord.MessageEmbed(); embed.setColor([50, 200, 255]); embed.setDescription(broadcasts[msg.guild.id].current.song); } embed.setTitle('Current Song Queue'); } else { embed = new self.Discord.MessageEmbed(); } if (broadcasts[msg.guild.id].queue.length &gt; 0) { let queueDuration = 0; let queueExact = true; const queueString = broadcasts[msg.guild.id] .queue .map(function(obj, index) { if (obj.info) { queueDuration += obj.info._duration_raw; return (index + 1) + ') ' + obj.info.title; } else { queueExact = false; return (index + 1) + ') ' + obj.song; } }) .join('\\n'); embed.addField( 'Queue [' + (queueExact ? '' : '&gt;') + formatPlaytime(queueDuration) + ']', queueString.substr(0, 1024)); } msg.channel.send(embed); } } /** * Removes all songs from the current queue except for the currently playing * song. * * @private * * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#clear * @listens Command#empty */ function commandClearQueue(msg) { if (broadcasts[msg.guild.id] &amp;&amp; broadcasts[msg.guild.id].subjugated) { reply(msg, 'Music is currently being controlled automatically.'); } else if (!broadcasts[msg.guild.id] || broadcasts[msg.guild.id].queue.length === 0) { reply( msg, 'The queue appears to be empty.\\nI can\\'t remove nothing ' + 'from nothing!'); } else { self.clearQueue(msg); reply(msg, 'All songs removed from queue.'); } } /** * Empty a guild's current music queue. * * @public * * @param {Discord~Message} msg The context for looking up the guild queue to * modify. */ this.clearQueue = function(msg) { if (!broadcasts[msg.guild.id]) return; broadcasts[msg.guild.id].queue = []; }; /** * Remove a song from the queue. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#remove * @listens Command#dequeue */ function commandRemove(msg) { if (broadcasts[msg.guild.id] &amp;&amp; broadcasts[msg.guild.id].subjugated) { reply(msg, 'Music is currently being controlled automatically.'); } else if (!broadcasts[msg.guild.id] || broadcasts[msg.guild.id].queue.length === 0) { reply( msg, 'The queue appears to be empty.\\nI can\\'t remove nothing ' + 'from nothing!'); } else { const indexString = msg.text; if (!indexString.startsWith(' ')) { reply( msg, 'You must specify the index of the song to dequeue, or \"all\".\\nYo' + 'u can view the queue with \"' + msg.prefix + 'queue\".'); } else { if (indexString.trim().match(/^all|^everything/)) { commandClearQueue(msg); return; } const index = Number(indexString.replace(' ', '')); if (typeof index !== 'number' || index &lt;= 0 || index &gt; broadcasts[msg.guild.id].queue.length) { reply(msg, 'That is not a valid index!'); } else { const removed = broadcasts[msg.guild.id].queue.splice(index - 1, 1)[0]; reply(msg, 'Dequeued #' + index + ': ' + removed.info.title); } } } } /** * Search for a song's lyrics via Genius. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#lyrics */ function commandLyrics(msg) { let song = msg.text; if (song.length &lt;= 1) { reply(msg, 'Please specify a song.'); return; } song = song.replace(' ', ''); const thisReq = geniusRequest; thisReq.path = '/search?q=' + encodeURIComponent(song); const req = https.request(thisReq, function(response) { let content = ''; response.on('data', function(chunk) { content += chunk; }); response.on('end', function() { if (response.statusCode == 200) { const parsed = JSON.parse(content); if (parsed.response.hits.length === 0) { reply(msg, '`Failed to find lyrics. No matches found.`'); } else { reqLyricsURL(msg, parsed.response.hits[0].result.id); } } else { msg.channel.send( response.statusCode + '```json\\n' + JSON.stringify(response.headers, null, 2) + '```\\n```html\\n' + content + '\\n```'); } }); response.on('close', function() { self.warn('Genius request closed! ' + content.length); }); response.on('error', function() { self.warn('Genius request errored! ' + content.length); }); }); req.end(); req.on('error', function(e) { self.error(e); }); msg.channel.send('`Loading...`').then((msg) =&gt; { msg.delete(30000); }); } /** * Request the song information from Genius from previous search to find the * page where the lyrics are. * * @private * @param {Discord~Message} msg The message that triggered the command. * @param {string} id The id of the first song in the search results. */ function reqLyricsURL(msg, id) { const thisReq = geniusRequest; thisReq.path = '/songs/' + id + '?text_format=plain'; const req = https.request(thisReq, function(response) { let content = ''; response.on('data', function(chunk) { content += chunk; }); response.on('end', function() { if (response.statusCode == 200) { const parsed = JSON.parse(content); fetchLyricsPage( msg, parsed.response.song.url, parsed.response.song.full_title, parsed.response.song.song_art_image_thumbnail_url); } else { msg.channel.send( response.statusCode + '```json\\n' + JSON.stringify(response.headers, null, 2) + '```\\n```html\\n' + content + '\\n```'); } }); response.on('close', function() { self.warn('Genius request closed! ' + content.length); }); response.on('error', function() { self.warn('Genius request errored! ' + content.length); }); }); req.end(); req.on('error', function(e) { self.error(e); }); } /** * Request the webpage that has the song lyrics on them from Genius. * * @private * @param {Discord~Message} msg The message that triggered the command. * @param {string} url The url of the page to request. * @param {string} title The song title for showing the user later. * @param {string} thumb The url of the album art thumbnail to show the user * later. */ function fetchLyricsPage(msg, url, title, thumb) { const URL = url.match(/https:\\/\\/([^/]*)(.*)/); const thisReq = {hostname: URL[1], path: URL[2], method: 'GET'}; const req = https.request(thisReq, function(response) { let content = ''; response.on('data', function(chunk) { content += chunk; }); response.on('end', function() { if (response.statusCode == 200) { stripLyrics(msg, content, title, url, thumb); } else { msg.channel.send( response.statusCode + '```json\\n' + JSON.stringify(response.headers, null, 2) + '```\\n```html\\n' + content + '\\n```'); } }); response.on('close', function() { self.warn('Genius request closed! ' + content.length); }); response.on('error', function() { self.warn('Genius request errored! ' + content.length); }); }); req.end(); req.on('error', function(e) { self.error(e); }); } /** * Crawl the received webpage for the data we need, then format the data and * show it to the user. * * @private * @param {Discord~Message} msg The message that triggered the command. * @param {string} content The entire page received. * @param {string} title The song title for showing the user. * @param {string} url The url of where we fetched the lyrics to show the * user. * @param {string} thumb The url of the album art thumbnail to show the user * later. */ function stripLyrics(msg, content, title, url, thumb) { try { const body = content.match(/&lt;!--sse--&gt;([\\s\\S]*?)&lt;!--\\/sse--&gt;/gm)[1]; const lyrics = []; let matches = []; const regex = /&lt;a[^&gt;]*&gt;([^&lt;]*)&lt;\\/a&gt;/gm; while (matches = regex.exec(body)) { lyrics.push(matches[1]); } const splitLyrics = lyrics.join('\\n').match(/(\\[[^\\]]*\\][^[]*)/gm).slice(1); const embed = new self.Discord.MessageEmbed(); if (title) embed.setTitle(title); if (url) embed.setURL(url); if (thumb) embed.setThumbnail(thumb); let numFields = 0; for (let i = 0; numFields &lt; 25 &amp;&amp; i &lt; splitLyrics.length; i++) { const splitLine = splitLyrics[i].match(/\\[([^\\]]*)\\]\\n([^]*)/m); if (!splitLine) continue; const secTitle = splitLine[1].substr(0, 256); const secBody = splitLine[2]; for (let j = 0; numFields &lt; 25 &amp;&amp; j * 1024 &lt; secBody.length; j++) { embed.addField( j === 0 ? secTitle : (secTitle + ' continued...').substr(0, 256), secBody.substr(j * 1024, 1024) || '\\u200B', true); numFields++; } } embed.setColor([0, 255, 255]); msg.channel.send(embed).catch((err) =&gt; { console.log(err); msg.channel.send( '`Something went wrong while formatting the lyrics.' + '\\nHere is the link to the page I found:`\\n' + url); }); } catch (err) { console.log(err); msg.channel.send( '`Something went wrong while formatting the lyrics.' + '\\nHere is the link to the page I found:`\\n' + url); } } /** * Join a voice channel and record the specified users audio to a file on this * server. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered the command. * @listens Command#record */ function commandRecord(msg) { if (msg.member.voice.channel === null) { reply(msg, 'You aren\\'t in a voice channel!'); return; } const filename = 'recordings/' + encodeURIComponent( msg.member.voice.channel.id + '_' + formatDateTime(Date.now())) + '.ogg'; const url = self.common.webURL + filename; if (msg.mentions.users.size === 0) { reply( msg, 'Recording everyone in voice channel. Type ' + msg.prefix + 'stop to stop', url); } else { reply( msg, 'Only recording ' + msg.mentions.users .map(function(obj) { return '`' + obj.username.replaceAll('`', '\\\\`') + '`'; }) .join(', '), url); } const streams = {}; const file = fs.createWriteStream(filename); file.on('close', () =&gt; { msg.channel.send('Saved to ' + url); }); const listen = function(user, receiver /* , conn*/) { if (streams[user.id] || (msg.mentions.users.size &gt; 0 &amp;&amp; !msg.mentions.users.get(user.id))) { return; } const stream = receiver.createStream(msg.author, {end: 'manual', mode: 'pcm'}); streams[user.id] = stream; // stream.pipe(file); Music.streamToOgg(stream, file); /* conn.on('disconnect', () =&gt; { stream.destroy(); }); */ }; msg.member.voice.channel.join() .then((conn) =&gt; { // Timeout and sound are due to current Discord bug requiring bot to // play sound for 0.1s before being able to receive audio. conn.play('./sounds/plink.ogg'); self.client.setTimeout(() =&gt; { const receiver = conn.receiver; msg.member.voice.channel.members.forEach(function(member) { listen(member.user, receiver, conn); }); conn.on('speaking', (user, speaking) =&gt; { if (speaking) { listen(user, receiver, conn); } }); }, 100); }) .catch((err) =&gt; { reply(msg, 'I am unable to join your voice channel.', err.message); }); } /** * Follow a user as they change voice channels. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#join */ function commandFollow(msg) { if (msg.mentions.users.size &gt; 0) { const targetMember = msg.mentions.members.first(); const target = targetMember.id; if (follows[msg.guild.id]) { if (follows[msg.guild.id] === target) { delete follows[msg.guild.id]; self.common.reply( msg, 'I will no longer follow ' + targetMember.user.username + ' to new voice channels.'); if (targetMember.voice.channel) { targetMember.voice.channel.join().catch(() =&gt; {}); } } else { self.common.reply( msg, 'I will follow ' + targetMember.user.username + ' into new voice channels.\\nType ' + self.bot.getPrefix(msg.guild.id) + 'follow to make me stop following you.', 'I will no longer follow &lt;@' + follows[msg.guild.id] + '&gt;'); follows[msg.guild.id] = target; } } else { follows[msg.guild.id] = target; self.common.reply( msg, 'When ' + targetMember.user.username + ' changes voice channels, I will follow them and continue ' + 'playing music.\\nType ' + self.bot.getPrefix(msg.guild.id) + 'follow to make me stop following you.'); if (targetMember.voice.channel) { targetMember.voice.channel.join().catch(() =&gt; {}); } } return; } if (follows[msg.guild.id]) { if (follows[msg.guild.id] == msg.member.id) { delete follows[msg.guild.id]; self.common.reply( msg, 'I will no longer follow you to new voice channels.'); if (msg.member.voice.channel) { msg.member.voice.channel.join().catch(() =&gt; {}); } } else { self.common.reply( msg, 'I will follow you into new voice channels.\\nType ' + self.bot.getPrefix(msg.guild.id) + 'follow to make me stop following you.', 'I will no longer follow &lt;@' + follows[msg.guild.id] + '&gt;'); follows[msg.guild.id] = msg.author.id; } } else { follows[msg.guild.id] = msg.member.id; self.common.reply( msg, 'When you change voice channels, I will follow you and continue ' + 'playing music.\\nType ' + self.bot.getPrefix(msg.guild.id) + 'follow to make me stop following you.'); if (msg.member.voice.channel) { msg.member.voice.channel.join().catch(() =&gt; {}); } } } /** * Formats a given date into a datestring. * * @private * @param {?Date|number|string} date The date that Date() can accept. * @returns {string} The formatted datetime. */ function formatDateTime(date) { const d = new Date(date); return monthToShort(d.getUTCMonth()) + '-' + d.getUTCDate() + '-' + d.getUTCFullYear() + '_at_' + d.getUTCHours() + '-' + ('0' + d.getUTCMinutes()).slice(-2) + '-' + ('0' + d.getUTCSeconds()).slice(-2) + '_UTC'; } /** * Convert the month number to a 3 letter string of the month's name. * * @private * @param {number} month The month number (1-12). * @returns {string} The 3 character string. */ function monthToShort(month) { return [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', ][month]; } /** * Show statistics about current music broadcasts. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#musicstats */ function commandStats(msg) { let queueLength = 0; const bList = Object.entries(broadcasts); let longestChannel; let isPaused; let pauseTime; bList.forEach((el) =&gt; { let qDuration = 0; if (el[1].current &amp;&amp; el[1].current.info) { qDuration += el[1].current.info._duration_raw - Math.round( (el[1].broadcast.dispatcher.streamTime - el[1].broadcast.dispatcher.pausedTime) / 1000); } el[1].queue.forEach((q) =&gt; { if (!q.info) return; qDuration += q.info._duration_raw; }); if (qDuration &gt; queueLength) { queueLength = qDuration; isPaused = el[1].broadcast.dispatcher.paused; pauseTime = el[1].broadcast.dispatcher.pausedTime; longestChannel = el[1].voice.channel.id; } }); if (queueLength) { self.common.reply( msg, 'I am currently playing music for ' + bList.length + ' channels.\\nThe longest queue has a length of ' + formatPlaytime(queueLength) + (isPaused ? ' (paused)' : '') + '.', msg.author.id === self.common.spikeyId ? (longestChannel + ' paused for ' + pauseTime + '(' + formatPlaytime(pauseTime) + ')') : null); } else { self.common.reply( msg, 'I am currently playing music for ' + bList.length + ' channels.'); } } /** * Change the volume of the current music stream. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#volume * @listens Command#vol * @listens Command#v */ function commandVolume(msg) { if (!broadcasts[msg.guild.id]) { self.common.reply(msg, 'Nothing is playing!'); } else if (!msg.text) { self.common.reply( msg, 'Volume is at ' + (getVolume(broadcasts[msg.guild.id]) * 100) + '%', 'Specify a percentage to change the volume.'); } else { let newVol = msg.text.match(/[0-9]*\\.?[0-9]+/); if (!newVol) { self.common.reply( msg, 'Sorry, but I wasn\\'t sure what volume to set to that.'); } else { if ((newVol + '').indexOf('.') &lt; 0) { newVol /= 100; } if (changeVolume(broadcasts[msg.guild.id], newVol)) { self.common.reply(msg, 'Changed volume to ' + (newVol * 100) + '%.'); } else { self.common.reply( msg, 'Oops! I wasn\\'t able to change the volume to ' + (newVol * 100) + '%.'); } } } } /** * Change the volume of the current broadcast. * * @private * @param {Music~Broadcast} broadcast The objected storing the current * broadcast information. * @param {number} percentage The volume percentage to set to. 0.5 is half, 2 * is double. * @returns {boolean} True if success, false if something went wrong. */ function changeVolume(broadcast, percentage) { if (!broadcast) return false; if (!broadcast.broadcast) return false; if (!broadcast.broadcast.dispatcher) return false; if (!broadcast.broadcast.dispatcher.setVolume) return false; try { broadcast.broadcast.dispatcher.setVolumeLogarithmic(percentage); } catch (err) { self.error('Failed to change volume to ' + percentage); console.error(err); return false; } return true; } /** * Get the volume of the current broadcast. * * @private * @param {Music~Broadcast} broadcast The objected storing the current * broadcast information. * @returns {?number} The logarithmic volume percentage. 0.5 is half, 2 is * double. Null if error. */ function getVolume(broadcast) { if (!broadcast) return null; if (!broadcast.broadcast) return null; if (!broadcast.broadcast.dispatcher) return null; return broadcast.broadcast.dispatcher.volumeLogarithmic; } } /** * Coverts an incoming Opus stream to a ogg format and writes it to file. * * @param {ReadableStream} input The opus stream from Discord. * @param {WritableStream} file The file stream we are writing to. */ Music.streamToOgg = function(input, file) { const opusEncoder = new opus.Encoder(); const oggEncoder = new ogg.Encoder(); input.pipe(opusEncoder).pipe(oggEncoder.stream()); oggEncoder.pipe(file); }; module.exports = new Music(); × Search results Close "},"patreon.js.html":{"id":"patreon.js.html","title":"Source: patreon.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: patreon.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); require('./subModule.js').extend(Patreon); // Extends the SubModule class. /** * @classdesc Modifies the SpikeyBot object with an interface for checking the * Patreon status of users. * @class * @augments SubModule * @listens Command#patreon */ function Patreon() { const self = this; /** @inheritdoc */ this.myName = 'Patreon'; /** @inheritdoc */ this.helpMessage = null; /** * The filename in the user's directory of the file where the settings related * to Patreon rewards are stored. * * @private * @constant * @default * @type {string} */ const patreonSettingsFilename = '/patreonSettings.json'; /** * Path to the file storing information about each patron tier rewards. * * @private * @constant * @default * @type {string} */ const patreonTierPermFile = './save/patreonTiers.json'; /** * The parsed data from file about patron tier rewards. * @see {@link Patreon~patreonTierPermFile} * * @private * @default * @type {Array.&lt;{0: number, 1: string[]}&gt;} */ let patreonTiers = {}; /** * File where the template for the Patreon settings is stored. * @see {@link Patreon~patreonSettingsTemplate} * @see {@link WebAccount~patreonSettingsTemplate} * * @private * @constant * @default * @type {string} */ const patreonSettingsTemplateFile = './save/patreonSettingTemplate.json'; /** * The parsed data from {@link Patreon~patreonSettingsTemplateFile}. Data * that outlines the available options that can be changed, and their possible * values. * @private * * @default * @type {Object.&lt;Object&gt;} */ let patreonSettingsTemplate = {}; /** * Parse tiers from file. * * @see {@link Patreon~patreonTierPermFile} * @private */ function updateTierPerms() { fs.readFile(patreonTierPermFile, (err, data) =&gt; { if (err) { self.error('Failed to read ' + patreonTierPermFile); return; } try { const parsed = JSON.parse(data); if (!parsed) return; patreonTiers = Object.entries(parsed); } catch (e) { console.error(e); } }); } updateTierPerms(); fs.watchFile(patreonTierPermFile, (curr, prev) =&gt; { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.debug('Re-reading Patreon tier reward information from file'); } else { console.log('Patreon: Re-reading tier reward information from file'); } updateTierPerms(); }); /** * Parse template from file. * * @see {@link Patreon~patreonSettingsTemplate} * @private */ function updatePatreonSettingsTemplate() { fs.readFile(patreonSettingsTemplateFile, (err, data) =&gt; { if (err) { self.error('Failed to read ' + patreonSettingsTemplateFile); return; } try { const parsed = JSON.parse(data); if (!parsed) return; patreonSettingsTemplate = parsed; } catch (e) { self.error('Failed to parse ' + patreonSettingsTemplateFile); console.error(e); } }); } updatePatreonSettingsTemplate(); fs.watchFile(patreonSettingsTemplateFile, (curr, prev) =&gt; { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.debug('Re-reading Patreon setting template information from file'); } else { console.log('Patreon: Re-reading setting template information from file'); } updatePatreonSettingsTemplate(); }); /** @inheritdoc */ this.initialize = function() { self.bot.patreon = toExport; self.command.on('patreon', commandPatreon); self.common.connectSQL(); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('patreon'); fs.unwatchFile(patreonTierPermFile); fs.unwatchFile(patreonSettingsTemplateFile); }; /** * Shows the user's Patreon information to the user. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#patreon */ function commandPatreon(msg) { /** * Verifies that valid data was found, then fetches all permissions for the * user's pledge amount. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: object, message: string}} data The returned data if * there was no error. */ function getPerms(err, data) { if (err) { if (err.startsWith('User has not connected')) { self.common.reply( msg, 'If you love SpikeyBot and wish to support SpikeyRobot, please ' + 'consider becoming a patron on Patreon!\\npatreon.com/Campbe' + 'llCrowley\\n\\nIf you have already pledged, be sure to link ' + 'your accounts in order to receive your rewards.\\nspikeybot' + '.com/account', 'https://www.patreon.com/campbellcrowley\\nhttps://www.spikeybot' + '.com/account/'); } else if (err.startsWith('User has never pledged')) { self.common.reply( msg, 'You currently have not pledged anything on Patreon.\\nIf you lo' + 've SpikeyBot, or wish to receive the perks of becoming a p' + 'atron, please consider supporting SpikeyRobot on Patreon.', 'https://www.patreon.com/campbellcrowley'); return; } else { self.common.reply( msg, 'Oops! Something went wrong while fetching your Patreon ' + 'information!', err); } return; } const pledgeAmount = data.status.pledge; if (!pledgeAmount || isNaN(Number(pledgeAmount))) { self.common.reply( msg, 'You currently have not pledged anything on Patreon.\\nIf you ' + 'love SpikeyBot, or wish to receive the perks of becoming a ' + 'patron, please consider supporting SpikeyRobot on Patreon.', 'https://www.patreon.com/campbellcrowley'); return; } toExport.getLevelPerms(pledgeAmount, false, onGetPerms); } /** * Verifies that valid data was found, then fetches all permissions for the * user's pledge amount. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: string[], message: string}} data The returned data if * there was no error. */ function onGetPerms(err, data) { if (err) { self.common.reply( msg, 'Oops! Something went wrong while fetching reward information!', err); return; } const permString = data.status.join(', '); self.common.reply( msg, 'Thank you for supporting SpikeyRobot!\\n' + 'Here are your current rewards: ' + permString, 'https://www.patreon.com/campbellcrowley'); } fetchPatreonRow(msg.author.id, getPerms); } /** * Basic callback function that has two parameters. One with error * information, and the other with data if there was no error. * @callback Patreon~basicCB * @param {?string} err The error string, or null if no error. * @param {?{status: *, message: string}} data The returned data if there was * no error. */ /** * @classdesc The object to put into the {@link SpikeyBot} object. This * contains all of the public data available through that interface. Data will * be available after {@link Patreon.initialize} has been called, at * `SpikeyBot.patreon`. * @class */ function toExport() {} /** * Check that a user or channel or guild has permission for something. Checks * overrides for each, and if the user does not have an override, the request * is forwarded to {@link toExport.checkPerm}. * * @public * * @param {?string|number} uId The Discord user ID to check. * @param {?string|number} cId The Discord channel ID to check. * @param {?string|number} gId The Discord guild ID to check. * @param {?string} perm The permission string to check against. Null to check * for overrides only. * @param {Patreon~basicCB} cb Callback with parameters for error and success * values. * @param {boolean} cb.data.status If the given IDs have permission. */ toExport.checkAllPerms = function(uId, cId, gId, perm, cb) { switch (gId) { case '318603252675379210': // Games cb(null, {status: true, message: 'Guild has override.'}); return; } switch (cId) { case '420045412679024660': // #bottesting cb(null, {status: true, message: 'Channel has override.'}); return; } switch (uId) { case self.common.spikeyId: case '126464376059330562': // Rohan case '284034290574950410': // Jenna cb(null, {status: true, message: 'User has override.'}); return; } if (uId &amp;&amp; perm) { toExport.checkPerm(uId, perm, cb); } else { cb(null, {status: false, message: 'User does not have permission.'}); } }; /** * Fetch all permissions for a given user, channel, or guild. * * @public * @param {?string|number} uId The ID of the Discord user. * @param {?string|number} cId The Discord channel ID. * @param {?string|number} gId The Discord guild ID. * @param {Patreon~basicCB} cb Callback once operation is complete. */ toExport.getAllPerms = function(uId, cId, gId, cb) { toExport.checkAllPerms(uId, cId, gId, null, onGetOverrides); /** * Handle response from checking IDs for overrides. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: boolean, message: string}} info The returned data if * there was no error. */ function onGetOverrides(err, info) { if (info.status) { getPerms( null, {status: {pledge: Number.MAX_SAFE_INTEGER}, message: info.message}); } else { fetchPatreonRow(uId, getPerms); } } /** * Verifies that valid data was found, then fetches all permissions for the * user's pledge amount. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: object, message: string}} data The returned data if * there was no error. */ function getPerms(err, data) { if (err) { cb(err, null); return; } const pledgeAmount = data.status.pledge; if (!pledgeAmount || isNaN(Number(pledgeAmount))) { cb('User is not pledged', null); return; } toExport.getLevelPerms(pledgeAmount, false, onGetPerms); } /** * Verifies that valid data was found, then fetches all permissions for the * user's pledge amount. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: string[], message: string}} data The returned data if * there was no error. */ function onGetPerms(err, data) { if (err) { cb(err, null); return; } cb(null, data); } }; /** * Check that a user has a specific permission. Permissions are defined in * {@link Patreon~patreonTierPermFile}. This does not check overrides. * * @public * * @param {string|number} uId The Discord user ID to check. * @param {string} perm The permission string to check against. * @param {Patreon~basicCB} cb Callback with parameters for error and success * values. * @param {boolean} cb.data.status If the user has permission. */ toExport.checkPerm = function(uId, perm, cb) { /** * Checks the received data from the Patreon table against the given perm * string. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: object, message: string}} data The returned data if * there was no error. */ function checkPerm(err, data) { if (err) { cb(err, data); return; } const pledgeAmount = data.status.pledge; if (!pledgeAmount || isNaN(Number(pledgeAmount))) { cb(null, {status: false, message: 'User is not currently pledged.'}); return; } if (!perm) { cb(null, {status: true, message: 'User is patron.'}); return; } for (let i = 0; i &lt; patreonTiers.length; i++) { for (let j = 0; j &lt; patreonTiers[i][1].length; j++) { if (patreonTiers[i][1][j] == perm) { if (patreonTiers[i][0] &lt;= pledgeAmount) { cb(null, {status: true, message: 'User has permission.'}); return; } } } } cb(null, {status: false, message: 'User does not have permission.'}); } fetchPatreonRow(uId, checkPerm); }; /** * Responds with all permissions available at the given pledge amount. * * @public * * @param {number} pledgeAmount The amount in cents that the user has pledged. * @param {boolean} exclusive Only get the rewards received at the exact * pledge amount. Does not show all tier rewards below the pledge amount. * @param {Patreon~basicCB} cb Callback with parameters for error and success * values. * @param {string[]} cb.data.status All of the permission strings. */ toExport.getLevelPerms = function(pledgeAmount, exclusive, cb) { let output = []; for (let i = 0; i &lt; patreonTiers.length; i++) { if (patreonTiers[i][0] &lt;= pledgeAmount) { if (exclusive &amp;&amp; patreonTiers[i][0] != pledgeAmount) continue; output = output.concat(patreonTiers[i][1]); } } cb(null, {status: output, message: 'Success'}); }; /** * Responds with the settings value for a user if they have permission for the * setting, otherwise replies with the default value. * * @public * * @param {?number|string} uId The user id to check, or null to get the * default value. * @param {?number|string} cId The Discord channel id to check, or null to get * the default value. * @param {?number|string} gId The Discord guild id to check, or null to get * the default value. * @param {string} permString The permission to check with subvalues separated * by spaces. * @param {Patreon~basicCB} cb Callback with parameters for error and success * values. * @param {*} cb.data.status The setting's value. */ toExport.getSettingValue = function(uId, cId, gId, permString, cb) { const permVals = permString.split(' '); const perm = permVals[0]; if (!patreonSettingsTemplate[perm]) { cb('Invalid Permission', null); return; } toExport.checkAllPerms(uId, cId, gId, perm, onCheckPerm); /** * After check for user perms, this will fetch either the default value, or * the user's custom setting. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: boolean, message: string}} info The returned data if * there was no error. */ function onCheckPerm(err, info) { if (err || !info.status) { fetchValue(patreonSettingsTemplate, permVals.concat(['default']), cb); } else { fs.readFile( self.common.userSaveDir + uId + patreonSettingsFilename, (err, data) =&gt; { let parsed = {}; if (!err) { try { parsed = JSON.parse(data); } catch (e) { self.error( 'Failed to parse user settings file: ' + uId + patreonSettingsFilename); console.error(e); cb('Internal Error', null); return; } } fetchValue(parsed, permVals, onFetchedValue); }); } } /** * Searches an object for the given key values. * * @private * @param {object} obj The object to traverse. * @param {string[]} keys The keys to step through. * @param {Patreon~basicCB} myCb The callback with the final value. */ function fetchValue(obj, keys, myCb) { if (keys.length == 1) { myCb(null, {status: obj[keys[0]], message: 'Success'}); return; } else if (typeof obj[keys[0]] === 'undefined') { myCb('Invalid Setting: ' + keys[1], null); return; } else { fetchValue(obj[keys[0]], keys.slice(1), myCb); } } /** * After a user's setting value has been fetched, check if it has been * set, if not then return the default. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: *, message: string}} info The returned data if * there was no error. */ function onFetchedValue(err, info) { if (err || typeof info.status === 'undefined') { onCheckPerm(null, {status: null, message: 'User value unset'}); } else { cb(null, info); } } }; /** * Get the Patreon information for a given Discord user. * * @private * @param {string|number} uId The Discord user ID to check. * @param {Patreon~basicCB} cb Callback with parameters for error and success * values. * @param {?object} cb.data.status A single row if it was found. */ function fetchPatreonRow(uId, cb) { /** * SQL query response callback for request to the Discord table. * * @private * @param {Error} err Errors during the query. * @param {Array} rows The results of the query. */ function receivedDiscordRow(err, rows) { if (err) { /* self.error('Failed to lookup user in Discord: ' + uId); console.error(err); */ cb('Failed to find user in database.', null); return; } if (!rows || rows.length != 1) { cb('User has not connected their Patreon ' + 'account to their Discord account.', null); return; } const user = rows[0]; if (!user.patreonId) { cb('User has not connected their Patreon ' + 'account to their Discord account.', null); return; } const toSend = global.sqlCon.format( 'SELECT * FROM Patreon WHERE id=? LIMIT 1', [user.patreonId]); global.sqlCon.query(toSend, receivedPatreonRow); } /** * SQL query response callback for request to the Patreon table. * * @private * @param {Error} err Errors during the query. * @param {Array} rows The results of the query. */ function receivedPatreonRow(err, rows) { if (err) { self.error('Failed to lookup user in Patreon: ' + uId); console.error(err); cb('Failed to find user in database.', null); return; } if (!rows || rows.length != 1) { cb('User has never pledged.', null); return; } cb(null, {status: rows[0], message: 'Success'}); } const toSend = global.sqlCon.format('SELECT * FROM Discord WHERE id=? LIMIT 1', [uId]); global.sqlCon.query(toSend, receivedDiscordRow); } } module.exports = new Patreon(); × Search results Close "},"poll.js.html":{"id":"poll.js.html","title":"Source: poll.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: poll.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const emojiChecker = require('./lib/twemojiChcker.js'); const fs = require('fs'); const mkdirp = require('mkdirp'); const rimraf = require('rimraf'); require('./subModule.js').extend(Polling); // Extends the SubModule class. /** * @classdesc Controlls poll and vote commands. * @class * @augments SubModule * @listens Command#poll * @listens Command#vote * @listens Command#endpoll * @listens Command#endvote */ function Polling() { const self = this; /** @inheritdoc */ this.myName = 'Polling'; /** @inheritdoc */ this.helpMessage = null; /** @inheritdoc */ this.initialize = function() { self.command.on(['poll', 'vote'], commandPoll, true); self.command.on(['endpoll', 'endvote'], commandEndPoll, true); self.client.guilds.forEach((g) =&gt; { const dir = self.common.guildSaveDir + g.id + guildSubDir; fs.readdir(dir, (err, files) =&gt; { if (err &amp;&amp; err.code != 'ENOENT') { self.error('Failed to read directory: ' + dir); console.error(err); return; } else if (err) { return; } files.forEach((folder) =&gt; { fs.readFile(dir + folder + saveFilename, (err, data) =&gt; { if (err) { self.error('Failed to read file: ' + dir + folder + saveFilename); console.error(err); return; } parsePollString(data); }); }); }); }); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('poll'); self.command.deleteEvent('endpoll'); Object.entries(currentPolls).forEach((p) =&gt; { if (p[1].timeout) self.client.clearTimeout(p[1].timeout); }); }; /** @inheritdoc */ this.save = function(opt) { self.client.guilds.forEach((g) =&gt; { const dir = self.common.guildSaveDir + g.id + guildSubDir; if (opt == 'async') { rimraf(dir, (err) =&gt; { if (err) { self.error('Failed to clean old polls for guild: ' + g.id); console.error(err); } }); } else { try { rimraf.sync(dir); } catch (err) { self.error('Failed to clean old polls for guild: ' + g.id); console.error(err); } } }); const polls = Object.entries(currentPolls); for (let i = 0; i &lt; polls.length; i++) { const dir = self.common.guildSaveDir + polls[i][1].message.guild.id + guildSubDir + polls[i][1].author; const filename = saveFilename; const temp = Object.assign({}, polls[i][1]); temp.message = { channel: temp.message.channel.id, message: temp.message.id, }; delete temp.timeout; const pollString = JSON.stringify(temp); if (opt === 'async') { mkdirAndWrite(dir, filename, pollString); } else { mkdirAndWriteSync(dir, filename, pollString); } } }; /** * Parse the saved poll data that has been read from file in JSON format. * * @private * @param {string} string The file data. */ function parsePollString(string) { let parsed; try { parsed = JSON.parse(string); } catch (err) { self.error('Failed to parse poll data'); console.error(err); return; } const channel = self.client.channels.get(parsed.message.channel); if (!channel) { self.error('Failed to find channel: ' + parsed.message.channel); return; } channel.messages.fetch(parsed.message.message) .then((message) =&gt; { const poll = (currentPolls[parsed.message.message] = new Poll(parsed.author, message, parsed)); addListenersToPoll(poll, parsed.message.message); }) .catch((err) =&gt; { self.error( 'Failed to find message: ' + parsed.message.message + ' in ' + parsed.message.channel); console.error(err); }); } /** * Asyncronously create a directory and write a file in the directory. * * @private * @param {string} dir The file path to create and write the file to. * @param {string} filename The file name of the file without the path. * @param {string} data The data to write to the tile. */ function mkdirAndWrite(dir, filename, data) { mkdirp(dir, (err) =&gt; { if (err) { self.error('Failed to mkdirp: ' + dir); console.error(err); return; } fs.writeFileSync(dir + filename, data, (err) =&gt; { if (err) { self.error('Failed to write: ' + dir + filename); console.error(err); return; } }); }); } /** * Syncronously create a directory and write a file in the directory. * * @private * @param {string} dir The file path to create and write the file to. * @param {string} filename The file name of the file without the path. * @param {string} data The data to write to the tile. */ function mkdirAndWriteSync(dir, filename, data) { try { mkdirp.sync(dir); } catch (err) { self.error('Failed to mkdirp: ' + dir); console.error(err); return; } try { fs.writeFileSync(dir + filename, data); } catch (err) { self.error('Failed to write: ' + dir + filename); console.error(err); return; } } /** * The subdirectory in the guild to store all member polls. * @private * @constant * @default */ const guildSubDir = '/polls/'; /** * The filename in the member's subdirectory, in the guild's subdirectory, to * save a poll's state. * @private * @constant * @default */ const saveFilename = '/save.json'; /** * The default reaction emojis to use for a poll. * @private * @default * @constant */ const defaultEmojis = ['👍', '👎', '🤷']; /** * Stores the currently cached data about all active polls. Organized by * message id that is collecting the poll data. * * @private * @type {Object.&lt;Polling~Poll&gt;} */ const currentPolls = {}; /** * @classdesc Stores data related to a single poll. * @class * @private * * @param {string} author ID of the user who started this poll. * @param {Discord~Message} message The message to watch for the results. * @param {Polling~PollOptions} options The settings for this current poll. * @property {string} author ID of the user who started this poll. * @property {Discord~Message} message Reference to the Message object with * the reaction listener. * @property {string} title The user defined text associated with this poll. * @property {?number} endTime The timestamp at which this poll is scheduled * to end. * @property {string[]} emojis The emojis to add as reactions to use as * buttons. * @property {string[]} choices The full string that came with the emoji if * the user specified custom response options. * @property {string[]} timeout The scheduled timeout when this poll will end. */ function Poll(author, message, options) { /** * ID of the user who started this poll. * @public * @type {string} */ this.author = author; /** * Reference to the Message object with the reaction listener. * @public * @type {Discord~Message} */ this.message = message; /** * The user defined text associated with this poll. * @public * @type {string} */ this.title = options.title; /** * The timestamp at which this poll is scheduled to end. * @public * @type {?number} */ this.endTime = options.endTime; /** * The emojis to add as reactions to use as buttons. * @public * @type {string[]} */ this.emojis = options.emojis; /** * The full string that came with the emoji if the user specified custom * response options. * @public * @type {string[]} */ this.choices = options.choices || options.emojis; /** * The scheduled timeout when this poll will end. * @public * @type {?Timeout} */ this.timeout = null; } /** * Starts a poll. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#poll * @listens Command#vote */ function commandPoll(msg) { if (Object.values(currentPolls).find((obj) =&gt; { return obj.author === msg.author.id &amp;&amp; obj.message.guild.id === msg.guild.id; })) { self.common.reply( msg, 'Sorry, you may only have one poll per server at a time.\\nType ' + self.bot.getPrefix(msg.guild.id) + 'endpoll to end your current poll.'); return; } const choicesMatch = msg.text.match(/\\[[^\\]]*\\]/g); let textString = msg.text; if (choicesMatch) { choicesMatch.forEach((el) =&gt; { textString = textString.replace(el, ''); }); } textString = textString.trim(); const durationMatch = textString.match(/^(\\d+)(\\w)(.*)/); let duration = 0; let timeUnit = 'infinite'; let emojis = defaultEmojis; if (durationMatch) { switch (durationMatch[2]) { case 's': duration = durationMatch[1] * 1000; timeUnit = 'second'; break; case 'm': duration = durationMatch[1] * 1000 * 60; timeUnit = 'minute'; break; case 'h': duration = durationMatch[1] * 1000 * 60 * 60; timeUnit = 'hour'; break; case 'd': duration = durationMatch[1] * 1000 * 60 * 60 * 24; timeUnit = 'day'; break; } textString = durationMatch[3]; } const embed = new self.Discord.MessageEmbed(); if (textString) { embed.setTitle(textString); } if (duration) { embed.setDescription( self.common.mention(msg) + '\\'s ' + durationMatch[1] + ' ' + timeUnit + ' poll'); } else { embed.setDescription(self.common.mention(msg) + '\\'s poll'); } if (choicesMatch) { if (choicesMatch.length &gt; 25) { self.common.reply(msg, 'Sorry, but that is way too many poll options.'); return; } emojis = []; let error = null; choicesMatch.forEach((el, i, obj) =&gt; { if (error) return; el = obj[i] = el.replace(/^\\[|\\]$/g, ''); const matchedEmoji = emojiChecker.match(el); if (!matchedEmoji) { error = i + 1; return; } emojis.push(matchedEmoji[0]); embed.addField(el, '\\u200B', true); }); if (error) { self.common.reply( msg, 'Sorry, but choice #' + error + ' does not have a valid emoji.'); return; } } const endTime = duration ? Date.now() + duration : null; const options = { title: textString, endTime: endTime, emojis: emojis, choices: choicesMatch, }; msg.channel.send(embed).then((msg_) =&gt; { const poll = new Poll(msg.author.id, msg_, options); currentPolls[msg_.id] = poll; addListenersToPoll(poll, msg_.id); addNextReaction(poll)(); }); } /** * Add timeout and possibly other listeners to a poll. * * @private * * @param {Polling~Poll} poll The poll to register. * @param {string} key The {@link Polling~currentPolls} key to remove the poll * from once the poll has ended. */ function addListenersToPoll(poll, key) { if (poll.endTime) { const duration = poll.endTime - Date.now(); if (duration &gt; 0) { poll.timeout = self.client.setTimeout( (function(poll, key) { return function() { endPoll(poll); delete currentPolls[key]; }; })(poll, key), duration); } } } /** * Create a callback for adding all reactions to a message. * * @private * @param {Polling~Poll} poll The poll object for adding reactions. * @param {number} [index=0] The index of the emoji to add first. * @returns {Function} The callback to run on Promise completion. */ function addNextReaction(poll, index = 0) { return function() { if (poll.emojis.length &lt;= index) return; poll.message.react(poll.emojis[index]) .then(addNextReaction(poll, index + 1)); }; } /** * Ends a poll. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#endpoll * @listens Command#endvote */ function commandEndPoll(msg) { let poll = Object.entries(currentPolls).find((obj) =&gt; { return obj[1].author === msg.author.id &amp;&amp; obj[1].message.guild.id === msg.guild.id; }); let key; if (poll) { key = poll[0]; poll = poll[1]; } if (!poll || !endPoll(poll)) { self.common.reply(msg, 'You don\\'t currently have a poll.'); } if (key) { delete currentPolls[key]; } } /** * End a poll. Does not remove it from {@link Polling~currentPolls}. * * @private * @param {Polling~Poll} poll The poll to end. * @returns {boolean} Was the poll successfully ended. */ function endPoll(poll) { if (!poll || !poll.message || !poll.author) { return false; } if (poll.timeout) { self.client.clearTimeout(poll.timeout); poll.timeout = null; } const reactions = poll.message.reactions.filter((reaction) =&gt; { return poll.emojis.concat(reaction.emoji.name); }); const embed = new self.Discord.MessageEmbed(); if (poll.title) embed.setTitle(poll.title); embed.setDescription(`&lt;@${poll.author}&gt;'s poll results`); if (!poll.endTime) { embed.setFooter('Poll ended manually'); } else if (Date.now() &lt; poll.endTime) { embed.setFooter('Poll ended early'); } else { embed.setFooter('Poll ended at time limit'); } let index = -1; let max = 0; reactions.forEach((r) =&gt; { const i = poll.emojis.findIndex((e) =&gt; { return e == r.emoji.name; }); if (r.count - 1 &gt; max) { index = i; max = r.count - 1; } embed.addField(poll.choices[i], r.count - 1, true); }); if (index &gt; -1) { embed.addField( 'Top Choice', (poll.choices[index] || poll.emojis[index]) + ' with ' + max + ' votes.'); } poll.message.channel.send(embed) .then(() =&gt; { // poll.message.delete().catch(() =&gt; {}); }) .catch((err) =&gt; { self.error( 'Failed to send poll results to channel: ' + poll.message.channel.id); console.error(err); }); return true; } } module.exports = new Polling(); × Search results Close "},"raidBlock.js.html":{"id":"raidBlock.js.html","title":"Source: raidBlock.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: raidBlock.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const SubModule = require('./subModule.js'); /** * @description Manages raid blocking commands and configuration. * @listens Discord:external~Client#guildMemberAdd * @listens Command#raid * @listens Command#lockdown * @fires RaidBlock#shutdown * @fires RaidBlock#lockdown * @fires RaidBlock#action */ class RaidBlock extends SubModule { /** * @description SubModule managing echo related commands. */ constructor() { super(); /** @inheritdoc */ this.myName = 'RaidBlock'; /** * Guild settings for raids mapped by their guild id. * * @private * @type {Object.&lt;RaidBlock~RaidSettings&gt;} * @default */ this._settings = {}; /** * All event handlers registered. * * @private * @type {Object.&lt;Array.&lt;Function&gt;&gt;} * @default */ this._events = {}; this.save = this.save.bind(this); this.on = this.on.bind(this); this.removeListener = this.removeListener.bind(this); this._commandLockdown = this._commandLockdown.bind(this); this._onGuildMemberAdd = this._onGuildMemberAdd.bind(this); } /** @inheritdoc */ initialize() { this.command.on( new this.command.SingleCommand( ['lockdown', 'raid'], this._commandLockdown, { validOnlyInGuild: true, defaultDisabled: true, permissions: this.Discord.Permissions.FLAGS.MANAGE_ROLES | this.Discord.Permissions.FLAGS.MANAGE_GUILD | this.Discord.Permissions.FLAGS.BAN_MEMBERS, })); this.client.on('guildMemberAdd', this._onGuildMemberAdd); this.client.guilds.forEach((g) =&gt; { fs.readFile( `${this.common.guildSaveDir}${g.id}/raidSettings.json`, (err, file) =&gt; { if (err) return; let parsed; try { parsed = RaidSettings.from(JSON.parse(file)); this._settings[g.id] = parsed; } catch (e) { this.error('Failed to parse raidSettings: ' + g.id); console.error(e); return; } }); }); } /** @inheritdoc */ shutdown() { this.command.removeListener('lockdown'); this.client.removeListener('guildMemberAdd', this._onGuildMemberAdd); this._fire('shutdown'); } /** @inheritdoc */ save(opt) { if (!this.initialized) return; Object.entries(this._settings).forEach((obj) =&gt; { const dir = `${this.common.guildSaveDir}${obj[0]}/`; const filename = `${dir}raidSettings.json`; if (opt == 'async') { this.common.mkAndWrite(filename, dir, JSON.stringify(obj[1])); } else { this.common.mkAndWriteSync(filename, dir, JSON.stringify(obj[1])); } }); } /** * @description Send a message to a guild's moderation channel (if * configured), describing the action that took place. * @see {@link ModLog} * * @private * @param {*} args The arguments to pass to ModLog. */ _modLog(...args) { const modLog = this.bot.getSubmodule('./modLog.js'); if (!modLog) return; modLog.output(...args); } /** * @description Mute a discord guild member. * @see {@link Moderation~muteMember} * * @private * @param {external:Discord~GuildMember} member Member to mute. * @param {Function} cb Callback function. */ _muteMember(member, cb) { const moderation = this.bot.getSubmodule('./moderation.js'); if (!moderation) return; moderation.muteMember(member, cb); } /** * @description Handle a member being added to a guild. * * @private * @param {external:Discord~GuildMember} member The guild member that was * added to a guild. */ _onGuildMemberAdd(member) { if (!this._settings[member.guild.id]) return; const s = this._settings[member.guild.id]; const now = Date.now(); while (s.history.length &gt; 0 &amp;&amp; now - s.history[0].time &gt; s.timeInterval) { s.history.splice(0, 1); } for (let i = 0; i &lt; s.history.length; i++) { if (s.history[i].id == member.id) { s.history.splice(i, 1); break; } } s.history.push({time: now, id: member.id}); if (s.enabled) { if (s.numJoin &lt;= s.history.length) { this._fire('lockdown', {id: member.guild.id, settings: s}); if (now - s.start &gt;= s.duration) { this._modLog( member.guild, 'lockdown', null, null, 'Lockdown Activated Automatically'); for (let i = 0; s.history[i].time &lt; now; i++) { const m = member.guild.members.get(s.history[i].id); if (m) this._doAction(m, s); } } s.start = now; } if (now - s.start &lt; s.duration) { this._doAction(member, s); } } } /** * @description Perform lockdown action on a member with given settings. * @private * @param {external:Discord~GuildMember} member Member to perform action on. * @param {RaidBlock~RaidSettings} s Guild settings for raids. */ _doAction(member, s) { this._fire( 'action', {id: member.guild.id, action: s.action, user: member.user}); const self = this; const go = function() { switch (s.action) { case 'kick': member.kick('Server on raid lockdown.') .then((m) =&gt; { self._modLog(m.guild, s.action, m.user, null, 'Raid Lockdown'); }) .catch((err) =&gt; { self.error('Failed to kick user during raid!'); console.error(err); }); break; case 'ban': member.ban({reason: 'Server on raid lockdown.'}) .then((m) =&gt; { self._modLog(m.guild, s.action, m.user, null, 'Raid Lockdown'); }) .catch((err) =&gt; { self.error('Failed to kick user during raid!'); console.error(err); }); break; case 'mute': self._muteMember(member, (err) =&gt; { if (err) { self._modLog( member.guild, s.action, member.user, null, 'Failed to mute: ' + err); } else { self._modLog( member.guild, s.action, member.user, null, 'Raid Lockdown'); } }); break; } }; if (s.sendWarning) { let verb = ''; switch (s.action) { case 'kick': verb = 'kicked'; break; case 'ban': verb = 'banned'; break; case 'mute': verb = 'muted'; break; } const finalMessage = s.warnMessage.replace(/\\{action\\}/, verb) .replace(/\\{server\\}/g, member.guild.name) .replace(/\\{username\\}/g, member.user.username); member.send(finalMessage).then(go).catch(go); } else { go(); } } /** * @description Initiate a server lockdown, or lift a current lockdown. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#lockdown * @listens Command#raid */ _commandLockdown(msg) { const s = this.getSettings(msg.guild.id); const now = Date.now(); if (msg.text.trim().length == 0) { if (!s.enabled) { this.common.reply(msg, 'Lockdown Status', 'Not Configured'); return; } const finalString = []; const active = now - s.start &lt; s.duration; finalString.push(`Active: ${active}`); if (active) { const dateString = new Date(s.start).toString(); const timeSince = this._formatDelay(now - s.start); const timeLeft = this._formatDelay(1 * s.start + 1 * s.duration); const durationString = this._formatDelay(s.duration); finalString.push(`Since: ${dateString} (${timeSince})`); finalString.push(`Duration: ${durationString} (${timeLeft})`); finalString.push(`Action: ${s.action}`); } else { const dateString = s.start ? new Date(s.start).toString() : 'Never'; const timeSince = s.start ? `(${this._formatDelay(now - s.start)} ago})` : ''; const timeLeft = s.start ? `${this._formatDelay(now - (s.start + s.duration))} ago` : ''; const durationString = this._formatDelay(s.duration); const intervalString = this._formatDelay(s.timeInterval); finalString.push(`Previous: ${dateString} ${timeSince}`); finalString.push(`Ended: ${timeLeft}`); finalString.push( `Activates if ${s.numJoin} join within ${intervalString}.`); finalString.push(`Duration: ${durationString}`); finalString.push(`Action: ${s.action}`); } this.common.reply(msg, 'Lockdown Status', finalString.join('\\n')); return; } const cmd = msg.text.trim().split(' ')[0]; const enableCmds = [ 'enable', 'enabled', 'start', 'begin', 'on', 'active', 'activate', 'protect', ]; const disableCmds = [ 'disable', 'end', 'off', 'finish', 'deactivate', 'inactive', 'disabled', 'cancel', 'abort', 'stop', ]; if (enableCmds.includes(cmd)) { s.enabled = true; s.start = now; this._fire('lockdown', {id: msg.guild.id, settings: s}); this.common.reply(msg, 'Activated Lockdown'); this._modLog( msg.guild, 'lockdown', null, msg.author, 'Lockdown Activated Manually'); } else if (disableCmds.includes(cmd)) { if (s.enabled &amp;&amp; now - s.start &lt; s.duration) { s.start = null; this.common.reply(msg, 'Deactivated Lockdown'); this._modLog( msg.guild, 'lockdown', null, msg.author, 'Lockdown Deactivated Manually'); } else { this.common.reply(msg, 'Lockdown is already deactivated'); } } else { this.common.reply( msg, 'Oops! I don\\'t understand that.', 'https://www.spikeybot.com/control/ has most settings for this.'); } } /** * @description Get the settings for a guilds. * @public * @param {string} gId The ID of the guild to fetch. * @returns {RaidBlock~RaidSettings} Reference to settings object. If it does * not exist yet, it will first be created with defaults. */ getSettings(gId) { if (!this._settings[gId]) this._settings[gId] = new RaidSettings(); return this._settings[gId]; } /** * @description Register an event handler for a specific event. Fires the * handler when the event occurs. * @public * @param {string} event Name of the event to listen for. * @param {Function} handler Callback function handler to fire on the event. */ on(event, handler) { if (!this._events[event]) this._events[event] = []; this._events[event].push(handler); } /** * @description Remove an event handler that was previously registered. * @public * @param {string} event Name of the event to listen for. * @param {Function} handler Callback function handler to fire on the event. */ removeListener(event, handler) { if (!this._events[event]) return; if (!handler) return; const index = this._events[event].findIndex((el) =&gt; el === handler); if (index &lt; 0) return; this._events[event].splice(index, 1); } /** * @description Fire an event on all handlers. * @private * @param {string} event The event name to fire. * @param {*} args The arguments to pass to handlers. */ _fire(event, ...args) { if (!this._events[event]) return; this._events[event].forEach((el) =&gt; el(...args)); } /** * Format a duration in milliseconds into a human readable string. * * @private * @param {number} msecs Duration in milliseconds. * @returns {string} Formatted string. */ _formatDelay(msecs) { let output = ''; let unit = 7 * 24 * 60 * 60 * 1000; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' week' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 7; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' day' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 24; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' hour' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 60; if (msecs &gt;= unit) { const num = Math.floor(msecs / unit); output += num + ' minute' + (num == 1 ? '' : 's') + ', '; msecs -= num * unit; } unit /= 60; if (msecs &gt;= unit) { const num = Math.round(msecs / unit); output += num + ' second' + (num == 1 ? '' : 's') + ''; } return output.replace(/,\\s$/, ''); } } /** * Container for RaidBlock related settings. * @memberof RaidBlock * @inner */ class RaidSettings { /** * @description Create a settings object. * * @param {boolean} [enabled=false] Is raid protection enabled. * @param {number} [numJoin=5] Number of users joined in given time. * @param {number} [timeInterval=10000] Time interval for checking number of * users joined. * @param {number} [duration=600000] Amount of time to be in automated * lockdown. * @param {string} [action='kick'] Action to perform during lockdown. * @param {?string} [warnMessage=null] DM message to send. * @param {boolean} [sendWarning=false] Should send DM. */ constructor( enabled = false, numJoin = 5, timeInterval = 10000, duration = 600000, action = 'kick', warnMessage = null, sendWarning = false) { /** * @description Is raid protection enabled. * @public * @type {boolean} * @default false */ this.enabled = enabled; /** * @description Number of users joined within the configured time interval * to be considered a raid. * @public * @type {number} * @default 5 */ this.numJoin = numJoin; /** * @description Amount of time for if too many players join, it will be * considered a raid. Time in milliseconds. * @public * @type {number} * @default 10000 */ this.timeInterval = timeInterval; /** * @description Amount of time to stay on lockdown after a raid has been * detected to have ended. * @public * @type {number} * @default 600000 (10 Minutes) */ this.duration = duration; /** * @description Action to perform, while on lockdown, to new member who * join. Possible values are `kick`, `ban`, or `mute`. * @public * @type {string} * @default 'kick' */ this.action = action; if (!['kick', 'ban', 'mute'].includes(this.action)) this.action = 'kick'; /** * @description Current raid block state information. Not null is if server * has had a lockdown, start is the last timestamp we consider the raid to * be active, or null if no raid is active. * @public * @type {?number} * @default */ this.start = null; /** * @description History of previous member who joined the server within the * time interval. Time is timestamp of join, and id is user's account id. * @public * @type {Array.&lt;{time: number, id: string}&gt;} * @default */ this.history = []; /** * @description Message to send to users when they are being warned that the * raid lockdown is active. * @public * @type {string} * @default */ this.warnMessage = warnMessage || '{username}, you have been {action} in' + ' {server} because the server is on lockdown.'; /** * @description Should we additionally send `warnMessage` in a DM to the * user prior to performing the action during a lockdown. * @public * @type {boolean} * @default */ this.sendWarning = sendWarning; } } /** * @description Create a RaidSettings object from a similarly structured object. * Similar to copy-constructor. * * @public * @static * @param {object} obj Object to convert to RaidSettings. * @returns {RaidBlock~RaidSettings} Created raidsettings object. */ RaidSettings.from = function(obj) { const output = new RaidSettings( obj.enabled, obj.numJoin, obj.timeInterval, obj.duration, obj.action, obj.warnMessage, obj.sendWarning); return output; }; RaidBlock.RaidSettings = RaidSettings; module.exports = new RaidBlock(); × Search results Close "},"roleColors.js.html":{"id":"roleColors.js.html","title":"Source: roleColors.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: roleColors.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(RoleColors); // Extends the SubModule class. /** * @classdesc Allows users to change their name color by giving them a role with * a color. * @class * @augments SubModule * @listens Command#color */ function RoleColors() { const self = this; /** @inheritdoc */ this.myName = 'Role Colors'; /** @inheritdoc */ this.initialize = function() { const cmdColor = new self.command.SingleCommand( [ 'color', ], commandColor, new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD, })); self.command.on(cmdColor); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('color'); }; /** * Allow a user to set their name color. This isn't very smart, and doesn't * check for correct position in hierarchy, but will try not to create * multiple roles for one person. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#color */ function commandColor(msg) { if (!msg.guild.me.hasPermission('MANAGE_ROLES')) { self.common.reply( msg, 'Unfortunately, I do not have permission to manage roles.'); return; } let target = msg.member; if (msg.member.hasPermission('MANAGE_ROLES') &amp;&amp; msg.mentions.members.size &gt; 0) { target = msg.mentions.members.first(); msg.text = msg.text.replace(self.Discord.MessageMentions.USERS_PATTERN, ''); } let color = msg.text.trim(); let colorString = color; const role = msg.guild.roles.find((el) =&gt; el.name == target.id); const colorList = [ 'DEFAULT', 'WHITE', 'AQUA', 'GREEN', 'BLUE', 'PURPLE', 'LUMINOUS_VIVID_PINK', 'GOLD', 'ORANGE', 'RED', 'GREY', 'DARKER_GREY', 'NAVY', 'DARK_AQUA', 'DARK_GREEN', 'DARK_BLUE', 'DARK_PURPLE', 'DARK_VIVID_PINK', 'DARK_GOLD', 'DARK_ORANGE', 'DARK_RED', 'DARK_GREY', 'LIGHT_GREY', 'DARK_NAVY', 'RANDOM', ]; if (colorList.includes(color.toUpperCase())) { color = color.toUpperCase(); } else { const rgbMatch = color.match(/(\\d{1,3})\\b\\D+\\b(\\d{1,3})\\b\\D+\\b(\\d{1,3}\\b)/); const hexMatch = color.match(/#?([A-Fa-f0-9]{6})/); if (rgbMatch) { color = [rgbMatch[1], rgbMatch[2], rgbMatch[3]]; colorString = ''; for (let i = 0; i &lt; color.length; i++) { color[i] = Math.max(0, Math.min(255, color[i])); } colorString = color.join(', '); } else if (hexMatch) { color = hexMatch[1]; colorString = `#${color}`; } else { self.common.reply( msg, 'I\\'m not sure what color that is, sorry.', color); return; } } if (!role) { const roleData = {name: target.id, color: color, permissions: 0}; msg.guild.roles.create({data: roleData}) .then((r) =&gt; { r.setColor(color); target.roles.add(r).then(() =&gt; { const embed = new self.Discord.MessageEmbed(); embed.setColor(color); embed.setTitle('Updated color.'); embed.setDescription(colorString); msg.channel.send(embed).catch(() =&gt; { self.common.reply(msg, 'Updated color.', colorString); }); }); }) .catch((err) =&gt; { self.error('Unable to create color role:' + msg.channel.id); console.error(err); self.common.reply(msg, 'Unable to update color.', err.message); }); } else { role.setColor(color) .then((r) =&gt; { target.roles.add(r).then(() =&gt; { const embed = new self.Discord.MessageEmbed(); embed.setColor(color); embed.setTitle('Updated color.'); embed.setDescription(colorString); msg.channel.send(embed).catch(() =&gt; { self.common.reply(msg, 'Updated color.', colorString); }); }); }) .catch((err) =&gt; { self.error('Unable to edit color role:' + msg.channel.id); console.error(err); self.common.reply(msg, 'Unable to update color.', err.message); }); } } } module.exports = new RoleColors(); × Search results Close "},"roleManager.js.html":{"id":"roleManager.js.html","title":"Source: roleManager.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: roleManager.js /* eslint-disable */ // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const mkdirp = require('mkdirp'); require('./subModule.js').extend(RoleManager); // Extends the SubModule class. /** * @classdesc Manages advanced role controls and features. * @class * @augments SubModule * @listens Discord#message * @listens Command#chat */ function RoleManager() { const self = this; /** @inheritdoc */ this.myName = 'Role Manager'; /** @inheritdoc */ this.initialize = function() { cmdRoleAdd = new self.command.SingleCommand( [ 'add', 'give', ], commandRoleAdd, new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD, })); cmdRoleRemove = new self.command.SingleCommand( [ 'remove', 'delete', 'take', ], commandRoleRemove, new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD, })); self.command.on( new self.command.SingleCommand( ['role', 'roles'], commandRole, new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD, })), [ new self.command.SingleCommand( [ 'manage', 'edit', 'modify', 'change', 'config', 'configure', 'settings', 'setting', 'options', 'option', 'opt', ], commandRoleManage, new self.command.CommandSetting({ validOnlyInGuild: true, defaultDisabled: true, permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES | self.Discord.Permissions.FLAGS.MANAGE_GUILD, })), cmdRoleAdd, cmdRoleRemove, ]); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('role'); }; /** * @override * @inheritdoc */ this.save = function(opt) { Object.entries(guildPerms).forEach((el) =&gt; { const id = el[0]; const data = el[1]; const dir = self.common.guildSaveDir + id; const filename = dir + saveFile; const saveStartTime = Date.now(); if (opt == 'async') { mkdirp(dir, function(err) { if (err) { self.error('Failed to create directory for ' + dir); console.error(err); return; } fs.writeFile(filename, JSON.stringify(data), function(err2) { if (err2) { self.error('Failed to save HG data for ' + filename); console.error(err2); } else if ( el[1].accessTimestamp - saveStartTime &lt; -15 * 60 * 1000) { delete guildPerms[id]; self.debug('Purged ' + id); } }); }); } else { try { mkdirp.sync(dir); } catch (err) { self.error('Failed to create directory for ' + dir); console.error(err); return; } try { fs.writeFileSync(filename, JSON.stringify(data)); } catch (err) { self.error('Failed to save role data for ' + filename); console.error(err); return; } if (el[1].accessTimestamp - Date.now() &lt; -15 * 60 * 1000) { delete guildPerms[id]; self.debug('Purged ' + id); } } }); }; /** * The SingleCommand storing permissions for adding roles. * @private * * @type {Command~SingleCommand} */ let cmdRoleAdd; /** * The SingleCommand storing permissions for removing roles. * @private * * @type {Command~SingleCommand} */ let cmdRoleRemove; /** * The roles that each user is allowed to give. Mapped by guild id, then user * id, then role id. Cached. Use {@link RoleManager~find} to access the data. * @private * * @type {Object.&lt;Object.&lt;Object.&lt;boolean&gt;&gt;&gt;} */ const guildPerms = {}; /** * The delay after failing to find a guild's data to look for it again. * * @private * @type {number} * @constant * @default 15 Seconds */ const findDelay = 15000; /** * The file path to save current state for a specific guild relative to * Common~guildSaveDir. * @see {@link Common~guildSaveDir} * * @private * @type {string} * @constant * @default */ const saveFile = '/rolePerms.json'; /** * Manage the basic fallback for the role command. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#role */ function commandRole(msg) { self.common.reply( msg, 'Please specify an action.', '(Ex: Add, remove, manage, etc.'); } /** * Handle the user configuring permissions. * @TODO: Implement. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#roleManage */ function commandRoleManage(msg) { let text = ''; let roles = []; let users = []; if (!msg.text || msg.text.length == 0) { self.common.reply( msg, 'Please specify a role or user to modify, and an action to perform.', '`' + msg.prefix + 'role manage @Trusted allow @Role1 @Role2`'); return; } const giveActions = ['allow', 'grant', 'give', 'permit']; const takeActions = ['deny', 'revoke', 'take', 'remove']; const actions = giveActions.concat(takeActions); const gRoleRegex = self.Discord.MessageMentions.ROLES_PATTERN; const sRoleRegex = new RegExp(gRoleRegex.source); const gUserRegex = self.Discord.MessageMentions.USERS_PATTERN; const sUserRegex = new RegExp(gUserRegex.source); const sRegex = new RegExp(gRoleRegex.source + '|' + gUserRegex); const gRegex = new RegExp(gRoleRegex.source + '|' + gUserRegex, 'g'); const cmdRegex = new RegExp( '(' + sRegex.source + ')\\s*(' + actions.join('|') + ')\\s*' + sRoleRegex.source); const cmdMatch = msg.text.match(cmdRegex); if (!cmdMatch) { self.common.reply( msg, 'Please specify a role or user to modify, and an action to perform.', '`' + msg.prefix + 'role manage @Trusted allow @Role1 @Role2`'); return; } roles = msg.text.match(gRoleRegex); users = msg.text.match(gUserRegex); text = msg.text.replace(self.Discord.MessageMentions.ROLES_PATTERN, '') .replace(/\\s+/g, ' '); if (text) { text.split(/\\s/).forEach((el) =&gt; { const str = el.toLowerCase(); }); } } /** * Give a guild member a role. * @public * * @param {string|number|Discord~Guild} guild Guild object, or ID. * @param {string|number|Discord~GuildMember} member Guild Member object, ID * or name (username, nickname or tag) to lookup. * @param {string|number|Discord~Role} role Guild Role object, ID or name to * lookup. * @return {?string} Null if success, string if error. */ this.giveRole = function(guild, member, role) { }; /** * Handle the user attempting to add a role. * @TODO: Implement. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#roleAdd */ function commandRoleAdd(msg) { } /** * Handle the user attempting to remove a role. * @TODO: Implement. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#roleRemove */ function commandRoleRemove(msg) { } /** * Returns a guild's data. Returns cached version if that exists, or searches * the file system for saved data. Data will only be checked from disk at most * once every `RoleManager~findDelay` milliseconds. Returns `null` if data * could not be found, or an error occurred. * * @private * @param {number|string} id The guild id to get the data for. * @return {?Object} The role data, or null if no data could be loaded. */ function find(id) { if (guildPerms[id]) return guildPerms[id]; if (Date.now() - guildPerms[id].accessTimestamp &lt; findDelay) return null; guildPerms[id].accessTimestamp = Date.now(); try { const tmp = fs.readFileSync(self.common.guildSaveDir + id + saveFile); try { guildPerms[id] = JSON.parse(tmp); if (self.initialized) self.debug('Loaded roles from file ' + id); } catch (e2) { self.error('Failed to parse roles data for guild ' + id); return null; } } catch (e) { if (e.code !== 'ENOENT') { self.debug('Failed to load role data for guild:' + id); console.error(e); } return null; } return guildPerms[id]; } } module.exports = new RoleManager(); × Search results Close "},"sandbox.js.html":{"id":"sandbox.js.html","title":"Source: sandbox.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: sandbox.js const childProcess = require('child_process'); require('./subModule.js').extend(Sandbox); // Extends the SubModule class. /** * @classdesc Creates a safe environment to run untrusted scripts. * @class * @augments SubModule * @listens Command#js */ function Sandbox() { const self = this; /** @inheritdoc */ this.myName = 'Sandbox'; /** @inheritdoc */ this.initialize = function() { self.command.on('js', commandJS); self.command.on(['py', 'python'], commandPython); self.command.on(['py3', 'python3'], commandPython3); }; /** @inheritdoc */ this.shutdown = function() { self.command.removeListener('js'); self.command.removeListener('py'); self.command.removeListener('py3'); }; /** * Arguments to pass into child_process.exec. * @private * @default * @constant * @type {Object} */ const execArgs = { timeout: 35000, // 5 second leniency for sandbox. maxBuffer: 2 * 1024, env: {}, }; /** * Command to execute to start a sandbox. * @private * @default * @constant * @type {string} */ const sandboxCommand = 'firejail --profile=./src/lib/sandbox.profile -- '; /** * The command to run in the sandbox to run JavaScript. * @private * @default * @constant * @type {string} */ const jsCommand = 'SBnode'; /** * The command to run in the sandbox to run Python2.7. * @private * @default * @constant * @type {string} */ const pyCommand = 'SBpython'; /** * The command to run in the sandbox to run Python3. * @private * @default * @constant * @type {string} */ const py3Command = 'SBpython3'; /** * Run JavaScript code in a sandbox, then show user outcome. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#js */ function commandJS(msg) { const cmd = `${sandboxCommand}${jsCommand}`; msg.channel.startTyping(); const p = childProcess.exec(cmd, execArgs, (...args) =&gt; { scriptEnd(msg, ...args); }); p.stdin.write(msg.text); p.stdin.end(); } /** * Run Python2.7 code in a sandbox, then show user outcome. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#py */ function commandPython(msg) { const cmd = `${sandboxCommand}${pyCommand}`; msg.channel.startTyping(); const p = childProcess.exec(cmd, execArgs, (...args) =&gt; { scriptEnd(msg, ...args); }); p.stdin.write(msg.text); p.stdin.end(); } /** * Run Python3 code in a sandbox, then show user outcome. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#py */ function commandPython3(msg) { const cmd = `${sandboxCommand}${py3Command}`; msg.channel.startTyping(); const p = childProcess.exec(cmd, execArgs, (...args) =&gt; { scriptEnd(msg, ...args); }); p.stdin.write(msg.text); p.stdin.end(); } /** * Callback when script user's program has finished executing. * * @private * @param {Discord~Message} msg The Discord message that triggered the initial * execution. * @param {Error} err Error while running script. * @param {string|Buffer} stdout All data passed through stdout. * @param {string|Buffer} stderr All data paseed through stderr. */ function scriptEnd(msg, err, stdout, stderr) { msg.channel.stopTyping(); if (err) { if (err.message === 'stderr maxBuffer exceeded' || err.message === 'stdout maxBuffer exceeded') { self.common.reply(msg, 'Code execution failed.', err.message); return; } else if (err.code === null) { self.common.reply( msg, 'Code execution failed.', 'Execution aborted. ' + 'Your code can run at most for 30 seconds.'); return; } self.common.reply( msg, 'Oops! Something didn\\'t work right...', 'Something is broken internally.'); console.error(err); self.debug('STDERR: ' + stderr); self.debug('STDOUT: ' + stdout); return; } const embed = new self.Discord.MessageEmbed(); embed.setColor([0, 255, 255]); if (stdout.length &gt; 0) { if (stdout.indexOf('\\\\n') != stdout.lastIndexOf('\\\\n')) { stdout = stdout.replace(/\\\\n/g, '\\n'); } embed.addField('STDOUT', stdout.substr(0, 1024), true); } if (stderr.length &gt; 0) { if (stderr.indexOf('\\\\n') != stderr.lastIndexOf('\\\\n')) { stderr = stderr.replace(/\\\\n/g, '\\n'); } embed.addField('STDERR', stderr.substr(0, 1024), true); } msg.channel.send(self.common.mention(msg), embed); } } module.exports = new Sandbox(); × Search results Close "},"smLoader.js.html":{"id":"smLoader.js.html","title":"Source: smLoader.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: smLoader.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const childProcess = require('child_process'); require('./mainModule.js')(SMLoader); // Extends the MainModule class. /** * @classdesc Manages loading, unloading, and reloading of all SubModules. * @class * @augments MainModule */ function SMLoader() { const self = this; /** @inheritdoc */ this.myName = 'SMLoader'; /** @inheritdoc */ this.import = function(data) { if (!data) return; subModules = data.subModules; subModuleNames = data.subModuleNames; }; /** @inheritdoc */ this.export = function() { const output = { subModules: subModules, subModuleNames: subModuleNames, }; subModules = null; subModuleNames = null; return output; }; /** @inheritdoc */ this.terminate = function() { for (const i in subModules) { if (subModules[i] &amp;&amp; subModules[i].end) { subModules[i].end(); } } }; /** @inheritdoc */ this.initialize = function() { self.command.on('reload', commandReload); self.command.on('unload', commandUnload); self.command.on('load', commandLoad); self.command.on( new self.command.SingleCommand(['help', 'commands'], commandHelp)); Object.assign(self.bot, toAssign.bot); Object.assign(self.client, toAssign.client); fs.readFile(smListFilename, (err, data) =&gt; { if (err) { self.error( 'Failed to read list of subModules from file: ' + smListFilename); console.error(err); return; } try { const parsed = JSON.parse(data); if (!parsed) { self.error('Empty list of subModules from file: ' + smListFilename); return; } goalSubModuleNames = parsed[self.bot.getFullBotName()]; if (!goalSubModuleNames) { self.error( 'Unable to find subModule list for bot: (' + self.bot.getFullBotName() + ') ' + smListFilename); return; } self.reload(); } catch (e) { self.error( 'Failed to parse subModule list from file: ' + smListFilename); console.error(e); } }); if (self.client.shard) { /* eslint-disable no-unused-vars */ /** * Receive message from another shard asking for us to reload subModules. * @see {@link SMLoader~shardReload} * * @private */ self.client.commandReload = shardReload; /** * Receive message from another shard asking for us to unload subModules. * @see {@link SMLoader~shardUnload} * * @private */ self.client.commandUnload = shardUnload; /** * Receive message from another shard asking for us to load subModules. * @see {@link SMLoader~shardLoad} * * @private */ self.client.commandLoad = shardLoad; /* eslint-enable no-unused-vars */ } }; this.shutdown = function() { self.command.deleteEvent('reload'); self.command.deleteEvent('unload'); self.command.deleteEvent('load'); self.command.deleteEvent('help'); const data = fs.readFileSync(smListFilename); const parsed = JSON.parse(data); parsed[self.bot.getFullBotName()] = goalSubModuleNames; fs.writeFileSync(smListFilename, JSON.stringify(parsed, null, 2)); if (self.client.shard) { self.client.commandReload = null; self.client.commandUnload = null; self.client.commandLoad = null; } }; /** @inheritdoc */ this.unloadable = function() { return subModuleNames.findIndex((el) =&gt; { return !subModules[el].unloadable(); }) &lt; 0; }; /** @inheritdoc */ this.save = function(...args) { for (const i in subModules) { if (subModules[i] &amp;&amp; subModules[i].save) { subModules[i].save.apply(null, args); } } }; /** * Properties to merge into other objects. `bot` is merged into self.bot, * `client` is merged into self.client. * * @private * @type {Class} */ const toAssign = {bot: {}, client: {}}; /** * The filename storing the list of all SubModules to load. * * @private * @constant * @defualt * @type {string} */ const smListFilename = './subModules.json'; /** * The list of all submodule names currently loaded. * * @private * @type {string[]} */ let subModuleNames = []; /** * The list of all submodules that we are intended to have loaded currently. * This should reflect the file at {@link SMloader~smListFilename}. Null means * the data is not available, and no action should be taken. * * @private * @type {null|string[]} */ let goalSubModuleNames = null; /** * Instances of SubModules currently loaded mapped by their name. * * @private * @type {Object.&lt;SubModule&gt;} */ let subModules = {}; /** * Timeouts for retrying to unload submodules that are currently not in an * unloadable state. Mapped by name of submodule. * * @private * @type {Object.&lt;Timeout&gt;} */ const unloadTimeouts = {}; /** * Callbacks for when a scheduled module to unload, has been unloaded. Mapped * by name of subModule, then array of all callbacks. * * @private * @type {Object.&lt;Array.&lt;Function&gt;&gt;} */ const unloadCallbacks = {}; /** * Discord IDs that are allowed to reboot the bot. * * @private * @type {string[]} * @constant */ const trustedIds = [ '124733888177111041', // Me '126464376059330562', // Rohan ]; /** * The message sent to the channel where the user asked for help. * * @private * @type {string} * @constant */ const helpmessagereply = 'I sent you a DM with commands!'; /** * The message sent to the channel where the user asked to be DM'd, but we * were unable to deliver the DM. * * @private * @type {string} * @constant */ const blockedmessage = 'I couldn\\'t send you a message, you probably blocked me :('; /** * @description Get array of all submodule names and the commit they were last * loaded from. * * @public * @returns {Array.&lt;{name: string, commit: string}&gt;} Array of submodule names * and commit short hashes. */ toAssign.bot.getSubmoduleCommits = function() { return subModuleNames.map((el) =&gt; { return {name: el, commit: subModules[el].commit || 'Unknown'}; }); }; /** * @description Get a reference to a submodule with the given name. * * @public * @param {string} name The name of the submodule. * @returns {?SubModule} Reference to the currently loaded submodule with the * given name, or null if not loaded. */ toAssign.bot.getSubmodule = function(name) { if (!subModules[name]) { return null; } return subModules[name]; }; /** * Unloads submodules that is currently loaded. * * @public * * @param {string} name Specify submodule to unload. If it is already * unloaded, it will be ignored and return successful. * @param {object} [opts] Options object. * @param {boolean} [opts.schedule=true] Automatically re-schedule unload for * submodule if it is in an unloadable state. * @param {boolean} [opts.ignoreUnloadable=false] Force a submodule to unload * even if it is not in an unloadable state. * @param {boolean} [opts.updateGoal=true] Update the goal state of the * subModule to unloaded. * @param {Function} [cb] Callback to fire once the operation is complete. * Single parameter is null if success, or string if error. */ this.unload = function(name, opts, cb) { if (!opts) { opts = {schedule: true, updateGoal: true, ignoreUnloadable: false}; } else { if (opts.schedule == null) opts.schedule = true; if (opts.updateGoal == null) opts.updateGoal = true; } const sm = subModules[name]; if (!sm) { const nameIndex = subModuleNames.findIndex((el) =&gt; el == name); if (nameIndex &gt;= 0) { self.error( 'Unloaded module still exists in list of names!' + ' This should not happen!'); subModuleNames.splice(nameIndex, 1); } cb(null); return; } if (!opts.ignoreUnloadable) { if (!sm.unloadable()) { if (opts.schedule) { if (unloadTimeouts[name]) { if (!unloadCallbacks[name]) unloadCallbacks[name] = []; unloadCallbacks[name].push(cb); } else { unloadTimeouts[name] = setTimeout(function() { delete unloadTimeouts[name]; self.unload(name, opts, cb); }, 10000); } } else { cb('Not Unloadable'); } return; } } try { if (subModules[name].save) { subModules[name].save(); } else { self.error('Submodule ' + name + ' does not have a save() function.'); } if (subModules[name].end) { subModules[name].end(); } else { self.error('Submodule ' + name + ' does not have an end() function.'); } } catch (err) { self.error('Error on unloading ' + name); console.log(err); } let message; try { delete require.cache[require.resolve(name)]; const index = subModuleNames.findIndex((el) =&gt; el == name); if (index &lt; 0) { self.error( 'Failed to find submodule name in list of loaded submodules! ' + name); console.log(subModuleNames); } else { subModuleNames.splice(index, 1); } if (opts.updateGoal) { const goalIndex = goalSubModuleNames.findIndex((el) =&gt; el == name); if (goalIndex &lt; 0) { self.error( 'Failed to find submodule name in list of goal submodules! ' + name); console.log(goalSubModuleNames); } else { goalSubModuleNames.splice(goalIndex, 1); } } delete subModules[name]; message = null; } catch (err) { self.error('Failed to clear: ' + name); console.log(err); message = 'Failed to Unload'; } cb(message); if (unloadCallbacks[name]) { unloadCallbacks[name].splice(0).forEach((el) =&gt; { el(message); }); } }; /** * Loads submodules from file. * * @public * * @param {string} name Specify submodule to load. If it is already loaded, * they will be ignored and return successful. * @param {object} [opts] Options object. * @param {boolean} [opts.updateGoal=true] Update the goal state of the * subModule to loaded. * @param {Function} [cb] Callback to fire once the operation is complete. * Single parameter is null if success, or string if error. */ this.load = function(name, opts, cb) { if (!opts) { opts = {updateGoal: true}; } else { if (opts.updateGoal == null) opts.updateGoal = true; } if (subModules[name]) { if (opts.updateGoal &amp;&amp; !goalSubModuleNames.includes(name)) { goalSubModuleNames.push(name); } } try { subModules[name] = require(name); subModules[name].modifiedTime = fs.statSync(__dirname + '/' + name).mtime; if (subModuleNames.includes(name)) { self.error( 'Submodule that is not loaded already exists in list of ' + 'loaded names! This should not happen!'); } else { subModuleNames.push(name); } if (opts.updateGoal &amp;&amp; !goalSubModuleNames.includes(name)) { goalSubModuleNames.push(name); } } catch (err) { cb('Failed to Load'); self.error('Failed to load submodule: ' + name); console.error(err); return; } try { subModules[name].begin( self.Discord, self.client, self.command, self.common, self.bot); } catch (err) { self.error('Failed to initialize submodule: ' + name); console.error(err); delete require.cache[require.resolve(name)]; cb('Failed to Initialize'); return; } cb(null); }; /** * @description Reloads submodules from file. Reloads currently loaded modules * if `name` is not specified. If a submodule is specified that is not loaded, * it will skip the unload step, bull will still be attempted to be loaded. * @public * * @param {?string|string[]} [name] Specify submodules to reload, or null to * reload all submodules to their goal state. * @param {object} [opts] Options object. * @param {boolean} [opts.schedule=true] Automatically re-schedule reload for * submodules if they are not in an unloadable state. * @param {boolean} [opts.ignoreUnloadable=false] Force a submodule to unload * even if it is not in an unloadable state. * @param {boolean} [opts.force=false] Reload a submodule even if the * currently loaded version is identical to the version on file. If false it * will not be reloaded if the version would not be changed due to a reload. * @param {Function} [cb] Callback to fire once the operation is complete. * Single parameter has array of strings of status of each module attempted to * be reloaded. */ this.reload = function(name, opts, cb) { if (typeof cb !== 'function') cb = function() {}; if (typeof name === 'string') name = [name]; if (!name || name.length === 0) name = goalSubModuleNames; if (!Array.isArray(name) || name.length === 0) { cb([]); return; } if (!opts) { opts = {schedule: true, force: false, ignoreUnloadable: false}; } else if (opts.schedule == null) { opts.schedule = true; } opts.updateGoal = false; const numTotal = name.length; let numComplete = 0; const output = []; for (let i = 0; i &lt; numTotal; i++) { if (!opts.force &amp;&amp; subModules[name[i]]) { try { const mtime = fs.statSync(__dirname + '/' + name[i]).mtime; // For some reason, directly comparing these two for equality does not // work. if (mtime - subModules[name[i]].modifiedTime == 0) { output.push(`~~${name[i]}~~`); done(); continue; } } catch (err) { self.error( 'Failed to stat submodule: ' + __dirname + '/' + name[i]); console.error(err); output.push('(' + name[i] + ': failed to stat)'); } } reloadSingle(name[i]); } /** * Actually trigger the reload process for a single submodule. * * @private * * @param {string} name The submodule name to reload. */ function reloadSingle(name) { self.unload(name, opts, (err) =&gt; { if (err) { output.push(name + ': ' + err); done(); return; } self.load(name, opts, (err2) =&gt; { if (err2) { output.push(name + ': ' + err2); done(); return; } output.push(name + ': `Success`'); done(); }); }); } /** * Called when a submodule's reload process is completed. Fires main * callback once all submodules reloads have been completed. * * @private */ function done() { numComplete++; if (numComplete != numTotal) return; cb(output); } }; /** * Reload all sub modules by unloading then re-requiring. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#reload */ function commandReload(msg) { if (trustedIds.includes(msg.author.id)) { if (self.client.shard) { const message = encodeURIComponent(msg.text); self.client.shard.broadcastEval( `this.commandReload(\"${message}\",${self.client.shard.ids[0]})`); } let toReload = msg.text.split(' ').splice(1); const opts = {}; toReload = toReload.filter((el) =&gt; { switch (el) { case '--force': opts.force = true; return false; case '--no-schedule': opts.ignoreUnloadable = true; return false; case '--immediate': opts.schedule = false; return false; default: return true; } }); self.common .reply( msg, 'Reloading modules... (waiting until users ' + 'won\\'t notice interruption)') .then((warnMessage) =&gt; { self.reload(toReload, opts, (out) =&gt; { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Reload complete.'); embed.setColor([255, 0, 255]); embed.setDescription(out.join('\\n') || 'NOTHING reloaded'); warnMessage.edit(self.common.mention(msg), embed); }); }); } else { self.common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); } } /** * @description Other shard has requested a reload command. * @private * @param {string} message The command message to parse. * @param {number} id Shard id requesting this. */ function shardReload(message, id) { if (id == self.client.shard.ids[0]) return; let toReload = decodeURIComponent(message).split(' ').splice(1); const opts = {}; toReload = toReload.filter((el) =&gt; { switch (el) { case '--force': opts.force = true; return false; case '--no-schedule': opts.ignoreUnloadable = true; return false; case '--immediate': opts.schedule = false; return false; default: return true; } }); self.reload(toReload, opts, () =&gt; {}); } /** * @description Other shard has requested an unload command. * @private * @param {string} message The command message to parse. * @param {number} id Shard id requesting this. */ function shardUnload(message, id) { if (id == self.client.shard.ids[0]) return; let toUnload = decodeURIComponent(message).split(' ').splice(1); const opts = {}; toUnload = toUnload.filter((el) =&gt; { switch (el) { case 'force': opts.force = true; return false; case 'no-schedule': opts.ignoreUnloadable = true; return false; case 'immediate': opts.schedule = false; return false; default: return true; } }); for (let i = 0; i &lt; toUnload.length; i++) { self.unload(toUnload[i], opts, () =&gt; {}); } } /** * @description Other shard has requested a load command. * @private * @param {string} message The command message to parse. * @param {number} id Shard id requesting this. */ function shardLoad(message, id) { if (id == self.client.shard.ids[0]) return; const toLoad = decodeURIComponent(message).split(' ').splice(1); for (let i = 0; i &lt; toLoad.length; i++) { self.load(toLoad[i], null, () =&gt; {}); } } /** * Unload specific sub modules. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#unload */ function commandUnload(msg) { if (trustedIds.includes(msg.author.id)) { if (self.client.shard) { const message = encodeURIComponent(msg.text); self.client.shard.broadcastEval( `this.commandUnload(\"${message}\",${self.client.shard.ids[0]})`); } let toUnload = msg.text.split(' ').splice(1); const opts = {}; toUnload = toUnload.filter((el) =&gt; { switch (el) { case 'force': opts.force = true; return false; case 'no-schedule': opts.ignoreUnloadable = true; return false; case 'immediate': opts.schedule = false; return false; default: return true; } }); self.common.reply(msg, 'Unloading modules...').then((warnMessage) =&gt; { const numTotal = toUnload.length; let numComplete = 0; const outs = []; for (let i = 0; i &lt; numTotal; i++) { unloadSingle(toUnload[i]); } /** * Begins actually loading a module. * * @private * * @param {string} name The name of the module. */ function unloadSingle(name) { self.unload(name, opts, (out) =&gt; { outs.push(name + ': ' + (out || 'Success')); done(); }); } /** * Triggered on each completed action. * * @private */ function done() { numComplete++; if (numComplete &lt; numTotal) return; const embed = new self.Discord.MessageEmbed(); embed.setTitle('Unload complete.'); embed.setColor([255, 0, 255]); embed.setDescription(outs.join(' ') || 'NOTHING unloaded'); warnMessage.edit(self.common.mention(msg), embed); } if (numTotal == 0) done(); }); } else { self.common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); } } /** * Load specific sub modules. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#load */ function commandLoad(msg) { if (trustedIds.includes(msg.author.id)) { if (self.client.shard) { const message = encodeURIComponent(msg.text); self.client.shard.broadcastEval( `this.commandLoad(\"${message}\",${self.client.shard.ids[0]})`); } const toLoad = msg.text.split(' ').splice(1); self.common.reply(msg, 'Loading modules...').then((warnMessage) =&gt; { const numTotal = toLoad.length; let numComplete = 0; const outs = []; for (let i = 0; i &lt; numTotal; i++) { loadSingle(toLoad[i]); } /** * Begins actually loading a module. * * @private * @param {string} name The name of the subModule. */ function loadSingle(name) { self.load(name, null, (out) =&gt; { outs.push(name + ': ' + (out || 'Success')); done(); }); } /** * Triggered on each completed action. * * @private */ function done() { numComplete++; if (numComplete &lt; numTotal) return; const embed = new self.Discord.MessageEmbed(); embed.setTitle('Load complete.'); embed.setColor([255, 0, 255]); embed.setDescription(outs.join(' ') || 'NOTHING loaded'); warnMessage.edit(self.common.mention(msg), embed); } if (numTotal == 0) done(); }); } else { self.common.reply( msg, 'LOL! Good try!', 'It appears SpikeyRobot doesn\\'t trust you enough with this ' + 'command. Sorry!'); } } /** * Send help message to user who requested it. * * @private * @type {Command~commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#help */ function commandHelp(msg) { let error = false; /** * Send the help message. * * @private * @param {Discord~MessageEmbed} help THe message to send. */ function send(help) { msg.author.send(help).catch((err) =&gt; { if (msg.guild !== null &amp;&amp; !error) { error = true; self.common .reply( msg, 'Oops! I wasn\\'t able to send you the help!\\n' + 'Did you block me?', err.message) .catch(() =&gt; {}); self.error( 'Failed to send help message in DM to user: ' + msg.author.id + ' ' + help.title); console.error(err); } }); } try { for (const i in subModules) { if (!(subModules[i] instanceof Object) || !subModules[i].helpMessage) { continue; } if (!Array.isArray(subModules[i].helpMessage)) { subModules[i].helpMessage = [subModules[i].helpMessage]; } subModules[i].helpMessage.forEach(send); } if (msg.guild !== null) { self.common .reply( msg, helpmessagereply, 'Tip: https://www.spikeybot.com/help/ also has more ' + 'information.') .catch((err) =&gt; { self.error( 'Unable to reply to help command in channel: ' + msg.channel.id); console.log(err); }); } } catch (err) { self.common.reply(msg, blockedmessage); self.error('An error occured while sending help message!'); console.error(err); } } /** * Check current loaded submodule commit to last modified commit, and reload * if the file has changed. * * @public */ toAssign.client.reloadUpdatedSubModules = function() { try { self.log('Reloading updated submodules.'); for (let i = 0; i &lt; subModuleNames.length; i++) { childProcess .exec( 'git diff-index --quiet ' + subModules[subModuleNames[i]].commit + ' -- ./src/' + subModuleNames[i]) .on('close', ((name) =&gt; { return (code) =&gt; { if (code) { self.reload(name, {force: true}, (out) =&gt; { self.log(out.join(' ')); }); } else { self.debug(name + ' unchanged (' + code + ')'); } }; })(subModuleNames[i])); } } catch (err) { self.error('Failed to reload updated submodules!'); console.error(err); } }; } module.exports = new SMLoader(); × Search results Close "},"spotify.js.html":{"id":"spotify.js.html","title":"Source: spotify.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: spotify.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const https = require('https'); require('./subModule.js').extend(Spotify); /** * @classdesc Attempts to play what a user is playing on Spotify, to a voice * channel. * @class * @augments SubModule * @listens Command#spotify */ function Spotify() { const self = this; this.myName = 'Spotify'; let music; /** * The request to send to spotify to fetch the currently playing information * for a user. * @private * @default * @constant * @type {Object} */ const apiRequest = { protocol: 'https:', host: 'api.spotify.com', path: '/v1/me/player/currently-playing', method: 'GET', }; /** @inheritdoc */ this.initialize = function() { self.command.on('spotify', commandSpotify, true); checkMusic(); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('spotify'); for (const i in following) { if (following[i]) endFollow({guild: {id: i}}); } }; /** @inheritdoc */ this.unloadable = function() { return true; }; /** * The current users we are monitoring the spotify status of, and some related * information. Mapped by guild id. * @private * @type {Object} */ const following = {}; /** * Lookup what a user is listening to on Spotify, then attempt to play the * song in the requester's voice channel. * * @private * @type {commandHandler} * @param {Discord~Message} msg The message that triggered command. * @listens Command#spotify */ function commandSpotify(msg) { if (!self.bot.accounts) { self.common.reply(msg, 'Unable to lookup account information.'); return; } let userId = msg.author.id; if (msg.mentions.users.size &gt; 0) { userId = msg.mentions.users.first().id; } const subCmd = msg.text.trim().split(' ')[0]; let infoOnly = false; switch (subCmd) { case 'info': case 'inf': case 'playing': case 'current': case 'currently': case 'status': case 'stats': case 'stat': infoOnly = true; break; } if (!infoOnly &amp;&amp; music.isSubjugated(msg) &amp;&amp; following[msg.guild.id]) { endFollow(msg); self.common.reply(msg, 'Stopped following Spotify.', '&lt;@' + userId + '&gt;'); if (following[msg.guild.id] &amp;&amp; userId == following[msg.guild.id].user) { return; } } getCurrentSong(userId, (err, song) =&gt; { if (err) { if (err == 'Unlinked') { self.common.reply( msg, 'Discord account is not linked to Spotify.\\nPlease link account' + ' at spikeybot.com to use this command.', 'https://www.spikeybot.com/account/'); } else if (err == 'Bad Response') { self.common.reply( msg, 'Unable to get current Spotify status.', 'Bad response from Spotify'); } else if (err == 'Nothing Playing') { self.common.reply(msg, 'Not listening to anything on Spotify.'); } else { self.common.reply(msg, 'Unable to get current Spotify status.', err); } if (infoOnly || err != 'Nothing Playing') return; } if (infoOnly) { self.common.reply( msg, 'Song: ' + song.name + '\\nArtist: ' + song.artist + '\\nAlbum: ' + song.album + '\\nProgress: ' + Math.round(song.progress / 1000) + ' seconds in.\\nCurrently ' + (song.isPlaying ? 'playing' : 'paused')); } else { self.common.reply( msg, 'Following Spotify music. Music control is now subjugated by ' + 'Spotify.\\n(Please wait, seeking may take a while)', '&lt;@' + userId + '&gt;'); updateFollowingState(msg, userId, song, true); return; } }); } /** * Fetch the current playing song on spotify for the given discord user id. * * @private * @param {string|number} userId The Discord user id to lookup. * @param {Fucntion} cb Callback with err, and data parameters. */ function getCurrentSong(userId, cb) { self.bot.accounts.getSpotifyToken(userId, (res) =&gt; { if (!res) { cb('Unlinked'); return; } const req = https.request(apiRequest, (res) =&gt; { let content = ''; res.on('data', (chunk) =&gt; { content += chunk; }); res.on('end', () =&gt; { if (res.statusCode == 200) { let parsed; try { parsed = JSON.parse(content); } catch (err) { self.error('Failed to parse Spotify response: ' + userId); console.log(err, content); cb('Bad Response'); return; } if (!parsed.item) { cb('Nothing Playing'); return; } const artists = (parsed.item.artists || []) .map((a) =&gt; { return a.name; }) .join(', '); const songInfo = { name: parsed.item.name, artist: artists, album: parsed.item.album.name, progress: parsed.progress_ms, isPlaying: parsed.is_playing, duration: parsed.duration_ms, }; cb(null, songInfo); } else if (res.statusCode == 204) { cb('Nothing Playing'); } else { self.error( 'Unable to fetch spotify currently playing info for user: ' + userId); console.error(content); cb(res.statusCode || 'VERY SCARY ERROR'); } }); }); req.setHeader('Authorization', 'Bearer ' + res); req.end(); }); } /** * Check on the user's follow state and update the playing status to match. * * @private * * @param {Discord~Message} msg The message to use as context. * @param {string|number} userId The discord user id that we are following. * @param {object} [songInfo] If song info is provided, this will not be * fetched first. If it is not, the information will be fetched from Spotify * first. * @param {boolean} [start=false] Should we setup the player with our settings * because this is the first run? */ function updateFollowingState(msg, userId, songInfo, start = false) { checkMusic(); if (!start &amp;&amp; !music.isSubjugated(msg)) { endFollow(msg); return; } if (!songInfo) { getCurrentSong(userId, (err, song) =&gt; { if (err) { if (err == 'Nothing Playing') { if (!following[msg.guild.id]) { following[msg.guild.id] = {}; } following[msg.guild.id].timeout = self.client.setTimeout(function() { updateFollowingState(msg, userId, null, true); }, 3000); } else { self.error(err); } return; } songInfo = song; makeTimeout(); }); } else { makeTimeout(); } /** * Start playing the music, and create a timeout to check the status, or for * the next song. * * @private */ function makeTimeout() { if (!start &amp;&amp; !music.isSubjugated(msg)) { endFollow(msg); return; } music.clearQueue(msg); if (start) { music.subjugate(msg); } if (songInfo &amp;&amp; (start || songInfo.progress &lt; 60000)) { startMusic(msg, songInfo); } if (following[msg.guild.id] &amp;&amp; following[msg.guild.id].timeout) { self.client.clearTimeout(following[msg.guild.id].timeout); } following[msg.guild.id] = { user: userId, song: songInfo, lastUpdate: Date.now(), }; if (!songInfo || songInfo.duration) { const delay = songInfo ? (songInfo.duration - songInfo.progress) : 3000; following[msg.guild.id].timeout = self.client.setTimeout(function() { updateFollowingState(msg, userId); }, delay); } else { following[msg.guild.id].timeout = self.client.setTimeout(function() { updateDuration(msg, userId); }, 1000); } } } /** * Fetch the song's length from music because Spotify was unable to provide it * for us. * * @private * * @param {Discord~Message} msg The context. * @param {string|number} userId The user id we are following. */ function updateDuration(msg, userId) { checkMusic(); if (following[msg.guild.id] &amp;&amp; following[msg.guild.id].timeout) { self.client.clearTimeout(following[msg.guild.id].timeout); } if (!music.isSubjugated(msg)) { endFollow(msg); return; } const dur = music.getDuration(msg); const prog = music.getProgress(msg); if (dur != null &amp;&amp; prog != null) { following[msg.guild.id].song.duration = dur * 1000; const f = following[msg.guild.id]; const delay = f.song.duration - f.song.progress; following[msg.guild.id].timeout = self.client.setTimeout(function() { updateFollowingState(msg, userId); }, delay); } else { following[msg.guild.id].timeout = self.client.setTimeout(function() { updateDuration(msg, userId); }, 1000); } } /** * Attempt to start playing the given song into a voice channel. * * @private * @param {Discord~Message} msg Message that caused this to happen, and to * pass into {@link Command} as context. * @param {{name: string, artist: string, progress: number}} song The current * song information. Name is song name, progress is progress into the song in * milliseconds. */ function startMusic(msg, song) { checkMusic(); const seek = Math.round(song.progress / 1000 + (song.progress / 1000 / 5)); music.playSong(msg, song.name + ' by ' + song.artist, seek, true); } /** * Update current reference to music submodule. * * @private */ function checkMusic() { if (!music || !music.initialized) { music = self.bot.getSubmodule('./music.js'); } } /** * Cleanup and delete data in order to stop following user. * * @private * @param {Discord~Message} msg THe context to clear. */ function endFollow(msg) { if (following[msg.guild.id]) { self.client.clearTimeout(following[msg.guild.id].timeout); } delete following[msg.guild.id]; checkMusic(); if (music) music.release(msg); } } module.exports = new Spotify(); × Search results Close "},"locale_Strings.js.html":{"id":"locale_Strings.js.html","title":"Source: locale/Strings.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: locale/Strings.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const fs = require('fs'); const Locale = require('./Locale.js'); /** * @description Static strings for Pets. */ class Strings { /** * @description Strings. * @param {string} [filename='global'] Filename to read strings from each * locale. Excluding path and extension. * @param {string} [dir='../..//strings/'] Path to find folder of available * locales, relative to this file. * @param {string} [defaultLocale='en_US'] Default and fallback locale to use * when unspecified or no string in given locale is found. */ constructor( filename = 'global', dir = '../../strings/', defaultLocale = 'en_US') { if (typeof filename !== 'string') { throw new TypeError('Filename is not a string.'); } if (typeof dir !== 'string') { throw new TypeError('Directory is not a string.'); } defaultLocale = Strings.parseLocale(defaultLocale); if (!defaultLocale) { throw new TypeError('Default Locale is not a valid locale.'); } /** * @description Path to directory storing locale information. * @private * @type {string} * @default '../../strings/' * @constant */ this._stringsDir = dir; /** * @description Filename in locale directory to read strings from. * @private * @type {string} * @default '/global.js' * @constant */ this._stringsFilename = `/${filename}.js`; /** * @description Default and fallback locale. * @private * @type {string} * @default 'en_US' * @constant */ this._stringsDefault = `${defaultLocale.language}_${defaultLocale.territory}`; /** * @description Reference to default locale. This is used when a string key * is unable to be found in a locale, or the locale doesn't exist. * @public * @type {Strings~Locale} * @default */ this.defaultLocale = require( `${this._stringsDir}${this._stringsDefault}${this._stringsFilename}`); this.get = this.get.bind(this); } /** * @description Regular Expression to match a valid locale. Attempts to * conform to ISO/IEC 15897. Does not accept modifier. */ static get localRegExp() { return new RegExp( '^(?&lt;language&gt;[a-z]{2})(?:_(?&lt;territory&gt;[A-Z]{2}))?' + '(?:\\\\.(?&lt;codeset&gt;[^@]+))?$'); } /** * @description Parse the given string as a locale. * @public * @static * @param {string} locale The locale to parse. * @returns {?{ * language: string, * territory: ?string, * codeset: ?string * }} Matched groups or null if not a valid locale. */ static parseLocale(locale) { const match = typeof locale === 'string' &amp;&amp; locale.match(Strings.localRegExp); return match &amp;&amp; match.groups; } /** * @description Purge all strings from memory to force them to be reloaded. * Asynchronous. Does not complete immediately. * @public */ purge() { fs.readdir(`${__dirname}/${this._stringsDir}`, (err, files) =&gt; { if (err) { console.error(err); return; } for (const f of files) { delete require.cache[require.resolve( `${this._stringsDir}${f}${this._stringsFilename}`)]; } }); } /** * @description Get and format a specific string. * * @public * @static * @param {string} key String key to find. * @param {string} [locale] Lookup the string in a specific locale. * @param {...string} [rep] Data to replace placeholders in the string. * @returns {?string} Matched and replaced string, or null if unable to find. */ get(key, locale, ...rep) { const match = Strings.parseLocale(locale || this._stringsDefault); let localeGroup = this.defaultLocale; let lang = this._stringsDefault; if (!match) { console.error(`Unable to find locale: ${locale}`); } else { lang = `${match.language}_${match.territory}`; } try { localeGroup = require(`${this._stringsDir}${lang}${this._stringsFilename}`); } catch (err) { console.error(`Unable to find locale: ${lang}`); } return localeGroup.get(key, rep); } } Strings.Locale = Locale; module.exports = Strings; × Search results Close "},"locale_Locale.js.html":{"id":"locale_Locale.js.html","title":"Source: locale/Locale.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: locale/Locale.js // Copyright 2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) /** * @description Base locale class that stores strings for a single locale. * @memberof Strings * @inner */ class Locale { /** * @description Bind this. */ constructor() { this.get = this.get.bind(this); } /** * @description Get string with given key and replace placeholders. * @public * @this Locale * @param {string} key Key of string to lookup. * @param {...string} [rep] Placeholder replacement strings. * @returns {?string} String with replaced placeholders, or null if unable to * find. */ get(key, ...rep) { const s = this[key]; let i = -1; if (typeof s === 'string') { return s.replace(/\\{\\}/g, () =&gt; rep[++i]); } else { return null; } } } module.exports = Locale; × Search results Close "},"ticTacToe.js.html":{"id":"ticTacToe.js.html","title":"Source: ticTacToe.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: ticTacToe.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(TicTacToe); // Extends the SubModule class. /** * @classdesc Manages a tic-tac-toe game. * @class * @augments SubModule * @listens Command#ticTacToe */ function TicTacToe() { const self = this; /** @inheritdoc */ this.myName = 'TicTacToe'; /** @inheritdoc */ this.initialize = function() { self.command.on('tictactoe', commandTicTacToe); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('tictactoe'); }; /** @inheritdoc */ this.unloadable = function() { return numGames === 0; }; /** * Maximum amount of time to wait for reactions to a message. Also becomes * maximum amount of time a game will run with no input, because controls will * be disabled after this timeout. * * @private * @constant * @type {number} * @default 5 Minutes */ const maxReactAwaitTime = 5 * 1000 * 60; // 5 Minutes /** * Helper object of emoji characters mapped to names. * * @private * @type {Object.&lt;string&gt;} * @constant * @default */ const emoji = { 0: '\\u0030\\u20E3', 1: '\\u0031\\u20E3', 2: '\\u0032\\u20E3', 3: '\\u0033\\u20E3', 4: '\\u0034\\u20E3', 5: '\\u0035\\u20E3', 6: '\\u0036\\u20E3', 7: '\\u0037\\u20E3', 8: '\\u0038\\u20E3', 9: '\\u0039\\u20E3', X: '❌', O: '⭕', }; /** * The number of currently active games. Used to determine of submodule is * unloadable. * @private * @type {number} * @default */ let numGames = 0; /** * Starts a tic tac toe game. If someone is mentioned it will start a game * between the message author and the mentioned person. Otherwise, waits for * someone to play. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#ticTacToe */ function commandTicTacToe(msg) { const players = {p1: msg.author, p2: null}; if (msg.mentions.users.size &gt; 0) { players.p2 = msg.mentions.users.first(); } self.createGame(players, msg.channel); } /** * Class that stores the current state of a tic tac toe game. * * @class * * @public * @param {{p1: Discord~User, p2: Discord~User}} players The players in this * game. * @param {Discord~Message} msg The message displaying the current game. */ this.Game = function(players, msg) { const game = this; /** * The players in this game. * @type {{p1: Discord~User, p2: Discord~User}} */ this.players = players; /** * An array of 9 elements that stores 0, 1, or 2 to signify who owns which * space of the board. 0 is nobody, 1 is player 1, 2 is player 2. * @type {number[]} */ this.board = [0, 0, 0, 0, 0, 0, 0, 0, 0]; /** * Which player's turn it is. Either 1 or 2. * @type {number} */ this.turn = 1; /** * The message displaying the current game. * @type {Discord~Message} */ this.msg = msg; /** * The template string for the game's board. * * @private * @type {string} * @constant * @default */ const boardString = '```css\\n | | \\n{0}|{1}|{2}\\n___|___|___\\n' + ' | | \\n{3}|{4}|{5}\\n___|___|___\\n' + ' | | \\n{6}|{7}|{8}\\n | | \\n```'; /** * Edit the current message to show the current board. * * @param {number} [winner=0] The player who has won the game. 0 is game not * done, 1 is player 1, 2 is player 2, 3 is draw. */ this.print = function(winner = 0) { const embed = new self.Discord.MessageEmbed(); const names = ['Nobody', 'Nobody']; let gameFull = true; if (this.players.p1) { names[0] = this.players.p1.username; } else { gameFull = false; } if (this.players.p2) { names[1] = this.players.p2.username; } else { gameFull = false; } embed.setTitle(names[0] + ' vs ' + names[1]); if (!gameFull) { embed.setDescription('To join the game, just make a move!'); } const finalBoard = boardString.replace(/\\{(.)\\}/g, function(match, num) { switch (game.board[num]) { case 1: if (winner &gt; 0 &amp;&amp; winner != 1) return ' x '; return ' X '; case 2: if (winner &gt; 0 &amp;&amp; winner != 2) return ' o '; return ' O '; default: if (winner &gt; 0) return ' '; return ' ' + num + ' '; } }); embed.addField('\\u200B', finalBoard, true); if (winner == 0) { embed.addField( names[this.turn - 1] + '\\'s turn (' + (this.turn == 1 ? 'X' : 'O') + ')', '`' + names[0] + '` is X\\n`' + names[1] + '` is O', true); } else { numGames--; embed.addField( '\\u200B', '`' + names[0] + '` was X\\n`' + names[1] + '` was O', true); } if (winner == 3) { embed.addField('Draw game!', 'Nobody wins'); } else if (winner == 2) { embed.addField( names[1] + ' Won! ' + emoji.O, names[0] + ', try harder next time.'); } else if (winner == 1) { embed.addField( names[0] + ' Won! ' + emoji.X, names[1] + ', try harder next time.'); } msg.edit('\\u200B', embed); }; }; /** * Create a game with the given players in a given text channel. * * @public * @param {{p1: Discord~User, p2: Discord~User}} players The players in the * game. * @param {Discord~TextChannel} channel The text channel to send messages. */ this.createGame = function(players, channel) { numGames++; channel.send('`Loading TicTacToe...`').then((msg) =&gt; { const game = new self.Game(players, msg); game.print(); addReactions(msg); addListener(msg, game); }); }; /** * Add the reactions to a message for controls of the game. Recursive. * * @private * @param {Discord~Message} msg The message to add the reactions to. * @param {number} index The number of reactions we have added so far. */ function addReactions(msg, index = 0) { msg.react(emoji[index]).then(() =&gt; { if (index &lt; 8) addReactions(msg, index + 1); }); } /** * Add the listener for reactions to the game. * * @private * @param {Discord~Message} msg The message to add the reactions to. * @param {TicTacToe~Game} game The game to update when changes are made. */ function addListener(msg, game) { msg.awaitReactions(function(reaction, user) { if (user.id != self.client.user.id) { reaction.users.remove(user).catch(() =&gt; {}); } else { return false; } if (game.turn == 1 &amp;&amp; game.players.p1 &amp;&amp; user.id != game.players.p1.id) { return false; } if (game.turn == 2 &amp;&amp; game.players.p2 &amp;&amp; user.id != game.players.p2.id) { return false; } for (let i = 0; i &lt; 9; i++) { if (emoji[i] == reaction.emoji.name) return true; } return false; }, {max: 1, time: maxReactAwaitTime}).then(function(reactions) { if (reactions.size == 0) { msg.reactions.removeAll().catch(() =&gt; {}); msg.edit( 'Game timed out!\\nThe game has ended because nobody made a ' + 'move in too long!'); game.print(game.turn == 1 ? 2 : 1); return; } if (!game.players.p1 &amp;&amp; game.turn == 1) { game.players.p1 = reactions.first().users.first(2)[1]; } if (!game.players.p2 &amp;&amp; game.turn == 2) { game.players.p2 = reactions.first().users.first(2)[1]; } reactions.first().users.remove(self.client.user).catch(() =&gt; {}); let move = -1; const choice = reactions.first().emoji; for (let i = 0; i &lt; 9; i++) { if (emoji[i] == choice.name &amp;&amp; game.board[i] === 0) { move = i; break; } } if (move == -1) { addListener(msg, game); return; } game.board[move] = game.turn; const winner = checkWin(game.board, move); if (winner != 0) { msg.reactions.removeAll().catch(() =&gt; {}); } else { game.turn = game.turn === 1 ? 2 : 1; addListener(msg, game); } game.print(winner); }); } /** * Checks if the given board has a winner, or if the game is over. * * @param {number[]} board Array of 9 numbers defining a board. 0 is nobody, 1 * is player 1, 2 is player 2. * @param {number} latest The index where the latest move occurred. * @returns {number} Returns 0 if game is not over, 1 if player 1 won, 2 if * player 2 won, 3 if draw. */ function checkWin(board, latest) { const player = board[latest]; // Column for (let i = 1; i &lt; 3; i++) { if (board[(i * 3) % 9] != player) break; if (i == 2) return player; } // Row const row = Math.floor(latest / 3) * 3; for (let i = 1; i &lt; 3; i++) { if (board[(i + latest - row) % 3 + row] != player) break; if (i == 2) return player; } // Diagonals switch (latest) { case 0: case 4: case 8: if (board[0] == board[4] &amp;&amp; board[4] == board[8]) return player; break; default: break; } switch (latest) { case 2: case 4: case 6: if (board[2] == board[4] &amp;&amp; board[4] == board[6]) return player; break; default: break; } // Is board full for (let i = 0; i &lt; 9; i++) { if (board[i] == 0) return 0; } return 3; } } module.exports = new TicTacToe(); × Search results Close "},"tts.js.html":{"id":"tts.js.html","title":"Source: tts.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: tts.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const Readable = require('stream').Readable; const tts = require('@google-cloud/text-to-speech'); require('./subModule.js').extend(TTS); // Extends the SubModule class. const ttsRequest = { input: {text: 'Hello world!'}, voice: {languageCode: 'en-AU', ssmlGender: 'MALE'}, audioConfig: {audioEncoding: 'OGG_OPUS'}, }; /** * @classdesc Adds text-to-speech support for voice channels. * @class * @augments SubModule * @listens Command#tts * @listens Command#speak */ function TTS() { const self = this; /** @inheritdoc */ this.myName = 'TTS'; /** @inheritdoc */ this.helpMessage = null; /** @inheritdoc */ this.initialize = function() { self.command.on(['tts', 'speak'], commandTTS, true); if (self.bot.getBotName()) { process.env.GOOGLE_APPLICATION_CREDENTIALS = './gApiCredentials-' + self.bot.getBotName() + '.json'; } else { process.env.GOOGLE_APPLICATION_CREDENTIALS = './gApiCredentials.json'; } ttsClient = new tts.TextToSpeechClient(); }; /** @inheritdoc */ this.shutdown = function() { self.command.deleteEvent('tts'); }; let ttsClient; /** * The permission required to use TTS commands. * * @private * @constant * @default * @type {string} */ const ttsPermString = 'tts:all'; /** * Joins a user's voice channel and speaks the given message. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#tts * @listens Command#speak */ function commandTTS(msg) { self.bot.patreon.checkAllPerms( msg.author.id, msg.channel.id, msg.guild.id, ttsPermString, onGetPerms); /** * Callback for checking permissions for command. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: boolean, message: string}} info The returned data if * there was no error. */ function onGetPerms(err, info) { if (err) { self.common.reply( msg, 'Oops! I wasn\\'t able to do that for you...', err); return; } else if (!info.status) { self.common.reply( msg, 'Sorry, but you aren\\'t able to use this command.', info.message); return; } self.bot.patreon.getSettingValue( msg.author.id, msg.channel.id, msg.guild.id, ttsPermString, onGetSettings); } let matchedSettings; /** * After checking if a user has permission for this command, send the * request too Google with the user's settings. * * @private * @type {Patreon~basicCB} * @param {?string} err The error string, or null if no error. * @param {?{status: string, message: string}} info The returned data if * there was no error. */ function onGetSettings(err, info) { if (err || !info.status) { self.common.reply( msg, 'Oops! Something went wrong while looking for your settings...', err || 'Received NULL'); self.error( 'Failed to fetch settings for tts:all: ' + msg.author.id + ' (' + (err || 'Received NULL') + ')'); return; } matchedSettings = info.status.match(/(\\w\\w-\\w\\w)-([MF])/); if (!matchedSettings) { self.common.reply( msg, 'Oops! Something went wrong while reading your settings...', 'Invalid Value'); self.error( 'User has invalid setting for tts:all: ' + msg.author.id + ' (' + info.status + ')'); return; } if (!msg.member.voice || !msg.member.voice.channel) { self.common.reply( msg, 'Oops! You must be in a voice channel for this command.'); return; } if (msg.member.voice.channel.connection) { onJoinVoice(msg.member.voice.channel.connection); } else { msg.member.voice.channel.join().then(onJoinVoice).catch(() =&gt; { self.common.reply( msg, 'Oops! I wasn\\'t able to join your voice channel.'); return; }); } } let vConn; /** * @description Successfully joined a voice channel, now we can request * audio data from Google. * * @private * @param {Discord~VoiceConnection} conn The voice channel connection. */ function onJoinVoice(conn) { if (msg.text.length &lt;= 1) { self.common.reply( msg, 'Please specify what you want me to say after the command.'); return; } vConn = conn; const thisRequest = Object.assign({}, ttsRequest); thisRequest.input.text = msg.text.slice(1); thisRequest.voice.languageCode = matchedSettings[1]; thisRequest.voice.ssmlGender = matchedSettings[2] == 'F' ? 'FEMALE' : 'MALE'; ttsClient.synthesizeSpeech(thisRequest, onSpeechResponse); } /** * Response from Google with TTS audio data. * * @private * @param {?Error} err Errors in request. * @param {?object} res Response. */ function onSpeechResponse(err, res) { if (err) { self.common.reply( msg, 'Oops! Google wasn\\'t able to turn that into audio...'); self.error('Google failed to create audio data.'); console.error(err); return; } self.common.reply( msg, 'Saying \"' + msg.text.slice(1) + '\" in ' + msg.member.voice.channel.name); const readable = new Readable(); readable._read = function() {}; vConn.play(readable); readable.push(res.audioContent); } } } module.exports = new TTS(); × Search results Close "},"uno.js.html":{"id":"uno.js.html","title":"Source: uno.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: uno.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) require('./subModule.js').extend(Uno); // Extends the SubModule class. /** * @classdesc Manages an Uno game. * @class * @augments SubModule * @listens Command#uno */ function Uno() { const self = this; /** @inheritdoc */ this.myName = 'Uno'; /** @inheritdoc */ this.initialize = function() { pFlags = self.Discord.Permissions.FLAGS; self.command.on( new self.command.SingleCommand( ['uno', 'one'], commandUno, {validOnlyInGuild: true}, [ new self.command.SingleCommand('endall', commandEndAll, { validOnlyInGuild: true, permissions: pFlags.MANAGE_CHANNELS, defaultDisabled: true, }), new self.command.SingleCommand('stats', commandStats), ])); }; /** @inheritdoc */ this.shutdown = function() { self.command.removeListener('uno'); const list = Object.values(games); list.forEach((el) =&gt; { const list = Object.values(el); list.forEach((el) =&gt; { if (typeof el.end === 'function') el.end(); }); }); }; /** @inheritdoc */ this.unloadable = function() { return numGames &lt;= 0; }; /** * ASCII art text to show when a player calls Uno. * @private * @constant * @default * @type {string} */ const unoText = '888 888 888b 888 .d88888b. 888 \\n' + '888 888 8888b 888 d88P\" \"Y88b 888 \\n' + '888 888 88888b 888 888 888 888 \\n' + '888 888 888Y88b 888 888 888 888 \\n' + '888 888 888 Y88b888 888 888 888 \\n' + '888 888 888 Y88888 888 888 Y8P \\n' + 'Y88b. .d88P 888 Y8888 Y88b. .d88P \" \\n' + ' \"Y88888P\" 888 Y888 \"Y88888P\" 888 '; /** * The number of currently active games. Used to determine of submodule is * unloadable. * @private * @type {number} * @default */ let numGames = 0; /** * self.Discord.Permissions.FLAGS * @private */ let pFlags = null; /** * All games currently in progress mapped by guilds, then by the game ID. * @private * @type {Object.&lt;Object.&lt;Uno.Game&gt;&gt;} */ const games = {}; /** * Delay for NPC to play their card. * @private * @type number * @default * @constant */ const npcDelay = 5000; /* eslint-disable no-multi-spaces */ /** * Default names of NPCs to add when adding non-bot NPCs. * @private * @default * @constant * @type {string[]} */ const npcNames = [ 'HAL', 'Jane', 'HEX', 'Deep Thought', 'Com Pewter', 'EDI', 'JARVIS', 'Samantha', 'TARS', 'Ava', 'Friday', 'Legion', 'Cortana', 'GLaDOS', 'Guilty Spark', '2B', '9S', 'CL4P-TP', 'Computer', 'NPC', 'AI', 'Bot', 'CPU', 'R2D2', 'AUTO', 'CASE', 'Alexa', 'Bixby', ]; /* eslint-enable */ /** * Maximum number of players allowed in a game. * @private * @type number * @default * @constant */ const maxPlayerCount = 10; /** * Starts an Uno game. If someone is mentioned it will start a game * between the message author and the mentioned person. Otherwise, waits for * someone to play. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#uno */ function commandUno(msg) { if (!msg.guild.me.hasPermission(pFlags.MANAGE_CHANNELS)) { self.common.reply( msg, 'I need permission to manage channels in order to start a game of ' + 'UNO.'); return; } if (games[msg.guild.id]) { const entries = Object.values(games[msg.guild.id]); const g = entries.find((el) =&gt; el.getPlayers().includes(msg.author.id)); if (g) { if (g.groupChannel.id == msg.channel.id) { return; } self.common.reply( msg, 'You appear to already be in a game. ' + 'You may only be in one game at a time.'); return; } } self.common.reply( msg, 'Creating a game of UNO.', 'Please be aware, Uno is still in BETA and has many known bugs.'); if (!games[msg.guild.id]) games[msg.guild.id] = {}; const newGame = new self.Game( (msg.mentions.members.array() || []).concat([msg.member]), msg.member); games[msg.guild.id][newGame.id] = newGame; } /** * Ends all Uno games. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#uno_endall */ function commandEndAll(msg) { if (!msg.guild.me.hasPermission(pFlags.MANAGE_CHANNELS)) { self.common.reply(msg, 'I don\\'t have permission to manage channels.'); return; } if (!games[msg.guild.id]) { self.common.reply( msg, 'There are no UNO games in progress in this server.'); return; } const list = Object.values(games[msg.guild.id]); list.forEach((g) =&gt; { if (typeof g.end == 'function') g.end(); }); delete games[msg.guild.id]; self.common.reply(msg, 'All UNO games have been ended.').catch(() =&gt; {}); } /** * Sends information about current uno games. * * @private * @type {commandHandler} * @param {Discord~Message} msg Message that triggered command. * @listens Command#uno_stats */ function commandStats(msg) { if (msg.author.id == self.common.spikeyId &amp;&amp; numGames &gt; 0) { let lastInteractTimestamp = 0; let lastCreatedTimestamp = 0; const list = Object.values(games); list.forEach((el) =&gt; { const list = Object.values(el); list.forEach((el) =&gt; { lastInteractTimestamp = Math.max(el.lastInteractTimestamp, lastInteractTimestamp); lastCreatedTimestamp = Math.max(el.createTimestamp, lastCreatedTimestamp); }); }); self.common.reply( msg, 'There are currently ' + numGames + ' games.', 'Last Interaction: ' + Math.round((Date.now() - lastInteractTimestamp) / 60000) + 'm\\nLast Created: ' + Math.round((Date.now() - lastCreatedTimestamp) / 60000) + 'm'); } else { self.common.reply(msg, 'There are currently ' + numGames + ' games.'); } } /** * Enum for card colors. * @public * @constant * @default * @enum {number} */ this.Color = { NONE: 0, RED: 1, BLUE: 2, GREEN: 3, YELLOW: 4, }; /** * Color as entries. * * @private * @constant */ const colorPairs = Object.entries(self.Color); /** * Regular expression search for acceptable colors. Case insensitive and * global flags are set. * * @private * @constant * @type {RegExp} */ const colorRegExp = new RegExp(colorPairs.map((el) =&gt; el[0]).join('|'), 'ig'); /** * Enum for card faces. The two least significant nibbles are the card face. * The most significant used nibbles are for card effects (designated by the * EFFECT_MASK). * * BASE_MASK is the bitwise not of EFFECT_MASK, except on only the nibbles * that are less significant than EFFECT_MASK. * * 0x01000: The card is a wild card. * 0x02000: The card skips the next player's turn. * 0x04000: The card reverses play direction. * 0x08000: The card causes the next player after the turn is over, to draw 2 * cards. * 0x10000: The next player must draw 4 cards. * * EFFECT entries are NOT real card faces, just the bitfield represented with * that effect. * * @public * @constant * @enum {number} */ this.CardFace = { // Card Face Effects Bases EFFECT_MASK: 0xFF000, BASE_MASK: 0x00FFF, WILD_EFFECT: 0x01000, SKIP_EFFECT: 0x02000, REVERSE_EFFECT: 0x04000, DRAW_TWO_EFFECT: 0x08000, DRAW_FOUR_EFFECT: 0x10000, // Card Faces SKIP: 0x02010, DRAW_TWO: 0x0A020, DRAW_2: 0x0A020, REVERSE: 0x04030, WILD: 0x01040, DRAW_FOUR: 0x13050, DRAW_4: 0x13050, ZERO: 0x0, 0: 0x0, ONE: 0x1, 1: 0x1, TWO: 0x2, 2: 0x2, THREE: 0x3, 3: 0x3, FOUR: 0x4, 4: 0x4, FIVE: 0x5, 5: 0x5, SIX: 0x6, 6: 0x6, SEVEN: 0x7, 7: 0x7, EIGHT: 0x8, 8: 0x8, NINE: 0x9, 9: 0x9, }; /** * CardFace as entries. * * @private */ const cardFacePairs = Object.entries(self.CardFace).filter((el) =&gt; { return !el[0].endsWith('_EFFECT') &amp;&amp; !el[0].endsWith('_MASK'); }); /** * Regular expression search for acceptable card faces. Case insensitive and * global flags are set. * * @private * @constant * @type {RegExp} */ const cardFaceRegExp = new RegExp( cardFacePairs.map((el) =&gt; el[0].replace(/_/g, ' ')).join('|'), 'ig'); /** * Class that stores the current information about a particular card. All * cards with the same color and face value are represented here using the * `count` attribute. * * @class * * @public * @param {CardFace} face The face value or type of card this is. * @param {Color} color The color of this card. */ this.Card = function(face, color) { if (typeof face !== 'number') { throw new Error('Given value for card face is not a number!'); } const card = this; /** * The face value of this card. * @public * @type {Uno.CardFace} */ this.face = face; if (typeof color !== 'number') { throw new Error('Given value for card color is not a number!'); } /** * The color of this card. * @public * @type {Uno.Color} */ this.color = color; /** * The name of this card retreivable with `toString()`. Null until first * `toString()` call. * * @private * @type {?string} */ let myName; /** * Stringifies the face and colors to their key names. * * @public * * @returns {string} This card as a string. */ this.toString = function() { // Wild cards can change color, so we can't cache their name. if (myName &amp;&amp; !(card.face &amp; self.CardFace.WILD_EFFECT)) return myName; const face = formatCard(cardFacePairs.find((el) =&gt; el[1] == card.face)[0]); if (card.color == self.Color.NONE) { myName = face; } else { let colorName = colorPairs.find((el) =&gt; el[1] == card.color); if (!colorName) { self.error('Unable to format card to string.'); console.log(card); console.log(card.color, 'not a valid color'); colorName = colorPairs.find((el) =&gt; el[0] == card.color); if (colorName) { card.color = colorName[1]; } } colorName = formatCard(colorName[0]); myName = colorName + ' ' + face; } return myName; }; }; /** * Class that stores the current state of an Uno game. * * @class * * @public * @param {Discord~GuildMember[]} memberList The players to initially add to * this game. * @param {Discord~GuildMember} maker The player who created the game and can * change settings and manage users. */ this.Game = function(memberList, maker) { const game = this; numGames++; if (!memberList || !memberList.length) { throw new Error('Member list must be an array of Discord.GuildMembers.'); } if (!maker || !maker.guild) { throw new Error('Game maker must be a guild member.'); } /** * The guild members in this game mapped by their ID. * * @private * @type {Object.&lt;Discord~GuildMember&gt;} */ const members = {}; do { /** * The ID of this uno game. Should be unique per guild. * * @public * @readonly * @type {number} */ this.id = Math.floor((Math.random() * 1000)); } while (games[maker.guild.id][game.id]); /** * The array of all player in the game in the order of their turn. * * @private * @type {Array.&lt;Uno.Player|Uno.NPC&gt;} */ const players = []; /** * The category that stores all channels for this game. Null until it is * created. * * @public * @type {?Discord~CategoryChannel} */ this.catChannel = null; /** * The channel that all players of this game can view and type in. Null * until the channel is created. * * @public * @type {?Discord~TextChannel} */ this.groupChannel = null; /** * All cards currently not in a player's hand. * * @private * @type {Uno.Card[]} */ let discarded = self.getHand(); /** * Has this game been started. * * @public * @default * @readonly * @type {boolean} */ this.started = false; /** * The timestamp at which this game was first created. * * @public * @readonly * @constant * @type {number} */ this.createTimestamp = Date.now(); /** * The timestamp at which this game was last interacted with. * * @public * @readonly * @constant * @type {number} */ this.lastInteractTimestamp = Date.now(); /** * The current index of the player whose turn it is. * * @private * @default * @type {number} */ let turn = -1; /** * If we need to wait for the player to choose a color for a wild card. * `null` if not waiting, or a reference to the player we are waiting for. * * @private * @default * @type {Uno.Player} */ // let waitingForColor = -1; /** * The current number of cards a player will need to draw if they cannot * stack another draw card. * * @private * @type {number} */ // let drawCount = 0; /** * The card played by the previous player in the turn order. Will be null * after a player has been skipped, since they did not play a card. * @see {@link Uno.Game~topCard} * * @private * @type {?Uno.Card} */ // let previousCard = null; /** * The index of the player whose turn it was previously. This is -1 if the * current turn is the first turn of the game, and will otherwise be the * previous player to play a card. * * @private * @type {number} */ let previousTurn = -1; /** * The current card on the top of the discard pile that will need to be * matched by the next player to play a card. * @see {@link Uno.Game~previousCard} * * @private * @type {?Uno.Card} */ let topCard = null; /** * The current direction of play. Either 1 or -1. * * @private * @default * @type {number} */ let direction = 1; /** * The current Discord~MessageCollector that is listening to messages in the * groupChannel. * * @private * @default * type {?Discord~MessageCollector} */ let currentCollector = null; /** * Creates all channels for this game and currently added players. * * @private */ (function setupChannels() { const channelOpts = { topic: 'UNO! (ID:' + game.id + ')', type: 'category', reason: 'An UNO game was started by ' + maker.user.tag, }; const groupPerms = [ { id: maker.guild.defaultRole, allow: 0, deny: pFlags.VIEW_CHANNEL | pFlags.SEND_MESSAGES, type: 'role', }, { id: self.client.user.id, allow: pFlags.VIEW_CHANNEL | pFlags.SEND_MESSAGES, deny: 0, type: 'member', }, ]; for (let i = 0; i &lt; memberList.length; i++) { members[memberList[i].id] = memberList[i]; groupPerms.push({ id: memberList[i].id, allow: pFlags.VIEW_CHANNEL | pFlags.SEND_MESSAGES, deny: 0, type: 'member', }); } maker.guild.channels.create('uno-' + game.id, channelOpts).then((c) =&gt; { game.catChannel = c; maker.guild.channels .create('uno-' + game.id, { topic: 'UNO! (ID:' + game.id + ')', type: 'text', reason: 'An UNO game was started by ' + maker.user.tag, permissionOverwrites: groupPerms, parent: c, }) .then((c) =&gt; { game.groupChannel = c; let fail = false; for (let i = 0; i &lt; memberList.length &amp;&amp; !fail; i++) { fail = fail || !game.addPlayer(memberList[i]); } if (memberList.length &gt; maxPlayerCount) { setTimeout(function() { c.send( 'A maximum of ' + maxPlayerCount + ' players are allowed'); }, 1000); } finishSetup(); }); }); })(); /** * Begins listening for messages in the groupChannel that relate to the * setup of the game, and sends a message to the group channel with game * instructions. * * @private */ function finishSetup() { sendHelp().then(() =&gt; { // This is disabled during testing as to not annoy others with // random notifications. /* game.groupChannel.permissionOverwrites.get(maker.guild.defaultRole) .update({VIEW_CHANNEL: true}); */ }); if (currentCollector) { currentCollector.stop( 'Previous collector failed to end before setup finish.'); // This is normal after a bot wins the game since it does not properly // end the previous collector. } currentCollector = game.groupChannel.createMessageCollector((m) =&gt; { const prefix = self.bot.getPrefix(m.guild); if (m.content.startsWith(prefix)) { m.content = m.content.replace(prefix, ''); } if (m.author.id != maker.id) { if (m.content.toLowerCase().startsWith('uno leave')) { // self.debug(m.channel.id + '@' + m.author.id + ' ' + m.content); game.removePlayer(m.author.id); } return false; } if (m.content.toLowerCase().startsWith('uno')) { const split = m.content.toLowerCase().split(' '); game.lastInteractTimestamp = Date.now(); // self.debug(m.channel.id + '@' + m.author.id + ' ' + m.content); const cmd = split[1]; switch (cmd) { case 'begin': case 'start': if (players.length &gt; 1) { setTimeout(startGame); return true; } else { self.common.reply( m, 'You can\\'t play by yourself! `invite` other players to' + ' join you first.'); return false; } case 'end': case 'abort': case 'stop': game.end(); return true; case 'players': case 'list': listPlayers(); return false; case 'invite': if (m.mentions.members.size == 0) { self.common.reply(m, 'Please mention users to invite.'); } else { let fail = false; m.mentions.members.forEach((m) =&gt; { fail = fail || !game.addPlayer(m); }); if (fail) { self.common.reply( m, 'There is a limit of ' + maxPlayerCount + ' players.'); } else { self.common.reply(m, 'Players have been added to the game.'); } } return false; case 'npc': case 'ai': case 'bot': { const subCmd = split[2]; switch (subCmd) { case 'add': { const num = split[3]; if (isNaN(num)) { self.common.reply( m, 'Please specify how many NPCs to add.'); } else { const fail = game.addNPCs(num); if (!fail) { self.common.reply( m, 'There is a maximum of ' + maxPlayerCount + ' players allowed.'); } else { self.common.reply(m, 'Added NPCs.'); } } return false; } case 'remove': { const num = split[3]; if (isNaN(num)) { self.common.reply( m, 'Please specify how many NPCs to remove.'); } else { game.removeNPCs(num); self.common.reply(m, 'Removed NPCs.'); } return false; } } break; } case 'kick': { let bad = false; m.mentions.members.forEach((el) =&gt; { if (el.id != maker.id) game.removePlayer(el); else bad = true; }); if (bad) { self.common.reply( m, 'As the game creator you cannot leave the game.\\nIf' + ' you wish to end the game, use `uno end`.'); } listPlayers(); return false; } case 'leave': self.common.reply( m, 'As the game creator you cannot leave the game.\\nIf' + ' you wish to end the game, use `uno end`.'); return false; } return false; } }, {max: 1}); currentCollector.on('end', () =&gt; { currentCollector = null; }); } /** * Send the list of current players in this game to the group channel. */ function listPlayers() { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Current Players'); embed.setDescription(players.map((p) =&gt; p.name).join(', ')); embed.setColor('WHITE'); game.groupChannel.send(embed); } /** * Deal cards to all players, and start the game. * * @private */ function startGame() { game.groupChannel.updateOverwrite( maker.guild.defaultRole, { VIEW_CHANNEL: false, }, 'UNO game has starte.'); for (turn = 0; turn &lt; players.length; turn++) { players[turn].hand = []; drawCards(7, true); } game.groupChannel.send('`Cards have been dealt.`'); turn = -1; game.started = true; // Play the game's first card. playCard(); if (currentCollector) { currentCollector.stop( 'Previous collector failed to end before game start.'); self.warn('Ending previous collector that should not exist.'); } currentCollector = game.groupChannel.createMessageCollector((m) =&gt; { const prefix = self.bot.getPrefix(m.guild); if (m.content.startsWith(prefix)) { m.content = m.content.replace(prefix, ''); } // Check for Uno calls. if (m.content.match(/^uno\\W*$/i)) { game.lastInteractTimestamp = Date.now(); callUno(m.author.id); return false; } if (m.author.id == maker.id &amp;&amp; m.content.toLowerCase().startsWith('uno')) { game.lastInteractTimestamp = Date.now(); // self.debug(m.channel.id + '@' + m.author.id + ' ' + m.content); switch (m.content.toLowerCase().split(' ')[1]) { case 'end': game.end(); return true; case 'kick': { let bad = false; m.mentions.members.forEach((el) =&gt; { if (el.id != maker.id) game.removePlayer(el); else bad = true; }); if (bad) { self.common.reply( m, 'As the game creator you cannot leave the game.\\nIf' + ' you wish to end the game, use `uno end`.'); } listPlayers(); return false; } } } if (turn &lt; 0 || m.author.id != players[turn].id) return false; if (m.content.toLowerCase().startsWith('uno')) { game.lastInteractTimestamp = Date.now(); // self.debug(m.channel.id + '@' + m.author.id + ' ' + m.content); const cmd = m.content.toLowerCase().split(' ')[1]; switch (cmd) { case 'play': if (playCard(m.content.split(' ').slice(2).join(' '))) { endGame(); return true; } else { return false; } case 'leave': game.removePlayer(m.author.id); return false; } return false; } else if (m.content.toLowerCase().startsWith('play')) { game.lastInteractTimestamp = Date.now(); // self.debug(m.channel.id + '@' + m.author.id + ' ' + m.content); if (playCard(m.content.split(' ').slice(1).join(' '))) { endGame(); return true; } else { return false; } } else if (m.content.toLowerCase().startsWith('draw')) { game.lastInteractTimestamp = Date.now(); // self.debug(m.channel.id + '@' + m.author.id + ' ' + m.content); drawAndSkip(); game.groupChannel.send(getCardEmbed(topCard)); return false; } }, {max: 1}); currentCollector.on('end', () =&gt; { currentCollector = null; }); } /** * Called after a game has been won by somebody. Clears all players of their * cards, and resets the game to ready for next game state. * * @private */ function endGame() { setTimeout(finishSetup, 5000); game.started = false; turn = -1; players.forEach((p) =&gt; { discarded = discarded.concat(p.hand.splice(0)); }); } /** * @description Sends the game help to the group channel. * * @private * @returns {Promise.&lt;Discord~Message&gt;} Promise of command help being sent * to the channel. */ function sendHelp() { const embed = new self.Discord.MessageEmbed(); embed.setTitle('Welcome to UNO! (Beta)'); embed.setAuthor(maker.user.tag); embed.setColor([237, 21, 31]); embed.setDescription( 'Just type `UNO!` into this channel to call uno.\\nTo play a card, ' + 'just type `play red 4` or `play yellow two` or `play draw 4` or ' + 'something like that.\\nIf you play a wild card, you must say what ' + 'color it is when you play it (eg: `play wild red` or `play yellow ' + 'draw four`).\\n`draw` to draw a card.'); embed.addField( 'Current Rules', 'Original rules (non-point based) as described here: ' + 'https://www.unorules.com/\\nWith the following exceptions:\\n' + '1) Challenging a plus four card is not in this version,\\n' + '2) If you draw a card, you do not get to play it until your ' + 'next turn.'); embed.addField( 'Player Commands', 'If you do not wish to be in this game anymore, just type ' + '`uno leave` in this channel, and you will be removed.'); if (!game.started) { embed.addField( 'Lobby Settings', 'The creator of this game can use the following commands in this ' + 'channel.\\n\\nUse `invite @SpikeyRobot#0971` to add new people' + ' to this game.\\nUse `uno npc add 2` to add 2 NPCs or `uno ' + 'npc remove 3` to remove 3 NPCs.\\nType `uno kick ' + '@SpikeyRobot#0971` to remove them from the game (Note: ' + 'don\\'t use the command prefix).\\nType `uno start` to start ' + 'the game once you\\'re ready!\\n`uno end` to end this game at ' + 'any time.'); } else { embed.addField( 'Lobby Settings', 'The creator of this game can use the following commands in this ' + 'channel.\\n\\n`uno end` to end this game at any time (this ' + 'deletes all Uno text channels).\\n`uno kick @SpikeyRobot#0971' + '` to kick players (Careful! They cannot be added back during' + ' the game!).'); } return game.groupChannel.send(embed); } /** * Called after a player's turn, to trigger the next player's turn. * * @param {boolean} [skip=false] True to add additional message saying this * player is skipped. Also doesn't send the player their hand. True if this * turn is intended to be skipped. * @private */ function nextTurn(skip) { if (turn &gt; -1 &amp;&amp; !players[turn].npc) { players[turn].channel.send( '`Your current hand:`', getCardEmbed(players[turn].hand)); } if (turn == -1) turn = Math.floor(Math.random() * players.length); turn += direction; if (turn &lt; 0) turn = players.length - 1; if (turn &gt; players.length - 1) turn = 0; if (skip) { game.groupChannel.send( '`Skipping` ' + players[turn].mention + '\\'s turn!'); } else { game.groupChannel.send( '`Next turn.` ' + players[turn].mention + '\\'s turn! They have ' + players[turn].hand.length + ' cards.'); if (players[turn].npc) setTimeout(playCard, npcDelay); } } /** * Cause the current player to draw cards from the discarded pile, then skip * their turn and continue to the next player. * * @private * @param {number} [num=1] The number of cards to draw. */ function drawAndSkip(num = 1) { drawCards(num); // previousCard = null; nextTurn(); } /** * Cause the current player to draw cards from the discarded pile. * * @private * @param {number} num The number of cards to draw. * @param {boolean} [silent=false] Do not send a message to the group * channel. */ function drawCards(num, silent = false) { const drawn = []; for (let j = 0; j &lt; num; j++) { if (discarded.length == 0) break; const single = discarded.splice( Math.floor(Math.random() * discarded.length), 1)[0]; if (single.face &amp; self.CardFace.WILD_EFFECT) { single.color = self.Color.NONE; } drawn.push(single); } players[turn].hand = drawn.concat(players[turn].hand); if (!players[turn].npc) { players[turn].hand = players[turn].hand.sort((a, b) =&gt; { if (a.face == b.face) { return a.color - b.color; } else { return a.face - b.face; } }); } if (!silent) { game.groupChannel.send( '`' + players[turn].name + '` drew ' + num + ' card' + (num == 1 ? '' : 's') + ' from the deck.'); if (!players[turn].npc) { players[turn].channel.send( '`You drew:` ' + drawn.map((card) =&gt; card.toString()).join(', ')); } } else { if (!players[turn].npc) { players[turn].channel.send( '`Your current hand`', getCardEmbed(players[turn].hand)); } } players[turn].calledUno = false; } /** * Play a card for the current player. * * @private * @param {?string} text User inputted text to parse into a card to play. * @returns {boolean} True if the game has ended. False if the game should * continue. */ function playCard(text) { let selected = -1; let hand; let color; // Used if a wild card was played. if (turn == -1) { // First card to be played. No restrictions, any card can be played. selected = Math.floor(Math.random() * discarded.length); hand = discarded; if (hand[selected].face &amp; self.CardFace.WILD_EFFECT) { color = colorPairs[Math.floor(Math.random() * (colorPairs.length - 1)) + 1][1]; } } else { hand = players[turn].hand; if (players[turn].npc) { if (previousTurn &gt; -1 &amp;&amp; !players[previousTurn].calledUno &amp;&amp; players[previousTurn].hand.length == 1 &amp;&amp; Math.random() &lt; players[turn].probCallUno) { callUno(players[turn].id); setTimeout(function() { playCard(text); }, npcDelay); return; } let i = hand.length; // Cards are in order of how they were drawn from the deck. This // prioritizes the oldest cards first. do { selected = --i; } while (selected &gt;= 0 &amp;&amp; !checkCard(hand[selected])); if (selected &lt; 0) { drawAndSkip(); return false; } if (hand[selected].face &amp; self.CardFace.WILD_EFFECT) { const handColors = []; hand.forEach((el) =&gt; { if (el.color != self.Color.NONE &amp;&amp; !handColors.includes(el.color)) { handColors.push(el.color); } }); color = handColors.length == 0 ? colorPairs[Math.floor(Math.random() * (colorPairs.length - 1)) + 1][1] : handColors[Math.floor(Math.random() * handColors.length)]; } if (hand.length == 2) { if (Math.random() &lt;= players[turn].probCallUno) { const myId = players[turn].id; setTimeout(function() { callUno(myId); }, players[turn].delayCallUno); } } } else if (!text || !text.trim()) { game.groupChannel.send( '`Please specify a card, that you have, to play.`'); return false; } else { const parsed = parseToCard(text); if (!parsed) { game.groupChannel.send( '`I\\'m not sure what card that is.`\\n' + text); return false; } if (parsed.face &amp; self.CardFace.WILD_EFFECT) { if (parsed.color == self.Color.NONE) { game.groupChannel.send( '`Please specify a color to make this card.`'); return false; } else { color = parsed.color; } } if (!((parsed.face == topCard.face) || (parsed.face &amp; self.CardFace.WILD_EFFECT || parsed.color == topCard.color))) { game.groupChannel.send( '`That\\'s not a valid card to play. The current card is`', getCardEmbed(topCard)); return false; } selected = hand.findIndex((el) =&gt; { return parsed.face == el.face &amp;&amp; (parsed.face &amp; self.CardFace.WILD_EFFECT || parsed.color == el.color); }); if (selected &lt; 0) { game.groupChannel.send( '`You don\\'t have that card.` Please play a card that you ' + 'have, or \\'draw\\' to draw a card from the deck.'); return false; } } } const card = hand.splice(selected, 1)[0]; if (topCard) { discarded.push(topCard); } topCard = card; // previousCard = card; if (color) { card.color = color; } if (turn &gt; -1 &amp;&amp; players[turn].hand.length &gt; 0) { game.groupChannel.send( '`' + players[turn].name + '` has ' + players[turn].hand.length + ' cards.', getCardEmbed(card)); } else { game.groupChannel.send(getCardEmbed(card)); } if (hand.length == 0) { game.groupChannel.send( players[turn].mention + ' `has no cards remaining!`\\n```' + players[turn].name + ' is the winner!```'); if (players[turn].npc) endGame(); return true; } previousTurn = turn; let skipping = false; if (card.face &amp; self.CardFace.REVERSE_EFFECT) { direction *= -1; if (players.length == 2) { skipping = true; } } /* if (card.face &amp; self.CardFace.WILD_EFFECT &amp;&amp; !card.color) { waitingForColor = players[turn].id; } */ nextTurn(skipping || card.face &amp; self.CardFace.SKIP_EFFECT); if (card.face &amp; self.CardFace.DRAW_TWO_EFFECT) { drawCards(2); // previousCard = null; } if (card.face &amp; self.CardFace.DRAW_FOUR_EFFECT) { drawCards(4); // previousCard = null; } if (skipping || card.face &amp; self.CardFace.SKIP_EFFECT) { nextTurn(); } return false; } /** * Parse a string of text to a playable card. * * @private * * @param {string} text The user-input to parse. * @returns {?Uno.Card} The matched card, or null if no match. */ function parseToCard(text) { const replaced = text.replace(/_/g, ' '); const colorMatch = replaced.match(colorRegExp); const faceMatch = replaced.match(cardFaceRegExp); if (!faceMatch) return null; if (faceMatch.length != 1) return null; faceMatch[0] = faceMatch[0].replace(/ /g, '_'); let color = self.Color.NONE; if (colorMatch &amp;&amp; colorMatch.length == 1) { color = self.Color[colorMatch[0].toUpperCase()]; } const face = self.CardFace[faceMatch[0].toUpperCase()]; // If not a wild card, and no color was chosen. if (!(face &amp; self.CardFace.WILD_EFFECT) &amp;&amp; color == self.Color.NONE) { return null; } return new self.Card(face, color); } /** * Checks if the given card may be played next. * * @see {@link Uno.Game~topCard} * * @private * @param {Uno.Card} card The card to check. * @param {Uno.Card} [card2] The card to check against. If not defined, the * current topCard will be used. * @returns {boolean} True if can be played, false otherwise. */ function checkCard(card, card2) { if (card.face &amp; self.CardFace.WILD_EFFECT) return true; card2 = card2 || topCard; const cardFace = card.face &amp; self.CardFace.BASE_MASK; const card2Face = card2.face &amp; self.CardFace.BASE_MASK; return (cardFace == card2Face) || (card.color == card2.color); } /** * A player has called Uno. To say that they are about to have one card, * they now have one card after playing, or the previous person now has one * card and did not call Uno. * * @private * @param {string|number} caller The user ID of the player who called Uno. */ function callUno(caller) { if (players[turn].id == caller &amp;&amp; !players[turn].calledUno &amp;&amp; players[turn].hand.length == 2) { players[turn].calledUno = true; const mention = players[turn].mention; game.groupChannel.send(`${mention} called\\`\\`\\`\\n${unoText}\\n\\`\\`\\``); } if (previousTurn &gt; -1) { if (players[previousTurn].id == caller &amp;&amp; !players[previousTurn].calledUno &amp;&amp; players[previousTurn].hand.length == 1) { players[previousTurn].calledUno = true; const mention = players[previousTurn].mention; game.groupChannel.send(`${mention} called\\`\\`\\`\\n${unoText}\\n\\`\\`\\``); } if (!players[previousTurn].calledUno &amp;&amp; players[previousTurn].hand.length == 1) { game.groupChannel.send( players[previousTurn].mention + ' `forgot to call \"UNO!\" and now must draw 2 cards!`'); const tmp = turn; turn = previousTurn; drawCards(2); turn = tmp; } } } /** * Ends this game and deletes all created channels. * * @public */ this.end = function() { if (currentCollector) currentCollector.stop('Game has ended'); if (game.groupChannel) { game.groupChannel.delete('The UNO game has ended.'); } if (players) { players.forEach((p) =&gt; { if (p.channel) p.channel.delete('The UNO game has ended.'); }); } if (game.catChannel) { game.catChannel.delete('The UNO game has ended.'); } delete games[maker.guild.id][game.id]; numGames--; }; /** * Add the given guild member to the game. * * @public * * @param {Discord~GuildMember} p The member to add to the game. * @returns {boolean} Success if true, failed if false. */ this.addPlayer = function(p) { if (!p) return; if (!game.catChannel) { memberList.push(p); return true; } if (players.length &gt;= maxPlayerCount) { return false; } if (p.user.bot) { players.push( new self.NPC( p.nickname || p.user.username, game, {id: p.id, bot: true})); } else { players.push(new self.Player(p, game)); } game.groupChannel.updateOverwrite( p.user.id, { VIEW_CHANNEL: true, SEND_MESSAGES: true, }, 'Player added to game.'); return true; }; /** * Add a certain number of NPCs into the game. * * @public * * @param {number} [num=1] The number of NPCs to add. * @returns {boolean} Success if true, failed if false. */ this.addNPCs = function(num = 1) { let added = 0; for (let i = 0; i &lt; num &amp;&amp; players.length &lt; maxPlayerCount; i++) { let name; const names = players.map((el) =&gt; el.name); do { name = npcNames[Math.floor(Math.random() * npcNames.length)]; } while (names.includes(name)); const npc = new self.NPC(name, game); players.push(npc); added++; } return added == num; }; /** * Remove a certain number of NPCs from the game. * * @public * * @param {number} [num=1] The number of NPCs to remove. * @returns {boolean} Success if true, failed if false. */ this.removeNPCs = function(num = 1) { let j = 0; for (let i = 0; j &lt; num &amp;&amp; i &lt; players.length; i++) { if (players[i].npc &amp;&amp; !players[i].bot) { players.splice(i, 1); i--; j++; } } return j == num; }; /** * Remove the user with the given ID from the game. * * @public * * @param {string|number|Discord~GuildMember|Uno.Player} p The ID of the * user to remove. */ this.removePlayer = function(p) { if (typeof p === 'object') p = p.id; if (!p) return; if (!players || !players.length || p.id == maker.id) return; const index = players.findIndex((player) =&gt; player.id == p); if (index &gt; -1) { players[index].remove(); discarded = discarded.concat(players[index].hand.splice(0)); players.splice(index, 1); const perms = game.groupChannel.permissionOverwrites.get(p); if (perms) perms.delete('User removed from game'); if (turn == index) nextTurn(); } }; /** * Returns the list of all players currently in this game. * * @public * * @returns {string[]|number[]} Array of player IDs. Type is number-like. */ this.getPlayers = function() { return players.map((el) =&gt; { return el.id; }); }; }; /** * A single player in the game. * * @public * @param {Discord~GuildMember} member The guild member this is based off of. * @param {Uno.Game} parent The parent game this player will be in. */ this.Player = function(member, parent) { const player = this; if (typeof member !== 'object') { throw new Error('A new player must be based off of a GuildMember.'); } const permOverwrites = [ { id: member.guild.defaultRole, allow: 0, deny: pFlags.VIEW_CHANNEL, type: 'role', }, { id: member.id, allow: pFlags.VIEW_CHANNEL, deny: pFlags.SEND_MESSAGES, type: 'member', }, { id: self.client.user.id, allow: pFlags.VIEW_CHANNEL | pFlags.SEND_MESSAGES, deny: 0, type: 'member', }, ]; const channelOpts = Object.assign({ topic: (member.nickname || member.user.username) + '\\'s UNO cards.', parent: parent.catChannel, permissionOverwrites: permOverwrites, type: 'text', reason: 'An UNO game was started.', }); /** * The Discord ID of this player. * @public * @readonly * @type {string} */ this.id = member.id; /** * The name of this player. * @public * @readonly * @type {string} */ this.name = member.nickname || member.user.username; /** * String for mentioning this user in chat. * * @public * @readonly * @type {string} */ this.mention = `&lt;@${this.id}&gt;`; /** * Whether this player is a npc or not. Must be false. Use Uno.NPC for bots. * * @public * @readonly * @default false * @type {boolean} */ this.npc = false; /** * Whether this player has called uno recently. * * @public * @type {boolean} * @default */ this.calledUno = false; /** * The channel for this player's private messages for the game. Null until * the channel is created. * @public * @readonly * @type {?Discord~TextChannel} */ this.channel = null; member.guild.channels .create( parent.catChannel.name + '-' + (member.nickname || member.user.username), channelOpts) .then((channel) =&gt; { player.channel = channel; channel.send( player.mention + ' You have been added to this game of Uno!\\n\\nThis channel ' + 'will show you the cards you currently have in your hand once ' + 'the game starts.\\n\\nUse &lt;#' + parent.groupChannel.id + '&gt; to play your cards and talk to other players!'); }) .catch((err) =&gt; { self.error( 'Failed to create private text channel for member: ' + member.id + ' in guild: ' + member.guild.id); console.error(err); if (parent.groupChannel) { parent.groupChannel.send( 'Failed to create text channel for ' + member.user.tag); } }); /** * The current cards that this player has in their hand. * @public * @type {Uno.Card[]} */ this.hand = []; /** * Remove this player from a game. Deletes the player's text channel. * * @public */ this.remove = function() { if (player.channel) { player.channel.delete('Player was removed from the UNO game.'); } }; }; /** * A single non-player character in the game. This is the same as a normal * player, except they are not given a text channel, and their actions are * controlled by us. * * @public * @param {string} name The display name of this NPC. * @param {Uno.Game} parent The parent game this player will be in. * @param {NPCOpts} [options] Optional options for this NPC. */ this.NPC = function(name, parent, options) { if (typeof options !== 'object') options = {}; /** * The ID of this npc. Must be uniqueness is not enforced, but is required. * @public * @readonly * @type {string} */ this.id = options.id || `NPC${name}`; /** * The name of this player. * @public * @readonly * @type {string} */ this.name = name; /** * String for mentioning this user in chat. * * @public * @readonly * @type {string} */ this.mention = `\\`${this.name}\\``; /** * Whether this player is a Discord bot or not. * * @public * @readonly * @default false * @type {boolean} */ this.bot = false; if (typeof options.bot === 'boolean') this.bot = options.bot; /** * Whether this player is a NPC or not. Always true. * * @public * @readonly * @default true * @type {boolean} */ this.npc = true; /** * Whether this player has called uno recently. * * @public * @type {boolean} * @default */ this.calledUno = false; /** * The current cards that this player has in their hand. * * @public * @type {Uno.Card[]} */ this.hand = []; /** * Probability this NPC will call uno when necessary. * * @public * @type {number} * @default 0.5 */ this.probCallUno = options.probCallUno || 0.5; /** * Delay before calling uno if this NPC is going to call it. (Milliseconds) * * @public * @type {number} * @default 3000 */ this.delayCallUno = options.delayCallUno || 3000; /** * Remove this player from a game. Cleans up references if any exist. * * @public */ this.remove = function() {}; }; /** * Format a hand of cards or a single card into Discord~MessageEmbed. * * @private * @param {Uno~Card|Uno~Card[]} hand The card or hand of cards to format. * @returns {Discord~MessageEmbed} The MessageEmbed to send to the user. */ function getCardEmbed(hand) { const embed = new self.Discord.MessageEmbed(); const colors = {}; if (hand instanceof self.Card) hand = [hand]; hand.forEach((card) =&gt; { if (!colors[card.color]) colors[card.color] = [card.toString()]; else colors[card.color].push(card.toString()); }); const noTitle = hand.length == 1; colorPairs.forEach((c) =&gt; { if (!colors[c[1]] || !c[1]) return; colors[c[1]].sort(); const str = colors[c[1]].join('\\n'); if (noTitle) { embed.setTitle(str); } else { embed.addField(c[0], str, true); } }); if (colors[0]) { colors[0].sort(); const str = colors[0].join('\\n'); if (noTitle) { embed.setTitle(str); } else { embed.addField('WILD', str, true); } } else if (hand.length == 1) { if (hand[0].color == self.Color.YELLOW) { embed.setColor('GOLD'); } else { embed.setColor(colorPairs.find((el) =&gt; el[1] == hand[0].color)[0]); } } return embed; } /** * Takes a string that is all caps with underscores and makes it more human * readable. * * @private * @param {string} txt The text to format. * @returns {string} The formatted text. */ function formatCard(txt) { return txt.replace(/_/g, ' ') .split(' ') .map((el) =&gt; { return el.charAt(0).toUpperCase() + el.substring(1).toLowerCase(); }) .join(' '); } /** * @description A default hand of cards that the classic game starts with. * * @returns {Uno.Card[]} An array of all cards in a deck. */ this.getHand = function() { const c = self.Color; const f = self.CardFace; /* eslint-disable no-multi-spaces */ return [ new self.Card(f.ZERO, c.RED), new self.Card(f.ZERO, c.GREEN), new self.Card(f.ZERO, c.YELLOW), new self.Card(f.ZERO, c.BLUE), new self.Card(f.ONE, c.RED), new self.Card(f.ONE, c.RED), new self.Card(f.ONE, c.GREEN), new self.Card(f.ONE, c.GREEN), new self.Card(f.ONE, c.YELLOW), new self.Card(f.ONE, c.YELLOW), new self.Card(f.ONE, c.BLUE), new self.Card(f.ONE, c.BLUE), new self.Card(f.TWO, c.RED), new self.Card(f.TWO, c.RED), new self.Card(f.TWO, c.GREEN), new self.Card(f.TWO, c.GREEN), new self.Card(f.TWO, c.YELLOW), new self.Card(f.TWO, c.YELLOW), new self.Card(f.TWO, c.BLUE), new self.Card(f.TWO, c.BLUE), new self.Card(f.THREE, c.RED), new self.Card(f.THREE, c.RED), new self.Card(f.THREE, c.GREEN), new self.Card(f.THREE, c.GREEN), new self.Card(f.THREE, c.YELLOW), new self.Card(f.THREE, c.YELLOW), new self.Card(f.THREE, c.BLUE), new self.Card(f.THREE, c.BLUE), new self.Card(f.FOUR, c.RED), new self.Card(f.FOUR, c.RED), new self.Card(f.FOUR, c.GREEN), new self.Card(f.FOUR, c.GREEN), new self.Card(f.FOUR, c.YELLOW), new self.Card(f.FOUR, c.YELLOW), new self.Card(f.FOUR, c.BLUE), new self.Card(f.FOUR, c.BLUE), new self.Card(f.FIVE, c.RED), new self.Card(f.FIVE, c.RED), new self.Card(f.FIVE, c.GREEN), new self.Card(f.FIVE, c.GREEN), new self.Card(f.FIVE, c.YELLOW), new self.Card(f.FIVE, c.YELLOW), new self.Card(f.FIVE, c.BLUE), new self.Card(f.FIVE, c.BLUE), new self.Card(f.SIX, c.RED), new self.Card(f.SIX, c.RED), new self.Card(f.SIX, c.GREEN), new self.Card(f.SIX, c.GREEN), new self.Card(f.SIX, c.YELLOW), new self.Card(f.SIX, c.YELLOW), new self.Card(f.SIX, c.BLUE), new self.Card(f.SIX, c.BLUE), new self.Card(f.SEVEN, c.RED), new self.Card(f.SEVEN, c.RED), new self.Card(f.SEVEN, c.GREEN), new self.Card(f.SEVEN, c.GREEN), new self.Card(f.SEVEN, c.YELLOW), new self.Card(f.SEVEN, c.YELLOW), new self.Card(f.SEVEN, c.BLUE), new self.Card(f.SEVEN, c.BLUE), new self.Card(f.EIGHT, c.RED), new self.Card(f.EIGHT, c.RED), new self.Card(f.EIGHT, c.GREEN), new self.Card(f.EIGHT, c.GREEN), new self.Card(f.EIGHT, c.YELLOW), new self.Card(f.EIGHT, c.YELLOW), new self.Card(f.EIGHT, c.BLUE), new self.Card(f.EIGHT, c.BLUE), new self.Card(f.NINE, c.RED), new self.Card(f.NINE, c.RED), new self.Card(f.NINE, c.GREEN), new self.Card(f.NINE, c.GREEN), new self.Card(f.NINE, c.YELLOW), new self.Card(f.NINE, c.YELLOW), new self.Card(f.NINE, c.BLUE), new self.Card(f.NINE, c.BLUE), new self.Card(f.DRAW_TWO, c.RED), new self.Card(f.DRAW_TWO, c.RED), new self.Card(f.DRAW_TWO, c.GREEN), new self.Card(f.DRAW_TWO, c.GREEN), new self.Card(f.DRAW_TWO, c.YELLOW), new self.Card(f.DRAW_TWO, c.YELLOW), new self.Card(f.DRAW_TWO, c.BLUE), new self.Card(f.DRAW_TWO, c.BLUE), new self.Card(f.SKIP, c.RED), new self.Card(f.SKIP, c.RED), new self.Card(f.SKIP, c.GREEN), new self.Card(f.SKIP, c.GREEN), new self.Card(f.SKIP, c.YELLOW), new self.Card(f.SKIP, c.YELLOW), new self.Card(f.SKIP, c.BLUE), new self.Card(f.SKIP, c.BLUE), new self.Card(f.REVERSE, c.RED), new self.Card(f.REVERSE, c.RED), new self.Card(f.REVERSE, c.GREEN), new self.Card(f.REVERSE, c.GREEN), new self.Card(f.REVERSE, c.YELLOW), new self.Card(f.REVERSE, c.YELLOW), new self.Card(f.REVERSE, c.BLUE), new self.Card(f.REVERSE, c.BLUE), new self.Card(f.WILD, c.NONE), new self.Card(f.WILD, c.NONE), new self.Card(f.WILD, c.NONE), new self.Card(f.WILD, c.NONE), new self.Card(f.DRAW_FOUR, c.NONE), new self.Card(f.DRAW_FOUR, c.NONE), new self.Card(f.DRAW_FOUR, c.NONE), new self.Card(f.DRAW_FOUR, c.NONE), ]; /* eslint-enable no-multi-spaces */ }; } module.exports = new Uno(); × Search results Close "},"web_account.js.html":{"id":"web_account.js.html","title":"Source: web/account.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: web/account.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (web@campbellcrowley.com) const fs = require('fs'); const http = require('http'); const https = require('https'); const socketIo = require('socket.io'); const auth = require('../../auth.js'); const patreon = require('patreon'); const mkdirp = require('mkdirp'); // mkdir -p const querystring = require('querystring'); const PATREON_CLIENT_ID = auth.patreonClientId; const PATREON_CLIENT_SECRET = auth.patreonClientSecret; const redirectURL = 'https://www.spikeybot.com/redirect/'; const patreonAPI = patreon.patreon; const patreonOAuthClient = patreon.oauth(PATREON_CLIENT_ID, PATREON_CLIENT_SECRET); require('../subModule.js').extend(WebAccount); // Extends the SubModule class. /** * @classdesc Manages the account webpage. * @class * @augments SubModule */ function WebAccount() { const self = this; this.myName = 'WebAccount'; const app = http.createServer(handler); const io = socketIo( app, {path: '/www.spikeybot.com/socket.io/', serveClient: false}); app.on('error', function(err) { if (err.code === 'EADDRINUSE') { self.warn( 'Accounts failed to bind to port because it is in use. (' + err.port + ')'); self.shutdown(true); } else { self.error('Account failed to bind to port for unknown reason.', err); } }); /** * The filename in the user's directory of the file where the settings related * to Patreon rewards are stored. * * @private * @constant * @default * @type {string} */ const patreonSettingsFilename = '/patreonSettings.json'; /** * File where the template for the Patreon settings is stored. * @see {@link WebAccount~patreonSettingsTemplate} * * @private * @constant * @default * @type {string} */ const patreonSettingsTemplateFile = './save/patreonSettingTemplate.json'; /** * The parsed data from {@link WebAccount~patreonSettingsTemplateFile}. Data * that outlines the available options that can be changed, and their possible * values. * @private * * @default * @type {Object.&lt;Object&gt;} */ let patreonSettingsTemplate = {}; const defaultSpotifyTokenReq = { protocol: 'https:', host: 'accounts.spotify.com', path: '/api/token', method: 'POST', headers: { 'Authorization': 'Basic ' + (Buffer.from(auth.spotifyId + ':' + auth.spotifySecret) .toString('base64')), 'Content-Type': 'application/x-www-form-urlencoded', }, }; const defaultSpotifyUserReq = { protocol: 'https:', host: 'api.spotify.com', path: '/v1/me', method: 'GET', }; /** * Parse template from file. * * @see {@link WebAccount~patreonSettingsTemplate} * @private */ function updatePatreonSettingsTemplate() { fs.readFile(patreonSettingsTemplateFile, (err, data) =&gt; { if (err) { self.error('Failed to read ' + patreonSettingsTemplateFile); return; } try { const parsed = JSON.parse(data); if (!parsed) return; patreonSettingsTemplate = parsed; } catch (e) { self.error('Failed to parse ' + patreonSettingsTemplateFile); console.error(e); } }); } updatePatreonSettingsTemplate(); fs.watchFile(patreonSettingsTemplateFile, (curr, prev) =&gt; { if (curr.mtime == prev.mtime) return; if (self.initialized) { self.log('Re-reading Patreon setting template information from file'); } else { console.log( 'WebAccount: Re-reading setting template information from file'); } updatePatreonSettingsTemplate(); }); /** @inheritdoc */ this.initialize = function() { app.listen(self.common.isRelease ? 8014 : 8015, '127.0.0.1'); self.bot.accounts = toExport; self.common.connectSQL(); }; const toExport = {}; /** * Causes a full shutdown of all servers. * * @public */ this.shutdown = function() { if (io) io.close(); if (app) app.close(); fs.unwatchFile(patreonSettingsTemplateFile); }; /** @inheritdoc */ this.unloadable = function() { return true; }; /** * Handler for all http requests. Should never be called. * * @private * @param {http.IncomingMessage} req The client's request. * @param {http.ServerResponse} res Our response to the client. */ function handler(req, res) { res.writeHead(418); res.end('TEAPOT'); } /** * Map of all currently connected sockets. * * @private * @type {Object.&lt;Socket&gt;} */ const sockets = {}; io.on('connection', socketConnection); /** * Handler for a new socket connecting. * * @private * @param {socketIo~Socket} socket The socket.io socket that connected. */ function socketConnection(socket) { // x-forwarded-for is trusted because the last process this jumps through is // our local proxy. const ipName = self.common.getIPName( socket.handshake.headers['x-forwarded-for'] || socket.handshake.address); self.common.log( 'Socket connected (' + Object.keys(sockets).length + '): ' + ipName, socket.id); sockets[socket.id] = socket; socket.on('getAccountInfo', (userData, cb) =&gt; { if (typeof cb !== 'function') { self.error('NO CB'); return; } if (!userData) { cb('Not signed in.', null); return; } fetchDiscordSQL(); /** * Fetch the Discord table data from our SQL server. * * @private */ function fetchDiscordSQL() { const toSend = global.sqlCon.format( 'SELECT * FROM Discord WHERE id=? LIMIT 1', [userData.id]); global.sqlCon.query(toSend, (err, rows) =&gt; { if (err) { self.error(err); cb('Server Error', null); return; } fetchPatreonSQL((rows &amp;&amp; rows[0]) || {}); }); } /** * Fetch the Patreon info from our SQL server. * * @private * * @param {object} data The data previously received to add the Patreon * info onto. */ function fetchPatreonSQL(data) { if (!data.patreonId) { fetchSpotifySQL(data); return; } const toSend = global.sqlCon.format( 'SELECT * FROM Patreon WHERE id=? LIMIT 1', [data.patreonId]); global.sqlCon.query(toSend, (err, rows) =&gt; { if (err) { self.error(err); cb('Server Error', null); return; } if (rows &amp;&amp; rows.length &gt; 0) { data.patreon = rows[0]; } fetchSpotifySQL(data); }); } /** * Fetch the Spotify info from our SQL server. * * @private * * @param {object} data The data previously received to add the Spotify * info onto. */ function fetchSpotifySQL(data) { if (!data.spotifyId) { fetchDiscordBot(data); return; } const toSend = global.sqlCon.format( 'SELECT * FROM Spotify WHERE id=? LIMIT 1', [data.spotifyId]); global.sqlCon.query(toSend, (err, rows) =&gt; { if (err) { self.error(err); cb('Server Error', null); return; } if (rows &amp;&amp; rows.length &gt; 0) { data.spotify = { id: rows[0].id, haveToken: rows[0].access_token !== null, name: rows[0].name, }; } fetchDiscordBot(data); }); } /** * Fetch the Discord user information through the Discord bot API. * * @private * * @param {object} data The data previously received to add the Discord * user info onto, then send to the client. */ function fetchDiscordBot(data) { self.client.users.fetch(userData.id) .then((user) =&gt; { data.username = user.username; data.avatarURL = user.displayAvatarURL(); data.createdAt = user.createdAt; data.discriminator = user.discriminator; data.activity = user.presence.activity; cb(null, data); }) .catch((err) =&gt; { cb('Server Error', null); self.error('Failed to fetch user data from discord.'); console.error(err); }); } }); socket.on('linkPatreon', (userData, code, cb) =&gt; { if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } validatePatreonCode(code, userData.id, socket.id, cb); }); socket.on('unlinkPatreon', (userData, cb) =&gt; { if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } updateUserPatreonId(userData.id, null, cb); }); socket.on('linkSpotify', (userData, code, cb) =&gt; { if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } validateSpotifyCode(code, userData.id, socket.id, cb); }); socket.on('unlinkSpotify', (userData, cb) =&gt; { if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } updateUserSpotifyId(userData.id, null, cb); }); socket.on('getSettingsTemplate', (userData, cb) =&gt; { if (typeof cb !== 'function') { self.error('Requested setting template without callback.', socket.id); return; } cb(patreonSettingsTemplate); }); socket.on('getUserSettings', (userData, cb) =&gt; { if (!userData) { cb('Not signed in.', null); return; } getPatreonSettings(userData.id, cb); }); socket.on('getUserPerms', (userData, cb) =&gt; { if (!userData) { cb('Not signed in.', null); return; } if (!self.bot.patreon) { self.error('Patreon submodule has not been loaded!'); cb('Internal Error', null); } else { self.bot.patreon.getAllPerms(userData.id, null, null, cb); } }); socket.on('changeSetting', (userData, setting, value, cb) =&gt; { if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } changePatreonSetting(userData.id, setting, value, cb); }); socket.on('disconnect', () =&gt; { self.common.log( 'Socket disconnected (' + (Object.keys(sockets).length - 1) + '): ' + ipName, socket.id); delete sockets[socket.id]; }); } /** * @description Validate a code received from the client, then use it to * retrieve the user ID associated with it. * * @private * @param {string} code The code received from Patreon OAuth2 flow. * @param {string|number} userid The Discord user ID associated with this code * in order to link accounts. * @param {string} ip The unique identifier for this connection for logging * purposes. * @param {Function} cb Callback with a single parameter. The parameter is a * string if there was an error, or null if no error. */ function validatePatreonCode(code, userid, ip, cb) { patreonOAuthClient.getTokens(code, redirectURL) .then(function(tokensResponse) { const patreonAPIClient = patreonAPI(tokensResponse.access_token); return patreonAPIClient('/current_user'); }) .then(function(result) { const store = result.store; const users = store.findAll('user').map((user) =&gt; user.serialize()); if (!users || users.length &lt; 1 || !users[0].data || !users[0].data.id) { self.common.error('Failed to get patreonid', ip); cb('Internal Server Error'); return; } updateUserPatreonId(userid, users[0].data.id, cb); }) .catch(function(err) { self.common.error('Failed to get patreonId'); console.error(err); cb('Internal Server Error'); }); } /** * @description Validate a code received from the client, then use it to * retrieve the user ID associated with it. * * @private * @param {string} code The code received from Patreon OAuth2 flow. * @param {string|number} userid The Discord user ID associated with this code * in order to link accounts. * @param {string} ip The unique identifier for this connection for logging * purposes. * @param {Function} cb Callback with a single parameter. The parameter is a * string if there was an error, or null if no error. */ function validateSpotifyCode(code, userid, ip, cb) { const req = https.request(defaultSpotifyTokenReq, (res) =&gt; { let content = ''; res.on('data', (chunk) =&gt; { content += chunk; }); res.on('end', () =&gt; { if (res.statusCode == 200) { handleSpotifyTokenResponse(userid, content, ip, cb); } else { self.common.error(content, ip); cb('Internal Server Error'); return; } }); }); /* eslint-disable @typescript-eslint/camelcase */ req.end(querystring.stringify({ code: code, redirect_uri: redirectURL, grant_type: 'authorization_code', })); /* eslint-enable @typescript-eslint/camelcase */ } /** * Handle the response after successfully requesting the user's tokens. * * @private * * @param {string|number} userid Discord user id. * @param {string} content The response from Spotify. * @param {string} ip Unique identifier for the client that caused this to * happen. Used for logging. * @param {Function} cb Callback with single parameter, string if error, null * if no error. */ function handleSpotifyTokenResponse(userid, content, ip, cb) { let parsed; try { parsed = JSON.parse(content); } catch (err) { cb('Internal Server Error'); self.common.error('Failed to parse token response from Spotify.', ip); console.error(err); return; } const vals = { accessToken: parsed.access_token, expiresIn: parsed.expires_in, expiresAt: dateToSQL(Date.now() + parsed.expires_in * 1000), }; if (parsed.refresh_token) { vals.refreshToken = parsed.refresh_token; } const req = https.request(defaultSpotifyUserReq, (res) =&gt; { let content = ''; res.on('data', (chunk) =&gt; { content += chunk; }); res.on('end', () =&gt; { if (res.statusCode == 200) { handleSpotifyUserResponse(userid, content, vals, ip, cb); } else { self.common.error(content, ip); cb('Internal Server Error'); return; } }); }); req.setHeader('Authorization', 'Bearer ' + vals.accessToken); req.end(); } /** * @description Handle the response after successfully requesting the user's * basic account information. * @private * * @param {string|number} userid Discord user id. * @param {string} content The response from Spotify. * @param {{accessToken: string, expiresIn: number, expiresAt: string, * refreshToken: string}} vals The object storing user session information. * @param {string} ip Unique identifier for the client that caused this to * happen. Used for logging. * @param {Function} cb Callback with single parameter, string if error, null * if no error. */ function handleSpotifyUserResponse(userid, content, vals, ip, cb) { let parsed; try { parsed = JSON.parse(content); } catch (err) { self.common.error('Failed to parse user response from Spotify.', ip); console.error(err); cb('Internal Server Error'); return; } vals.id = parsed.id; vals.name = parsed.display_name; const toSend = global.sqlCon.format( 'INSERT INTO Spotify (id,name,accessToken,refreshToken,tokenExpiresAt' + ') VALUES (?,?,?,?,?) ON DUPLICATE KEY UPDATE accessToken=?,token' + 'ExpiresAt=?', [ vals.id, vals.name, vals.accessToken, vals.refreshToken, vals.expiresAt, vals.accessToken, vals.expiresAt, ]); global.sqlCon.query(toSend, (err) =&gt; { if (err) { self.common.error('Failed to update Spotify table with user data.', ip); console.error(err); cb('Internal Server Error'); return; } updateUserSpotifyId(userid, vals.id, cb); }); } /** * @description Update our Discord table with the retrieved patreon account ID * for the Discord user. * * @private * @param {string|number} userid The Discord ID of the user to link to the * patreonid. * @param {string|number} patreonid The Patreon id of the account to link to * the Discord ID. * @param {Function} cb Callback with single argument that is string if error, * or null if no error. */ function updateUserPatreonId(userid, patreonid, cb) { const toSend = global.sqlCon.format( 'UPDATE Discord SET patreonId=? WHERE id=?', [patreonid, userid]); global.sqlCon.query(toSend, (err) =&gt; { if (err) { self.common.error('Failed to update patreonId in Discord table.'); console.log(err); cb('Internal Server Error'); } else { cb(null); } }); } /** * @description Update our Discord table with the retrieved spotify account ID * for the Discord user. Deletes row from Spotify table if the userId is * falsey. * * @private * @param {string|number} userid The Discord ID of the user to link to the * patreonid. * @param {string|number} spotifyid The Spotify id of the account to link to * the Discord ID. * @param {Function} cb Callback with single argument that is string if error, * or null if no error. */ function updateUserSpotifyId(userid, spotifyid, cb) { if (!spotifyid) { const toSendGet = global.sqlCon.format( 'SELECT spotifyId FROM Discord WHERE id=?', [userid]); global.sqlCon.query(toSendGet, (err, rows) =&gt; { if (err) { self.common.error('Failed to fetch spotifyId from Discord table.'); console.log(err); cb('Internal Server Error'); } else { const toSend2 = global.sqlCon.format( 'DELETE FROM Spotify WHERE id=?', [rows[0].spotifyId]); global.sqlCon.query(toSend2, (err) =&gt; { if (err) { self.common.error( 'Failed to delete spotifyId from Spotify table.'); console.log(err); cb('Internal Server Error'); } else { setId(); } }); } }); } else { setId(); } /** * Send request to sql server. */ function setId() { const toSend = global.sqlCon.format( 'UPDATE Discord SET spotifyId=? WHERE id=?', [spotifyid, userid]); global.sqlCon.query(toSend, (err) =&gt; { if (err) { self.common.error('Failed to update spotifyId in Discord table.'); console.log(err); cb('Internal Server Error'); } else { cb(null); } }); } } /** * Fetch a user's current patreon settings from file. * * @private * * @param {string|number} userid Thd Discord id of the user to lookup. * @param {Function} cb Callback with 2 parameters, the first is the error * string or null if no error, the second will be the settings object if there * is no error. */ function getPatreonSettings(userid, cb) { fs.readFile( self.common.userSaveDir + userid + patreonSettingsFilename, (err, data) =&gt; { if (err) { cb(err, null); return; } try { cb(null, JSON.parse(data)); } catch (e) { cb(e, null); } }); } /** * Change a user's setting that is related to Patreon rewards. * * @private * * @param {string|number} userid The Discord id of the user to change the * setting for. * @param {string} setting The name of the setting to change. * @param {string} value The value to set the setting to. * @param {Function} cb Callback that is called once the operations are * complete with a single parameter for errors, string if error, null if none. */ function changePatreonSetting(userid, setting, value, cb) { const dirname = self.common.userSaveDir + userid; const filename = dirname + patreonSettingsFilename; const split = setting.split(' '); setting = split[0]; /** * Make the directory for writing the user's settings if it does not exist * already. * * @private * @param {?Error} err The error in readin the existing file. * @param {?string} data The data read from the existing file if any. */ function makeDirectory(err, data) { if (err) { mkdirp(dirname, function(err) { writeFile(err, data); }); } else { writeFile(null, data); } } /** * Checks that the setting that was requested to be changed is a valid * setting to change. * * @private * @param {object} obj The template object to compare the request against. * @param {string[]} s The array of each setting key that was a part of * the request. * @param {string|number} value The value to change the setting to. * @returns {boolean} True if the request was invalid in some way, or false * if everything is fine. */ function isInvalid(obj, s, value) { const type = obj.type; let valid = false; if (type === 'select') { for (let i = 0; i &lt; obj.values.length; i++) { if (obj.values[i] == value) { valid = true; break; } } } else if (type === 'number') { if (!isNaN(Number(value))) valid = true; if (valid &amp;&amp; obj.range) { if (value &lt; obj.range.min || value &gt; obj.range.max) { valid = false; } } } else if (type === 'string') { valid = true; } else if (type === 'color') { valid = typeof value === 'string' &amp;&amp; value.match(/^0x[0-9a-fA-f]{6,9}$/); } else if (type === 'boolean') { valid = typeof value === 'boolean' || (typeof value === 'string' &amp;&amp; (value.toLowerCase() === 'false' || value.toLowerCase() === 'true')); } else if (type === 'object') { return isInvalid(obj.values[s[0]], s.slice(1), value); } if (!valid) { cb('Invalid Value', {status: type || 'NOTYPE', message: value}); return true; } else { return false; } } /** * Write the modified data to file. * * @private * * @param {?Error} err The error in creating the directory. * @param {?string} file The current file data that was read. */ function writeFile(err, file) { let parsed = {}; if (file != null) { try { parsed = JSON.parse(file); } catch (e) { self.error( 'Failed to parse ' + self.common.userSaveDir + userid + patreonSettingsFilename); console.error(e); cb('Internal Error'); return; } } if (split.length &gt; 1) { if (!parsed[setting]) parsed[setting] = {}; let obj = parsed[setting]; while (split.length &gt; 2) { const next = split.splice(1, 1)[0]; if (!obj[next]) obj[next] = {}; obj = obj[next]; } obj[split[1]] = value; } else { parsed[setting] = value; } fs.writeFile(filename, JSON.stringify(parsed), (err) =&gt; { if (!err) { cb(null); return; } self.error('Failed to write user settings to file: ' + filename); console.error(err); cb('Internal Error'); }); } if (patreonSettingsTemplate[setting] == null) { cb('Invalid Setting'); return; } else { if (isInvalid(patreonSettingsTemplate[setting], split.slice(1), value)) { return; } } fs.readFile(filename, makeDirectory); } /** * Get a current access token for a given discord user to make a request to * the Spotify API. * * @public * * @param {string|number} uId The Discord user id to get the token for. * @param {Function} cb Callback with a single argument that is the token, or * null if no token is available. */ toExport.getSpotifyToken = function(uId, cb) { let firstAttempt = true; let sId; const toSend = global.sqlCon.format( 'SELECT spotifyId FROM Discord WHERE id=? LIMIT 1', [uId]); global.sqlCon.query(toSend, (err, rows) =&gt; { if (err) { self.error(err); cb(null); return; } if (rows[0]) { fetchSpotifySQL(rows[0].spotifyId); } else { fetchSpotifySQL(null); } }); /** * Request the user's Spotify info from our SQL server. * * @private * * @param {string} id The spotify ID of the user to fetch. */ function fetchSpotifySQL(id) { if (!id) { cb(null); return; } sId = id; const toSend = global.sqlCon.format( 'SELECT * FROM Spotify WHERE id=? LIMIT 1', [sId]); global.sqlCon.query(toSend, (err, rows) =&gt; { if (err) { self.error(err); cb(null); return; } const expiresAt = new Date(rows[0].tokenExpiresAt); if (Date.now() - expiresAt.getTime() &gt; 0) { refreshSpotifyToken(rows[0].refreshToken); } else { cb(rows[0].accessToken); } }); } /** * Use the user's refresh token to request a new access token. Only * attempted once. * * @private * * @param {string} token The refresh token to use. */ function refreshSpotifyToken(token) { if (!firstAttempt || !token) { cb(null); return; } firstAttempt = false; const req = https.request(defaultSpotifyTokenReq, (res) =&gt; { let content = ''; res.on('data', (chunk) =&gt; { content += chunk; }); res.on('end', () =&gt; { if (res.statusCode == 200) { handleSpotifyTokenResponse(uId, content, null, (err) =&gt; { if (err) { cb(null); } else { fetchSpotifySQL(sId); } }); } else { self.error(content); cb(null); return; } }); }); /* eslint-disable @typescript-eslint/camelcase */ req.end(querystring.stringify({ refresh_token: token, grant_type: 'refresh_token', })); /* eslint-enable @typescript-eslint/camelcase */ } }; /** * Convert the given date into a format that SQL can understand. * * @private * @param {*} date Something that `new Date()` can interpret. * @returns {string} Formatted Datetime string not including fractions of a * second. */ function dateToSQL(date) { date = new Date(date); return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + ' ' + date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds(); } } module.exports = new WebAccount(); × Search results Close "},"web_webhooks.js.html":{"id":"web_webhooks.js.html","title":"Source: web/webhooks.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: web/webhooks.js // Copyright 2018 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const http = require('http'); const auth = require('../../auth.js'); require('../subModule.js').extend(WebCommands); // Extends the SubModule class. const basicAuth = 'Basic ' + (auth.commandUsername + ':' + auth.commandPassword).toString('base64'); /** * @classdesc Handles receiving webhooks requests from external services. * @class * @augments SubModule */ function WebCommands() { const self = this; this.myName = 'Webhooks'; let app; /** @inheritdoc */ this.initialize = function() { app = http.createServer(handler); setTimeout(() =&gt; { app.listen(self.common.isRelease ? 8018 : 8019, '127.0.0.1'); }); app.on('error', function(err) { if (err.code === 'EADDRINUSE') { self.warn( 'Webhooks failed to bind to port because it is in use. (' + err.port + ')'); self.shutdown(true); } else { self.error('Webhooks failed to bind to port for unknown reason.', err); } }); }; /** @inheritdoc */ this.shutdown = function() { if (app) app.close(); }; /** * Handler for all http requests. * * @private * @param {http.IncomingMessage} req The client's request. * @param {http.ServerResponse} res Our response to the client. */ function handler(req, res) { const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'ERROR'; if (req.method !== 'POST') { res.writeHead(405); res.end(); self.common.log( 'Requested endpoint with invalid method: ' + req.method + ' ' + req.url, ip); } else if (req.url.indexOf('/webhook/botstart') &gt; -1) { self.common.logDebug('Bot start webhook request: ' + req.url, ip); let content = ''; req.on('data', (chunk) =&gt; { content += chunk; }); req.on('end', () =&gt; { self.debug('Bot start webhook content: ' + content); res.writeHead(204); res.end(); }); } else if (req.url.indexOf('/webhook') &lt; 0) { res.writeHead(501); res.end(); self.common.log('Requested non-existent endpoint: ' + req.url, ip); } else if (req.headers.authorization !== basicAuth) { self.common.error( 'Requested webhook with incorrect authorization header: ' + req.headers.authorization, ip); res.writeHead(401); res.end(); } else { let content = ''; req.on('data', (chunk) =&gt; { content += chunk; }); req.on('end', () =&gt; { console.log(content); res.writeHead(204); res.end(); }); } } } module.exports = new WebCommands(); × Search results Close "},"web_settings.js.html":{"id":"web_settings.js.html","title":"Source: web/settings.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: web/settings.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (web@campbellcrowley.com) const http = require('http'); const auth = require('../../auth.js'); const socketIo = require('socket.io'); require('../subModule.js').extend(WebSettings); // Extends the SubModule class. /** * @classdesc Manages changing settings for the bot from a website. * @class * @augments SubModule */ function WebSettings() { const self = this; /** @inheritdoc */ this.myName = 'WebSettings'; /** @inheritdoc */ this.initialize = function() { app.listen(self.common.isRelease ? 8020 : 8021, '127.0.0.1'); setTimeout(updateModuleReferences, 100); self.command.addEventListener('settingsChanged', handleSettingsChanged); self.command.addEventListener('settingsReset', handleSettingsReset); }; /** @inheritdoc */ this.unloadable = function() { return getNumClients() == 0; }; /** @inheritdoc */ this.shutdown = function() { if (io) io.close(); if (ioClient) { ioClient.close(); ioClient = null; } if (app) app.close(); if (cmdScheduler) { cmdScheduler.removeListener('shutdown', handleShutdown); cmdScheduler.removeListener('commandRegistered', handleCommandRegistered); cmdScheduler.removeListener('commandCancelled', handleCommandCancelled); self.command.removeEventListener( 'settingsChanged', handleSettingsChanged); self.command.removeEventListener('settingsReset', handleSettingsReset); } }; let ioClient; const app = http.createServer(handler); const io = socketIo( app, {path: '/www.spikeybot.com/socket.io/', serveClient: false}); app.on('error', function(err) { if (io) io.close(); if (app) app.close(); if (err.code === 'EADDRINUSE') { self.warn( 'Settings failed to bind to port because it is in use. (' + err.port + ')'); startClient(); } else { console.error('Settings failed to bind to port for unknown reason.', err); } }); /** * Stores the current reference to the CmdScheduling subModule. Null if it * doesn't exist. * * @private * @type {?CmdScheduling} */ let cmdScheduler; /** * Stores the current reference to the RaidBlock subModule. Null if it doesn't * exist. * * @private * @type {?RaidBlock} */ let raidBlock; /** * Update the references to the aplicable subModules. * * @private */ function updateModuleReferences() { if (!self.initialized) return; if (!cmdScheduler || !cmdScheduler.initialized) { cmdScheduler = self.bot.getSubmodule('./cmdScheduling.js'); if (!cmdScheduler || !cmdScheduler.initialized) { cmdScheduler = null; setTimeout(updateModuleReferences, 100); } else { cmdScheduler.on('shutdown', handleShutdown); cmdScheduler.on('commandRegistered', handleCommandRegistered); cmdScheduler.on('commandCancelled', handleCommandCancelled); } } if (!raidBlock || !raidBlock.initialized) { raidBlock = self.bot.getSubmodule('./raidBlock.js'); if (!raidBlock || !raidBlock.initialized) { raidBlock = null; if (cmdScheduler &amp;&amp; cmdScheduler.initialized) { setTimeout(updateModuleReferences, 100); } } else { raidBlock.on('shutdown', handleRaidShutdown); raidBlock.on('lockdown', handleLockdown); raidBlock.on('action', handleRaidAction); } } } /** * Handle CmdScheduling shutting down. * * @private * @listens CmdScheduling#shutdown */ function handleShutdown() { if (cmdScheduler) { cmdScheduler.removeListener('shutdown', handleShutdown); cmdScheduler.removeListener('commandRegistered', handleCommandRegistered); cmdScheduler.removeListener('commandCancelled', handleCommandCancelled); } cmdScheduler = null; if (!self.initialized) return; setTimeout(updateModuleReferences, 100); } /** * Handle RaidBlock shutting down. * * @private * @listens RaidBlock[w#shutdown */ function handleRaidShutdown() { if (raidBlock) { raidBlock.removeListener('shutdown', handleRaidShutdown); raidBlock.removeListener('lockdown', handleLockdown); raidBlock.removeListener('action', handleRaidAction); } raidBlock = null; if (!self.initialized) return; setTimeout(updateModuleReferences, 100); } /** * Handle new CmdScheduling.ScheduledCommand being registered. * * @private * @listens CmdScheduling#commandRegistered * * @param {CmdScheduling.ScheduledCommand} cmd The command that was scheduled. * @param {string|number} gId The guild ID of which the command was scheduled * in. */ function handleCommandRegistered(cmd, gId) { const toSend = { id: cmd.id, channel: cmd.channelId, cmd: cmd.cmd, repeatDelay: cmd.repeatDelay, time: cmd.time, member: makeMember(cmd.member), }; for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit('commandRegistered', toSend, gId); } } if (ioClient) { ioClient.emit('_guildBroadcast', gId, 'commandRegistered', toSend, gId); } } /** * Handle a CmdScheduling.ScheduledCommand being canceled. * * @private * @listens CmdScheduling#commandCancelled * @param {string} cmdId The ID of the command that was cancelled. * @param {string|number} gId The ID of the guild the command was cancelled * in. */ function handleCommandCancelled(cmdId, gId) { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit('commandCancelled', cmdId, gId); } } if (ioClient) { ioClient.emit('_guildBroadcast', gId, 'commandCancelled', cmdId, gId); } } /** * Handle Command~CommandSetting value changed. * * @private * @listens Command.events#settingsChanged * @see {@link Command~CommandSetting.set} * * @param {?string} gId The ID of the guild this setting was changed in, or * null of not specific to a single guild. * @param {string} value Value of setting. * @param {string} type Type of value. * @param {string} id Setting id. * @param {string} [id2] Second setting id. */ function handleSettingsChanged(gId, value, type, id, id2) { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; (!gId || sockets[i].cachedGuilds.includes(gId))) { sockets[i].emit('settingsChanged', gId, value, type, id, id2); } } if (ioClient) { ioClient.emit( '_guildBroadcast', gId, 'settingsChanged', gId, value, type, id, id2); } } /** * Handle Command~CommandSetting was deleted or reset in a guild. * * @private * @listens Command.events#settingsReset * * @param {string} gId The ID of the guild in which the settings were reset. */ function handleSettingsReset(gId) { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit('settingsReset', gId); } } if (ioClient) { ioClient.emit('_guildBroadcast', gId, 'settingsReset', gId); } } /** * Handle a guild going on lockdown. * * @private * @listens RaidBlock#lockdown * * @param {{settings: RaidBlock~RaidSettings, id: string}} event Event * information. */ function handleLockdown(event) { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(event.id)) { sockets[i].emit('lockdown', event.id, event.settings); } } if (ioClient) { ioClient.emit( '_guildBroadcast', event.id, 'lockdown', event.id, event.settings); } } /** * Handle a guild lockdown action being performed. * * @private * @listens RaidBlock#action * * @param {{action: string, user: external:Discord~User}} event Event * information. */ function handleRaidAction(event) { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(event.id)) { sockets[i].emit('raidAction', event.id, event.action, event.user.id); } } if (ioClient) { ioClient.emit( '_guildBroadcast', event.id, 'raidAction', event.id, event.action, event.user.id); } } /** * Start a socketio client connection to the primary running server. * * @private */ function startClient() { self.log( 'Restarting into client mode due to server already bound to port.'); ioClient = require('socket.io-client')( self.common.isRelease ? 'http://localhost:8020' : 'http://localhost:8021', {path: '/www.spikeybot.com/socket.io/control/'}); clientSocketConnection(ioClient); } /** * Handler for all http requests. Should never be called. * * @private * @param {http.IncomingMessage} req The client's request. * @param {http.ServerResponse} res Our response to the client. */ function handler(req, res) { res.writeHead(418); res.end('TEAPOT'); } /** * Map of all currently connected sockets. * * @private * @type {Object.&lt;Socket&gt;} */ const sockets = {}; /** * Returns the number of connected clients that are not siblings. * * @private * @returns {number} Number of sockets. */ function getNumClients() { return Object.keys(sockets).length - Object.keys(siblingSockets).length; } /** * Map of all sockets connected that are siblings. * * @private * @type {Object.&lt;Socket&gt;} */ const siblingSockets = {}; io.on('connection', socketConnection); /** * Handler for a new socket connecting. * * @private * @param {socketIo~Socket} socket The socket.io socket that connected. */ function socketConnection(socket) { // x-forwarded-for is trusted because the last process this jumps through is // our local proxy. const ipName = self.common.getIPName( socket.handshake.headers['x-forwarded-for'] || socket.handshake.address); self.common.log( 'Socket connected Settings (' + Object.keys(sockets).length + '): ' + ipName, socket.id); sockets[socket.id] = socket; socket.emit('time', Date.now()); // @TODO: Replace this authentication with gpg key-pairs; socket.on('vaderIAmYourSon', (verification, cb) =&gt; { if (verification === auth.webSettingsSiblingVerification) { siblingSockets[socket.id] = socket; cb(auth.webSettingsSiblingVerificationResponse); socket.on('_guildBroadcast', (gId, ...args) =&gt; { for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit(...args); } } }); } else { self.common.error('Client failed to authenticate as child.', socket.id); } }); socket.on('fetchGuilds', (...args) =&gt; { callSocketFunction(fetchGuilds, args, false); }); socket.on('fetchGuild', (...args) =&gt; { callSocketFunction(fetchGuild, args); }); socket.on('fetchMember', (...args) =&gt; { callSocketFunction(fetchMember, args); }); socket.on('fetchChannel', (...args) =&gt; { callSocketFunction(fetchChannel, args); }); socket.on('fetchSettings', (...args) =&gt; { callSocketFunction(fetchSettings, args); }); socket.on('fetchRaidSettings', (...args) =&gt; { callSocketFunction(fetchRaidSettings, args); }); socket.on('fetchModLogSettings', (...args) =&gt; { callSocketFunction(fetchModLogSettings, args); }); socket.on('fetchCommandSettings', (...args) =&gt; { callSocketFunction(fetchCommandSettings, args); }); socket.on('fetchScheduledCommands', (...args) =&gt; { callSocketFunction(fetchScheduledCommands, args); }); socket.on('fetchGuildScheduledCommands', (...args) =&gt; { callSocketFunction(fetchGuildScheduledCommands, args); }); socket.on('cancelScheduledCommand', (...args) =&gt; { callSocketFunction(cancelScheduledCommand, args); }); socket.on('registerScheduledCommand', (...args) =&gt; { callSocketFunction(registerScheduledCommand, args); }); socket.on('changePrefix', (...args) =&gt; { callSocketFunction(changePrefix, args); }); socket.on('changeRaidSetting', (...args) =&gt; { callSocketFunction(changeRaidSetting, args); }); socket.on('changeModLogSetting', (...args) =&gt; { callSocketFunction(changeModLogSetting, args); }); socket.on('changeCommandSetting', (...args) =&gt; { callSocketFunction(changeCommandSetting, args); }); /** * Calls the functions with added arguments, and copies the request to all * sibling clients. * * @private * @param {Function} func The function to call. * @param {Array.&lt;*&gt;} args Array of arguments to send to function. * @param {boolean} [forward=true] Forward this request directly to all * siblings. */ function callSocketFunction(func, args, forward = true) { const noLog = ['fetchMember', 'fetchChannel']; if (!noLog.includes(func.name.toString())) { const logArgs = args.map((el) =&gt; { if (typeof el === 'function') { return (el.name || 'cb') + '()'; } else { return el; } }); self.common.logDebug(`${func.name}(${logArgs.join(',')})`, socket.id); } let cb; if (typeof args[args.length - 1] === 'function') { const origCB = args[args.length - 1]; let fired = false; cb = function(...args) { if (fired) { self.warn( 'Attempting to fire callback a second time! (' + func.name + ')'); } origCB(...args); fired = true; }; args[args.length - 1] = cb; } func.apply(func, [args[0], socket].concat(args.slice(1))); if (typeof cb === 'function') { args[args.length - 1] = {_function: true}; } if (forward) { Object.entries(siblingSockets).forEach((s) =&gt; { s[1].emit( 'forwardedRequest', args[0], socket.id, func.name, args.slice(1), (res) =&gt; { if (res._forward) socket.emit(...res.data); if (res._callback &amp;&amp; typeof cb === 'function') { cb(...res.data); } }); }); } } socket.on('disconnect', () =&gt; { self.common.log( 'Socket disconnected Settings (' + (Object.keys(sockets).length - 1) + '): ' + ipName, socket.id); if (siblingSockets[socket.id]) delete siblingSockets[socket.id]; delete sockets[socket.id]; }); } /** * Handler for connecting as a client to the server. * * @private * @param {socketIo~Socket} socket The socket.io socket that connected. */ function clientSocketConnection(socket) { let authenticated = false; socket.on('connect', () =&gt; { socket.emit( 'vaderIAmYourSon', auth.webSettingsSiblingVerification, (res) =&gt; { self.common.log('Sibling authenticated successfully.'); authenticated = res === auth.webSettingsSiblingVerificationResponse; }); }); socket.on('fetchGuilds', (userData, id, cb) =&gt; { fetchGuilds(userData, {id: id}, cb); }); socket.on('forwardedRequest', (userData, sId, func, args, cb) =&gt; { if (!authenticated) return; const fakeSocket = { fake: true, emit: function(...args) { if (typeof cb == 'function') cb({_forward: true, data: args}); }, id: sId, }; if (args[args.length - 1]._function) { args[args.length - 1] = function(...a) { if (typeof cb === 'function') cb({_callback: true, data: a}); }; } if (!self[func]) { self.common.error(func + ': is not a function.', socket.id); } else { self[func].apply(self[func], [userData, fakeSocket].concat(args)); } }); } /** * Send a message to the given socket informing the client that the command * they attempted failed due to insufficient permission. * * @private * @param {Socket} socket The socket.io socket to reply on. * @param {string} cmd THe command the client attempted. */ function replyNoPerm(socket, cmd) { self.common.logDebug( 'Attempted ' + cmd + ' without permission.', socket.id); socket.emit( 'message', 'Failed to run command \"' + cmd + '\" because you don\\'t have permission for this.'); } /** * Checks if the current shard is responsible for the requested guild. * * @private * @param {number|string} gId The guild id to check. * @returns {boolean} True if this shard has this guild. */ function checkMyGuild(gId) { const g = self.client.guilds.get(gId); return (g &amp;&amp; true) || false; } /** * Check that the given user has permission to manage the games in the given * guild. * * @private * @param {UserData} userData The user to check. * @param {string} gId The guild id to check against. * @param {?string} cId The channel id to check against. * @param {string} cmd The command being attempted. * @returns {boolean} Whether the user has permission or not to manage the * hungry games in the given guild. */ function checkPerm(userData, gId, cId, cmd) { if (!userData) return false; if (userData.id == self.common.spikeyId) return true; const msg = makeMessage(userData.id, gId, cId, cmd); if (!msg) return false; if (self.command.validate(null, makeMessage(userData.id, gId, null, cmd))) { return false; } return true; } /** * Check that the given user has permission to see and send messages in the * given channel, as well as manage the games in the given guild. * * @private * @param {UserData} userData The user to check. * @param {string} gId The guild id of the guild that contains the channel. * @param {string} cId The channel id to check against. * @returns {boolean} Whether the user has permission or not to manage the * hungry games in the given guild and has permission to send messages in the * given channel. */ function checkChannelPerm(userData, gId, cId) { if (!userData) return false; const g = self.client.guilds.get(gId); if (!g) return false; if (userData.id == self.common.spikeyId) return true; const m = g.members.get(userData.id); if (!m) return false; const channel = g.channels.get(cId); if (!channel) return false; const perms = channel.permissionsFor(m); if (!perms.has(self.Discord.Permissions.FLAGS.VIEW_CHANNEL)) return false; if (!perms.has(self.Discord.Permissions.FLAGS.SEND_MESSAGES)) return false; return true; } /** * Strips a Discord~GuildMember to only the necessary data that a client will * need. * * @private * @param {Discord~GuildMember} m The guild member to strip the data from. * @returns {object} The minimal member. */ function makeMember(m) { if (!m) return null; if (typeof m !== 'object') { m = { roles: { array: function() { return []; }, }, guild: {}, permissions: {bitfield: 0}, user: self.client.users.get(m), }; } return { nickname: m.nickname, roles: m.roles.array(), color: m.displayColor, guild: {id: m.guild.id}, user: { username: m.user.username, tag: m.user.tag, discriminator: m.user.discriminator, avatarURL: m.user.displayAvatarURL(), id: m.user.id, bot: m.user.bot, }, joinedTimestamp: m.joinedTimestamp, }; } /** * Forms a Discord~Message similar object from given IDs. * * @private * @param {string} uId The id of the user who wrote this message. * @param {string} gId The id of the guild this message is in. * @param {?string} cId The id of the channel this message was 'sent' in. * @param {?string} msg The message content. * @returns { * { * author: Discord~User, * member: Discord~GuildMember, * guild: Discord~Guild, * channel: Discord~GuildChannel, * text: string, * content: string, * prefix: string * } * } The created message-like object. */ function makeMessage(uId, gId, cId, msg) { const g = self.client.guilds.get(gId); if (!g) return null; const prefix = self.bot.getPrefix(gId); return { member: g.members.get(uId), author: self.client.users.get(uId), guild: g, channel: g.channels.get(cId), text: msg, content: `${prefix}${msg}`, prefix: prefix, }; } /** * Basic callback with single argument. The argument is null if there is no * error, or a string if there was an error. * @callback WebSettings~basicCB * * @param {?string} err The error response. */ /** * Fetch all relevant data for all mutual guilds with the user and send it to * the user. * * @private * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchGuilds(userData, socket, cb) { if (!userData) { self.common.error('Fetch Guilds without userData', 'WebSettings'); if (typeof cb === 'function') cb('Not signed in', null); return; } const numReplies = (Object.entries(siblingSockets).length || 0); let replied = 0; const guildBuffer = {}; let done; if (typeof cb === 'function') { done = cb; } else { /** * The callback for each response with the requested data. Replies to the * user once all requests have replied. * * @private * @param {string|object} guilds Either the guild data to send to the * user, or 'guilds' if this is a reply from a sibling client. * @param {?string} [err] The error that occurred, or null if no error. * @param {object} [response] The guild data if `guilds` equals 'guilds'. */ done = function(guilds, err, response) { if (guilds === 'guilds') { if (err) { guilds = null; } else { guilds = response; } } for (let i = 0; guilds &amp;&amp; i &lt; guilds.length; i++) { guildBuffer[guilds[i].id] = guilds[i]; } replied++; if (replied &gt; numReplies) { if (typeof cb === 'function') cb(guildBuffer); socket.emit('guilds', null, guildBuffer); socket.cachedGuilds = Object.keys(guildBuffer || {}); } }; } Object.values(siblingSockets).forEach((obj) =&gt; { obj.emit('fetchGuilds', userData, socket.id, done); }); try { let guilds = []; if (userData.guilds &amp;&amp; userData.guilds.length &gt; 0) { userData.guilds.forEach((el) =&gt; { const g = self.client.guilds.get(el.id); if (!g) return; guilds.push(g); }); } else { guilds = self.client.guilds .filter((obj) =&gt; { return obj.members.get(userData.id); }) .array(); } const strippedGuilds = stripGuilds(guilds, userData); socket.cachedGuilds = strippedGuilds.map((g) =&gt; g.id); done(strippedGuilds); } catch (err) { self.error(err); // socket.emit('guilds', 'Failed', null); done(); } } this.fetchGuilds = fetchGuilds; /** * Strip a Discord~Guild to the basic information the client will need. * * @private * @param {Discord~Guild[]} guilds The array of guilds to strip. * @param {object} userData The current user's session data. * @returns {Array&lt;object&gt;} The stripped guilds. */ function stripGuilds(guilds, userData) { return guilds.map((g) =&gt; { const member = g.members.get(userData.id); const newG = {}; newG.iconURL = g.iconURL(); newG.name = g.name; newG.id = g.id; newG.ownerId = g.ownerID; newG.members = g.members.map((m) =&gt; { return m.id; }); newG.channels = g.channels .filter((c) =&gt; { const perms = c.permissionsFor(member); return userData.id == self.common.spikeyId || (perms &amp;&amp; perms.has(self.Discord.Permissions.FLAGS.VIEW_CHANNEL)); }) .map((c) =&gt; { return c.id; }); newG.myself = makeMember(member || userData.id); return newG; }); } /** * Fetch a single guild. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The ID of the guild that was requested. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchGuild(userData, socket, gId, cb) { if (!userData) { self.common.error('Fetch Guild without userData', socket.id); if (typeof cb === 'function') cb('SIGNED_OUT'); return; } if (typeof cb !== 'function') { self.common.logWarning( 'Fetch Guild attempted without callback', socket.id); return; } const guild = self.client.guilds.get(gId); if (!guild) { // cb(null); return; } if (userData.id != self.common.spikeyId &amp;&amp; !guild.members.get(userData.id)) { // cb(null); return; } cb(stripGuilds([guild], userData)[0]); } this.fetchGuild = fetchGuild; /** * Fetch data about a member of a guild. * * @private * @type {HGWeb~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The guild id to look at. * @param {number|string} mId The member's id to lookup. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function fetchMember(userData, socket, gId, mId, cb) { if (typeof cb !== 'function') return; if (!checkPerm(userData, gId, null, 'players')) return; const g = self.client.guilds.get(gId); if (!g) return; const m = g.members.get(mId); if (!m) { cb('No Member'); return; } const finalMember = makeMember(m); cb(null, finalMember); } this.fetchMember = fetchMember; /** * Client has requested data for a specific channel. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {number|string} gId The ID of the Discord guild where the channel * is. * @param {number|string} cId The ID of the Discord channel to fetch. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchChannel(userData, socket, gId, cId, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkChannelPerm(userData, gId, cId)) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'fetchChannel'); cb(null); return; } const c = self.client.channels.get(cId); const m = self.client.guilds.get(gId).members.get(userData.id); const perms = c.permissionsFor(m); const stripped = { id: c.id, permissions: perms, name: c.name, position: c.position, type: c.type, }; if (c.parent) { stripped.parent = {position: c.parent.position}; } cb(stripped); } this.fetchChannel = fetchChannel; /** * Client has requested all settings for all guilds for the connected user. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchSettings(userData, socket, cb) { if (!userData) { if (typeof cb === 'function') cb('Not signed in.', null); return; } let guilds = []; if (userData.guilds &amp;&amp; userData.guilds.length &gt; 0) { userData.guilds.forEach((el) =&gt; { const g = self.client.guilds.get(el.id); if (!g) return; guilds.push(g); }); } else { guilds = self.client.guilds.filter((obj) =&gt; { return userData.id == self.common.spikeyId || obj.members.get(userData.id); }); } const cmdDefaults = self.command.getDefaultSettings(); const modLog = self.bot.getSubmodule('./modLog.js'); const settings = guilds.map((g) =&gt; { return { guild: g.id, prefix: self.bot.getPrefix(g), commandSettings: self.command.getUserSettings(g.id), commandDefaults: cmdDefaults, raidSettings: raidBlock &amp;&amp; raidBlock.getSettings(g.id) || null, modLogSettings: modLog &amp;&amp; modLog.getSettings(g.id) || null, }; }); if (!socket.fake &amp;&amp; typeof cb === 'function') { cb(settings); } else { socket.emit('settings', settings); } } this.fetchSettings = fetchSettings; /** * Client has requested settings specific to raids for single guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string} gId The guild ID to fetch the settings for. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchRaidSettings(userData, socket, gId, cb) { if (!checkMyGuild(gId)) return; if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } if (userData.id != self.common.spikeyId) { const guild = self.client.guilds.get(gId); const member = guild.members.get(userData.id); if (!member) { cb('NO_PERM'); return; } } if (!raidBlock) { cb('Internal Server Error'); return; } cb(raidBlock.getSettings(gId)); } this.fetchRaidSettings = fetchRaidSettings; /** * Client has requested settings specific to ModLog for single guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string} gId The guild ID to fetch the settings for. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchModLogSettings(userData, socket, gId, cb) { if (!checkMyGuild(gId)) return; if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } if (userData.id != self.common.spikeyId) { const guild = self.client.guilds.get(gId); const member = guild.members.get(userData.id); if (!member) { cb('NO_PERM'); return; } } const modLog = self.bot.getSubmodule('./modLog.js'); if (!modLog) { cb('Internal Server Error'); return; } cb(modLog.getSettings(gId)); } this.fetchModLogSettings = fetchModLogSettings; /** * Client has requested settings specific to a single command in a single * guild. This only supplies user settings, if values are default, this will * reply with null. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string} gId The guild ID to fetch the settings for. * @param {?string} cmd The name of the command to fetch the setting for, or * null to fetch all settings. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchCommandSettings(userData, socket, gId, cmd, cb) { if (!checkMyGuild(gId)) return; if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } if (userData.id != self.common.spikeyId) { const guild = self.client.guilds.get(gId); const member = guild.members.get(userData.id); if (!member) { cb('NO_PERM'); return; } } let settings = self.command.getUserSettings(gId); if (cmd) { const command = self.command.find(cmd); if (!command) { settings = null; } else { settings = settings[command.getFullName()]; } } cb(settings); } this.fetchCommandSettings = fetchCommandSettings; /** * Client has requested all scheduled commands for the connected user. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchScheduledCommands(userData, socket, cb) { if (!userData) { if (!socket.fake &amp;&amp; typeof cb === 'function') cb('Not signed in.', null); return; } let guilds = userData.guilds; if (guilds) { guilds.map((el) =&gt; self.client.guilds.get(el.id)); } else { guilds = self.client.guilds.filter((obj) =&gt; { return obj.members.get(userData.id); }); } const sCmds = {}; updateModuleReferences(); if (!cmdScheduler) { self.warn('Failed to get reference to CmdScheduler!'); return; } guilds.forEach((g) =&gt; { if (!g) return; const list = cmdScheduler.getScheduledCommandsInGuild(g.id); if (list &amp;&amp; list.length &gt; 0) { sCmds[g.id] = list.map((el) =&gt; { return { id: el.id, channel: el.channel.id, cmd: el.cmd, repeatDelay: el.repeatDelay, time: el.time, member: makeMember(el.member), }; }); } }); if (!socket.fake &amp;&amp; typeof cb === 'function') { cb(sCmds); } else { socket.emit('scheduledCmds', sCmds); } } this.fetchScheduledCommands = fetchScheduledCommands; /** * Client has requested scheduled commands for a guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string} gId The guild ID to fetch. * @param {basicCB} [cb] Callback that fires once the requested action is * complete and has data, or has failed. */ function fetchGuildScheduledCommands(userData, socket, gId, cb) { if (!checkMyGuild(gId)) return; if (typeof cb !== 'function') cb = function() {}; if (!userData) { cb('Not signed in.', null); return; } if (userData.id != self.common.spikeyId) { const guild = self.client.guilds.get(gId); const member = guild.members.get(userData.id); if (!member) { cb('NO_PERM'); return; } } updateModuleReferences(); if (!cmdScheduler) { self.warn('Failed to get reference to CmdScheduler!'); return; } const list = cmdScheduler.getScheduledCommandsInGuild(gId); let sCmds; if (list &amp;&amp; list.length &gt; 0) { sCmds = list.map((el) =&gt; { return { id: el.id, channel: el.channel.id, cmd: el.cmd, repeatDelay: el.repeatDelay, time: el.time, member: makeMember(el.member), }; }); } cb(sCmds); } this.fetchGuildScheduledCommands = fetchGuildScheduledCommands; /** * Client has requested that a scheduled command be cancelled. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The id of the guild of which to cancel the * command. * @param {string} cmdId The ID of the command to cancel. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function cancelScheduledCommand(userData, socket, gId, cmdId, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkPerm(userData, gId, null, 'schedule')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'cancelScheduledCommand'); cb('Forbidden'); return; } updateModuleReferences(); cmdScheduler.cancelCmd(gId, cmdId); cb(); } this.cancelScheduledCommand = cancelScheduledCommand; /** * @description Client has created a new scheduled command. * @see {@link CmdScheduling~ScheduledCommand} * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The id of the guild of which to add the command. * @param {object} cmd The command data of which to make into a * scheduled command and register. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function registerScheduledCommand(userData, socket, gId, cmd, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkMyGuild(gId)) return; if (!checkPerm(userData, gId, cmd &amp;&amp; cmd.channel, 'schedule')) { replyNoPerm(socket, 'registerScheduledCommand'); cb('Forbidden'); return; } if (!cmd || typeof cmd !== 'object') { cb('Invalid Data'); return; } if (!cmd.time || cmd.time &lt; Date.now()) { cb('Time cannot be in past.'); return; } updateModuleReferences(); if (cmd.repeatDelay &amp;&amp; cmd.repeatDelay &lt; cmdScheduler.minRepeatDelay) { cb('Repeat time is too soon.'); return; } let cId = self.client.channels.get(cmd.channel); if (!cId) { cb('Invalid Channel'); return; } cId = cId.id; if (typeof cmd.cmd !== 'string') { cb('Invalid Command'); return; } const msg = makeMessage(userData.id, gId, cId, cmd.cmd); if (!msg) { cb('Invalid Member'); return; } const invalid = self.command.validate(cmd.cmd.split(/\\s/)[0], msg); if (invalid) { cb('Invalid Command'); return; } const prefix = self.bot.getPrefix(gId); if (!cmd.cmd.startsWith(prefix)) { cmd.cmd = prefix + cmd.cmd; } const single = self.command.find(cmd.cmd, {prefix: prefix}); if (!single) { cb('Invalid Command'); return; } if (single.getFullName() === self.command.find('sch').getFullName()) { cb('Invalid Command'); return; } const newCmd = new cmdScheduler.ScheduledCommand({ cmd: cmd.cmd, channel: msg.channel, message: msg, time: cmd.time, repeatDelay: cmd.repeatDelay, member: msg.member, }); if (!cmdScheduler.registerScheduledCommand(newCmd)) { cb('Time is too close to existing command.'); } else { cb(null); } } this.registerScheduledCommand = registerScheduledCommand; /** * Client has requested to change the command prefix for a guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The id of the guild of which to change the * prefix. * @param {string} prefix The new prefix value to set. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function changePrefix(userData, socket, gId, prefix, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkPerm(userData, gId, null, 'changeprefix')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'changePrefix'); cb('Forbidden'); return; } try { self.bot.changePrefix(gId, prefix); } catch (err) { cb('Internal Error'); return; } cb(); } this.changePrefix = changePrefix; /** * Client has requested to change a single raid setting for a guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The id of the guild of which to change the * setting. * @param {string} key The name of the setting to change. * @param {string|boolean} value The value to set the setting to. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function changeRaidSetting(userData, socket, gId, key, value, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkPerm(userData, gId, null, 'lockdown')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'changeRaidSetting'); cb('Forbidden'); return; } if (!raidBlock) { cb('Internal Server Error'); self.common.error( 'Attempted to change RaidBlock settings while raidBlock.js ' + 'is not loaded!', socket.id); return; } const settings = raidBlock.getSettings(gId); if (typeof settings[key] === 'number') { value *= 1; if (isNaN(value)) { cb('Bad Payload'); return; } } if (typeof settings[key] === typeof value) { if (typeof value === 'string' &amp;&amp; value.length &gt; 1000) { value = value.substr(0, 1000); } settings[key] = value; } else { cb('Bad Payload'); return; } cb(); for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit('raidSettingsChanged', gId); } } if (ioClient) { ioClient.emit('_guildBroadcast', gId, 'raidSettingsChanged', gId); } } this.changeRaidSetting = changeRaidSetting; /** * Client has requested to change a single ModLog setting for a guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The id of the guild of which to change the * setting. * @param {string} key The name of the setting to change. * @param {string|boolean} value The value to set the setting to. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function changeModLogSetting(userData, socket, gId, key, value, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkPerm(userData, gId, null, 'setlogchannel')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'changeModLogSetting'); cb('Forbidden'); return; } const modLog = self.bot.getSubmodule('./modLog.js'); if (!modLog) { cb('Internal Server Error'); self.common.error( 'Attempted to change ModLog settings while modLog.js is not loaded!', socket.id); return; } const settings = modLog.getSettings(gId); if (typeof settings[key] === 'number') { value *= 1; if (isNaN(value)) { cb('Bad Payload'); return; } } if (key === 'channel') { const channel = self.client.guilds.get(gId).channels.get(value); if (!channel) { cb('Bad Payload'); return; } else { settings[key] = value; } } else if (typeof settings[key] === typeof value) { settings[key] = value; } else { cb('Bad Payload'); return; } cb(); for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit('modLogSettingsChanged', gId); } } if (ioClient) { ioClient.emit('_guildBroadcast', gId, 'modLogSettingsChanged', gId); } } this.changeModLogSetting = changeModLogSetting; /** * Client has requested to change a single command setting for a guild. * * @public * @type {WebSettings~SocketFunction} * @param {object} userData The current user's session data. * @param {socketIo~Socket} socket The socket connection to reply on. * @param {string|number} gId The id of the guild of which to change the * setting. * @param {string} cmd The name of the command to change the setting for. * @param {string} key The name of the setting to change. * @param {string|boolean} value The value to set the setting to, or the key * if changing an enabled or disabled category. * @param {?string} id The ID of the channel, user, or role to change * the setting for if changing the enabled or disabled category. * @param {?boolean} enabled The setting to set the value of the ID setting. * @param {basicCB} [cb] Callback that fires once the requested action is * complete, or has failed. */ function changeCommandSetting( userData, socket, gId, cmd, key, value, id, enabled, cb) { if (typeof cb !== 'function') cb = function() {}; if (!checkPerm(userData, gId, null, 'enable') || !checkPerm(userData, gId, null, 'disable')) { if (!checkMyGuild(gId)) return; replyNoPerm(socket, 'changeCommandSetting'); cb('Forbidden'); return; } const command = self.command.find(cmd); if (!command) { cb('Bad Payload'); return; } const userSettings = self.command.getUserSettings(gId); const name = command.getFullName(); if (!userSettings[name]) { userSettings[name] = new self.command.CommandSetting(command.options); } const setting = userSettings[name]; if (typeof setting[key] === 'object' &amp;&amp; typeof value === 'string') { if (typeof id !== 'string' || typeof setting[key][value] === 'undefined') { cb('Bad Payload'); return; } else { if (enabled === true) { setting[key][value][id] = true; } else if (enabled === false) { delete setting[key][value][id]; } else { cb('Bad Payload'); return; } } } else if (typeof setting[key] !== typeof value) { cb('Bad Payload'); return; } else { setting[key] = value; } cb(); for (const i in sockets) { if (sockets[i] &amp;&amp; sockets[i].cachedGuilds &amp;&amp; sockets[i].cachedGuilds.includes(gId)) { sockets[i].emit('commandSettingsChanged', gId, name ); } } if (ioClient) { ioClient.emit('_guildBroadcast', gId, 'commandSettingsChanged', gId); } } this.changeCommandSetting = changeCommandSetting; } module.exports = new WebSettings(); × Search results Close "},"web_stats.js.html":{"id":"web_stats.js.html","title":"Source: web/stats.js","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Source: web/stats.js // Copyright 2018-2019 Campbell Crowley. All rights reserved. // Author: Campbell Crowley (dev@campbellcrowley.com) const http = require('http'); const https = require('https'); const auth = require('../../auth.js'); require('../subModule.js').extend(WebStats); // Extends the SubModule class. /** * @classdesc Handles sending the bot's stats to http client requests, and * discordbots.org. * @class * @augments SubModule */ function WebStats() { const self = this; this.myName = 'Stats'; const app = http.createServer(handler); /** @inheritdoc */ this.initialize = function() { app.listen(self.common.isRelease ? 8016 : 8017, '127.0.0.1'); postTimeout = self.client.setTimeout(postUpdatedCount, 1000); }; /** @inheritdoc */ this.shutdown = function() { if (app) app.close(); if (postTimeout) self.client.clearTimeout(postTimeout); }; app.on('error', function(err) { if (err.code === 'EADDRINUSE') { self.warn( 'Stats failed to bind to port because it is in use. (' + err.port + ')'); self.shutdown(true); } else { self.error('Webhooks failed to bind to port for unknown reason.', err); } }); /** * The timestamp at which the stats were last requested. * @private * @default * @type {number} */ let cachedTime = 0; /** * The amount of time the cached data is considered fresh. Anything longer * than this must be re-fetched. * @private * @constant * @default 5 Minutes * @type {number} */ const cachedLifespan = 5 * 60 * 1000; // 5 minutes /** * The object storing the previously received stats values. * @private * @default * @type {Main~getAllStats~values} */ let cachedStats = {}; /** * The amount frequency at which we will post our stats to discordbots.org * @private * @constant * @default 12 Hours * @type {number} */ const postFrequency = 12 * 60 * 60 * 1000; // 12 Hours /** * The next scheduled event at which to post our stats. * @private * @type {Timeout} */ let postTimeout; /** * The request information for updating our server count on bot list websites. * @private * @default * @constant */ const apiHosts = [ { protocol: 'https:', host: 'discordbots.org', path: '/api/bots/{id}/stats', method: 'POST', headers: { 'Authorization': auth.discordBotsOrgToken, 'content-type': 'application/json', }, }, { protocol: 'https:', host: 'discordbotlist.com', path: '/api/bots/{id}/stats', method: 'POST', headers: { 'Authorization': 'Bot ' + auth.discordBotListComToken, 'content-type': 'application/json', }, }, { protocol: 'https:', host: 'discord.bots.gg', path: '/api/v1/bots/{id}/stats', method: 'POST', headers: { 'Authorization': auth.discordBotsGGToken, 'content-type': 'application/json', }, }, { protocol: 'https:', host: 'bots.ondiscord.xyz', path: '/bot-api/bots/{id}/guilds', method: 'POST', headers: { 'Authorization': auth.botsOnDiscordXYZKey, 'content-type': 'application/json', }, }, { protocol: 'https:', host: 'divinediscordbots.com', path: '/bot/318552464356016131/stats', method: 'POST', headers: { 'Authorization': auth.divineDiscordBotsComToken, 'content-type': 'application/json', }, }, ]; /** * Handler for all http requests. Always replies to res with JSON encoded bot * stats. * * @private * @param {http.IncomingMessage} req The client's request. * @param {http.ServerResponse} res Our response to the client. */ function handler(req, res) { const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'ERROR'; if (req.url.indexOf('/webhook') &gt; -1) { res.writeHead(501); res.end(); self.common.log('Requested Webhook that doesn\\'t exist yet.', ip); } else if (req.url.indexOf('/stats/shield') == 0) { getStats((stats) =&gt; { res.writeHead(200, {'content-type': 'application/json'}); const filteredStats = { schemaVersion: 1, label: 'SpikeyBot Servers', message: stats.numGuilds + '', color: 'purple', cacheSeconds: Math.floor(cachedLifespan / 1000), }; res.end(JSON.stringify(filteredStats)); self.common.log('Sent stats: ' + req.url, ip); }); } else { getStats((stats) =&gt; { res.writeHead(200, {'content-type': 'application/json'}); const filteredStats = Object.assign({}, stats); filteredStats.activities = 'REDACTED'; res.end(JSON.stringify(filteredStats)); self.common.log('Sent stats: ' + req.url, ip); }); } } /** * @description Fetch the bot's stats. * @see {@link Main~getAllStats~values} * * @private * @param {object} cb The bot's stats as an object. */ function getStats(cb) { if (cachedTime + cachedLifespan &lt; Date.now()) { cachedTime = Date.now(); self.bot.getStats((values) =&gt; { cachedStats = values; cb(values); }); } else { cb(cachedStats); } } /** * Send our latest guild count to discordbots.org via https post request. * * @private */ function postUpdatedCount() { if (postTimeout) self.client.clearTimeout(postTimeout); if (self.client.user.id !== '318552464356016131') return; getStats((values) =&gt; { self.log('Current Guild Count: ' + values.numGuilds); /* eslint-disable @typescript-eslint/camelcase */ if (self.client.shard) { sendRequest({ server_count: values.numGuilds, guilds: values.numGuilds, guildCount: values.numGuilds, users: values.numMembers, // shards: Object.values(values.shardGuilds), // shard_id: values.reqShard, // shardId: values.reqShard, shard_count: values.numShards, shardCount: values.numShards, }); } else { sendRequest({ server_count: values.numGuilds, guilds: values.numGuilds, guildCount: values.numGuilds, users: values.numMembers, }); } /* eslint-enable @typescript-eslint/camelcase */ }); /** * Send the request after we have fetched our stats. * * @private * @param {{server_count: number, shards: number[], shard_id: number, * shard_count: number}} data The data to send in our request. */ function sendRequest(data) { const body = JSON.stringify(data); apiHosts.forEach((apiHost) =&gt; { const host = apiHost; host.path = host.path.replace('{id}', self.client.user.id); const req = https.request(host, (res) =&gt; { let content = ''; res.on('data', (chunk) =&gt; { content += chunk; }); res.on('end', () =&gt; { if (postTimeout) self.client.clearTimeout(postTimeout); postTimeout = self.client.setTimeout(postUpdatedCount, postFrequency); if (res.statusCode == 200 || res.statusCode == 204) { self.log('Successfully posted guild count to ' + apiHost.host); } else { self.error( 'Failed to post guild count to ' + apiHost.host + ' (' + res.statusCode + ')'); console.error(host, body, content); } }); }); req.end(body); req.on('error', console.error); }); } } } module.exports = new WebStats(); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Global Members &lt;private, constant&gt; self Wrapper for logging functions that normally reference SubModule.error and similar. Source: hg/Simulator.js, line 13 To Do: Obtain reference to SubModule to be able to remove this. &lt;nullable&gt; sqlCon :sql.ConnectionConfig The object describing the connection with the SQL server. Type: sql.ConnectionConfig Source: common.js, line 648 Methods &lt;private&gt; __stack() Gets the stack trace of the current function call. Source: common.js, line 701 Returns: Error stack for logging. Type Stack &lt;private&gt; unhandledRejection(args) Handler for an unhandledRejection or uncaughtException, to prevent the bot from silently crashing without an error. Parameters: Name Type Argument Description args * &lt;repeatable&gt; All information to log. Source: SpikeyBot.js, line 25 Listens to Events: Process#event:unhandledRejection Process#event:uncaughtException Type Definitions commandHandler(msg) The function to call when a command is triggered. Parameters: Name Type Description msg Discord~Message The message sent in Discord. Source: commands.js, line 142 HGStatGroupUserSelectOptions Options for fetching a group of user stats. Type: object Properties: Name Type Argument Default Description sort string &lt;optional&gt; 'wins' Column to sort data by. ascending boolean &lt;optional&gt; false Sort ascending or descending order. limit number &lt;optional&gt; 10 Limit the number of fetched users. offset number &lt;optional&gt; 0 Offset start index of found users. Source: hg/StatGroup.js, line 239 HGStatMetadata Metadata to store along with a HungryGames~StatGroup object. These values are user-defined and are not necessarily correct and are not trustworthy for any processing. Type: object Properties: Name Type Argument Description name string &lt;optional&gt; The user-defined name of this stats object. startTime Date &lt;optional&gt; The timestamp at which this stats object starts to include information. endTime Date &lt;optional&gt; The timestamp of the last time this object includes information for. createDate Date The timestamp at which this stats object was created. modifiedDate Date The timestamp at which this stats object was last modified. Source: hg/StatGroup.js, line 9 loginState The current OAuth2 access information for a single session. Properties: Name Type Argument Description access_token string The current token for api requests. token_type string The type of token. (Usually 'Bearer') expires_in number Number of seconds after the token is authorized at which it becomes invalid. refresh_token string Token used to refresh the expired access_token. scope string The scopes that the access_token has access to. expires_at number The unix timestamp when the access_token expires. expiration_date number The unix timestamp when we consider the session to have expired, and the session is deleted. session string The 64 byte base64 string that identifies this session to the client. refreshTimeout Timeout &lt;nullable&gt; The current timeout registered for refreshing the access_token. Source: web/proxy.js, line 67 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Modules Classes ChatBot CmdScheduling ScheduledCommand Command CommandSetting SingleCommand Common Connect4 Game Define DevCmds Echo Character FunTranslators HG HGWeb HungryGames ArenaEvent Battle Day DefaultOptions BooleanOption NumberOption ObjectOption Option SelectOption Event FinalEvent ForcedOutcome Game Grammar GuildGame Messages OutcomeProbabilities Player Simulator Worker StatGroup StatManager Stats Team UserIconUrl WeaponEvent Main MainModule Messages Moderation ModLog Settings Music NPC Patreon toExport Polling Poll RaidBlock RaidSettings RoleColors RoleManager Sandbox SMLoader SpikeyBot Spotify Strings Locale SubModule TicTacToe Game TTS Uno Card Game WebAccount WebCommands WebProxy WebSettings WebStats × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Classes Classes ChatBot CmdScheduling ScheduledCommand Command CommandSetting SingleCommand Common Connect4 Game Define DevCmds Echo Character FunTranslators HG HGWeb HungryGames ArenaEvent Battle Day DefaultOptions BooleanOption NumberOption ObjectOption Option SelectOption Event FinalEvent ForcedOutcome Game Grammar GuildGame Messages OutcomeProbabilities Player Simulator Worker StatGroup StatManager Stats Team UserIconUrl WeaponEvent Main MainModule Messages Moderation ModLog Settings Music NPC Patreon toExport Polling Poll RaidBlock RaidSettings RoleColors RoleManager Sandbox SMLoader SpikeyBot Spotify Strings Locale SubModule TicTacToe Game TTS Uno Card Game WebAccount WebCommands WebProxy WebSettings WebStats × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Externals Classes ChatBot CmdScheduling ScheduledCommand Command CommandSetting SingleCommand Common Connect4 Game Define DevCmds Echo Character FunTranslators HG HGWeb HungryGames ArenaEvent Battle Day DefaultOptions BooleanOption NumberOption ObjectOption Option SelectOption Event FinalEvent ForcedOutcome Game Grammar GuildGame Messages OutcomeProbabilities Player Simulator Worker StatGroup StatManager Stats Team UserIconUrl WeaponEvent Main MainModule Messages Moderation ModLog Settings Music NPC Patreon toExport Polling Poll RaidBlock RaidSettings RoleColors RoleManager Sandbox SMLoader SpikeyBot Spotify Strings Locale SubModule TicTacToe Game TTS Uno Card Game WebAccount WebCommands WebProxy WebSettings WebStats × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Bot's website: SpikeyBot.com Support my development: Patreon PayPal Commands Web Page with most commands available on the bot's website Hidden Commands These commands are not included in the normal help page or help command because they are either easter-eggs, developer commands, or just not useful for most users. git (Get the git commit log, or run a git command) js (Run sandboxed javascript code, currently disabled) py (Run sandboxed python code, currently disabled) py3 (Run sandboxed python3 code, currently disabled) run (If dev.js is loaded, this will run unsafe scripts on the bot using eval) thotpm (Semi-anonymously have the bot DM someone. Only a couple people can use this command) pmuser (Sends the specified user a pm from the bot, but tells the recipient who the sender was) uptime (Amount of time the bot has been running) version (Current bot version) game (Information about a user's current visible status) hg save (Causes hungry games to save all data manually) hg debug (Dumps current guild's hungry games data into a file) hg debugevents (Dumps all currently loaded events for the guild into a JSON files for download) hg makemewin (Replies with a message telling the user their chances of winning have not increased) hg makemelose (Replies with a message telling the user their chances of losing have not increased) hg rigged (Replies with an image of the emoji that says \"rigged\") hg nums (Replies with number of currently simulating games, loaded games, and connected web clients across all shards) vi (Alias for play nice try vi) airhorn (Plays airhorn sound) rickroll (Plays Rick Astley in voice channel) kokomo (Alias for play kokomo) updategame (Changes bot's status) reboot (Triggers a graceful shutdown of the entire bot. Assumes the parent process will restart automatically) reload (Gracefully unloads all sub-modules, and re-loads and initializes them) mainreload (Gracefully unloads all main-modules, and re-loads and initializes them) unload (Gracefully unloads specified sub-modules, and will not load them again until load is used) load (Attempts to load the specified sub-modules) record (Record audio in a voice channel. Mention people to only record specific people.) perms (Sends a message with the bitfields of all permissions, as well as the sender's and the bot's permissions for the guild and channel) lookup (Finds information about a given ID) sendto (Given a user or channel ID, the bot will send the message anonymously. Only trusted people can do this) saveall (Trigger all submodules to save their data) thanks (Thanks the person that was mentioned, or says \"You're welcome\") musicstats (Shows information about currently playing broadcasts) uno stats (Shows information about current uno games) chat (Forces the sent message to be sent to dialogflow instead of being treated as a normal command) listcommands (Lists all commands that are currently registered with SpikeyBot~Commands) getprefix (Used by chatbot so users can ask the bot, by mentioning it, what the prefix is) whoami (Replies with the user's username, and full tag from different sources) gettime (Replies with the server's timezone and time, as well as GMT) Event Controlled Added to guild Sends a message to the top text channel introducing the bot. User in guild is banned Sends a message saying the user was banned and by whom. Disable with togglebanmessages. Self-Hosting The bot is not designed to be easily hosted by others, but still may be done. The below steps outline the minimum required to get the SpikeyBot to run. Have a server/computer SB is developed and tested solely on Debian Stretch (amd64), but other OS's may work. Install NodeJS The bot is currently running on NodeJS v10.16.0. Other versions may work, but are untested. Download source code Clone this repository git clone https://github.com/CampbellCrowley/SpikeyBot-Discord.git or click the green download button in GitHub. Install system dependencies sudo apt install make libtool autoconf g++ ffmpeg are required for the default installation. Install dependencies via NPM Current version of NPM used is v6.9.0, but almost any version should be fine. In the SpikeyBot-Discord directory, run npm install. Get a bot token from Discord A token for the bot that you are trying to run from Discord is required. DO NOT give this token to anybody. Keep it private. The token allows anyone to be your bot. Configure SpikeyBot Create auth.js in the SpikeyBot-Discord/ directory with a line that says exports.release = 'BOT_TOKEN';, where BOT_TOKEN is the bot token from Discord. Modify ./subModules.json \"release\" section to have the subModules you want. If you wish to have access to developer commands that normally only SpikeyRobot has access to, replace the spikeyId in ./src/common.js with your account ID. Run SpikeyBot Run node src/SpikeyBot.js in SpikeyBot-Discord/ (working directory must be the project root). Errors about gApiCredentials.json missing can be suppressed by removing ./tts.js and ./chatbot.js from ./subModules.json since these require special authentication from Google's API. (https://console.cloud.google.com/) All website related subModules will not work, and related errors can be suppressed by removing all subModules that start with ./web/ from ./subModules.json. If you are not running with --shards and wish to use the Hungry Games submodule, you must run node with --experimental-worker. Development Unit tests exist Covers all current commands with text-only replies. Tests only send a message, and check for response messages that match expected output. String exact match String contains match String does not contain match String is not an error Is an embed Correct number of messages Does not check the content of embeds. Need more thorough and flexible tests. Linting All commits are checked by eslint using Google defaults. Eslint is run with pre-commit git hook. Most code is moved into subModules for easier division and reloading. Minimal mode only loads minimal features to allow for multiple bots to run without overlap. Music subModule downloads audio in a separate thread but is still managed by the main event loop. SubModules are stored in ./subModules.json. Path relative to module should be given (Usually relative to ./src/). Must be valid for directly being passed into require(). MainModules are loaded automatically by ./src/SpikeyBot.js and are required. SubModules are loaded by ./src/smLoader.js. Commands are all managed by ./src/commands.js. Additional MainModules can be loaded by placing them in ./mainModules.json Files Most persistent data is saved to disk when bot shuts down. Hungry Games current state is saved and loaded. Events and most messages are also read from file. Timers settings are saved. Music queues are not saved, but may continue playing after unloading submodule. × Search results Close "},"ChatBot.html":{"id":"ChatBot.html","title":"Class: ChatBot","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: ChatBot ChatBot Manages natural language interaction. new ChatBot() Source: chatbot.js, line 16 Listens to Events: Discord#event:message Command#event:chat Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; disabledChatBot :Object.&lt;boolean&gt; The guilds that have disabled the chatbot feature. Type: Object.&lt;boolean&gt; Source: chatbot.js, line 26 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandToggleChatBot(msg) Toggles the chatbot feature on a guild. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: chatbot.js, line 299 Listens to Events: Command#event:togglechatbot &lt;private, inner&gt; escapeRegExp(str) Escape a given string to be passed into a regular expression. Parameters: Name Type Description str string Input to escape. Source: chatbot.js, line 317 Returns: Escaped string. Type string &lt;private, inner&gt; mkAndWrite(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Async. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: chatbot.js, line 104 See: Main~mkAndWriteSync &lt;private, inner&gt; mkAndWriteSync(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Synchronous. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: chatbot.js, line 131 See: Main~mkAndWrite &lt;private, inner&gt; onChatMessage(msg) Send message text content to dialogflow for handling. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: chatbot.js, line 205 Listens to Events: Command#event:chat &lt;private, inner&gt; onMessage(msg) Respond to messages where I've been mentioned. Parameters: Name Type Description msg Discord~Message Message was sent. Source: chatbot.js, line 167 Listens to Events: Discord#event:message × Search results Close "},"CmdScheduling.html":{"id":"CmdScheduling.html","title":"Class: CmdScheduling","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: CmdScheduling CmdScheduling Provides interface for scheduling a specific time or interval for a command to be run. new CmdScheduling() Source: cmdScheduling.js, line 18 Listens to Events: Command#event:schedule Command#event:sch Command#event:sched Command#event:scheduled Extends SubModule Classes ScheduledCommand Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 cancelCmd Cancel a scheduled command in a guild. Source: cmdScheduling.js, line 854 See: CmdScheduling~cancelCmd client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;constant&gt; minDelay :number Minimum allowable amount of time in milliseconds from when the scheduled command is registered to when it runs. Type: number Default Value: 10 Seconds Source: cmdScheduling.js, line 237 &lt;constant&gt; minRepeatDelay :number Minimum allowable amount of time in milliseconds from when the scheduled command is run to when it run may run again. Type: number Default Value: 30 Seconds Source: cmdScheduling.js, line 248 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 registerScheduledCommand Register a created CmdScheduling.ScheduledCommand. Source: cmdScheduling.js, line 574 See: CmdScheduling~registerScheduledCommand &lt;private, inner, constant&gt; embedColor :Array.&lt;number&gt; The color to use for embeds sent from this submodule. Type: Array.&lt;number&gt; Default Value: [50,255,255] Source: cmdScheduling.js, line 226 &lt;private, inner, constant&gt; idChars :string The possible characters that can make up an ID of a scheduled command. Type: string Default Value: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ Source: cmdScheduling.js, line 216 &lt;private, inner&gt; listeners :Object.&lt;Array.&lt;function()&gt;&gt; Currently registered event listeners, mapped by event name. Type: Object.&lt;Array.&lt;function()&gt;&gt; Source: cmdScheduling.js, line 256 &lt;private, inner&gt; longInterval :Interval Interval that runs every maxTimeout milliseconds in order to re-schedule commands that were beyond the max timeout duration. Type: Interval Source: cmdScheduling.js, line 185 &lt;private, inner, constant&gt; maxTimeout :number The maximum amount of time to set a Timeout for. The JS limit is 24 days (iirc), after which, Timeouts do not work properly. Type: number Default Value: 14 Days Source: cmdScheduling.js, line 196 &lt;private, inner, constant&gt; saveSubDir :string The filename in the guild directory to save the scheduled commands. Type: string Default Value: /scheduledCmds.json Source: cmdScheduling.js, line 206 &lt;private, inner, constant&gt; schedules :Object.&lt;Array.&lt;CmdScheduling.ScheduledCommand&gt;&gt; All of the currently loaded commands to run. Mapped by Guild ID, then sorted arrays by time to run next command. Type: Object.&lt;Array.&lt;CmdScheduling.ScheduledCommand&gt;&gt; Source: cmdScheduling.js, line 265 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 on(name, handler) Register an event handler for the given name with the given handler. Parameters: Name Type Description name string The event name to listen for. handler function The function to call when the event is fired. Source: cmdScheduling.js, line 970 removeListener(name [, handler]) Remove an event handler for the given name. Parameters: Name Type Argument Description name string The event name to remove the handler for. handler function &lt;optional&gt; THe specific handler to remove, or null for all. Source: cmdScheduling.js, line 986 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; cancelAndReply(msg) Find a scheduled command with the given ID, and remove it from commands to run. Parameters: Name Type Description msg Discord~Message The message to reply to. Source: cmdScheduling.js, line 863 &lt;private, inner&gt; cancelCmd(gId, cmdId) Cancel a scheduled command in a guild. Parameters: Name Type Description gId string | number The guild id of which to cancel the command. cmdId string | number The ID of the command to cancel. Source: cmdScheduling.js, line 833 Fires: CmdScheduling#event:commandCancelled Returns: Null if failed, or object that was cancelled. Type CmdScheduling.ScheduledCommand &lt;private, inner&gt; commandSchedule(msg) Allow user to schedule command to be run, or view currently scheduled commands. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: cmdScheduling.js, line 585 Listens to Events: Command#event:schedule &lt;private, inner&gt; fireEvent(name, data) Fires a given event with the associated data. Parameters: Name Type Argument Description name string The name of the event to fire. data * &lt;repeatable&gt; The arguments to pass into the function calls. Source: cmdScheduling.js, line 1007 &lt;private, inner&gt; formatDelay(msecs) Format a duration in milliseconds into a human readable string. Parameters: Name Type Description msecs number Duration in milliseconds. Source: cmdScheduling.js, line 929 Returns: Formatted string. Type string &lt;inner&gt; getScheduledCommandsInGuild(gId) Returns an array of references to scheduled commands in a guild. Parameters: Name Type Description gId string | number The guild id of which to get the commands. Source: cmdScheduling.js, line 773 Returns: Null if none, or the array of ScheduledCommands. Type null | Array.&lt;CmdScheduling.ScheduledCommand&gt; &lt;private, inner&gt; makeMessage(uId, gId, cId, msg) Forms a Discord~Message similar object from given IDs. Parameters: Name Type Description uId string The id of the user who wrote this message. gId string The id of the guild this message is in. cId string The id of the channel this message was 'sent' in. msg string The message content. Source: cmdScheduling.js, line 1038 Returns: The created message-like object. Type Object &lt;private, inner&gt; registerScheduledCommand(sCmd) Register a created CmdScheduling.ScheduledCommand. Parameters: Name Type Description sCmd CmdScheduling.ScheduledCommand The ScheduledCommand object to register. Source: cmdScheduling.js, line 553 Fires: CmdScheduling#event:commandRegistered Returns: True if succeeded, False if too close to existing command. Type boolean &lt;private, inner&gt; replyWithSchedule(msg) Find all scheduled commands for a certain guild, and reply to the message with the list of commands. Parameters: Name Type Description msg Discord~Message The message to reply to. Source: cmdScheduling.js, line 790 &lt;inner&gt; reScheduleCommands() Reschedule all future commands that are beyond maxTimeout. Source: cmdScheduling.js, line 899 &lt;private, inner&gt; sortGuildCommands(id) Sort all scheduled commands in a guild by the next time they will run. Parameters: Name Type Description id string | number The guild id of which to sort the commands. Source: cmdScheduling.js, line 673 &lt;private, inner&gt; stringToMilliseconds(str) Given a user-inputted string, convert to a number of milliseconds. Input can be on most common time units up to a week. Parameters: Name Type Description str string The input string to parse. Source: cmdScheduling.js, line 707 Returns: Number of milliseconds parsed from string. Type number &lt;private, inner&gt; writeSaveData(i, data [, opt]) Write save data for a guild. Parameters: Name Type Argument Default Description i string | number The guild ID. data object The data to write. opt string &lt;optional&gt; 'sync' See save. Source: cmdScheduling.js, line 121 × Search results Close "},"CmdScheduling-ScheduledCommand.html":{"id":"CmdScheduling-ScheduledCommand.html","title":"Class: ScheduledCommand","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: ScheduledCommand CmdScheduling~ ScheduledCommand Stores information about a specific command that is scheduled. new ScheduledCommand(cmd, channel, message, time, repeatDelay) Parameters: Name Type Argument Default Description cmd string | object The command to run, or an object instance of this class (exported using toJSON, then parsed into an object). channel string | number | Discord~TextChannel The channel or channel id of where to run the command. message string | number | Discord~Message The message or message id that created this scheduled command. time number The unix timestamp at which to run the command. repeatDelay number &lt;nullable&gt; 0 The delay in milliseconds at which to run the command again, or null if it does not repeat. Properties: Name Type Argument Default Description cmd string The command to run. bot number | string The id of the bot instantiating this command. channel Discord~TextChannel The channel or channel id of where to run the command. channelId string | number The id of the channel where the message was sent. message Discord~Message &lt;nullable&gt; The message that created this scheduled command, or null if the message was deleted. messageId string | number The id of the message sent. time number The unix timestamp at which to run the command. repeatDelay number &lt;optional&gt; 0 The delay in milliseconds at which to run the command again. 0 to not repeat. id string Random base 36, 3-character long id of this command. complete boolean True if the command has been run, and will not run again. timeout Timeout The current timeout registered to run the command. member Discord~GuildMember The author of this ScheduledCommand. memberId string | number The id of the member. Source: cmdScheduling.js, line 302 Methods cancel() Cancel this command and remove Timeout. Source: cmdScheduling.js, line 484 go() Trigger the command to be run immediately. Automatically fired at the scheduled time. Does not cancel the normally scheduled command. Re-schedules the command if the command should repeat. Source: cmdScheduling.js, line 401 setTimeout() Schedule the Timeout event to call the command at the scheduled time. If the scheduled time to run the command is more than 2 weeks in the future, the command is not scheduled, and this function must be called manually (less than 2 weeks) before the scheduled time for the command to run. Source: cmdScheduling.js, line 497 toJSON() Export the relevant data to recreate this object, as a JSON object. Source: cmdScheduling.js, line 524 Returns: JSON formatted object. Type object &lt;private, inner&gt; getReferences() Update channel and message with their associated IDs. Source: cmdScheduling.js, line 340 × Search results Close "},"Command.html":{"id":"Command.html","title":"Class: Command","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Command Command Manages the command event firing for all commands. This is not a normal submodule, and is treated differently in the SpikeyBot class. new Command() Source: commands.js, line 12 Extends MainModule Classes CommandSetting SingleCommand Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 CommandSetting Source: commands.js, line 673 See: Command~CommandSetting &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 deleteEvent Alias for Command.removeListener Deprecated: Yes Source: commands.js, line 862 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: MainModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 SingleCommand Source: commands.js, line 382 See: Command~SingleCommand &lt;private, inner&gt; cmds :Object.&lt;SingleCommand&gt; All tracked commands mapped by command name. Type: Object.&lt;SingleCommand&gt; Source: commands.js, line 160 &lt;private, inner, constant&gt; commandSettingsFile :string Filename in the guild's subdirectory where command settings are stored. Type: string Default Value: /commandSettings.json Source: commands.js, line 730 &lt;inner&gt; eventList Currently registered event listeners for non-command events. Source: commands.js, line 152 &lt;private, inner, constant&gt; onlyservermessage :string The message to send to the user if they attempt a server-only command in a non-server channel. Type: string Source: commands.js, line 720 &lt;private, inner, constant&gt; userSettings :Object.&lt;Object.&lt;CommandSetting&gt;&gt; Specific settings defined by users as restrictions on commands. Mapped by guild id, then by the command. Type: Object.&lt;Object.&lt;CommandSetting&gt;&gt; Source: commands.js, line 682 Methods addEventListener(name, handler) Register an event listener. Parameters: Name Type Description name string The name of the event to listen for. handler function The function to call when the event is fired. Source: commands.js, line 1604 begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 export() Export data required to maintain the bot across reloading this module. Expected to be returned directly to this.import once reloaded. Inherited From: MainModule#export Overrides: MainModule#export Source: mainModule.js, line 40 Returns: The data to be exported. Type MainModule~ModuleData find(cmd, msg [, setCmd]) Returns the callback function for the given event. Parameters: Name Type Argument Default Description cmd string &lt;nullable&gt; Command to force search for, and ignore command that could be matched with msg. msg Discord~Message Message that is to trigger this command. This object will be updated with the command name that was found as msg.cmd. setCmd boolean &lt;optional&gt; false Set the cmd variable in the msg object to match the found command. Source: commands.js, line 878 Returns: The single command object reference, or null if it could not be found. Type Command~SingleCommand findAll(cmd, msg) Returns all the callback functions for the given event with wildcards allowed. Parameters: Name Type Description cmd string Command and subcommands to search for without guild prefixes. msg Discord~Message Message object to use to remove command prefix if it exist. Source: commands.js, line 920 Returns: The command object references, or an empty array if it could not be found. Type Array.&lt;Command~SingleCommand&gt; fire(name, args) Fire all handlers listening for an event. Parameters: Name Type Description name string The name of the event to fire. args * The arguments to pass to the handlers. Source: commands.js, line 1635 getAllNames() Fetches a list of all currently registered commands. Source: commands.js, line 1030 Returns: Array of all registered commands. Type Array.&lt;string&gt; getDefaultSettings() Fetch all commands and their default setting values. Source: commands.js, line 708 See: Command~cmds Returns: All currently registered commands. Type object.&lt;SingleCommand&gt; getUserSettings(gId) Fetch all user-defined settings for a guild. Parameters: Name Type Description gId string The guild id of which to fetch the settings. Source: commands.js, line 693 Returns: The settings for the guild mapped by command name. If it doesn't exist, an object will first be created. Type object.&lt;CommandSetting&gt; import(data) Imports data from a previous instance of this class in order to maintain references to other objects and classes across reloads. Parameters: Name Type Argument Description data MainModule~ModuleData &lt;nullable&gt; The data that was exported previously, or null if no data to import. Inherited From: MainModule#import Overrides: MainModule#import Source: mainModule.js, line 30 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: MainModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 on(cmd [, cb] [, onlyserver]) Registers a listener for a command. Parameters: Name Type Argument Default Description cmd string | Array.&lt;string&gt; | Command~SingleCommand Command to listen for. cb commandHandler &lt;optional&gt; Function to call when command is triggered. onlyserver boolean &lt;optional&gt; false Whether the command is only allowed on a server. Source: commands.js, line 811 removeEventListener(name, handler) Remove an event listener. Parameters: Name Type Description name string The name of the event to listen for. handler function THe handler that is currently registered to listen on this event. Source: commands.js, line 1617 removeListener(cmd) Remove listener for a command. Parameters: Name Type Description cmd string | Array.&lt;string&gt; Command or alias of command to remove listener for. Source: commands.js, line 837 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: MainModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: MainModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; terminate() Signal that the bot is shutting down and will not be restarting immediately. This is triggered on all shutdowns where all MainModules and SubModules will be unloaded. Inherited From: MainModule#terminate Source: mainModule.js, line 51 trigger(msg [, msg2]) Trigger a command firing and call it's handler passing in msg as only argument. Parameters: Name Type Argument Description msg Discord~Message | string Message received from Discord to pass to handler and to use to find the correct handler, OR a string to override the command to trigger from msg. msg2 Discord~Message &lt;optional&gt; The message received from Discord if the first argument is a string. Source: commands.js, line 743 Returns: True if command was handled by us. Type boolean &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean validate(cmd, msg [, func]) Checks that the given command can be run with the given context. Does not actually fire the event. Parameters: Name Type Argument Description cmd string &lt;nullable&gt; The command to validate. Null to use msg to find the command to validate. msg Discord~Message &lt;nullable&gt; The message that will fire the event. If null, checks for channel and guild specific changes will not be validated. func Command~SingleCommand &lt;optional&gt; A command handler override to use for settings lookup. If this is not specified, the handler associated with cmd will be fetched. Source: commands.js, line 972 Returns: Message causing failure, or null if valid. Type string &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandAllowCmd(msg) Allow user to unmute a command. Parameters: Name Type Description msg Discord~Message The message the user sent that triggered this. Source: commands.js, line 1292 &lt;private, inner&gt; commandBlockCmd(msg) Allow user to mute a command. Parameters: Name Type Description msg Discord~Message The message the user sent that triggered this. Source: commands.js, line 1256 &lt;private, inner&gt; commandDisable(msg) Allow user to disable a command. Parameters: Name Type Description msg Discord~Message The message the user sent that triggered this. Source: commands.js, line 1042 &lt;private, inner&gt; commandEnable(msg) Allow user to enable a command. Parameters: Name Type Description msg Discord~Message The message the user sent that triggered this. Source: commands.js, line 1149 &lt;private, inner&gt; commandReset(msg) Reset all custom command settings to default. Parameters: Name Type Description msg Discord~Message The message the user sent that triggered this. Source: commands.js, line 1506 Fires: Command.events#event:settingsReset &lt;private, inner&gt; commandShow(msg) Show user the currently configured settings for commands. Parameters: Name Type Description msg Discord~Message The message the user sent that triggered this. Source: commands.js, line 1328 &lt;private, inner&gt; escapeRegExp(str) Escape a given string to be passed into a regular expression. Parameters: Name Type Description str string Input to escape. Source: commands.js, line 1650 Returns: Escaped string. Type string × Search results Close "},"Command-CommandSetting.html":{"id":"Command-CommandSetting.html","title":"Class: CommandSetting","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: CommandSetting Command~ CommandSetting Stores all settings related to a command. new CommandSetting( [opts]) Parameters: Name Type Argument Description opts Command~CommandSetting &lt;optional&gt; The options to set, or nothing for default values. Source: commands.js, line 392 Members defaultDisabled Whether this command is disabled for all by default and requires them to be in the list of enabled IDs. If this is false, the command is enabled for everyone, unless they fall under the 'disabled' list. Source: commands.js, line 413 &lt;readonly&gt; disabled :Object The IDs of all places where this command is currently disabled. Any ID will be mapped to a truthy value. Roles will be mapped to the guild ID and the role ID. Use Command~CommandSetting.set to change these values. Type: Object Source: commands.js, line 428 &lt;readonly&gt; enabled :Object The IDs of all places where this command is currently enabled. Any ID will be mapped to a truthy value. Roles will be mapped to the guild ID and the role ID. Use Command~CommandSetting.set to change these values. Type: Object Source: commands.js, line 457 &lt;private&gt; isMuted :boolean Will this command be completely silenced so that no output will be sent. Only applicable when command is disabled. Type: boolean Source: commands.js, line 492 &lt;nullable&gt; myGuild :string The guild ID of the guild is settings object is for, or null if this instance is not specific to a single guild. Type: string Source: commands.js, line 401 permissions :number Bitfield representation of the required permissions for a user to have to run this command. Same bitfield used by Discord~Permissions. Type: number Default Value: 0 Source: commands.js, line 480 validOnlyInGuild :boolean If the command is only allowed to be used in guilds. Type: boolean Source: commands.js, line 407 Methods isDisabled(msg) Check if this command is disabled with the given context. Parameters: Name Type Description msg Discord~Message The message with the current context of which to check if the command is disabled. Source: commands.js, line 579 Returns: 0 if not disabled, 2 if disabled is specific to user, 1 if disabled for any other reason. Type number set(value, type, id [, id2]) Enable, disable, or neutralize this command for the associated guild, channel, user, or role. Parameters: Name Type Argument Description value string Whether to set this ID to enabled, disabled, or to whatever the default value is. Allowed values: `enabled`|`disabled`|`default`. type string The type of ID that is being given. Allowed values: `guild`|`channel`|`user`|`role`. id string The id to set the value to. id2 string &lt;optional&gt; The guild ID if `type` is 'role', of where the role is created. Source: commands.js, line 509 Fires: Command.events#event:settingsChanged toJSON() Creates a JSON formatted object with the necessary properties for re-creating this object. Source: commands.js, line 660 Returns: Object ready to be stringified for file saving. Type object × Search results Close "},"Command-SingleCommand.html":{"id":"Command-SingleCommand.html","title":"Class: SingleCommand","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: SingleCommand Command~ SingleCommand Object storing information about a single command, it's handler, and default options. new SingleCommand(cmd, handler [, opts] [, subCmds]) Parameters: Name Type Argument Description cmd string | Array.&lt;string&gt; All commands the handler will fire on. handler commandHandler The event handler when the command has been triggered. opts CommandSetting &lt;optional&gt; The options for this command. subCmds SingleCommand | Array.&lt;SingleCommand&gt; &lt;optional&gt; Sub commands that use this command as a fallback. Command names must be separated by white space in order to trigger the sub command. Source: commands.js, line 176 Members aliases :Array.&lt;string&gt; All versions of this command that may be used to trigger the same handler. Type: Array.&lt;string&gt; Source: commands.js, line 247 options :Command~CommandSetting The current options and settings for this command. Type: Command~CommandSetting Source: commands.js, line 354 &lt;readonly, nullable&gt; parentName :string The name of the parent command if this is a subcommand. Type: string Source: commands.js, line 195 subCmds :Object.&lt;SingleCommand&gt; Sub commands for this single command. Triggered by commands separated by whitespace. Object mapped by subcommand name, similar to Command~cmds. Type: Object.&lt;SingleCommand&gt; Source: commands.js, line 258 Methods getFullName() Get the full name for this command including parent command. Source: commands.js, line 219 Returns: This command's name prefixed with the parent command's name. Type string getName() Get the primary key for this object. The first or only value passed in for `cmd`, and may be used to show the user the command that this object stores information about. Source: commands.js, line 236 Returns: The command string. Type string getUserOptions() Fetches the user options for this command, taking into account this could be a subcommand. Source: commands.js, line 363 Returns: The settings for this command or sub-command mapped by guild ids. Type object.&lt;CommandSetting&gt; trigger(msg) The function to call when this command has been triggered. Parameters: Name Type Description msg Discord~Message The message that is triggering this command. Source: commands.js, line 271 updateParentName(to) Update the parent name for this command and all child commands. Parameters: Name Type Description to string The parent name to set. Source: commands.js, line 203 × Search results Close "},"Common.html":{"id":"Common.html","title":"Class: Common","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Common Common new Common() Commonly required things. Helper functions and constants. Source: common.js, line 15 Members &lt;static&gt; fmtDAPIErr Format a Discord API error. Source: common.js, line 416 &lt;static, constant&gt; guildSaveDir :string The root file directory for finding saved data related to individual guilds. Type: string Source: common.js, line 500 &lt;static, constant&gt; logChannel :string The channel id for the channel to send general log messages to. Type: string Source: common.js, line 433 &lt;static&gt; mention Creates formatted string for mentioning the author of msg. Source: common.js, line 540 &lt;static, constant&gt; spikeyId :string SpikeyRobot's Discord ID Type: string Source: common.js, line 375 &lt;static, constant&gt; trustedIds :Array.&lt;string&gt; Trusted IDs. Type: Array.&lt;string&gt; Source: common.js, line 396 See: Common.prototype.trustedIds &lt;static, constant&gt; userSaveDir :string The root file directory for finding saved data related to individual users. Type: string Source: common.js, line 518 &lt;static, constant&gt; webHelp :string The website full URL for commands help page. Type: string Source: common.js, line 482 &lt;static, constant&gt; webPath :string The website path for more help and documentation. Type: string Source: common.js, line 466 &lt;static, constant&gt; webURL :string The website base URL for pointing to for more help and documentation. Type: string Source: common.js, line 450 &lt;constant&gt; guildSaveDir :string The root file directory for finding saved data related to individual guilds. Type: string Default Value: ./save/guilds/ Source: common.js, line 492 isRelease :boolean Whether this should be shown as a release version, or a debug version in the log. Type: boolean Source: common.js, line 54 isTest :boolean Whether this current instance is running as a unit test. Type: boolean Source: common.js, line 59 &lt;constant&gt; logChannel :string The channel id for the channel to send general log messages to. Type: string Default Value: 473935520821673991 Source: common.js, line 425 &lt;constant&gt; spikeyId :string SpikeyRobot's Discord ID. If you are self-hosting SpikeyBot, change this to your account ID to be able to give yourself full access to all features of the bot. Type: string Default Value: 124733888177111041 Source: common.js, line 367 &lt;constant&gt; trustedIds :Array.&lt;string&gt; Discord IDs that are allowed to reboot the bot, and are overall trusted individuals/accounts. Type: Array.&lt;string&gt; Source: common.js, line 384 &lt;constant&gt; userSaveDir :string The root file directory for finding saved data related to individual users. Type: string Default Value: ./save/users/ Source: common.js, line 510 &lt;constant&gt; webHelp :string The website full URL for commands help page. Type: string Source: common.js, line 475 &lt;constant&gt; webPath :string The website path for more help and documentation. Type: string Default Value: help/ Source: common.js, line 459 &lt;constant&gt; webURL :string The website base URL for pointing to for more help and documentation. Type: string Default Value: https://www.spikeybot.com/ Source: common.js, line 443 &lt;private, inner, constant&gt; app :string The script's filename to show in the log. Type: string Source: common.js, line 39 &lt;private, inner&gt; mycolor :number The color code to prefix log messages with for this script. Type: number Source: common.js, line 32 &lt;private, inner, constant&gt; prefixLength :number The number of characters reserved for the filename of the script. Type: number Default Value: 14 Source: common.js, line 24 &lt;private, inner&gt; title :string The final formatted filename for logging. Type: string Source: common.js, line 47 Methods &lt;private, static&gt; camelToSpaces(str) Convert a string in camelcase to a human readable spaces format. (helloWorld --&gt; Hello World) Parameters: Name Type Description str string The input. Source: common.js, line 635 Returns: The output. Type string &lt;static&gt; connectSQL( [force]) Create initial connection with sql server. The connection is injected into the global scope as sqlCon. If a connection still exists, calling this function just returns the current reference. Parameters: Name Type Argument Default Description force boolean &lt;optional&gt; false Force a new connection to be established. Source: common.js, line 658 Returns: Current sql connection object. Type sql.ConnectionConfig &lt;static&gt; deepFreeze(object) Recursively freeze all elements of an object. Parameters: Name Type Description object object The object to deep freeze. Source: common.js, line 616 Returns: The frozen object. Type object &lt;static&gt; mkAndWrite(filename, dir, data [, cb]) Write data to a file and make sure the directory exists or create it if it doesn't. Async. Parameters: Name Type Argument Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string | object The data to write to the file. cb function &lt;optional&gt; Callback to fire on completion. Only parameter is optional error. Source: common.js, line 557 See: Common~mkAndWriteSync &lt;static&gt; mkAndWriteSync(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Synchronous. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: common.js, line 591 See: Common~mkAndWrite begin(isTest, isRelease) Initialize variables and settings for logging properly. Parameters: Name Type Description isTest boolean Is this running as a test. isRelease boolean Is this a release version, or a development version of the app running. Source: common.js, line 68 error(message, ip [, traceIncrease]) Format an error message to be logged. Parameters: Name Type Argument Default Description message string The message to display. ip string The IP address or unique identifier of the client that caused this event to happen. traceIncrease number &lt;optional&gt; 0 Increase the distance up the stack to show the in the log. Source: common.js, line 235 fmtDAPIErr(e) Format a Discord API error. Parameters: Name Type Description e Discord~DiscordAPIError DiscordAPIError to format into a string. Source: common.js, line 404 Returns: Error formatted as single line string. Type string getIPName(ip) Formats a given IP address by padding with zeroes, or completely replacing with a human readable alias if the address is a known location. Parameters: Name Type Description ip string The ip address to format. Source: common.js, line 129 Returns: The formmatted address. Type string log(message, ip [, traceIncrease]) Format a log message to be logged. Parameters: Name Type Argument Default Description message string The message to display. ip string The IP address or unique identifier of the client that caused this event to happen. traceIncrease number &lt;optional&gt; 0 Increase the distance up the stack to show the in the log. Source: common.js, line 209 logDebug(message, ip [, traceIncrease]) Format a log message to be logged. Prefixed with DBG. Parameters: Name Type Argument Default Description message string The message to display. ip string The IP address or unique identifier of the client that caused this event to happen. traceIncrease number &lt;optional&gt; 0 Increase the distance up the stack to show the in the log. Source: common.js, line 196 logWarning(message, ip [, traceIncrease]) Format a log message to be logged. Prefixed with WRN. Parameters: Name Type Argument Default Description message string The message to display. ip string The IP address or unique identifier of the client that caused this event to happen. traceIncrease number &lt;optional&gt; 0 Increase the distance up the stack to show the in the log. Source: common.js, line 222 mention(msg) Creates formatted string for mentioning the author of msg. Parameters: Name Type Description msg Discord~Message | Discord~UserResolvable Message to format a mention for the author of. Source: common.js, line 527 Returns: Formatted mention string. Type string padIp(str) Pad an IP address with zeroes. Parameters: Name Type Description str number The ipv4 address as a string to format. Source: common.js, line 98 Returns: The padded address. Type string reply(msg, text [, post]) Replies to the author and channel of msg with the given message. Parameters: Name Type Argument Description msg Discord~Message Message to reply to. text string The main body of the message. post string &lt;optional&gt; The footer of the message. Source: common.js, line 254 Returns: Promise of Discord~Message that we attempted to send, or null if error occurred before attempting to send. Type Promise updatePrefix(ip) Format a prefix for a log message or error. Includes the ip before the message. Parameters: Name Type Description ip string The ip to include in the prefix. Source: common.js, line 152 Returns: The formatted prefix for a log message. Type string &lt;private, inner&gt; __filename( [inc]) Gets the name of the file that called a log function. Parameters: Name Type Argument Default Description inc number &lt;optional&gt; 0 Increase distance up the stack to returns. Source: common.js, line 353 Returns: Filename in call stack. Type string &lt;private, inner&gt; __line( [inc]) Gets the line number of the function that called a log function. Parameters: Name Type Argument Default Description inc number &lt;optional&gt; 0 Increase distance up the stack to returns. Source: common.js, line 331 Returns: Line number of call in stack. Type number &lt;private, inner&gt; getTrace( [traceIncrease]) Gets the name and line number of the current function stack. Parameters: Name Type Argument Default Description traceIncrease number &lt;optional&gt; 0 Increase the distance up the stack to show the in the log. Source: common.js, line 314 Returns: Formatted string with length 24. Type string &lt;private, inner&gt; write(prefix, message, ip [, traceIncrease]) Write the final portion of the log message. Parameters: Name Type Argument Default Description prefix string The first characters on the line. message string The message to display. ip string The IP address or unique identifier of the client that caused this event to happen. traceIncrease number &lt;optional&gt; 0 Increase the distance up the stack to show the in the log. Source: common.js, line 173 × Search results Close "},"Connect4.html":{"id":"Connect4.html","title":"Class: Connect4","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Connect4 Connect4 Manages a Connect 4 game. new Connect4() Source: connect4.js, line 11 Listens to Events: Command#event:connect4 Extends SubModule Classes Game Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; emoji :Object.&lt;string&gt; Helper object of emoji characters mapped to names. Type: Object.&lt;string&gt; Default Value: {\"undefined\":\"9⃣\",\"X\":\"❌\",\"O\":\"⭕\"} Source: connect4.js, line 71 &lt;private, inner, constant&gt; maxReactAwaitTime :number Maximum amount of time to wait for reactions to a message. Also becomes maximum amount of time a game will run with no input, because controls will be disabled after this timeout. Type: number Default Value: 5 Minutes Source: connect4.js, line 41 &lt;private, inner, constant&gt; numCols :number The number of columns in the board. Type: number Default Value: 7 Source: connect4.js, line 61 &lt;private, inner&gt; numGames :number The number of currently active games. Used to determine of submodule is unloadable. Type: number Source: connect4.js, line 93 &lt;private, inner, constant&gt; numRows :number The number of rows in the board. Type: number Default Value: 6 Source: connect4.js, line 51 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 createGame(players, channel) Create a game with the given players in a given text channel. Parameters: Name Type Description players Object The players in the game. channel Discord~TextChannel The text channel to send messages. Source: connect4.js, line 252 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; addListener(msg, game) Add the listener for reactions to the game. Parameters: Name Type Description msg Discord~Message The message to add the reactions to. game Connect4~Game The game to update when changes are made. Source: connect4.js, line 282 &lt;private, inner&gt; addReactions(msg, index) Add the reactions to a message for controls of the game. Recursive. Parameters: Name Type Default Description msg Discord~Message The message to add the reactions to. index number 0 The number of reactions we have added so far. Source: connect4.js, line 269 &lt;inner&gt; checkWin(board, latestR, latestC) Checks if the given board has a winner, or if the game is over. Parameters: Name Type Description board Array.&lt;number&gt; Array of 9 numbers defining a board. 0 is nobody, 1 is player 1, 2 is player 2. latestR number The row index where the latest move occurred. latestC number The column index where the latest move occurred. Source: connect4.js, line 367 Returns: Returns 0 if game is not over, 1 if player 1 won, 2 if player 2 won, 3 if draw. Type number &lt;private, inner&gt; commandConnect4(msg) Starts a connect 4 game. If someone is mentioned it will start a game between the message author and the mentioned person. Otherwise, waits for someone to play. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: connect4.js, line 105 Listens to Events: Command#event:connect4 × Search results Close "},"Connect4_Game.html":{"id":"Connect4_Game.html","title":"Class: Game","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Game Connect4# Game new Game(players, msg) Class that stores the current state of a connect 4 game. Parameters: Name Type Description players Object The players in this game. msg Discord~Message The message displaying the current game. Source: connect4.js, line 123 Members board :Array.&lt;Array.&lt;number&gt;&gt; 2D Array of a 7w x 6h board. 0 is nobody, 1 is player 1, 2 is player 2. Type: Array.&lt;Array.&lt;number&gt;&gt; Source: connect4.js, line 134 msg :Discord~Message The message displaying the current game. Type: Discord~Message Source: connect4.js, line 151 players :Object The players in this game. Type: Object Source: connect4.js, line 129 turn :number Which player's turn it is. Either 1 or 2. Type: number Source: connect4.js, line 146 Methods print( [winner]) Edit the current message to show the current board. Parameters: Name Type Argument Default Description winner number &lt;optional&gt; 0 The player who has won the game. 0 is game not done, 1 is player 1, 2 is player 2, 3 is draw. Source: connect4.js, line 159 × Search results Close "},"Define.html":{"id":"Define.html","title":"Class: Define","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Define Define Handles defining word commands. new Define() Source: define.js, line 14 Listens to Events: Command#event:define Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; reqURL :string Base url to request from api. Type: string Default Value: https://wordsapiv1.p.rapidapi.com/words/ Source: define.js, line 36 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandDefine(msg) Handle the user asking for a definition. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: define.js, line 46 Listens to Events: Command#event:define &lt;private, inner&gt; formatSingle(el) Format a single definition to string format. Parameters: Name Type Description el Object Definition object to format. Source: define.js, line 139 Returns: Formatted string. Type string &lt;private, inner&gt; fUp(s) Capitalize first character of string, and lowercase the rest. Parameters: Name Type Description s string Input. Source: define.js, line 164 Returns: Output. Type string &lt;private, inner&gt; replyDef(msg, data) Format a Discord message reply from the given data. Parameters: Name Type Description msg Discord~Message Message to reply to. data object Parsed reply from words api. Source: define.js, line 99 × Search results Close "},"DevCmds.html":{"id":"DevCmds.html","title":"Class: DevCmds","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: DevCmds DevCmds Runs unsafe scripts for development purposes. DO NOT LOAD ON RELEASE VERSIONS. new DevCmds() Source: dev.js, line 14 Listens to Events: Discord~Client#event:message Command#event:run Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandRun(msg) Run code as the bot. EXTREMELY UNSAFE! Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: dev.js, line 37 &lt;private, inner&gt; onMessage(msg) Handle receiving a message. Only adds reactions in the #feature-ideas channel. Parameters: Name Type Description msg Discord~Message The message that was sent. Source: dev.js, line 57 Listens to Events: Discord~Client#event:message × Search results Close "},"Echo.html":{"id":"Echo.html","title":"Class: Echo","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Echo Echo new Echo() SubModule managing echo related commands. Source: echo.js, line 25 Listens to Events: Discord:external~Client#event:message Command#event:say Command#event:echo Command#event:become Command#event:self Command#event:be Command#event:character Command#event:impersonate Command#event:who Command#event:whois Command#event:whoami Classes Character Members &lt;private, static, constant&gt; _urlRegex :RegExp Regex to match all URLs in a string. Type: RegExp Source: echo.js, line 492 &lt;private&gt; _characters :Object All npc characters a users are currently being. Mapped by guild id, then channel id, then user id. Type: Object Default Value: {} Source: echo.js, line 54 &lt;private&gt; _prevUserSayCnt :number The number of times the say command has been used consecutively by the previous user. Type: number Source: echo.js, line 45 &lt;private&gt; _prevUserSayId :string The id of the last user to use the say command. Type: string Source: echo.js, line 36 myName Source: echo.js, line 28 Methods &lt;private&gt; _commandBecome(msg) Replace all following messages from a user with a character. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: echo.js, line 272 Listens to Events: Command#event:become Command#event:self Command#event:be Command#event:character Command#event:imprsonate &lt;private&gt; _commandResetCharacters(msg) Reset all current characters, and delete all webhooks. Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: echo.js, line 416 Listens to Events: Command#event:resetcharacters &lt;private&gt; _commandSay(msg) The user's message will be deleted and the bot will send an identical message without the command to make it seem like the bot sent the message. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: echo.js, line 239 Listens to Events: Command#event:say Command#event:echo &lt;private&gt; _commandWhoAmI(msg) Tell the user who they are. Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: echo.js, line 360 Listens to Events: Command#event:whoami &lt;private&gt; _commandWhoIs(msg) List all characters currently active in all channels of a guild. Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: echo.js, line 384 Listens to Events: Command#event:who Command#event:whois &lt;private&gt; _formatUsername(u [, remove]) Remove url from username, and format to rules similar to Discord. Parameters: Name Type Argument Description u string The username. remove string | RegExp &lt;optional&gt; A substring or RegExp to remove. Source: echo.js, line 446 Returns: Formatted username. Type string &lt;private&gt; _mkAndWrite(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Async. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: echo.js, line 142 See: Echo~_mkAndWriteSync &lt;private&gt; _mkAndWriteSync(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Synchronous. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: echo.js, line 169 See: Echo~_mkAndWrite &lt;private&gt; _onMessage(msg) Handle receiving a message for webhook replacing. Parameters: Name Type Description msg Discord~Message The message that was sent. Source: echo.js, line 193 Listens to Events: Discord~Client#event:message initialize() Source: echo.js, line 65 save() Source: echo.js, line 117 shutdown() Source: echo.js, line 108 × Search results Close "},"Echo-Character.html":{"id":"Echo-Character.html","title":"Class: Character","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Character Echo~ Character new Character(username [, url]) Create a Character. Parameters: Name Type Argument Description username string Username for webhook. url string &lt;optional&gt; Avatar url override for webhook. Source: echo.js, line 466 Members avatarURL :string Avatar url of this character. Type: string Source: echo.js, line 476 username :string Username of this character. Type: string Source: echo.js, line 471 × Search results Close "},"external-Discord.html":{"id":"external-Discord.html","title":"External: Discord","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord External: Discord Discord DiscordJS base object. Source: SpikeyBot.js, line 3 See: https://discord.js.org/ × Search results Close "},"FunTranslators.html":{"id":"FunTranslators.html","title":"Class: FunTranslators","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: FunTranslators FunTranslators Converts text strings into different formats. new FunTranslators() Source: lib/funTranslators.js, line 8 Methods to(name, input) Convert a string to a format based on it's name. Parameters: Name Type Description name string The name of the translator. input string The string to convert. Source: lib/funTranslators.js, line 19 Returns: The formatted string. Type string toLeetSpeak(input) Convert a string to Leet Speak (1337 5p34k). Parameters: Name Type Description input string The string to convert. Source: lib/funTranslators.js, line 41 Returns: The formatted string. Type string toMockingFont(input) Convert a string to the SpongeBob mocking meme font (SpOngEBoB MoCKinG). Parameters: Name Type Description input string The string to convert. Source: lib/funTranslators.js, line 75 Returns: The formatted string. Type string toSmallCaps(input) Convert string to small caps (Hᴇʟʟᴏ Wᴏʀʟᴅ!). Parameters: Name Type Description input string The string to convert. Source: lib/funTranslators.js, line 92 Returns: The formatted string. Type string toSuperScript(input) Convert string to superscript characters (ᴴᵉˡˡᵒ ᵂᵒʳˡᵈᵎ). Parameters: Name Type Description input string The string to convert. Source: lib/funTranslators.js, line 172 Returns: The formatted string. Type string × Search results Close "},"HG.html":{"id":"HG.html","title":"Class: HG","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: HG HG Hunger Games simulator subModule. new HG() Source: hungryGames.js, line 20 Listens to Events: Discord~Client#event:guildDelete Discord~Client#event:channelDelete Command#event:hg Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 &lt;constant&gt; defaultOptions :Object.&lt;{value: (string|number|boolean), values: ?Array.&lt;string&gt;, comment: string}&gt; Default options for a game. Type: Object.&lt;{value: (string|number|boolean), values: ?Array.&lt;string&gt;, comment: string}&gt; Source: hungryGames.js, line 160 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 formatUsername Source: hungryGames.js, line 5551 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;constant&gt; maxBytes :number The maximum number of bytes allowed to be received from a client in an image upload. Type: number Default Value: 8000000 (8MB) Source: hungryGames.js, line 57 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 NPC Source: hungryGames.js, line 988 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Overrides: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; alph :string The alphabet twice, first lowercase, then uppercase. Type: string Default Value: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ Source: hungryGames.js, line 231 &lt;private, inner, constant&gt; battleFile :string The file path to read battle events. Type: string Default Value: ./save/hgBattles.json Source: hungryGames.js, line 94 See: HungryGames~battles &lt;private, inner, constant&gt; battleMessage :Object.&lt;Discord~Message&gt; Storage of battle messages to edit the content of on the next update. Type: Object.&lt;Discord~Message&gt; Default Value: {} Source: hungryGames.js, line 254 &lt;private, inner&gt; battles :Object All attacks and outcomes for battles. Type: Object Source: hungryGames.js, line 246 See: HungryGames~battleFile &lt;private, inner, constant&gt; blockedmessage :string Reply if unable to send message via DM. Type: string Default Value: I couldn't send you a message, you probably blocked me :( Source: hungryGames.js, line 429 &lt;private, inner&gt; defaultArenaEvents :Array.&lt;HungryGames~ArenaEvent&gt; Default parsed arena events. Type: Array.&lt;HungryGames~ArenaEvent&gt; Source: hungryGames.js, line 287 See: HungryGames~eventFile &lt;private, inner&gt; defaultBloodbathEvents :Array.&lt;HungryGames~Event&gt; Default parsed bloodbath events. Type: Array.&lt;HungryGames~Event&gt; Source: hungryGames.js, line 271 See: HungryGames~eventFile &lt;private, inner, constant&gt; defaultColor :Discord~ColorResolveable Default color to choose for embedded messages. Type: Discord~ColorResolveable Default Value: [200,125,0] Source: hungryGames.js, line 170 &lt;private, inner, constant&gt; defaultOptions :HungryGames~DefaultOptions Default options for a game. Type: HungryGames~DefaultOptions Source: hungryGames.js, line 146 &lt;private, inner&gt; defaultPlayerEvents :Array.&lt;HungryGames~Event&gt; Default parsed player events. Type: Array.&lt;HungryGames~Event&gt; Source: hungryGames.js, line 279 See: HungryGames~eventFile &lt;private, inner, constant&gt; emoji :Object.&lt;string&gt; Helper object of emoji characters mapped to names. Type: Object.&lt;string&gt; Source: hungryGames.js, line 189 &lt;private, inner, constant&gt; eventFile :string The file path to read default events. Type: string Default Value: ./save/hgEvents.json Source: hungryGames.js, line 84 See: HungryGames~defaultPlayerEvents HungryGames~defaultArenaEvents HungryGames~defaultBloodbathEvents &lt;private, inner, constant&gt; eventHandlers :Object.&lt;Array.&lt;function()&gt;&gt; All registered event handlers. Type: Object.&lt;Array.&lt;function()&gt;&gt; Source: hungryGames.js, line 319 &lt;private, inner, constant&gt; helpmessagereply :string Reply to help on a server. Type: string Default Value: I sent you a DM with commands! Source: hungryGames.js, line 421 &lt;private, inner, constant&gt; helpObject The object that stores all data to be formatted into the help message. Source: hungryGames.js, line 438 &lt;private, inner&gt; listenersEndTime :number The last time the currently scheduled reaction event listeners are expected to end. Used for checking of submoduleis unloadable. Type: number Source: hungryGames.js, line 312 &lt;private, inner, constant&gt; maxReactAwaitTime :number Maximum amount of time to wait for reactions to a message. Type: number Default Value: 5 Minutes Source: hungryGames.js, line 124 &lt;private, inner, constant&gt; newEventMessages :Object.&lt;Discord~Message&gt; Messages that the user sent with a new event to add, for storage while getting the rest of the information about the event. Type: Object.&lt;Discord~Message&gt; Default Value: {} Source: hungryGames.js, line 296 &lt;private, inner, constant&gt; numEventsPerPage :number Number of events to show on a single page of events. Type: number Default Value: 10 Source: hungryGames.js, line 114 &lt;private, inner, constant&gt; optionMessages :Object.&lt;Discord~Message&gt; Messages I have sent showing current options. Type: Object.&lt;Discord~Message&gt; Default Value: {} Source: hungryGames.js, line 304 &lt;private, inner, constant&gt; patreonColor :number Color to put above patrons avatars. RGBA Hex (0xRRGGBBAA). Type: number Default Value: 4184364287 Source: hungryGames.js, line 180 &lt;private, inner, constant&gt; patreonSettingKeys :Array.&lt;string&gt; The permission tags for all settings related to the Hungry Games. Type: Array.&lt;string&gt; Default Value: [\"hg:fun_translators\",\"hg:bar_color\",\"hg:customize_stats\",\"hg:personal_weapon\"] Source: hungryGames.js, line 67 &lt;private, inner, constant&gt; urlRegex :RegExp Regex to match all URLs in a string. Type: RegExp Source: hungryGames.js, line 134 &lt;private, inner&gt; weapons :Object.&lt;HungryGames~WeaponEvent&gt; All weapons and their respective actions. Parsed from file. Type: Object.&lt;HungryGames~WeaponEvent&gt; Default Value: {} Source: hungryGames.js, line 263 See: HungryGames~weaponsFile &lt;private, inner, constant&gt; weaponsFile :string The file path to read weapon events. Type: string Default Value: ./save/hgWeapons.json Source: hungryGames.js, line 104 See: HungryGames~weapons &lt;private, inner, constant&gt; webSM :string Name of the HG Web submodule for lookup. Type: string Default Value: ./web/hg.js Source: hungryGames.js, line 30 Methods addEvent(id, type, event) Adds a given event to the given guild's custom events. Parameters: Name Type Description id string The id of the guild to add the event to. type string The type of event this is. event HungryGames~Event The event to add. Source: hungryGames.js, line 4214 Returns: Error message or null if no error. Type string addMajorEvent(id, type, data [, name]) Creates an event and adds it to the custom events for the given guild. Or edits an existing event by appending new events to the major event. Parameters: Name Type Argument Description id string The guild id to add the event to. type string The type of event this is. Either 'arena' or 'weapon'. data HungryGames~ArenaEvent | HungryGames~WeaponEvent The event data. name string &lt;optional&gt; The internal name of the weapon being added. Source: hungryGames.js, line 4244 Returns: Error message or null if no error. Type string begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 createGame(id [, cb]) Create a Hungry Games for a guild. Parameters: Name Type Argument Description id string The id of the guild to create the game in. cb function &lt;optional&gt; Callback that fires once loading is complete. Only parameter is created HungryGames~GuildGame or null if failed. Source: hungryGames.js, line 1144 createNPC(gId, username, avatar, id) Create an npc in a guild. Parameters: Name Type Description gId string | number The guild id to add the npc to. username string The name of the npc. avatar string The url path to the avatar. Must be valid url to this server. (ex: https://www.spikeybot.com/avatars/NPCBBBADEF031F83638/avatar1.png). id string The npc id of this npc. Must match the id in the avatar url. Source: hungryGames.js, line 5502 Returns: Error message or null if no error. Type string createReactJoinMessage(channel) Send a message with a reaction for users to click on. Records message id and channel id in game data. Parameters: Name Type Description channel Discord~TextChannel | string The channel in the guild to send the message, or the ID of the channel. Source: hungryGames.js, line 6380 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 editMajorEvent(id, type, search, data [, name] [, newName]) Searches custom events for the given one, then edits it with the given data. If the data is null besides required data for finding the major event, the major event gets deleted. (Arena or Weapon events). Parameters: Name Type Argument Description id string The id of the guild to remove the event from. type string The type of event this is. search HungryGames~ArenaEvent | HungryGames~WeaponEvent The event data to use to search for. data HungryGames~ArenaEvent | HungryGames~WeaponEvent The event data to set the matched search to. If this is null, the event is deleted. name string &lt;optional&gt; The name of the weapon to look for or the message of the arena event to edit. newName string &lt;optional&gt; The new name of the weapon that was found with `name`. Source: hungryGames.js, line 4309 Returns: Error message or null if no error. Type string editTeam(uId, gId, cmd, one, two) Allows editing teams. Entry for all team actions. Parameters: Name Type Description uId string The id of the user is running the action. gId string The id of the guild to run this in. cmd string The command to run on the teams. one string The id of the user to swap, or the new name of the team if we're renaming a team. two string The id of the user to swap, or the team id if we're moving a player to a team. Source: hungryGames.js, line 3604 Returns: Error message or null if no error. Type string end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 endGame(uId, gId) End the games in the given guild as the given user. Parameters: Name Type Description uId string | Discord~Message The id of the user who trigged the games to end, or a Discord message sent by the user who triggered this. gId string The id of the guild to end the games in. Source: hungryGames.js, line 1520 endReactJoinMessage(id [, cb]) End the reaction join and update the included users to only include those who reacted to the message. Parameters: Name Type Argument Description id string The guild id of which to end the react join. cb function &lt;optional&gt; Callback once this is complete. First parameter is a string if error, null otherwise, the second is a string with info if success or null otherwise. Source: hungryGames.js, line 6413 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 excludeUsers(users, id, cb) Removes users from a games of a given guild. Parameters: Name Type Description users string | Array.&lt;string&gt; | Array.&lt;Discord~User&gt; | Array.&lt;HungryGames~NPC&gt; The users to exclude, or 'everyone' to exclude everyone. id string The guild id to remove the users from. cb function Callback for when long running operations complete. Single argument with a string with the outcomes of each user. May have multiple lines for a single user. Source: hungryGames.js, line 2656 getDefaultBattles() Returns the object storing all default HungryGames~Battles parsed from file. Source: hungryGames.js, line 1049 Returns: Array of all default battle events. Type Array.&lt;HungryGames~Battle&gt; getDefaultEvents() Returns an object storing all of the default events for the games. Source: hungryGames.js, line 1034 Returns: Object storing default events. Type Object getDefaultWeapons() Returns the object storing all default HungryGames~Weapons parsed from file. Source: hungryGames.js, line 1059 Returns: Array of all default weapons. Type Array.&lt;HungryGames~Weapon&gt; getHG() Fetch a reference to the current HungryGames instance. Source: hungryGames.js, line 45 Returns: Current instance. Type HungryGames getNumSimulating() Returns the number of games that are currently being shown to users. Source: hungryGames.js, line 6523 Returns: Number of games simulating. Type number includeUsers(users, id, cb) Adds a user back into the next game. Parameters: Name Type Description users string | Array.&lt;string&gt; | Array.&lt;Discord~User&gt; | Array.&lt;HungryGames~NPC&gt; The users to include, 'everyone' to include all users, 'online' to include online users, 'offline', 'idle', or 'dnd' for respective users. id string The guild id to add the users to. cb function Callback for when long running operations complete. Single argument with a string with the outcomes of each user. May have multiple lines for a single user. Source: hungryGames.js, line 2932 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 makeAndAddEvent(id, type, message, numVictim, numAttacker, victimOutcome, attackerOutcome, victimKiller, attackerKiller, vWeapon, aWeapon) Creates an event and adds it to the custom events for the given guild. Parameters: Name Type Description id string The guild id to add the event to. type string The type of event this is. Either 'player' or 'bloodbath'. message string The event message. numVictim number The number of victims in the event. numAttacker number The number of attackers in the event. victimOutcome string The outcome of the victims due to this event. attackerOutcome string The outcome of the attackers due to this event. victimKiller boolean Do the victims kill anyone. attackerKiller boolean Do the attackers kill anyone. vWeapon Object The weapon information to give the victim. aWeapon Object The weapon information to give the attacker. Source: hungryGames.js, line 4187 Returns: Error message or null if no error. Type string nextDay(uId, gId, cId) Start the next day of the game in the given channel and guild by the given user. Parameters: Name Type Description uId string The id of the user who trigged autoplay to start. gId string The id of the guild to run autoplay in. cId string The id of the channel to run autoplay in. Source: hungryGames.js, line 1715 on(evt, handler) Register an event listener. Handlers are called in order they are registered. Earlier events can modify event data. Parameters: Name Type Description evt string The name of the event to listen for. handler function The function to call when the event is fired. Source: hungryGames.js, line 6699 pauseAutoplay(uId, gId) Pause autoplay in the given guild as the given user. Parameters: Name Type Description uId string The id of the user who trigged autoplay to end. gId string The id of the guild to end autoplay. Source: hungryGames.js, line 1534 pauseGame(id) Pause the game in by clearing the current interval. Parameters: Name Type Description id string The id of the guild to pause in. Source: hungryGames.js, line 1680 Returns: User information of the outcome of this command. Type string removeEvent(id, type, event) Searches custom events for the given one, then removes it from the custom events. (Bloodbath or Player events). Parameters: Name Type Description id string The id of the guild to remove the event from. type string The type of event this is. event HungryGames~Event The event to search for. Source: hungryGames.js, line 4401 Returns: Error message or null if no error. Type string removeListener(evt, handler) Remove an event listener;. Parameters: Name Type Description evt string The name of the event that was being listened for. handler function The currently registered handler. Source: hungryGames.js, line 6711 removeNPC(gId, npc) Delete an NPC from a guild. Parameters: Name Type Description gId string Guild id of which to remove npc. npc string ID of npc to delete. Source: hungryGames.js, line 5590 Returns: String if error, MessageEmbed to send if success. Type string | Discord~MessageEmbed renameGame(id, name) Rename the guild's game to the given custom name. Parameters: Name Type Description id string | number The guild id of which to change the game's name. name string The custom name to change to. Must be 100 characters or fewer. Source: hungryGames.js, line 6295 Returns: True if successful, false if failed. Failure is probably due to a game not existing or the name being longer than 100 characters. Type boolean save( [opt] [, wait]) Save all game data to file. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. wait boolean &lt;optional&gt; false If requested before subModule is initialized, keep trying until it is initialized. Inherited From: HG#save Overrides: SubModule#save Source: hungryGames.js, line 6679 setOption(id, option, value [, text]) Change an option to a value for the given guild. Parameters: Name Type Argument Default Description id string The guild id to change the option in. option string &lt;nullable&gt; The option key to change. value string | boolean | number The value to change the option to. text string &lt;optional&gt; '' The original message sent without the command prefix in the case we are changing the value of an object and require all user inputted data. Source: hungryGames.js, line 3298 Returns: A message saying what happened, or null if we should show the user the list of options instead. Type string &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 startAutoplay(uId, gId, cId) Start autoplay in the given channel and guild by the given user. Parameters: Name Type Description uId string The id of the user who trigged autoplay to start. gId string The id of the guild to run autoplay in. cId string The id of the channel to run autoplay in. Source: hungryGames.js, line 1509 startGame(uId, gId, cId) Start the games in the given channel and guild by the given user. Parameters: Name Type Description uId string The id of the user who trigged the games to start. gId string The id of the guild to run the games in. cId string The id of the channel to run the games in. Source: hungryGames.js, line 1498 toggleEvent(id, type, subCat, event [, value]) Enable or disable an event without deleting it completely. Parameters: Name Type Argument Description id number | string The guild id that the event shall be toggled in. type string The type of event. 'bloodbath', 'player', 'weapon', or 'arena'. subCat string &lt;nullable&gt; The sub-category name of the event if there is one (Such as the weapon name, or arena event message). event HungryGames~Event | HungryGames~ArenaEvent | HungryGames~WeaponEvent The event to toggle. value boolean &lt;optional&gt; Set enabled to a value instead of toggling. Source: hungryGames.js, line 4447 Returns: Error message or null if no error. Type string unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; calcColNum(numCols, statusList) Calculates the number of columns for the given player list. Assumes maximum character count of 1024 per section. The number of columns also becomes limited to 5, because we will run into the embed total character limit of 6000 if we add any more. [Discord API Docs]( https://discordapp.com/developers/docs/resources/channel#embed-limits). Parameters: Name Type Description numCols number Minimum number of columns. statusList Array.&lt;string&gt; List of text to check. Source: hungryGames.js, line 6568 Returns: Number of columns the data shall be formatted as. Type number &lt;private, inner&gt; changeObjectValue(obj, defaultObj, option, value, values, id [, range]) Recurse through an object to change a certain child value based off a given array of words. Parameters: Name Type Argument Description obj HungryGames~GuildGame.options The object with the values to change. defaultObj HungryGames~defaultOptions The default template object to base changes off of. option string The first value to check. value number | boolean | string The value to change to, or the next option key to check if we have not found an end to a branch yet. values Array.&lt;(string|boolean|number)&gt; All keys leading to the final value, as well as the final value. id string The id of the guild this was triggered for. range Object &lt;optional&gt; Allowable range for values that are numbers. Source: hungryGames.js, line 3338 Returns: Message saying what happened. Can be an error message. Type string &lt;private, inner&gt; commandDeleteGroup(msg, id) Deletes an existing stat group. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5897 &lt;private, inner&gt; commandGroups(msg, id) Responds with list of all stat group names and IDs. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5742 &lt;private, inner&gt; commandHeal(msg, id [, game]) Allows the game creator to heal or revive a player in the game. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 6228 &lt;private, inner&gt; commandKill(msg, id [, game]) Allows the game creator to kill a player in the game. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 6194 &lt;private, inner&gt; commandLeaderboard(msg, id) Ranks players by stat. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5932 &lt;private, inner&gt; commandMakeMeLose(msg) Tell a user their chances of losing have not increased. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: hungryGames.js, line 851 Listens to Events: Command#event:hg makemelose &lt;private, inner&gt; commandMakeMeWin(msg) Tell a user their chances of winning have not increased. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: hungryGames.js, line 839 Listens to Events: Command#event:hg makemelose &lt;private, inner&gt; commandNewGroup(msg, id) Creates a new stat group. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5805 &lt;private, inner&gt; commandNums(msg) Replies to the user with stats about all the currently loaded games in this shard. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. Source: hungryGames.js, line 6036 &lt;private, inner&gt; commandReactJoin(msg, id [, game]) Start or stop allowing users to enter in to a game by clicking on a reaction to a message. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 6346 &lt;private, inner&gt; commandRename(msg, id [, game]) Rename a guild's game to a custom name. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 6313 &lt;private, inner&gt; commandRenameGroup(msg, id) Renames an existing stat group. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5859 &lt;private, inner&gt; commandRig(msg) Replies to the user with an image saying \"rigged\". That is all. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. Source: hungryGames.js, line 6100 &lt;private, inner&gt; commandSelectGroup(msg, id) Selects an existing stat group. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5824 &lt;private, inner&gt; commandStats(msg, id) Responds with stats about a player in the games. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string Guild ID this command was called from. Source: hungryGames.js, line 5673 &lt;inner&gt; commandToggleEvent(msg) Toggle events in the games. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. Source: hungryGames.js, line 4423 To Do: Write this. This is not implemented yet. &lt;private, inner&gt; commandWound(msg, id [, game]) Allows the game creator to wound a player in the game. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 6261 &lt;private, inner&gt; createEvent(msg, id [, game]) Create a custom event for a guild. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 3942 &lt;private, inner&gt; createEventAttacker(msg, id, show, cb) Let the user choose whether the event attackers and victims kill anyone. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. show string The message to show explaining the options. cb HungryGames~createEventBooleanCallback The callback after the user has chosen an outcome. Source: hungryGames.js, line 4680 &lt;private, inner&gt; createEventNums(msg, id, show, cb) Let the user choose how many of something will be in this event being created. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. show string The message to show explaining the number. cb HungryGames~createEventNumCallback The callback after the user has chosen a number. Source: hungryGames.js, line 4552 &lt;private, inner&gt; createEventOutcome(msg, id, show, cb) Let the user choose what the outcome of an event will be. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. show string The message to show explaining the options. cb HungryGames~createEventOutcomeCallback The callback after the user has chosen an outcome. Source: hungryGames.js, line 4616 &lt;private, inner&gt; createGame(msg, id [, silent] [, cb]) Create a Hungry Games for a guild. Parameters: Name Type Argument Default Description msg Discord~Message &lt;nullable&gt; The message that lead to this being called. id string The id of the guild this was triggered from. silent boolean &lt;optional&gt; false Should we suppress replies to message. cb function &lt;optional&gt; Callback that fires once loading is complete. Only parameter is created HungryGames~GuildGame or null if failed. Source: hungryGames.js, line 1075 &lt;private, inner&gt; createNPC(msg, id) Create a new NPC. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 5257 &lt;private, inner&gt; editTeam(msg, id [, silent]) Entry for all team commands. Parameters: Name Type Argument Default Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. silent boolean &lt;optional&gt; false Should we disable replying to the given message? Source: hungryGames.js, line 3534 Returns: Error message or null if no error. Type string &lt;private, inner&gt; endGame(msg, id [, silent]) End a game early. Parameters: Name Type Argument Default Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. silent boolean &lt;optional&gt; false Prevent sending messages. Source: hungryGames.js, line 2545 &lt;private, inner&gt; excludeIterate(game, obj [, onlyError]) Exclude a single user from the game as a single iteration step of the exclude command. Parameters: Name Type Argument Default Description game HungryGames~GuildGame The game to manipulate. obj string | HungryGames~Player | HungryGames~NPC Player for this iteration. onlyError boolean &lt;optional&gt; false Only add error messages to response. Source: hungryGames.js, line 2754 Returns: Response text for the user performing the operation. Type string &lt;private, inner&gt; excludeNPC(msg, id) Exclude an NPC from the game. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 5637 &lt;private, inner&gt; excludeUser(msg, id [, game]) Remove a user from users to be in next game. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; Game object to exclude user from. Source: hungryGames.js, line 2567 &lt;private, inner&gt; exit( [code]) Catch process exiting so we can save if necessary, and remove other handlers to allow for another module to take our place. Parameters: Name Type Argument Description code number &lt;optional&gt; The exit code. Source: hungryGames.js, line 6744 Listens to Events: Process#event:exit &lt;private, inner&gt; fetchPatreonSettings(players, cId, gId [, cb]) Given an array of players, lookup the settings for each and update their data. This is asynchronous. Parameters: Name Type Argument Description players Array.&lt;HungryGames~Player&gt; The players to lookup and update. cId string | number The channel ID to fetch the settings for. gId string | number The guild ID to fetch the settings for. cb function &lt;optional&gt; Calls this callback on completion. No parameters. Source: hungryGames.js, line 1159 &lt;private, inner&gt; fetchStats(events) Put information about an array of events into the array. Parameters: Name Type Description events Array.&lt;HungryGames~Event&gt; Array of events to process and modify. Source: hungryGames.js, line 4857 &lt;private, inner&gt; fire(evt, args) Fire an event on all listeners. Parameters: Name Type Argument Description evt string The event to fire. args * &lt;repeatable&gt; Arguments for the event. Source: hungryGames.js, line 6724 &lt;private, inner&gt; formatEventString(arenaEvent [, newline]) Format an event to show its settings to the user. Parameters: Name Type Argument Default Description arenaEvent HungryGames~Event | string The event to format. newline boolean &lt;optional&gt; false If a new line should be inserted for better formatting. Source: hungryGames.js, line 5089 Returns: The formatted message with emojis. Type string &lt;private, inner&gt; formatUsername(u [, remove]) Remove url from username, and format to rules similar to Discord. Parameters: Name Type Argument Description u string The username. remove string | RegExp &lt;optional&gt; A substring or RegExp to remove. Source: hungryGames.js, line 5540 Returns: Formatted username. Type string &lt;private, inner&gt; getName(guild, user) Get the username of a user id if available, or their id if they couldn't be found. Parameters: Name Type Description guild Discord~Guild The guild to look for the user in. user string The id of the user to find the name of. Source: hungryGames.js, line 3254 Returns: The user's name or id if name was unable to be found. Type string &lt;private, inner&gt; getOutcomeEmoji(outcome) Get the emoji for a specific outcome of an event. Parameters: Name Type Description outcome string The outcome to get the emoji of. Source: hungryGames.js, line 5119 Returns: The emoji. Type string &lt;private, inner&gt; getStatsString( [short]) Get this shard's stats and format it into a human readable string. Parameters: Name Type Argument Default Description short boolean &lt;optional&gt; false Provide a short version. Source: hungryGames.js, line 6065 Returns: The formatted string. Type string &lt;private, inner&gt; handleMessageEdit(oldMsg, newMsg) Handler for when the create event message is edited and we should update our message with the updated event. Parameters: Name Type Description oldMsg Discord~Message The message before being edited. newMsg Discord~Message The message after being edited. Source: hungryGames.js, line 725 Listens to Events: Discord~Client#event:messageUpdate &lt;private, inner&gt; help(msg) Send help message to DM and reply to server. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. Source: hungryGames.js, line 5648 &lt;private, inner&gt; includeIterate(game, obj [, onlyError]) Include a single user from the game as a single iteration step of the include command. Parameters: Name Type Argument Default Description game HungryGames~GuildGame The game to manipulate. obj string | HungryGames~Player | HungryGames~NPC Player for this iteration. onlyError boolean &lt;optional&gt; false Only add error messages to response. Source: hungryGames.js, line 3030 Returns: Response text for the user performing the operation. Type string &lt;private, inner&gt; includeNPC(msg, id) Include an NPC in the game. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 5625 &lt;private, inner&gt; includeUser(msg, id [, game]) Add a user back into the next game. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 2842 &lt;private, inner&gt; listEvents(msg, id [, page] [, eventType] [, editMsg]) Allow user to view all events available on their server and summary of each type of event. Parameters: Name Type Argument Default Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. page number &lt;optional&gt; 0 The page number to show. eventType string &lt;optional&gt; 'player' The type of event to show. editMsg Discord~Message &lt;optional&gt; The message to edit instead of sending a new message. Source: hungryGames.js, line 4891 &lt;private, inner&gt; listNPCs(msg, id) List all currently created NPCs. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 5144 &lt;private, inner&gt; listPlayers(msg, id) Show a formatted message of all users and teams in current server. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 3124 &lt;private, inner&gt; makeMessage(uId, gId, cId, msg) Forms a Discord~Message similar object from given IDs. Parameters: Name Type Argument Description uId string The id of the user who wrote this message. gId string The id of the guild this message is in. cId string &lt;nullable&gt; The id of the channel this message was 'sent' in. msg string &lt;nullable&gt; The message content. Source: hungryGames.js, line 1553 Returns: The created message-like object. Type Object &lt;private, inner&gt; makePlayerListEmbed(game [, finalMessage]) Create a external:Discord~MessageEmbed that lists all included and excluded players in the game. Parameters: Name Type Argument Description game HungryGames~GuildGame The game to format. finalMessage external:Discord~MessageEmbed &lt;optional&gt; Optional existing embed to modify instead of creating a new one. Source: hungryGames.js, line 3150 Returns: The created message embed. Type external:Discord~MessageEmbed &lt;private, inner&gt; mkCmd(cb) Make a subcommand handler with the given callback function. This is a wrapper around existing functions. Parameters: Name Type Description cb HungryGames~hgCommandHandler Command handler when subcommand is triggered. Source: hungryGames.js, line 774 Returns: Subcommand initial handler that will fire when command is fired. Calls the passed callback handler with the mapped parameters. Type Command~commandHandler &lt;private, inner&gt; moveTeamUser(msg, id [, game]) Move a single user to another team. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 3752 &lt;private, inner&gt; newReact(duration) Update HungryGames~listenersEndTime because a new listener was registered with the given duration. Parameters: Name Type Description duration number The length of time the listener will be active. Source: hungryGames.js, line 6590 &lt;private, inner&gt; nextDay(msg, id) Simulate a single day then show events to users. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1726 &lt;private, inner&gt; nothing() Get a random word that means \"nothing\". Source: hungryGames.js, line 6538 Returns: A word meaning \"nothing\". Type string &lt;private, inner&gt; onChannelDelete(channel) Handle a channel being deleted. Cleans up games that may be in progress in these channels. Parameters: Name Type Description channel Discord~DMChannel | Discord~GuildChannel The channel that was deleted. Source: hungryGames.js, line 757 Listens to Events: Discord~Client#event:channelDelete &lt;private, inner&gt; onGuildDelete(guild) Handle being removed from a guild. Parameters: Name Type Description guild Discord~Guild The guild that we just left. Source: hungryGames.js, line 741 Listens to Events: Discord~Client#event:guildDelete &lt;private, inner&gt; optChangeListener(msg_, options, index) The callback for when the user chooses to change page of the options. Parameters: Name Type Description msg_ Discord~Message The message we sent showing the options. options object The options to show in the message. index number The page index to show. Source: hungryGames.js, line 3491 &lt;private, inner&gt; parseGamePlayers(msg, game) Fetch an array of user IDs that are in the current game and have been referenced in any way due to the given message from the user. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. game HungryGames~GuildGame The game this is for. Source: hungryGames.js, line 6116 Returns: Array of user IDs that are in the current game that were mentioned. Type Array.&lt;string&gt; &lt;private, inner&gt; pauseAutoplay(msg, id) Stop autoplaying. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1587 &lt;private, inner&gt; pauseGame(msg, id) Stop the game in the middle of the day until resumed. Just clears the interval for the game. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1702 &lt;private, inner&gt; printDay(msg, id) Trigger the end of a day and print summary/outcome at the end of the day. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 2121 &lt;private, inner&gt; printEvent(msg, id) Print an event string to the channel and add images, or if no events remain, trigger end of day. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1867 &lt;private, inner&gt; randomizeTeams(msg, id [, silent]) Swap random users between teams. Parameters: Name Type Argument Default Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. silent boolean &lt;optional&gt; false If true, this will not attempt to send messages to the channel where the msg was sent.. Source: hungryGames.js, line 3898 &lt;private, inner&gt; readImage(url) Attempt to fetch an image from a URL. Checks if the file has been cached to the filesystem first. Parameters: Name Type Description url string | Jimp | Buffer The url to fetch the image from, or anything Jimp supports. Source: hungryGames.js, line 6606 Returns: Promise from JIMP with image data. Type Promise &lt;private, inner&gt; removeEvent(msg, id) Delete a custom event from a guild. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 4769 &lt;private, inner&gt; removeNPC(msg, id) Delete an NPC. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 5561 &lt;private, inner&gt; renameTeam(msg, id [, silent]) Rename a team. Parameters: Name Type Argument Default Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. silent boolean &lt;optional&gt; false Disable replying to message. Source: hungryGames.js, line 3842 &lt;private, inner&gt; resetGame(msg, id) Reset data that the user specifies. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1282 &lt;private, inner&gt; sendAtTime(channel, one, two, time) Delay a message to send at the given time in milliseconds since epoch. Parameters: Name Type Description channel Discord~TextChannel The channel to send the message in. one Discord~StringResolvable | Discord~MessageOptions | Discord~MessageEmbed | Discord~MessageAttachment | Array.&lt;Discord~MessageAttachment&gt; The message to send. two Discord~StringResolvable | Discord~MessageOptions | Discord~MessageEmbed | Discord~MessageAttachment | Array.&lt;Discord~MessageAttachment&gt; The message to send. time number The time to send the message in milliseconds since epoch. Source: hungryGames.js, line 1013 &lt;private, inner&gt; setupHelp() Set all help messages once we know what prefix to use. Source: hungryGames.js, line 447 &lt;private, inner&gt; showGameEvents(msg, id) Send all event data about the default events to the chat. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1319 &lt;private, inner&gt; showGameInfo(msg, id) Send all of the game data about the current server to the chat. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1294 &lt;private, inner&gt; showOpts(msg, options) Format the options for the games and show them to the user. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. options object The options to format. Source: hungryGames.js, line 3428 &lt;private, inner&gt; sigint() Same as exit(), but triggered via SIGINT, SIGHUP or SIGTERM. Source: hungryGames.js, line 6768 Listens to Events: Process#event:SIGINT Process#event:SIGHUP Process#event:SIGTERM &lt;private, inner&gt; sortTeams(game) Sort the includedUsers and teams for the given game. Parameters: Name Type Description game HungryGames~GuildGame The game to sort. Source: hungryGames.js, line 6489 &lt;private, inner&gt; startAutoplay(msg, id [, game]) Start autoplaying. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to start autoplay on. Source: hungryGames.js, line 1618 &lt;private, inner&gt; startGame(msg, id) Start the games in the channel this was called from. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 1394 &lt;private, inner&gt; swapTeamUsers(msg, id [, game]) Swap two users from one team to the other. Parameters: Name Type Argument Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. game HungryGames~GuildGame &lt;optional&gt; The game object to modify. Source: hungryGames.js, line 3693 &lt;private, inner&gt; toggleOpt(msg, id) Change an option to a value that the user specifies. Parameters: Name Type Description msg Discord~Message The message that lead to this being called. id string The id of the guild this was triggered from. Source: hungryGames.js, line 3274 &lt;private, inner&gt; updateBattles() Parse all battles from file. Source: hungryGames.js, line 360 &lt;private, inner&gt; updateEventPreview(msg) When a user is creating a custom event and edits their message, we need to edit the preview. Parameters: Name Type Description msg Discord~Message Our message previewing the new event. Source: hungryGames.js, line 4712 &lt;private, inner&gt; updateEvents() Parse all default events from file. Source: hungryGames.js, line 326 &lt;private, inner&gt; updateWeapons() Parse all weapons events from file. Source: hungryGames.js, line 389 × Search results Close "},"HGWeb.html":{"id":"HGWeb.html","title":"Class: HGWeb","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: HGWeb HGWeb Creates a web interface for managing the Hungry Games. Expects ../hungryGames.js is loaded or will be loaded. new HGWeb() Source: web/hg.js, line 16 Members &lt;private, inner, constant&gt; imageBuffer :Object Buffer storing all current image uploads and their associated meta-data. Type: Object Source: web/hg.js, line 28 &lt;private, inner, constant&gt; siblingSockets :Object.&lt;Socket&gt; Map of all sockets connected that are siblings. Type: Object.&lt;Socket&gt; Source: web/hg.js, line 149 &lt;private, inner, constant&gt; sockets :Object.&lt;Socket&gt; Map of all currently connected sockets. Type: Object.&lt;Socket&gt; Source: web/hg.js, line 131 Methods getNumClients() Returns the number of connected clients that are not siblings. Source: web/hg.js, line 139 Returns: Number of sockets. Type number initialize() Source: web/hg.js, line 91 shutdown() Causes a full shutdown of all servers. Source: web/hg.js, line 103 &lt;private, inner&gt; beginImageUpload(uId) Create an upload ID and buffer for a client to send to. Automatically cancelled after 60 seconds. Parameters: Name Type Description uId string The user ID that started this upload. Source: web/hg.js, line 595 Returns: The metadata storing object. Type object &lt;private, inner&gt; cancelImageUpload(iId) Cancel and clean up a current image upload. Parameters: Name Type Description iId string Image upload ID to purge and abort. Source: web/hg.js, line 581 &lt;private, inner&gt; checkChannelPerm(userData, gId, cId, cmd) Check that the given user has permission to see and send messages in the given channel, as well as manage the games in the given guild. Parameters: Name Type Description userData UserData The user to check. gId string The guild id of the guild that contains the channel. cId string The channel id to check against. cmd string The command being attempted to check permisisons for. Source: web/hg.js, line 484 Returns: Whther the user has permission or not to manage the hungry games in the given guild and has permission to send messages in the given channel. Type boolean &lt;private, inner&gt; checkMyGuild(gId) Checks if the current shard is responsible for the requested guild. Parameters: Name Type Description gId number | string The guild id to check. Source: web/hg.js, line 446 Returns: True if this shard has this guild. Type boolean &lt;private, inner&gt; checkPerm(userData, gId, cId, cmd) Check that the given user has permission to manage the games in the given guild. Parameters: Name Type Argument Description userData UserData The user to check. gId string The guild id to check against. cId string &lt;nullable&gt; The channel id to check against. cmd string The command being attempted. Source: web/hg.js, line 463 Returns: Whther the user has permission or not to manage the hungry games in the given guild. Type boolean &lt;private, inner&gt; clientSocketConnection(socket) Handler for connecting as a client to the server. Parameters: Name Type Description socket socketIo~Socket The socket.io socket that connected. Source: web/hg.js, line 353 &lt;private, inner&gt; createEvent(userData, socket, gId, type, message, nV, nA, oV, oA, kV, kA, wV, wA [, cb]) Create a game event. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. type string The type of event. message string The message of the event. nV string Number of victims. nA string Number of attackers. oV string Outcome of victims. oA string Outcome of attackers. kV string Do the victims kill. kA string Do the attackers kill. wV object &lt;nullable&gt; The weapon information for this event. wA object &lt;nullable&gt; The weapon information for this event. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1357 See: HungryGames.createEvent &lt;private, inner&gt; createGame(userData, socket, gId [, cb]) Create a Game. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1073 See: HungryGames.createGame &lt;private, inner&gt; createMajorEvent(userData, socket, gId, type, data, name [, cb]) Create a larger game event. Either Arena or Weapon at this point. If message or weapon name already exists, this will instead edit the event. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. type string The type of event. data HungryGames~ArenaEvent | HungryGames~WeaponEvent The event data. name string &lt;nullable&gt; The name of the weapon if this is a weapon event. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1407 See: HungryGames.addMajorEvent &lt;private, inner&gt; dayStateChange(hg, gId) This gets fired whenever the day state of any game changes in the hungry games. This then notifies all clients that the state changed, if they care about the guild. Parameters: Name Type Description hg HungryGames HG object firing the event. gId string Guild id of the state change. Source: web/hg.js, line 398 Listens to Events: HungryGames#event:dayStateChange &lt;private, inner&gt; editMajorEvent(userData, socket, gId, type, search, data, name, newName [, cb]) Delete a larger game event. Either Arena or Weapon at this point. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. type string The type of event. search HungryGames~ArenaEvent | HungryGames~WeaponEvent The event data to find to edit. data HungryGames~ArenaEvent | HungryGames~WeaponEvent The event data to set the matched searches to. name string &lt;nullable&gt; The internal name of the weapon to find. newName string &lt;nullable&gt; The new internal name of the weapon. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1456 See: HungryGames.editMajorEvent &lt;private, inner&gt; editTeam(userData, socket, gId, cmd, one, two [, cb]) Edit the teams. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cmd string The command to run. one string The first argument. two string The second argument. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1320 See: HungryGames.editTeam &lt;private, inner&gt; endGame(userData, socket, gId [, cb]) End the game. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1222 See: HungryGames.endGame &lt;private, inner&gt; excludeMember(userData, socket, gId, mId [, cb]) Exclude a member from the Games. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. mId number | string The member id to exclude. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 967 See: HungryGames.excludeUsers &lt;private, inner&gt; fetchChannel(userData, socket, gId, cId [, cb]) Fetch data about a channel of a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cId number | string The channel's id to lookup. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 840 &lt;private, inner&gt; fetchDay(userData, socket, gId [, cb]) Fetch the updated game's day information. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 906 See: HungryGames.getGame &lt;private, inner&gt; fetchGames(userData, socket, gId [, cb]) Fetch all game data within a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 877 See: HungryGames.getGame &lt;private, inner&gt; fetchGuild(userData, socket, gId [, cb]) Fetch a single guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The ID of the guild that was requested. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 777 &lt;private, inner&gt; fetchGuilds(userData, socket [, cb]) Fetch all relevant data for all mutual guilds with the user and send it to the user. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 627 &lt;private, inner&gt; fetchMember(userData, socket, gId, mId [, cb]) Fetch data about a member of a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. mId number | string The member's id to lookup. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 813 &lt;private, inner&gt; forcePlayerState(userData, socket, gId, list, state [, text] [, persists] [, cb]) Force a player in the game to end a day in a certain state. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo-Socket The socket connection to reply on. gId number | string The guild id to run this command on. list Array.&lt;string&gt; The list of user IDs of the players to effect. state string The forced state. text string &lt;optional&gt; The message to show in the games as a result of this command. persists boolean &lt;optional&gt; Will this state be forced until the game ends. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete. Source: web/hg.js, line 1590 See: HungryGames.forcePlayerState &lt;private, inner&gt; handler(req, res) Handler for all http requests. Should never be called. Parameters: Name Type Description req http.IncomingMessage The client's request. res http.ServerResponse Our response to the client. Source: web/hg.js, line 120 &lt;private, inner&gt; hg() Update the reference to HungryGames. Source: web/hg.js, line 67 Returns: Reference to the currently loaded HungryGames subModule. Type HG &lt;private, inner&gt; imageChunk(userData, socket, gId, iId, chunkId, chunk [, cb]) Handle receiving image data for avatar uploading. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. iId string The image ID that is being uploaded. chunkId string Id of the chunk being received. chunk Buffer &lt;nullable&gt; Chunk of data received, or null if all data has been sent. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1699 &lt;private, inner&gt; imageInfo(userData, socket, gId, meta [, cb]) Handle client requesting to begin image upload. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. meta object Metadata to associate with this upload. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. If succeeded, an upload ID will be passed as the second parameter. Any error will be the first parameter. Source: web/hg.js, line 1791 &lt;private, inner&gt; includeMember(userData, socket, gId, mId [, cb]) Include a member in the Games. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. mId number | string The member id to include. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1000 See: HungryGames.includeUsers &lt;private, inner&gt; makeMember(m) Strips a Discord~GuildMember to only the necessary data that a client will need. Parameters: Name Type Description m Discord~GuildMember The guild member to strip the data from. Source: web/hg.js, line 543 Returns: The minimal member. Type object &lt;private, inner&gt; makeMessage(uId, gId, cId, msg) Forms a Discord~Message similar object from given IDs. Parameters: Name Type Argument Description uId string The id of the user who wrote this message. gId string The id of the guild this message is in. cId string &lt;nullable&gt; The id of the channel this message was 'sent' in. msg string &lt;nullable&gt; The message content. Source: web/hg.js, line 520 Returns: The created message-like object. Type Object &lt;private, inner&gt; nextDay(userData, socket, gId, cId [, cb]) Start the next day. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cId number | string Channel to send the messages in. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1193 See: HungryGames.nextDay &lt;private, inner&gt; pauseAutoplay(userData, socket, gId [, cb]) Disable autoplay. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1251 See: HungryGames.pauseAutoplay &lt;private, inner&gt; pauseGame(userData, socket, gId [, cb]) Pause game. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1280 See: HungryGames.pauseGame &lt;private, inner&gt; removeEvent(userData, socket, gId, type, event [, cb]) Remove a game event. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. type string The type of event. event HungryGames~Event The game event to remove. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1501 See: HungryGames.removeEvent &lt;private, inner&gt; removeNPC(userData, socket, gId, npcId [, cb]) Remove an NPC from a game. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo-Socket The socket connection to reply on. gId number | string The guild id to run this command on. npcId string The ID of the NPC to remove. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete. Source: web/hg.js, line 1670 See: HungryGames.removeNPC &lt;private, inner&gt; renameGame(userData, socket, gId, name [, cb]) Rename the guild's game. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo-Socket The socket connection to reply on. gId number | string The guild id to run this command on. name string The name to change the game to. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete. Source: web/hg.js, line 1638 See: HungryGames.renameGame &lt;private, inner&gt; replyNoPerm(socket, cmd) Send a message to the given socket informing the client that the command they attempted failed due to insufficient permission. Parameters: Name Type Description socket Socket The socket.io socket to reply on. cmd string THe command the client attempted. Source: web/hg.js, line 431 &lt;private, inner&gt; resetGame(userData, socket, gId, cmd [, cb]) Reset game data. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cmd string Command specifying what data to delete. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1103 See: HungryGames.resetGame &lt;private, inner&gt; socketConnection(socket) Handler for a new socket connecting. Parameters: Name Type Description socket socketIo~Socket The socket.io socket that connected. Source: web/hg.js, line 157 &lt;private, inner&gt; startAutoplay(userData, socket, gId, cId [, cb]) Enable autoplay. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cId number | string Channel to send the messages in. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1163 See: HungryGames.startAutoplay &lt;private, inner&gt; startClient() Start a socketio client connection to the primary running server. Source: web/hg.js, line 51 &lt;private, inner&gt; startGame(userData, socket, gId, cId [, cb]) Start the game. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. cId number | string Channel to start the game in. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1133 See: HungryGames.startGame &lt;private, inner&gt; stripGuilds(guilds, userData) Strip a Discord~Guild to the basic information the client will need. Parameters: Name Type Description guilds Array.&lt;Discord~Guild&gt; The array of guilds to strip. userData object The current user's session data. Source: web/hg.js, line 710 Returns: The stripped guilds. Type Array.&lt;object&gt; &lt;private, inner&gt; toggleEvent(userData, socket, gId, type, subCat, event, value [, cb]) Enable or disable an event without deleting it. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo-Socket The socket connection to reply on. gId number | string The guild id to run this command on. type string The type of event that we are toggling. subCat string &lt;nullable&gt; The subcategory if necessary. event HungryGames~Event | HungryGames~ArenaEvent | HungryGames~WeaponEvent The event to toggle. value boolean &lt;nullable&gt; Set the enabled value instead of toggling. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete. Source: web/hg.js, line 1550 See: HungryGames.toggleEvent &lt;private, inner&gt; toggleOption(userData, socket, gId, option, value, extra [, cb]) Toggle an option in the Games. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. option string The option to change. value string | number The value to set option to. extra string The extra text if the option is in an object. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/hg.js, line 1035 See: HungryGames.setOption &lt;private, inner&gt; unlinkHG() Unregister all event handlers from `hg_`. Source: web/hg.js, line 84 Type Definitions basicCB(err) Basic callback with single argument. The argument is null if there is no error, or a string if there was an error. Parameters: Name Type Argument Description err string &lt;nullable&gt; The error response. Source: web/hg.js, line 608 × Search results Close "},"HungryGames.html":{"id":"HungryGames.html","title":"Class: HungryGames","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: HungryGames HungryGames Contains a Hunger Games style simulation. new HungryGames(parent) HungryGames constructor. Currently requires a valid SubModule as a parent. Parameters: Name Type Description parent SubModule Parent submodule used to hook logging into. Source: hg/HungryGames.js, line 18 To Do: Remove reliance on SubModule. Classes ArenaEvent Battle Day DefaultOptions Event FinalEvent ForcedOutcome Game Grammar GuildGame Messages OutcomeProbabilities Player Simulator StatGroup StatManager Stats Team UserIconUrl WeaponEvent Members &lt;private&gt; _defaultArenaEvents :Array.&lt;HungryGames~ArenaEvent&gt; Array of all arena events that can take place normally by default. Type: Array.&lt;HungryGames~ArenaEvent&gt; Default Value: [] Source: hg/HungryGames.js, line 129 &lt;private&gt; _defaultBattles :Array.&lt;HungryGames~Battle&gt; Array of all battles that can take place normally by default. Type: Array.&lt;HungryGames~Battle&gt; Default Value: [] Source: hg/HungryGames.js, line 137 &lt;private&gt; _defaultBloodbathEvents :Array.&lt;HungryGames~Event&gt; Array of all events that can take place in the bloodbath by default. Type: Array.&lt;HungryGames~Event&gt; Default Value: [] Source: hg/HungryGames.js, line 113 &lt;private&gt; _defaultPlayerEvents :Array.&lt;HungryGames~Event&gt; Array of all events that can take place normally by default. Type: Array.&lt;HungryGames~Event&gt; Default Value: [] Source: hg/HungryGames.js, line 121 &lt;private&gt; _defaultWeapons :Array.&lt;HungryGames~Weapon&gt; Array of all weapons that can be used normally by default. Type: Array.&lt;HungryGames~Weapon&gt; Default Value: [] Source: hg/HungryGames.js, line 145 &lt;private, constant&gt; _findDelay :number The delay after failing to find a guild's data to look for it again. Type: number Default Value: 15 Seconds Source: hg/HungryGames.js, line 70 &lt;private, constant&gt; _findTimestamps :Object.&lt;number&gt; Stores the guilds we have looked for their data recently and the timestamp at which we looked. Used to reduce filesystem requests and blocking. Type: Object.&lt;number&gt; Source: hg/HungryGames.js, line 61 &lt;private, constant&gt; _games :Object.&lt;HungryGames~GuildGame&gt; All currently tracked games. Mapped by guild ID. In most cases you should NOT reference this directly. Use HungryGames#getGame to get the game object for a guild. Type: Object.&lt;HungryGames~GuildGame&gt; Default Value: {} Source: hg/HungryGames.js, line 51 See: HungryGames#getGame &lt;private, constant&gt; _hgSaveDir :string The file directory for finding saved data related to the hungry games data of individual guilds. Type: string Default Value: /hg/ Source: hg/HungryGames.js, line 105 See: Common#guildSaveDir HungryGames#_games HungryGames#_saveFile &lt;private, constant&gt; _parent :HG Parent subModule for logging and bot hooking. Type: HG Source: hg/HungryGames.js, line 25 &lt;private, constant&gt; _saveFile :string The file path to save current state for a specific guild relative to Common#guildSaveDir. Type: string Default Value: game.json Source: hg/HungryGames.js, line 92 See: Common#guildSaveDir HungryGames#_games HungryGames#_hgSaveDir &lt;constant&gt; defaultOptions :HungryGames~DefaultOptions Default game options. Type: HungryGames~DefaultOptions Source: hg/HungryGames.js, line 39 hgSaveDir The file directory for finding saved data related to the hungry games data of individual guilds. Source: hg/HungryGames.js, line 173 See: Common#guildSaveDir HungryGames#_games HungryGames#_saveFile HungryGames#_hgSaveDir &lt;constant&gt; maxDelta :number Maximum amount of milliseconds long running operations are allowed to take to prevent cpu deadlock. Type: number Default Value: 5 Source: hg/HungryGames.js, line 79 &lt;constant&gt; messages :HungryGames~Messages Current HungryGames~Messages instance. Type: HungryGames~Messages Source: hg/HungryGames.js, line 32 saveFile The file path to save current state for a specific guild relative to Common#guildSaveDir. Source: hg/HungryGames.js, line 159 See: Common#guildSaveDir HungryGames#_games HungryGames#_saveFile HungryGames#_hgSaveDir Methods &lt;private, static&gt; tmpRequire(name) Wrapper for normal `require()` but also deletes cache reference to object before requiring. This forces the object to be updated. Parameters: Name Type Description name string Name of module to require. Source: hg/HungryGames.js, line 702 Returns: The required module. Type object &lt;private&gt; _find(id [, cb]) Returns a guild's game data. Returns cached version if that exists, or searches the file system for saved data. Data will only be checked from disk at most once every `HungryGames~findDelay` milliseconds. Returns `null` if data could not be found, or an error occurred. Parameters: Name Type Argument Description id number | string The guild id to get the data for. cb function &lt;optional&gt; Callback to fire once complete. This becomes asyncronous if given, if not given this function is syncronous. Single parameter is null if not found, or HungryGames~GuildGame if found. Source: hg/HungryGames.js, line 490 Returns: The game data, or null if no game could be loaded or loading asyncronously because a callback was given. Type HungryGames~GuildGame create(guild [, cb]) Create a new GuildGame. Parameters: Name Type Argument Description guild external:Discord~Guild | string Guild object, or ID to create a game for. cb function &lt;optional&gt; Callback once game has been fully created. Passes the created game as the only argument. Source: hg/HungryGames.js, line 262 fetchGame(id, cb) Similar to HungryGames.getGame except asyncronous and fetched game is passed as callback argument. Parameters: Name Type Description id string The guild id to get the data for. cb function Callback with single argument. Null if unable to be found, HungryGames~GuildGame if found. Source: hg/HungryGames.js, line 199 getAllPlayers(members, excluded, bots, included, excludeByDefault [, includedNPCs], cb) Form an array of Player objects based on guild members, excluded members, and whether to include bots. Parameters: Name Type Argument Default Description members external:Discord~Collection.&lt;external:Discord~GuildMember&gt; All members in guild. excluded Array.&lt;string&gt; Array of ids of users that should not be included in the games. bots boolean Should bots be included in the games. included Array.&lt;string&gt; Array of ids of users that should be included in the games. Used if excludeByDefault is true. excludeByDefault boolean Should new users be excluded from the game by default? includedNPCs Array.&lt;NPC&gt; &lt;optional&gt; [] NPCs to include as players. cb basicCB Callback on completion. Only argument is array of HungryGames~Player to include in the games. Source: hg/HungryGames.js, line 336 getGame(id) Returns a reference to the current games object for a given guild. Parameters: Name Type Description id string The guild id to get the data for. Source: hg/HungryGames.js, line 186 Returns: The current object storing all data about game in a guild. Type HungryGames~GuildGame refresh(guild [, cb]) Create a new Game for a guild, and refresh the player lists. Parameters: Name Type Argument Description guild external:Discord~Guild | string Guild object, or ID to refresh a game for. cb function &lt;optional&gt; Callback once game has been fully refreshed. Passes the refreshed game as the only argument, or null if unable to find the game. Source: hg/HungryGames.js, line 296 resetGame(id, command) Reset the specified category of data from a game. Parameters: Name Type Description id string The id of the guild to modify. command string The category of data to reset. Source: hg/HungryGames.js, line 420 Returns: The message explaining what happened. Type string save( [opt]) Save all HG related data to file. Purges old data from memory as well. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Source: hg/HungryGames.js, line 623 setDefaultArenaEvents(list) Update the reference to the array storing default arena events. Parameters: Name Type Description list Array.&lt;HungryGames~ArenaEvent&gt; Array to reference. Source: hg/HungryGames.js, line 230 setDefaultBattles(list) Update the reference to the array storing default battles events. Parameters: Name Type Description list Array.&lt;HungryGames~Battle&gt; Array to reference. Source: hg/HungryGames.js, line 240 setDefaultBloodbathEvents(list) Update the reference to the array storing default bloodbath events. Parameters: Name Type Description list Array.&lt;HungryGames~Event&gt; Array to reference. Source: hg/HungryGames.js, line 210 setDefaultPlayerEvents(list) Update the reference to the array storing default player events. Parameters: Name Type Description list Array.&lt;HungryGames~Event&gt; Array to reference. Source: hg/HungryGames.js, line 220 setDefaultWeapons(list) Update the reference to the array storing default weapons events. Parameters: Name Type Description list Array.&lt;HungryGames~Weapon&gt; Array to reference. Source: hg/HungryGames.js, line 250 shutdown() End all event listeners, intervals, and timeouts to prepare for a full stop. Source: hg/HungryGames.js, line 685 Type Definitions createEventBooleanCallback(outcome) The callback after receiving a boolean input. Parameters: Name Type Description outcome boolean The value chosen by the user. Source: hungryGames.js, line 4663 createEventNumCallback(num) The callback after receiving a number from user input. Parameters: Name Type Description num number The number received from the user. Source: hungryGames.js, line 4534 createEventOutcomeCallback(outcome) The callback after receiving an event outcome from a user. Parameters: Name Type Description outcome string The outcome chosen by the user. Source: hungryGames.js, line 4599 hgCommandHandler(msg, id) Handler for a Hungry Games command. Parameters: Name Type Description msg Discord~Message The message sent in Discord that triggered this command. id string The id of the guild this command was run on for convenience. Source: hungryGames.js, line 856 × Search results Close "},"HungryGames-ArenaEvent.html":{"id":"HungryGames-ArenaEvent.html","title":"Class: ArenaEvent","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: ArenaEvent HungryGames~ ArenaEvent new ArenaEvent(message, outcomes, outcomeProbs) An Arena event storing Events. Parameters: Name Type Argument Description message string The message at the start of the arena event. outcomes Array.&lt;HungryGames~Event&gt; All possible events in this arena event. outcomeProbs HungryGames~OutcomeProbabilities &lt;nullable&gt; Overrides the global setting for arena event outcome probabilities for this event. Source: hg/ArenaEvent.js, line 17 Members message :string Message sent at the start of the arena event. Type: string Source: hg/ArenaEvent.js, line 23 &lt;nullable&gt; outcomeProbs :HungryGames~OutcomeProbabilities Outcome probabilities specific to this arena event. Overrides the global arena event outcome probability settings. Null to use global settings. Type: HungryGames~OutcomeProbabilities Source: hg/ArenaEvent.js, line 36 outcomes :Array.&lt;HungryGames~Event&gt; All possible events in this arena event. Type: Array.&lt;HungryGames~Event&gt; Source: hg/ArenaEvent.js, line 29 × Search results Close "},"HungryGames-Battle.html":{"id":"HungryGames-Battle.html","title":"Class: Battle","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Battle HungryGames~ Battle new Battle(message, attacker, victim) Create a single battle. Parameters: Name Type Description message string The message of this battle event. attacker number The damage done to the attacker. victim number The damage done to the victim. Source: hg/Battle.js, line 17 Members &lt;private, static, constant&gt; _fistBoth :string The file path to read attacking both directions image. Type: string Default Value: ./img/fist_both.png Source: hg/Battle.js, line 68 &lt;private, static, constant&gt; _fistLeft :string The file path to read attacking left image. Type: string Default Value: ./img/fist_left.png Source: hg/Battle.js, line 48 &lt;private, static, constant&gt; _fistRight :string The file path to read attacking right image. Type: string Default Value: ./img/fist_right.png Source: hg/Battle.js, line 58 attacker :Object Information about attacker. Type: Object Source: hg/Battle.js, line 29 message :string Message of this battle event. Type: string Source: hg/Battle.js, line 23 victim :Object Information about victim. Type: Object Source: hg/Battle.js, line 35 Methods &lt;static&gt; finalize(affectedUsers, numVictim, numAttacker, mention, game, battles) Make an event that contains a battle between players before the main event message. Parameters: Name Type Description affectedUsers Array.&lt;HungryGames~Player&gt; All of the players involved in the event. numVictim number The number of victims in this event. numAttacker number The number of attackers in this event. mention boolean Should every player be mentioned when their name comes up? game HungryGames~GuildGame The GuildGame this battle is for. This is for settings checking and fetching non-affected users. battles Array.&lt;HungryGames~Battle&gt; Array of all possible battle events to choose from. Source: hg/Battle.js, line 88 Returns: The event that was created. Type HungryGames~Event × Search results Close "},"HungryGames-Day.html":{"id":"HungryGames-Day.html","title":"Class: Day","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Day HungryGames~ Day new Day( [num] [, events]) Create a basic game day. Parameters: Name Type Argument Description num number &lt;optional&gt; The day number. events Array.&lt;HungryGames~Event&gt; &lt;optional&gt; The events that will take place during this day. Source: hg/Day.js, line 17 Members events :Array.&lt;HungryGames~Event&gt; All events to take place during this day. Type: Array.&lt;HungryGames~Event&gt; Source: hg/Day.js, line 41 num :number The day number this is. (Bloodbath is 0) Type: number Source: hg/Day.js, line 24 state :number The state index of this day. 0 is not yet simulated, 1 is currently simulating, and 2-n are the index of the event to show if reduced by 2. (2 = event #0, 3 = event #1) Type: number Source: hg/Day.js, line 34 Methods &lt;static&gt; from(data) Create a Day from an Object. Similar to copy-constructor. Parameters: Name Type Description data object Day like Object. Source: hg/Day.js, line 52 Returns: Created Day. Type HungryGames~Day × Search results Close "},"HungryGames-DefaultOptions.html":{"id":"HungryGames-DefaultOptions.html","title":"Class: DefaultOptions","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: DefaultOptions HungryGames~ DefaultOptions Default options for a HungryGames. new DefaultOptions() Creates a set of default options for a HungryGames. Source: hg/DefaultOptions.js, line 222 Classes BooleanOption NumberOption ObjectOption Option SelectOption Members allowNoVictors Get allowNoVictors. Source: hg/DefaultOptions.js, line 414 anonForceOutcome Get anonForceOutcome. Source: hg/DefaultOptions.js, line 568 arenaEvents Get arenaEvents. Source: hg/DefaultOptions.js, line 393 arenaOutcomeProbs Get arenaOutcomeProbs. Source: hg/DefaultOptions.js, line 386 battleAvatarSizes Get battleAvatarSizes. Source: hg/DefaultOptions.js, line 533 battleHealth Get battleHealth. Source: hg/DefaultOptions.js, line 428 bleedDays Get bleedDays. Source: hg/DefaultOptions.js, line 421 bloodbathOutcomeProbs Get bloodbathOutcomeProbs. Source: hg/DefaultOptions.js, line 372 customEventWeight Get customEventWeight. Source: hg/DefaultOptions.js, line 561 delayDays Get delayDays. Source: hg/DefaultOptions.js, line 491 delayEvents Get delayEvents. Source: hg/DefaultOptions.js, line 484 disableOutput Get disableOutput. Source: hg/DefaultOptions.js, line 575 entries Source: hg/DefaultOptions.js, line 596 eventAvatarSizes Get eventAvatarSizes. Source: hg/DefaultOptions.js, line 526 excludeNewUsers Get excludeNewUsers. Source: hg/DefaultOptions.js, line 407 includeBots Get includeBots. Source: hg/DefaultOptions.js, line 400 keys Source: hg/DefaultOptions.js, line 582 mentionAll Get mentionAll. Source: hg/DefaultOptions.js, line 463 mentionEveryoneAtStart Get mentionEveryoneAtStart. Source: hg/DefaultOptions.js, line 470 mentionVictor Get mentionVictor. Source: hg/DefaultOptions.js, line 456 numDaysShowDeath Get numDaysShowDeath. Source: hg/DefaultOptions.js, line 547 playerOutcomeProbs Get playerOutcomeProbs. Source: hg/DefaultOptions.js, line 379 probabilityOfArenaEvent Get probabilityOfArenaEvent. Source: hg/DefaultOptions.js, line 498 probabilityOfBattle Get probabilityOfBattle. Source: hg/DefaultOptions.js, line 512 probabilityOfBleedToDeath Get probabilityOfBleedToDeath. Source: hg/DefaultOptions.js, line 505 probabilityOfUseWeapon Get probabilityOfUseWeapon. Source: hg/DefaultOptions.js, line 519 showLivingPlayers Get showLivingPlayers. Source: hg/DefaultOptions.js, line 554 teammatesCollaborate Get teammatesCollaborate. Source: hg/DefaultOptions.js, line 442 teamSize Get teamSize. Source: hg/DefaultOptions.js, line 435 useEnemyWeapon Get useEnemyWeapon. Source: hg/DefaultOptions.js, line 449 useNicknames Get useNicknames. Source: hg/DefaultOptions.js, line 477 victorAvatarSizes Get victorAvatarSizes. Source: hg/DefaultOptions.js, line 540 × Search results Close "},"HungryGames-DefaultOptions-BooleanOption.html":{"id":"HungryGames-DefaultOptions-BooleanOption.html","title":"Class: BooleanOption","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: BooleanOption HungryGames~DefaultOptions~ BooleanOption Boolean option. new BooleanOption(value [, comment] [, category]) Stores a boolean. Parameters: Name Type Argument Default Description value boolean Value of this option. comment string &lt;optional&gt; &lt;nullable&gt; null Comment/description for the user about this option. category string &lt;optional&gt; &lt;nullable&gt; null Category this option falls under for showing user. Source: hg/DefaultOptions.js, line 129 Extends HungryGames~DefaultOptions~Option Members &lt;nullable&gt; category :string Get the category of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#category Overrides: HungryGames~DefaultOptions~Option#category Source: hg/DefaultOptions.js, line 50 &lt;nullable&gt; comment :string Get the description of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#comment Overrides: HungryGames~DefaultOptions~Option#comment Source: hg/DefaultOptions.js, line 42 entries Inherited From: HungryGames~DefaultOptions~Option#entries Overrides: HungryGames~DefaultOptions~Option#entries Source: hg/DefaultOptions.js, line 69 keys Inherited From: HungryGames~DefaultOptions~Option#keys Overrides: HungryGames~DefaultOptions~Option#keys Source: hg/DefaultOptions.js, line 57 value :* Get the value of this option. Type: * Inherited From: HungryGames~DefaultOptions~Option#value Overrides: HungryGames~DefaultOptions~Option#value Source: hg/DefaultOptions.js, line 34 × Search results Close "},"HungryGames-DefaultOptions-NumberOption.html":{"id":"HungryGames-DefaultOptions-NumberOption.html","title":"Class: NumberOption","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: NumberOption HungryGames~DefaultOptions~ NumberOption Number option. new NumberOption(value [, comment] [, category] [, range]) Stores a number value with optional range. Parameters: Name Type Argument Default Description value number Value of this option. comment string &lt;optional&gt; &lt;nullable&gt; null Comment/description for the user about this option. category string &lt;optional&gt; &lt;nullable&gt; null Category this option falls under for showing user. range Object &lt;optional&gt; Allowed range of this value. Source: hg/DefaultOptions.js, line 95 Extends HungryGames~DefaultOptions~Option Members &lt;nullable&gt; category :string Get the category of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#category Overrides: HungryGames~DefaultOptions~Option#category Source: hg/DefaultOptions.js, line 50 &lt;nullable&gt; comment :string Get the description of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#comment Overrides: HungryGames~DefaultOptions~Option#comment Source: hg/DefaultOptions.js, line 42 entries Inherited From: HungryGames~DefaultOptions~Option#entries Overrides: HungryGames~DefaultOptions~Option#entries Source: hg/DefaultOptions.js, line 69 keys Inherited From: HungryGames~DefaultOptions~Option#keys Overrides: HungryGames~DefaultOptions~Option#keys Source: hg/DefaultOptions.js, line 57 range Get the range of allowable values for this option. Source: hg/DefaultOptions.js, line 110 value :* Get the value of this option. Type: * Inherited From: HungryGames~DefaultOptions~Option#value Overrides: HungryGames~DefaultOptions~Option#value Source: hg/DefaultOptions.js, line 34 × Search results Close "},"HungryGames-DefaultOptions-ObjectOption.html":{"id":"HungryGames-DefaultOptions-ObjectOption.html","title":"Class: ObjectOption","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: ObjectOption HungryGames~DefaultOptions~ ObjectOption Object option. Shallow copies passed value and range. new ObjectOption(value [, comment] [, category] [, range]) Stores any object. Shallow copies the object using Object.assign. Parameters: Name Type Argument Default Description value object Value of this option. comment string &lt;optional&gt; &lt;nullable&gt; null Comment/description for the user about this option. category string &lt;optional&gt; &lt;nullable&gt; null Category this option falls under for showing user. range Object &lt;optional&gt; Range of allowable values for this option. Source: hg/DefaultOptions.js, line 153 Extends HungryGames~DefaultOptions~Option Members &lt;nullable&gt; category :string Get the category of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#category Overrides: HungryGames~DefaultOptions~Option#category Source: hg/DefaultOptions.js, line 50 &lt;nullable&gt; comment :string Get the description of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#comment Overrides: HungryGames~DefaultOptions~Option#comment Source: hg/DefaultOptions.js, line 42 entries Inherited From: HungryGames~DefaultOptions~Option#entries Overrides: HungryGames~DefaultOptions~Option#entries Source: hg/DefaultOptions.js, line 69 keys Inherited From: HungryGames~DefaultOptions~Option#keys Overrides: HungryGames~DefaultOptions~Option#keys Source: hg/DefaultOptions.js, line 57 range Get the range of allowable values for this option. Source: hg/DefaultOptions.js, line 167 value :* Get the value of this option. Type: * Inherited From: HungryGames~DefaultOptions~Option#value Overrides: HungryGames~DefaultOptions~Option#value Source: hg/DefaultOptions.js, line 34 × Search results Close "},"HungryGames-DefaultOptions-Option.html":{"id":"HungryGames-DefaultOptions-Option.html","title":"Class: Option","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Option HungryGames~DefaultOptions~ Option Option base. new Option(value [, comment] [, category]) Default option constructor. Parameters: Name Type Argument Default Description value * Value of this option. comment string &lt;optional&gt; &lt;nullable&gt; null Comment/description for the user about this option. category string &lt;optional&gt; &lt;nullable&gt; null Category this option falls under for showing user. Source: hg/DefaultOptions.js, line 18 Members &lt;nullable&gt; category :string Get the category of this option. Type: string Source: hg/DefaultOptions.js, line 50 &lt;nullable&gt; comment :string Get the description of this option. Type: string Source: hg/DefaultOptions.js, line 42 entries Source: hg/DefaultOptions.js, line 69 keys Source: hg/DefaultOptions.js, line 57 value :* Get the value of this option. Type: * Source: hg/DefaultOptions.js, line 34 × Search results Close "},"HungryGames-DefaultOptions-SelectOption.html":{"id":"HungryGames-DefaultOptions-SelectOption.html","title":"Class: SelectOption","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: SelectOption HungryGames~DefaultOptions~ SelectOption One of multiple choices option. new SelectOption(value [, comment] [, category], values) Allows an option from a set of possible values. Parameters: Name Type Argument Default Description value string Value of this option. comment string &lt;optional&gt; &lt;nullable&gt; null Comment/description for the user about this option. category string &lt;optional&gt; &lt;nullable&gt; null Category this option falls under for showing user. values Array.&lt;string&gt; Possible values. Source: hg/DefaultOptions.js, line 188 Extends HungryGames~DefaultOptions~Option Members &lt;nullable&gt; category :string Get the category of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#category Overrides: HungryGames~DefaultOptions~Option#category Source: hg/DefaultOptions.js, line 50 &lt;nullable&gt; comment :string Get the description of this option. Type: string Inherited From: HungryGames~DefaultOptions~Option#comment Overrides: HungryGames~DefaultOptions~Option#comment Source: hg/DefaultOptions.js, line 42 entries Inherited From: HungryGames~DefaultOptions~Option#entries Overrides: HungryGames~DefaultOptions~Option#entries Source: hg/DefaultOptions.js, line 69 keys Inherited From: HungryGames~DefaultOptions~Option#keys Overrides: HungryGames~DefaultOptions~Option#keys Source: hg/DefaultOptions.js, line 57 value :* Get the value of this option. Type: * Inherited From: HungryGames~DefaultOptions~Option#value Overrides: HungryGames~DefaultOptions~Option#value Source: hg/DefaultOptions.js, line 34 values Get possible values for this option. Source: hg/DefaultOptions.js, line 208 × Search results Close "},"HungryGames-Event.html":{"id":"HungryGames-Event.html","title":"Class: Event","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Event HungryGames~ Event Event that can happen in a game. new Event(message [, numVictim] [, numAttacker] [, victimOutcome] [, attackerOutcome] [, victimKiller] [, attackerKiller] [, battle] [, state] [, attacks]) Creates a HungryGames Event. Parameters: Name Type Argument Default Description message string The message to show. numVictim number &lt;optional&gt; 0 The number of victims in this event. numAttacker number &lt;optional&gt; 0 The number of attackers in this event. victimOutcome string &lt;optional&gt; nothing The outcome of the victims from this event. attackerOutcome string &lt;optional&gt; nothing The outcome of the attackers from this event. victimKiller boolean &lt;optional&gt; false Do the victims kill anyone in this event. Used for calculating kill count. attackerKiller boolean &lt;optional&gt; false Do the attackers kill anyone in this event. Used for calculating kill count. battle boolean &lt;optional&gt; false Is this event a battle? state number &lt;optional&gt; 0 State of event if there are multiple attacks before the event. attacks Array.&lt;HungryGames~Event&gt; &lt;optional&gt; [] Array of attacks that take place before the event. Source: hg/Event.js, line 34 Members &lt;nullable&gt; action :string The action to format into a message if this is a weapon event. Type: string Source: hg/Event.js, line 50 attacker :Object Information about the attackers in this event. Type: Object Properties: Name Type Argument Description weapon Object &lt;nullable&gt; The weapon information to give to the player. Source: hg/Event.js, line 74 attacks :Array.&lt;HungryGames~Event&gt; The attacks in a battle to show before the message. Type: Array.&lt;HungryGames~Event&gt; Default Value: [] Source: hg/Event.js, line 100 battle :boolean Is this event a battle event. Type: boolean Default Value: false Source: hg/Event.js, line 86 consumes :number|string Amount of consumables used if this is a weapon event. Type: number | string Source: hg/Event.js, line 107 custom :boolean If the event is created by the user. Type: boolean Default Value: true Source: hg/Event.js, line 114 message :string The message to show. Type: string Source: hg/Event.js, line 43 state :number The current state of printing the battle messages. Type: number Default Value: 0 Source: hg/Event.js, line 93 victim :Object Information about the victims in this event. Type: Object Properties: Name Type Argument Description weapon Object &lt;nullable&gt; The weapon information to give to the player. Source: hg/Event.js, line 59 Methods &lt;static&gt; equal(e1, e2) Compare two events to check if they are equivalent. Parameters: Name Type Description e1 HungryGames~Event First event. e2 HungryGames~Event Second event to compare. Source: hg/Event.js, line 231 Returns: If the two given events are equivalent. Type boolean &lt;static&gt; finalize(message, affectedUsers, numVictim, numAttacker, victimOutcome, attackerOutcome, game) Format an event string based on specified users. Parameters: Name Type Description message string The message to show. affectedUsers Array.&lt;HungryGames~Player&gt; An array of all users affected by this event. numVictim number Number of victims in this event. numAttacker number Number of attackers in this event. victimOutcome string The outcome of the victims from this event. attackerOutcome string The outcome of the attackers from this event. game HungryGames~GuildGame The GuildGame to make this event for. Used for settings and fetching other players not affected by this event if necessary. Source: hg/Event.js, line 157 Returns: The final event that was created and formatted ready for display. Type HungryGames~FinalEvent &lt;private, static&gt; finalizeSimple(message [, game]) Make an event that doesn't affect any players and is just a plain message. Parameters: Name Type Argument Description message string The message to show. game HungryGames~GuildGame &lt;optional&gt; The GuildGame to make this event for. This is to check options and fetch players that may be necessary. Source: hg/Event.js, line 137 Returns: The event that was created. Type HungryGames~FinalEvent Example Event.finalizeSimple('Something happens!', game); equal(two) Compare this Event to another to check if they are equivalent. Parameters: Name Type Description two HungryGames~Event Other Event to compare against. Source: hg/Event.js, line 124 Returns: If they are equivalent. Type boolean Example console.log(firstEvent.equal(otherEvent)); × Search results Close "},"HungryGames-FinalEvent.html":{"id":"HungryGames-FinalEvent.html","title":"Class: FinalEvent","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: FinalEvent HungryGames~ FinalEvent new FinalEvent(message [, icons] [, numVictim] [, victimOutcome] [, attackerOutcome] [, mentionString]) Create an event ready for display. Parameters: Name Type Argument Default Description message string Text to send to users. icons Array.&lt;HungryGames~UserIconUrl&gt; &lt;optional&gt; Icons for this event. numVictim number &lt;optional&gt; 0 Number of victims in this event. victimOutcome string &lt;optional&gt; 'nothing' Victim outcome due to this event. attackerOutcome string &lt;optional&gt; 'nothing' Attacker outcome due to this event. mentionString string &lt;optional&gt; '' String of mentions to separate from the message embeds so that users are properly pinged. Source: hg/FinalEvent.js, line 21 Members attacker :Object Information about the attackers in this event. Type: Object Default Value: {outcome: 'nothing'} Source: hg/FinalEvent.js, line 57 icons :Array.&lt;HungryGames~UserIconUrl&gt; Icons to include with sent message. Type: Array.&lt;HungryGames~UserIconUrl&gt; Default Value: [] Source: hg/FinalEvent.js, line 36 mentionString :string String mentions to ping users. Type: string Default Value: '' Source: hg/FinalEvent.js, line 64 message :string Message to send to users. Type: string Source: hg/FinalEvent.js, line 29 numVictim :number Number of victims in this event. Type: number Default Value: 0 Source: hg/FinalEvent.js, line 43 victim :Object Information about the victims in this event. Type: Object Default Value: {outcome: 'nothing'} Source: hg/FinalEvent.js, line 50 × Search results Close "},"HungryGames-ForcedOutcome.html":{"id":"HungryGames-ForcedOutcome.html","title":"Class: ForcedOutcome","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: ForcedOutcome HungryGames~ ForcedOutcome new ForcedOutcome(id, list, state, text [, persists]) Create a single forced outcome. Parameters: Name Type Argument Default Description id string The guild ID in which the users will be affected. list Array.&lt;string&gt; The array of player IDs of which to affect. state string The outcome to force the players to have been victims of by the end of the simulated day. (\"living\", \"dead\", \"wounded\", or \"thriving\"). text string Message to show when the user is affected. persists boolean &lt;optional&gt; false Does this outcome persist to the end of the game, if false it only exists for the next day. Source: hg/ForcedOutcome.js, line 21 Members id :string The guild ID of which the users will be affected. Type: string Source: hg/ForcedOutcome.js, line 34 list :Array.&lt;string&gt; The array of player IDs of which this concerns. Type: Array.&lt;string&gt; Source: hg/ForcedOutcome.js, line 40 persists :boolean Does this outcome persist to the end of the game. False to only exist for a single day. Type: boolean Default Value: false Source: hg/ForcedOutcome.js, line 61 state :string The state to force the players to be in. Type: string Source: hg/ForcedOutcome.js, line 46 text :string Message to show when the user is affected. Type: string Source: hg/ForcedOutcome.js, line 52 × Search results Close "},"HungryGames-Game.html":{"id":"HungryGames-Game.html","title":"Class: Game","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Game HungryGames~ Game new Game( [name] [, includedUsers] [, teams]) Create a game with basic game information. Parameters: Name Type Argument Description name string &lt;optional&gt; The name of this game. includedUsers Array.&lt;HungryGames~Player&gt; &lt;optional&gt; Array of user players that are included in this game. teams Array.&lt;HungryGames~Team&gt; &lt;optional&gt; Array of teams that have been formed already. Source: hg/Game.js, line 20 Members day :HungryGames~Day Information about the day that was simulated. Type: HungryGames~Day Source: hg/Game.js, line 71 ended :boolean Has the game ended. Type: boolean Source: hg/Game.js, line 64 forcedOutcomes :Array.&lt;HungryGames~ForcedOutcome&gt; List of outcomes and players to force before the end of the day. Does not affect the simulation, outcomes are forced by appending events at the end of the simulated day. Type: Array.&lt;HungryGames~ForcedOutcome&gt; Default Value: [] Source: hg/Game.js, line 57 includedUsers :Array.&lt;HungryGames~Player&gt; Array of all users currently in the game. Type: Array.&lt;HungryGames~Player&gt; Source: hg/Game.js, line 41 inProgress :boolean Is the game currently in progress. Type: boolean Source: hg/Game.js, line 34 isPaused :boolean Is this game currently paused. Type: boolean Source: hg/Game.js, line 84 name :string The name of this game. Type: string Default Value: 'Hungry Games' Source: hg/Game.js, line 27 numAlive :number The number of players still alive in this game. Type: number Source: hg/Game.js, line 77 teams :Array.&lt;HungryGames~Team&gt; All teams in the game. Type: Array.&lt;HungryGames~Team&gt; Default Value: [] Source: hg/Game.js, line 48 Methods &lt;static&gt; from(data) Create a new Game from an object. Similar to a copy constructor. Parameters: Name Type Description data object Game like object to copy. Source: hg/Game.js, line 95 Returns: Created Game object. Type HungryGames~Game × Search results Close "},"HungryGames-Grammar.html":{"id":"HungryGames-Grammar.html","title":"Class: Grammar","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Grammar HungryGames~ Grammar new Grammar() Grammar related string formatting. Source: hg/Grammar.js, line 9 Methods &lt;static&gt; formatMultiNames(names [, format]) Format an array of users into names based on options and grammar rules. Parameters: Name Type Argument Default Description names Array.&lt;HungryGames~Player&gt; An array of players to format the names of. format string &lt;optional&gt; 'username' Setting of how to format the user's name. `username` will use their account name, `mention` will use their ID to format a mention tag, `nickname` will use their custom guild nickname. Source: hg/Grammar.js, line 21 Returns: The formatted string of names. Type string × Search results Close "},"HungryGames-GuildGame.html":{"id":"HungryGames-GuildGame.html","title":"Class: GuildGame","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: GuildGame HungryGames~ GuildGame A single instance of a game in a guild. new GuildGame(bot, id, options [, name] [, includedUsers] [, excludedUsers] [, includedNPCs] [, excludedNPCs] [, customEvents] [, disabledEvents]) Create a game instance for a single guild. Parameters: Name Type Argument Description bot string User id of the current bot instance. id string Guild id of the Guild that this object is for. options object.&lt;(number|boolean|string|object)&gt; The game options. name string &lt;optional&gt; Name of this game to be passed to the Game object. includedUsers Array.&lt;string&gt; | Array.&lt;HungryGames~Player&gt; &lt;optional&gt; Array of user IDs that will be included in the next game, or array of Players to include. excludedUsers Array.&lt;string&gt; &lt;optional&gt; Array of user IDs that have been excluded from the games. includedNPCs Array.&lt;HungryGames~NPC&gt; &lt;optional&gt; Array of NPC objects to include in the game. excludedNPCs Array.&lt;HungryGames~NPC&gt; &lt;optional&gt; Array of NPC objects to exclude from the game. customEvents Object &lt;optional&gt; All custom events for the guild. disabledEvents Object &lt;optional&gt; All disabled events for the guild. Source: hg/GuildGame.js, line 42 Members &lt;private, nullable&gt; _autoPlayTimeout :Timeout The timeout to continue autoplaying after the day ends. Used for cancelling if user ends the game between days. Type: Timeout Source: hg/GuildGame.js, line 232 &lt;private&gt; _autoStep :boolean Is this game automatically stepping, or are steps controlled manually. Type: boolean Default Value: false Source: hg/GuildGame.js, line 124 &lt;private, nullable&gt; _dayEventInterval :Timeout Interval for day events. Type: Timeout Source: hg/GuildGame.js, line 223 &lt;private, nullable&gt; _stateUpdateCallback :HungryGames~GuildGame~StateUpdateCB Function to call when state is modified. Type: HungryGames~GuildGame~StateUpdateCB Source: hg/GuildGame.js, line 240 &lt;private, constant&gt; _stats :HungryGames~StatManager Manages all stats for all players. Type: HungryGames~StatManager Source: hg/GuildGame.js, line 247 &lt;nullable&gt; author :string The id of the user that last sent a command which interacted with this guild game. Type: string Source: hg/GuildGame.js, line 190 autoPlay :boolean Is this game autoplaying? Type: boolean Default Value: false Source: hg/GuildGame.js, line 109 &lt;constant&gt; bot :string The ID of the current bot account. Type: string Source: hg/GuildGame.js, line 51 &lt;nullable&gt; channel :string The channel id a command was last sent from that affected this guild game. Type: string Source: hg/GuildGame.js, line 182 currentGame :HungryGames~Game Current game information. Type: HungryGames~Game Source: hg/GuildGame.js, line 157 customEvents :Object All custom events for the guild. Type: Object Default Value: {{bloodbath: [], player: [], arena: [], weapon: {}}} Source: hg/GuildGame.js, line 138 disabledEvents :Object Disabled event information. These events are not allowed to show up in the game. Type: Object Default Value: {{bloodbath: [], player: [], arena: {}, weapon: {}}} Source: hg/GuildGame.js, line 172 excludedNPCs :Array.&lt;HungryGames~NPC&gt; Array of NPCs that will be excluded from the game. Type: Array.&lt;HungryGames~NPC&gt; Default Value: [] Source: hg/GuildGame.js, line 96 excludedUsers :Array.&lt;string&gt; Array of user IDs that will be excluded from the next game. Type: Array.&lt;string&gt; Default Value: [] Source: hg/GuildGame.js, line 82 &lt;constant&gt; id :string The ID of the Guild this is for. Type: string Source: hg/GuildGame.js, line 58 includedNPCs :Array.&lt;HungryGames~NPC&gt; Array of NPCs that will be included in the game. Type: Array.&lt;HungryGames~NPC&gt; Default Value: [] Source: hg/GuildGame.js, line 89 includedUsers :Array.&lt;string&gt; Array of user IDs that will be included in the next game. Type: Array.&lt;string&gt; Default Value: [] Source: hg/GuildGame.js, line 65 loading :boolean Does this game currently have any long running operations being performed. Type: boolean Default Value: false Source: hg/GuildGame.js, line 117 options :Object Game options. Type: Object Source: hg/GuildGame.js, line 102 &lt;nullable&gt; outputChannel :string The channel id where the game messages are currently being sent in. Type: string Source: hg/GuildGame.js, line 198 &lt;nullable&gt; reactMessage :Object Message ID of the message to fetch reactions from for join via react. Type: Object Source: hg/GuildGame.js, line 206 serializable Get a serializable version of this class instance. Strips all private variables, and all functions. Assumes all public variables are serializable if they aren't a function. Source: hg/GuildGame.js, line 259 &lt;nullable&gt; statGroup :string The ID of the currently active HungryGames~StatGroup tracking stats. Type: string Source: hg/GuildGame.js, line 215 Methods &lt;static&gt; forcePlayerState(game, list, state, messages [, text] [, persists]) Force a player to have a certain outcome in the current day being simulated, or the next day that will be simulated. This is acheived by adding a custom event in which the player will be affected after their normal event for the day. Parameters: Name Type Argument Default Description game HungryGames~GuildGame The game context. list Array.&lt;string&gt; The array of player IDs of which to affect. state string The outcome to force the players to have been victims of by the end of the simulated day. (\"living\", \"dead\", \"wounded\", or \"thriving\"). messages HungryGames~Messages Reference to current Messages instance. text string | Array.&lt;HungryGames~Event&gt; &lt;optional&gt; Message to show when the user is affected, or array of default events if not specifying a specific message. persists boolean &lt;optional&gt; false Does this outcome persist to the end of the game, if false it only exists for the next day. Source: hg/GuildGame.js, line 533 Returns: The output message to tell the user of the outcome of the operation. Type string &lt;static&gt; from(data) Create a GuildGame from data parsed from file. Similar to copy constructor. Parameters: Name Type Description data object GuildGame like object. Source: hg/GuildGame.js, line 494 Returns: Created GuildGame. Type HungryGames~GuildGame clearIntervals() Clear all timeouts and intervals. Source: hg/GuildGame.js, line 413 createInterval(cb) Create an interval for this guild. Calls the callback every time the game state is about to be modified. State is updated immediately after the callback completes. This also sets `_autoStep` to true. Parameters: Name Type Description cb HungryGames~GuildGame~StateUpdateCB Callback to fire on the interval. Source: hg/GuildGame.js, line 432 end() Force this current game to end immediately. Source: hg/GuildGame.js, line 402 formTeams() Add users to teams, and remove excluded users from teams. Deletes empty teams, and adds teams once all teams have teamSize of players. Source: hg/GuildGame.js, line 291 Returns: Null if success, string if error. Type string step() Progress to the next game state. Calls `_stateUpdateCallback` prior to any action, if it's set. Source: hg/GuildGame.js, line 452 Type Definitions StateUpdateCB(dayComplete, doSim) Callback to fire when game state is about to be modified. Parameters: Name Type Description dayComplete boolean True if this update is after a day has ended, false if the state is still during a day. doSim boolean True if the next day should be simulated and started. Source: hg/GuildGame.js, line 274 × Search results Close "},"HungryGames-Messages.html":{"id":"HungryGames-Messages.html","title":"Class: Messages","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Messages HungryGames~ Messages String text getter helper. new Messages() Source: hg/Messages.js, line 5 × Search results Close "},"HungryGames-OutcomeProbabilities.html":{"id":"HungryGames-OutcomeProbabilities.html","title":"Class: OutcomeProbabilities","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: OutcomeProbabilities HungryGames~ OutcomeProbabilities new OutcomeProbabilities( [kill] [, wound] [, thrive] [, revive] [, nothing]) Create an object storing relative probabilities. Parameters: Name Type Argument Description kill number &lt;optional&gt; Kill probability. wound number &lt;optional&gt; Wound probability. thrive number &lt;optional&gt; Thrive probability. revive number &lt;optional&gt; Revive probability. nothing number &lt;optional&gt; Probability of no outcome change. Source: hg/OutcomeProbabilities.js, line 22 Members kill :number The probability of an event being chosen that kills players. Type: number Source: hg/OutcomeProbabilities.js, line 29 nothing :number The probability of an event being chosen that does not have any effect on players. Type: number Source: hg/OutcomeProbabilities.js, line 58 revive :number The probability of an event being chosen that revives players. Type: number Source: hg/OutcomeProbabilities.js, line 50 thrive :number The probability of an event being chosen that heals players. Type: number Source: hg/OutcomeProbabilities.js, line 43 wound :number The probability of an event being chosen that wounds players. Type: number Source: hg/OutcomeProbabilities.js, line 36 × Search results Close "},"HungryGames-Player.html":{"id":"HungryGames-Player.html","title":"Class: Player","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Player HungryGames~ Player new Player(id, username, avatarURL [, nickname]) Create a player object for a game. Requires a unique ID and a username. Parameters: Name Type Argument Default Description id string The id of the user this object is representing. username string The name of the user to show in the game. avatarURL string URL to avatar to show for the user in the game. nickname string &lt;optional&gt; &lt;nullable&gt; null The nickname for this user usually assigned by the guild. If the user does not have a nickname, this will have the same value as `name`. Source: hg/Player.js, line 21 Members avatarURL :string The URL to the discord avatar of the User. Type: string Default Value: '' Source: hg/Player.js, line 44 bleeding :number How many days has the player been wounded. Type: number Source: hg/Player.js, line 65 dayOfDeath :number The day at which the player last died in the game. Only a valid number if the player is currently dead. Otherwise a garbage value will be available. Type: number Source: hg/Player.js, line 109 id :string The id of the User this Player represents. Type: string Source: hg/Player.js, line 31 kills :number The number of players this player has caused to die. Type: number Source: hg/Player.js, line 86 living :boolean Is the player still alive. Type: boolean Default Value: true Source: hg/Player.js, line 58 name :string The name of this Player. Type: string Source: hg/Player.js, line 37 nickname :string The nickname for this user usually assigned by the guild. If the user does not have a nickname, this will have the same value as `name`. Type: string Source: hg/Player.js, line 51 rank :number The current rank of the player in the game. Type: number Default Value: 1 Source: hg/Player.js, line 72 settings :Object Custom settings for this user associated with the games. Type: Object Default Value: {} Source: hg/Player.js, line 100 state :string The current player state (normal, wounded, dead, zombie). Type: string Default Value: normal Source: hg/Player.js, line 79 weapons :Object.&lt;number&gt; The weapons the player currently has and how many of each. Type: Object.&lt;number&gt; Default Value: {} Source: hg/Player.js, line 93 Methods &lt;static&gt; from(member) Create a Player from a given Discord.User or Player-like Object. Can be used as a copy-constructor. Parameters: Name Type Description member Discord~User | Discord~GuildMember | object Object, User or GuildMember to make a Player from. Source: hg/Player.js, line 124 Returns: Player object created. Type HungryGames~Player × Search results Close "},"HungryGames-Simulator.html":{"id":"HungryGames-Simulator.html","title":"Class: Simulator","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Simulator HungryGames~ Simulator new Simulator(game, hg [, msg]) Create a simulator instance. Parameters: Name Type Argument Description game HungryGames~GuildGame The GuildGame to simulate. hg HungryGames Parent game manager for logging and SubModule references. msg Discord~Message &lt;optional&gt; Message to reply to if necessary. Source: hg/Simulator.js, line 32 Classes Worker Members &lt;private, static, constant&gt; _littleDeathRate :number If a lower percentage of people die in one day than this value, then show a relevant message. Type: number Default Value: 0.15 Source: hg/Simulator.js, line 170 &lt;private, static, constant&gt; _lotsOfDeathRate :number If a larger percentage of people die in one day than this value, then show a relevant message. Type: number Default Value: 0.75 Source: hg/Simulator.js, line 159 &lt;private, static, constant&gt; _multiEventUserDistribution :Object.&lt;number&gt; Probability of each amount of people being chosen for an event. Must total to 1.0 Type: Object.&lt;number&gt; Default Value: {\"undefined\":0.0005} Source: hg/Simulator.js, line 137 &lt;private, static, constant&gt; _workerPath :string Relative path from CWD where the simulation worker is located. Type: string Default Value: ./src/hg/simulator/worker.js Source: hg/Simulator.js, line 919 Methods &lt;private, static&gt; _effectUser(game, affected, kills [, weapon]) Base of all actions to perform on a player. Parameters: Name Type Argument Description game HungryGames~GuildGame Current GuildGame being affected. affected HungryGames~Player The player to affect. kills number The number of kills the player gets in this action. weapon Array.&lt;HungryGames~Weapon&gt; &lt;optional&gt; The weapon being used if any. Source: hg/Simulator.js, line 350 &lt;private, static&gt; _killUser(game, a, k [, w]) Kill the given player in the given guild game. Parameters: Name Type Argument Description game HungryGames~GuildGame Current GuildGame being affected. a HungryGames~Player The player to affect. k number The number of kills the player gets in this action. w Array.&lt;HungryGames~Weapon&gt; &lt;optional&gt; The weapon being used if any. Source: hg/Simulator.js, line 375 &lt;private, static&gt; _parseConsumeCount(consumeString, numVictim, numAttacker) Parse the number of items consumed from the given consumed value, and number of victims and attackers. Parameters: Name Type Description consumeString string The consumes value for the event. numVictim number The number of victims in the event. numAttacker number The number of attackers in the event. Source: hg/Simulator.js, line 898 Returns: The number of consumed items. Type number &lt;private, static&gt; _pickAffectedPlayers(numVictim, numAttacker, victimOutcome, attackerOutcome, options, userPool, deadPool, teams, weaponWielder) Pick the players to put into an event. Parameters: Name Type Argument Description numVictim number Number of victims in this event. numAttacker number Number of attackers in this event. victimOutcome string Outcome of victims. If \"revived\", uses deadPool instead of userPool. attackerOutcome string Outcome of attackers. If \"revived\", uses deadPool instead of userPool. options object Options for this game. userPool Array.&lt;HungryGames~Player&gt; Pool of all remaining players to put into an event. deadPool Array.&lt;HungryGames~Player&gt; Pool of all dead players that can be revived. teams Array.&lt;HungryGames~Team&gt; All teams in this game. weaponWielder Player &lt;nullable&gt; A player that is using a weapon in this event, or null if no player is using a weapon. Source: hg/Simulator.js, line 218 Returns: Array of all players that will be affected by this event. Type Array.&lt;HungryGames~Player&gt; &lt;private, static&gt; _pickEvent(userPool, eventPool, options, numAlive, numTotal, teams, probOpts, weaponWielder, chosenWeapon) Pick event that satisfies all requirements and settings. Parameters: Name Type Argument Description userPool Array.&lt;HungryGames~Player&gt; Pool of players left to chose from in this day. eventPool Array.&lt;HungryGames~Event&gt; Pool of all events available to choose at this time. options object The options set in the current game. numAlive number Number of players in the game still alive. numTotal number Number of players in the game total. teams Array.&lt;HungryGames~Team&gt; Array of teams in this game. probOpts HungryGames~OutcomeProbabilities Death rate weights. weaponWielder Player &lt;nullable&gt; A player that is using a weapon in this event, or null if no player is using a weapon. chosenWeapon string Name of the weapon the player is trying to use. Source: hg/Simulator.js, line 487 Returns: The chosen event that satisfies all requirements, or null if something went wrong. Type HungryGames~Event &lt;private, static&gt; _probabilityEvent(eventPool, probabilityOpts [, customWeight] [, recurse]) Produce a random event that using probabilities set in options. Parameters: Name Type Argument Default Description eventPool Array.&lt;HungryGames~Event&gt; The pool of all events to consider. probabilityOpts Object The probabilities of each type of event being used. customWeight number &lt;optional&gt; 1 The weight of custom events. recurse number &lt;optional&gt; 0 The current recursive depth. Source: hg/Simulator.js, line 809 Returns: The index of the event that was chosen. Type number &lt;private, static&gt; _restoreUser(game, a, k [, w]) Heal the given player in the given guild game. Parameters: Name Type Argument Description game HungryGames~GuildGame Current GuildGame being affected. a HungryGames~Player The player to affect. k number The number of kills the player gets in this action. w Array.&lt;HungryGames~Weapon&gt; &lt;optional&gt; The weapon being used if any. Source: hg/Simulator.js, line 428 &lt;private, static&gt; _reviveUser(game, a, k [, w]) Revive the given player in the given guild game. Parameters: Name Type Argument Description game HungryGames~GuildGame Current GuildGame being affected. a HungryGames~Player The player to affect. k number The number of kills the player gets in this action. w Array.&lt;HungryGames~Weapon&gt; &lt;optional&gt; The weapon being used if any. Source: hg/Simulator.js, line 443 &lt;private, static&gt; _validateEventNumConstraint(numVictim, numAttacker, userPool, numAlive) Ensure the number of users in an event is mathematically possible. Parameters: Name Type Description numVictim number Number of victims in this event. numAttacker number Number of attackers in this event. userPool Array.&lt;HungryGames~Player&gt; Pool of all remaining players to put into an event. numAlive number Total number of living players left in the game. Source: hg/Simulator.js, line 751 Returns: If the event requires a number of players that is valid from the number of players left to choose from. Type boolean &lt;private, static&gt; _validateEventRequirements(numVictim, numAttacker, userPool, numAlive, teams, options, victimsDie, attackersDie, weaponWielder) Ensure the event chosen meets all requirements for actually being used in the current game. Parameters: Name Type Argument Description numVictim number Number of victims in this event. numAttacker number Number of attackers in this event. userPool Array.&lt;HungryGames~Player&gt; Pool of all remaining players to put into an event. numAlive number Total number of living players left in the game. teams Array.&lt;HungryGames~Team&gt; All teams in this game. options object The options set for this game. victimsDie boolean Do the victims die in this event? attackersDie boolean Do the attackers die in this event? weaponWielder Player &lt;nullable&gt; A player that is using a weapon in this event, or null if no player is using a weapon. Source: hg/Simulator.js, line 775 Returns: String of failing constraint check, or null if passes. Type string &lt;private, static&gt; _validateEventTeamConstraint(numVictim, numAttacker, userPool, teams, options, victimsDie, attackersDie, weaponWielder) Ensure teammates don't attack each other. Parameters: Name Type Argument Description numVictim number The number of victims in the event. numAttacker number The number of attackers in the event. userPool Array.&lt;HungryGames~Player&gt; Pool of all remaining players to put into an event. teams Array.&lt;HungryGames~Team&gt; All teams in this game. options object Options for this game. victimsDie boolean Do the victims die in this event? attackersDie boolean Do the attackers die in this event? weaponWielder Player &lt;nullable&gt; A player that is using a weapon in this event, or null if no player is using a weapon. Source: hg/Simulator.js, line 633 Returns: String describing failing check, or null of pass. Type string &lt;private, static&gt; _validateEventVictorConstraint(numVictim, numAttacker, numAlive, options, victimsDie, attackersDie) Ensure the event we choose will not force all players to be dead. Parameters: Name Type Description numVictim number Number of victims in this event. numAttacker number Number of attackers in this event. numAlive number Total number of living players left in the game. options object The options set for this game. victimsDie boolean Do the victims die in this event? attackersDie boolean Do the attackers die in this event? Source: hg/Simulator.js, line 728 Returns: Will this event follow current options set about number of victors required. Type boolean &lt;private, static&gt; _woundUser(game, a, k [, w]) Wound the given player in the given guild game. Parameters: Name Type Argument Description game HungryGames~GuildGame Current GuildGame being affected. a HungryGames~Player The player to affect. k number The number of kills the player gets in this action. w Array.&lt;HungryGames~Weapon&gt; &lt;optional&gt; The weapon being used if any. Source: hg/Simulator.js, line 414 &lt;static&gt; weightedUserRand() Produce a random number that is weighted by multiEventUserDistribution. Source: hg/Simulator.js, line 181 See: multiEventUserDistribution Returns: The weighted number outcome. Type number go(cb) Simulate a day with the current GuildGame. Parameters: Name Type Description cb function Callback that always fires on completion. The only parameter is a possible error string, null if no error. Source: hg/Simulator.js, line 67 setGame(game) Change the GuildGame to simulate. Parameters: Name Type Description game HungryGames~GuildGame The new GuildGame. Source: hg/Simulator.js, line 42 setMessage(msg) Update the message to reply to. Parameters: Name Type Description msg Discord~Message New message to reference. Source: hg/Simulator.js, line 58 setParent(hg) Update the reference to the parent HungryGames. Parameters: Name Type Description hg HungryGames New parent reference. Source: hg/Simulator.js, line 50 × Search results Close "},"HungryGames-Simulator-Worker.html":{"id":"HungryGames-Simulator-Worker.html","title":"Class: Worker","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Worker HungryGames~Simulator~ Worker new Worker(sim [, retry]) Create and start simulating. Parameters: Name Type Argument Default Description sim Object Simulation data. retry boolean &lt;optional&gt; true Whether to try again if there is an error. Source: hg/simulator/worker.js, line 24 Methods cb( [data]) Pass a message back to the parent. Parameters: Name Type Argument Description data * &lt;optional&gt; Data to send to the parent. Source: hg/simulator/worker.js, line 606 × Search results Close "},"HungryGames-StatGroup.html":{"id":"HungryGames-StatGroup.html","title":"Class: StatGroup","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: StatGroup HungryGames~ StatGroup new StatGroup(parent [, metadata]) Create group. Parameters: Name Type Argument Description parent GuildGame The parent instance of this group. metadata HGStatMetadata | string &lt;optional&gt; Additional information to store with these stats, or ID if metadata should be read from file since this group already exists. Source: hg/StatGroup.js, line 39 Members &lt;private, constant&gt; _dir :string The directory where all of this group's information is stored. Type: string Source: hg/StatGroup.js, line 102 &lt;private&gt; _fetchQueue :Object.&lt;Array.&lt;function()&gt;&gt; Queue of callbacks to fire once an object has been read from file. This is used to ensure that if multiple manipulations are requested on a single object at the same time, all modifications will take place on the same instance instead of overwriting eachother. Mapped by ID being fetched. Type: Object.&lt;Array.&lt;function()&gt;&gt; Default Value: {} Source: hg/StatGroup.js, line 83 &lt;private&gt; _saveQueue :Object.&lt;{data: HungryGames~Stats, timeout: Timeout}&gt; Cache of Stats objects that are to be saved to file, and the Timeout until it will be saved. Prevents saving the same file multiple times at once. Type: Object.&lt;{data: HungryGames~Stats, timeout: Timeout}&gt; Default Value: {} Source: hg/StatGroup.js, line 92 &lt;constant&gt; bot :string The ID of this current bot. Type: string Source: hg/StatGroup.js, line 55 &lt;constant&gt; guild :string The guild ID where this stat group resides. Type: string Source: hg/StatGroup.js, line 63 id :string The unique ID for this stat group. Unique per-guild. Type: string Source: hg/StatGroup.js, line 70 Methods &lt;static&gt; createID(game) Create an ID for a new group. Parameters: Name Type Description game HungryGames~GuildGame The game to create an ID for to ensure no collisions. Source: hg/StatGroup.js, line 634 To Do: Limit number of IDs to prevent infinite loop finding new ID. Returns: Valid created ID. Type string &lt;static&gt; exists(game, id) Check if a stat group with the given ID exists for the given game. Parameters: Name Type Description game HungryGames~GuildGame The game of which the stats to look up. id string The group ID to check for. Source: hg/StatGroup.js, line 608 Returns: True if exists, false otherwise. Type boolean &lt;static&gt; fetchList(game, cb) Fetch list of IDs for all created groups. Parameters: Name Type Description game HungryGames~GuildGame The game to get list for. cb function Callback with optional error argument, otherwise second argument is array of IDs as strings. Source: hg/StatGroup.js, line 621 &lt;private&gt; _fetchMetadata(cb) Fetch the metadata for this group from file. Parameters: Name Type Description cb function Callback with optional error argument, otherwise second argument is parsed HGStatMetadata. Source: hg/StatGroup.js, line 509 &lt;private&gt; _fetchUser(uId, cb) Fetch stats for a specific user in this group. Returned stats are modifiable, but changes will not persist unless saved to file. Parameters: Name Type Description uId string The user ID of which to lookup. cb function Callback with optional error as first argument, otherwise has stats as second argument. Source: hg/StatGroup.js, line 137 &lt;private&gt; _parseMetadata(data) Parse the given object into a HGStatMetadata object. Parameters: Name Type Description data object The data to parse. Source: hg/StatGroup.js, line 530 Returns: The parsed object. Type HGStatMetadata &lt;private&gt; _saveMetadata(meta [, immediate]) Save the current metadata to file. Parameters: Name Type Argument Default Description meta HGStatMetadata The data to save. Overwrites existing data. immediate boolean &lt;optional&gt; false Force saving to perform immediately instead of delaying until next event loop. Source: hg/StatGroup.js, line 549 &lt;private&gt; _saveUser(data [, immediate]) Save a stats object to file. Parameters: Name Type Argument Default Description data HungryGames~Stats The stats object to save. immediate boolean &lt;optional&gt; false Force saving to happen immediately instead of waiting until next event loop. Source: hg/StatGroup.js, line 413 &lt;private&gt; fetchMetadata(cb) Fetch the metadata for this group from file. Modified values will not persist. Use functions to modify. Parameters: Name Type Description cb function Callback with optional error argument, otherwise second argument is parsed HGStatMetadata. Source: hg/StatGroup.js, line 520 fetchUser(uId, cb) Fetch stats for a specific user in this group. Modified values will not persist. Use functions to modify. Parameters: Name Type Description uId string The user ID of which to lookup. cb function Callback with optional error as first argument, otherwise has stats as second argument. Source: hg/StatGroup.js, line 228 To Do: Return immutable/frozen copy to enforce no-modify rule. fetchUsers( [opts], cb) Fetch stats for a group of users. If array of IDs is given, data will not be sorted. Parameters: Name Type Argument Description opts HGStatGroupUserSelectOptions | Array.&lt;string&gt; &lt;optional&gt; Options to specify which users are fetched, or array of user IDs to fetch. cb function Callback with optional error as first argument, otherwise has stats as second argument as array of HungryGames~Stats objects. Source: hg/StatGroup.js, line 259 fetchValue(uId, key, cb) Fetch a stat value for a single user. Immutable. Parameters: Name Type Description uId string The user ID of which to fetch. key string The key of the value to fetch. cb function Callback with optional error argument, and matched value. Source: hg/StatGroup.js, line 358 increment(uId, key [, amount] [, cb]) Increment a value by an amount. Parameters: Name Type Argument Default Description uId string The user ID of which to modify. key string The key of the value to modify. amount number &lt;optional&gt; 1 Amount to increment by. Can be negative to decrement. cb function &lt;optional&gt; Callback with single optional error argument. Source: hg/StatGroup.js, line 377 reset() Delete all data associated with this group. Source: hg/StatGroup.js, line 577 setMetaEnd(endTime) Set the metadata end time. Parameters: Name Type Description endTime Date | number | string Date parsable time. Source: hg/StatGroup.js, line 492 setMetaName(name) Set the metadata name. Parameters: Name Type Description name string The new value. Source: hg/StatGroup.js, line 461 setMetaStart(startTime) Set the metadata start time. Parameters: Name Type Description startTime Date | number | string Date parsable time. Source: hg/StatGroup.js, line 476 setValue(uId, key, value, cb) Set a stat value for a single user. Parameters: Name Type Description uId string The user ID of which to change. key string The key of the value to change. value * The value to store. cb function Callback with single optional error argument. Source: hg/StatGroup.js, line 338 × Search results Close "},"HungryGames-StatManager.html":{"id":"HungryGames-StatManager.html","title":"Class: StatManager","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: StatManager HungryGames~ StatManager new StatManager(game) Constructor. Parameters: Name Type Description game HungryGames~GuildGame Parent game. Source: hg/StatManager.js, line 15 Members &lt;constant&gt; game :HungryGames~GuildGame Parent game to reference by default. Type: HungryGames~GuildGame Source: hg/StatManager.js, line 22 Methods createGroup( [metadata] [, cb]) Create a new stat group. Parameters: Name Type Argument Description metadata HGStatMetadata &lt;optional&gt; Metadata to store with stat group. cb function &lt;optional&gt; Callback function once completed. Only argument is the created group. Source: hg/StatManager.js, line 144 fetchGroup( [id], cb) Fetch a {@HungryGames~StatGroup} reference. Parameters: Name Type Argument Default Description id string &lt;optional&gt; 'global' The ID of the group to fetch. cb function Callback with optional error argument, otherwise second argument is the group reference. Source: hg/StatManager.js, line 119 fetchGroupList(cb) Fetch IDs of all created groups. Parameters: Name Type Description cb function Callback with optional error argument, otherwise second argument is array of IDs as strings. Source: hg/StatManager.js, line 159 parseDay() Update stats based on the current day data of the given game. Source: hg/StatManager.js, line 29 × Search results Close "},"HungryGames-Stats.html":{"id":"HungryGames-Stats.html","title":"Class: Stats","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Stats HungryGames~ Stats new Stats(data) Create object. Parameters: Name Type Description data HungryGames~Stats | string Data to initialize this stats object with, or ID of user this instance represents. Source: hg/Stats.js, line 15 Members &lt;static&gt; keys Get array of all keys stored by this object when requested from a static scope. Source: hg/Stats.js, line 100 &lt;private&gt; _data :Object Cache of all datapoints. All properties must match SQL database excluding `groupId`, `guildId` and `userId` which must not be included. Type: Object Properties: Name Type Description kills number Number of kills. deaths number Number of deaths. wounds number Number of times wounded. heals number Number of times wounds have healed. revives number Number of times revived. wins number Number of games won. losses number Number of games lost. daysAlive number Number of days spent alive (includes wounded). daysDead number Number of days spent dead. daysWounded number Number of days spent wounded. Source: hg/Stats.js, line 48 &lt;constant&gt; _id :string The ID of the user this object represents. Type: string Source: hg/Stats.js, line 27 id The ID this of the user this object represents. Source: hg/Stats.js, line 70 keys Get array of all keys stored by this object. Source: hg/Stats.js, line 89 serializable Fetch the data stored here as a serializable object. Source: hg/Stats.js, line 121 Methods &lt;static&gt; from(obj) Create a Stats object instance from a Stats-like object. Parameters: Name Type Description obj object The object to create a Stats instance of. Source: hg/Stats.js, line 132 Returns: The created instance. Type HungryGames~Stats get(key) Fetch the value of a certain data point. Parameters: Name Type Description key string The name of the datapoint. Source: hg/Stats.js, line 80 Returns: The value, or undefined if unable to be found. Type number set(key, value) Set a value for a certain datapoint. Parameters: Name Type Description key string The name of this datapoint. value number The new value to set. Source: hg/Stats.js, line 110 × Search results Close "},"HungryGames-Team.html":{"id":"HungryGames-Team.html","title":"Class: Team","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Team HungryGames~ Team new Team(id, name, players) Create a team for a game. Parameters: Name Type Description id string | number The id unique to a guild for this team. name string The name of this team. players Array.&lt;string&gt; Array of player ids on the team. Source: hg/Team.js, line 16 Members id :string The unique id unique to a guild for this team. Type: string Source: hg/Team.js, line 22 name :string The name of this team. Truncates to 100 characters. Type: string Source: hg/Team.js, line 28 numAlive :number The number of players on the team still alive. Type: number Default Value: players.length Source: hg/Team.js, line 48 players :Array.&lt;string&gt; Array of player ids on the team. Type: Array.&lt;string&gt; Source: hg/Team.js, line 34 rank :number The current team rank. Type: number Default Value: 1 Source: hg/Team.js, line 41 × Search results Close "},"HungryGames-UserIconUrl.html":{"id":"HungryGames-UserIconUrl.html","title":"Class: UserIconUrl","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: UserIconUrl HungryGames~ UserIconUrl new UserIconUrl(url, id [, settings] [, fetchSize]) Create a container for an icon to show. Parameters: Name Type Argument Description url string Url of icon. id string Id of the user the icon belongs to. settings Array.&lt;string&gt; &lt;optional&gt; Possible settings for the user related to how this icon should be displayed. fetchSize number &lt;optional&gt; Size of icon to fetch from Discord. Source: hg/UserIconUrl.js, line 18 Members &lt;static, constant&gt; fetchSize :number The default size of the icon to request from discord. Type: number Default Value: 128 Source: hg/UserIconUrl.js, line 57 fetchSize :number Size of the icon to request from Discord. Type: number Source: hg/UserIconUrl.js, line 25 id :string User ID. Type: string Source: hg/UserIconUrl.js, line 37 &lt;nullable&gt; settings :Array.&lt;string&gt; Optional user settings for displaying this icon. Type: Array.&lt;string&gt; Source: hg/UserIconUrl.js, line 43 url :string Icon URL. Type: string Source: hg/UserIconUrl.js, line 31 Methods &lt;static&gt; from(users) Get an array of icons urls from an array of users. Parameters: Name Type Description users Array.&lt;HungryGames~Player&gt; | HungryGames~Player Array of users to process, or single user. Output will always be an array. Source: hg/UserIconUrl.js, line 69 Returns: The user ids and urls for all users avatars. Type Array.&lt;HungryGames~UserIconUrl&gt; × Search results Close "},"HungryGames-WeaponEvent.html":{"id":"HungryGames-WeaponEvent.html","title":"Class: WeaponEvent","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: WeaponEvent HungryGames~ WeaponEvent new WeaponEvent(outcomes [, consumable]) Create a basic weapon. Parameters: Name Type Argument Description outcomes Array.&lt;HungryGames~Event&gt; All possible events in this weapon event. consumable string &lt;optional&gt; The formattable string for what to call this weapons consumable items. Source: hg/WeaponEvent.js, line 17 Members &lt;nullable&gt; consumable :string The formattable string for what to call this weapon's consumable items. Type: string Source: hg/WeaponEvent.js, line 29 outcomes :Array.&lt;HungryGames~Event&gt; All possible events for this weapon event. Type: Array.&lt;HungryGames~Event&gt; Source: hg/WeaponEvent.js, line 23 × Search results Close "},"Main.html":{"id":"Main.html","title":"Class: Main","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Main Main Basic commands and features for the bot. new Main() Source: main.js, line 82 Listens to Events: Discord~Client#event:guildCreate Discord~Client#event:guildDelete Discord~Client#event:guildBanAdd Discord~Client#event:message Command#event:addMe Command#event:invite Command#event:add Command#event:simplify Command#event:solve Command#event:eval Command#event:evaluate Command#event:graph Command#event:derive Command#event:timer Command#event:timers Command#event:remind Command#event:reminder Command#event:reminders Command#event:createDate Command#event:joinDate Command#event:server Command#event:serverInfo Command#event:pmMe Command#event:dmMe Command#event:pmSpikey Command#event:dmSpikey Command#event:thotPm Command#event:pmUser Command#event:flip Command#event:coin Command#event:flipcoin Command#event:coinflip Command#event:purge Command#event:prune Command#event:fuckYou Command#event:ban Command#event:smite Command#event:profile Command#event:avatar Command#event:ping Command#event:uptime Command#event:game Command#event:version Command#event:roll Command#event:dice Command#event:die Command#event:d Command#event:toggleMute Command#event:toggleBanMessages Command#event:toggleRigged Command#event:perms Command#event:stats Command#event:lookup Command#event:sendto Command#event:thanks Command#event:thx Command#event:thank Command#event:thankyou Command#event:listCommands Command#event:getPrefix Command#event:git Command#event:gettime Command#event:update Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; addmessage :string The message with instructions of how to add the bot to a server. Type: string Source: main.js, line 224 &lt;private, inner, constant&gt; adminHelpObject The object that stores all data to be formatted into the help message for admin commands. Source: main.js, line 267 &lt;private, inner, constant&gt; banMsgs :Array.&lt;string&gt; All of the possible messages to show when using the ban command. Type: Array.&lt;string&gt; Source: main.js, line 234 &lt;private, inner, constant&gt; blockedmessage :string The message sent to the channel where the user asked to be DM'd, but we were unable to deliver the DM. Type: string Source: main.js, line 215 &lt;private, inner&gt; commit :string The current commit hash at HEAD. Type: string Source: main.js, line 100 &lt;private, inner, constant&gt; disabledAutoSmite :Object.&lt;boolean&gt; All guilds that have disabled the auto-smite feature. Type: Object.&lt;boolean&gt; Source: main.js, line 139 &lt;private, inner, constant&gt; disabledBanMessage :Object.&lt;boolean&gt; All guilds that have disabled sending messages when someone is banned. Type: Object.&lt;boolean&gt; Source: main.js, line 147 &lt;private, inner, constant&gt; disabledRiggedCounter :Object.&lt;boolean&gt; The guilds that have disabled the rigged messages. Type: Object.&lt;boolean&gt; Source: main.js, line 155 &lt;private, inner, constant&gt; helpObject The object that stores all data to be formatted into the help message. Source: main.js, line 259 &lt;private, inner, constant&gt; introduction :string The introduction message the bots sends when pmme is used. Type: string Source: main.js, line 201 &lt;private, inner, constant&gt; mentionAccumulator :Object.&lt;Object.&lt;string&gt;&gt; The guilds with auto-smite enabled, and members who have mentioned Type: Object.&lt;Object.&lt;string&gt;&gt; Source: main.js, line 164 &lt;private, inner, constant&gt; oldestPing :number Oldest ping value to store. Type: number Default Value: 24 hours Source: main.js, line 192 &lt;private, inner&gt; pingHistory :Array.&lt;{time: number, delta: number}&gt; Previous ping values and their associated timestamps. Stores up to the previous oldestPing worth of pings since a reboot. Type: Array.&lt;{time: number, delta: number}&gt; Default Value: [] Source: main.js, line 174 &lt;private, inner&gt; timers :Array.&lt;Main~Timer&gt; Array of all timers currently set. Type: Array.&lt;Main~Timer&gt; Source: main.js, line 131 &lt;private, inner&gt; version :string The current bot version parsed from package.json. Type: string Source: main.js, line 93 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; checkSimilarity(s1, s2) Returns the percentage of how similar the two given strings are. Parameters: Name Type Description s1 string First string. s2 string Second string to compare. Source: main.js, line 1100 Returns: Number from 0 to 1 of how similar the two strings are. Type number &lt;private, inner&gt; commandAdd(msg) Parses message and adds given numbers. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1169 Listens to Events: Command#event:add &lt;private, inner&gt; commandAddMe(msg) Replies to message with URL for inviting the bot to a guild. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1157 Listens to Events: Command#event:addMe Command#event:invite &lt;private, inner&gt; commandAvatar(msg) Send a larger resolution version of the mentioned user's avatar. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2173 Listens to Events: Command#event:avatar &lt;private, inner&gt; commandBan(msg) Ban a mentioed user (or role from ID) and send a message saying they were banned. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1951 Listens to Events: Command#event:ban Command#event:fuckyou &lt;private, inner&gt; commandCreateDate(msg) Tell the user the date when they created their Discord account. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1580 Listens to Events: Command#event:createDate &lt;private, inner&gt; commandDerive(msg) Take the derivative of a given equation in terms of dy/dx. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1454 Listens to Events: Command#event:derive &lt;private, inner&gt; commandEvaluate(msg) Evaluate a string as an equation with units. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1306 Listens to Events: Command#event:eval Command#event:evaluate &lt;private, inner&gt; commandFlip(msg) Send an image of a coin, either Heads or Tails. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1854 Listens to Events: Command#event:flip &lt;private, inner&gt; commandGame(msg) Reply to message saying what game the mentioned user is playing and possibly other information about their profile. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2291 Listens to Events: Command#event:game &lt;private, inner&gt; commandGetPrefix(msg) User has requested to view the current prefix for their guild. This is intended to be fired internally, usually through chatbot.js due to no other way to reference this if the user has forgotten the prefix. Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: main.js, line 3187 Listens to Events: Command#event:getPrefix &lt;private, inner&gt; commandGetTime(msg) Reply with server time and GMT. Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: main.js, line 3240 Listens to Events: Command#event:gettime &lt;private, inner&gt; commandGit(msg) Get the graph of the last few git commits. Parameters: Name Type Description msg Discord~Message The message that triggered this command. Source: main.js, line 3202 Listens to Events: Command#event:git &lt;private, inner&gt; commandGraph(msg) Graph a given equation by plugging in values for X and creating an image based off values. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1330 Listens to Events: Command#event:graph &lt;private, inner&gt; commandJoinDate(msg) Tell the user the date when they joined the server the message was sent from. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1607 Listens to Events: Command#event:joinDate &lt;private, inner&gt; commandListCommands(msg) Fetch all registered commands and send them to the user. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 3171 Listens to Events: Command#event:listCommands &lt;private, inner&gt; commandLookup(msg) Lookup an ID and give information about what it represents. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2943 Listens to Events: Command#event:lookup &lt;private, inner&gt; commandPerms(msg) Send information about permissions for debugging. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2508 Listens to Events: Command#event:perms &lt;private, inner&gt; commandPing(msg) Reply to user with my ping to the Discord servers. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2194 Listens to Events: Command#event:ping &lt;private, inner&gt; commandPmMe(msg) Send the user a PM with a greeting introducing who the bot is. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1707 Listens to Events: Command#event:pmMe Command#event:dmMe &lt;private, inner&gt; commandPmSpikey(msg) Send a PM to SpikeyRobot with a message. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1730 Listens to Events: Command#event:pmSpikey Command#event:pmSpikey &lt;private, inner&gt; commandPmUser(msg) Send a PM to a specific user via a given id or name and descriminator. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1783 Listens to Events: Command#event:pmUser &lt;private, inner&gt; commandPurge(msg) Delete a given number of messages from a text channel. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1874 Listens to Events: Command#event:purge &lt;private, inner&gt; commandRollDie(msg) Roll a die with the given number of sides. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2379 Listens to Events: Command#event:roll Command#event:dice Command#event:die Command#event:d &lt;private, inner&gt; commandSendTo(msg) Lookup an ID and send a message to the given channel or user without telling the recipient who sent the message. Only looks up cached users and channels on the same shard. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 3055 Listens to Events: Command#event:sendto &lt;private, inner&gt; commandServerInfo(msg) Send information about the current server. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1655 Listens to Events: Command#event:server Command#event:serverInfo &lt;private, inner&gt; commandSimplify(msg) Simplifies equation given in message. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1220 Listens to Events: Command#event:simplify &lt;private, inner&gt; commandSmite(msg) Remove all roles from a user and give them a role that prevents them from doing anything. Checks if all parties involved have permission to do this without the bot's help. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2042 Listens to Events: Command#event:smite &lt;private, inner&gt; commandSolve(msg) Solve an equation. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1254 Listens to Events: Command#event:solve &lt;private, inner&gt; commandStats(msg) Send information about the bot. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2693 Listens to Events: Command#event:stats &lt;private, inner&gt; commandThankYou(msg) Reply saying \"you're welcome\" unless another user was mentioned, then thank them instead. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 3146 Listens to Events: Command#event:thanks Command#event:thank Command#event:thx Command#event:thankyou &lt;private, inner&gt; commandThotPm(msg) Send a PM to a mentioned user semi-anonymously. Messages are copied to SpikeyRobot to monitor for abuse. This command only works for 3 people. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1763 Listens to Events: Command#event:thotPm &lt;private, inner&gt; commandTimer(msg) Set a timer for a certain about of time. After which, the bot will DM the user the message they specified. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 1482 Listens to Events: Command#event:timer Command#event:timers Command#event:remind Command#event:reminder Command#event:reminders &lt;private, inner&gt; commandToggleBanMessages(msg) Toggles sending a message when a user is banned from a guild. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 894 Listens to Events: Command#event:toggleBanMessages &lt;private, inner&gt; commandToggleMute(msg) Toggles auto-muting a user for using @everyone too much. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 875 Listens to Events: Command#event:toggleMute &lt;private, inner&gt; commandToggleRiggedCounter(msg) Toggles sending a message when a user says 'rigged'. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 914 Listens to Events: Command#event:toggleRigged &lt;private, inner&gt; commandUpdate(msg) Trigger fetching the latest version of the bot from git, then tell all shards to reload the changes. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 3258 Listens to Events: Command#event:update &lt;private, inner&gt; commandUptime(msg) Reply to message with the amount of time since the bot has been running. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2273 Listens to Events: Command#event:uptime &lt;private, inner&gt; commandVersion(msg) Read the current version from package.json and show it to the user. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: main.js, line 2327 Listens to Events: Command#event:version &lt;private, inner&gt; editDistance(s1, s2) Calculates the edit distance between the two strings. Parameters: Name Type Description s1 string First string. s2 string Second string to compare to the first. Source: main.js, line 1122 Returns: Number of characters distance between the two strings. Type number &lt;private, inner&gt; fetchShardPerms(id [, id2]) Fetch the bitfield of permissions for our self or a given user id in the guild or channel with the given id. This: external:Discord~Client Parameters: Name Type Argument Description id string The channel or guild id or user id to lookup permissions for. id2 string &lt;optional&gt; The channel or guild id or user id to lookup permissions for. Source: main.js, line 2641 Returns: Null if unable to find, or an object with found data. Element`cId` is channel id, `gId` is guild id, `cY` is bitfield permissions for user in channel, `cM` is bitfield permissions for self in channel, `gY` is bitfield permissions for user in guild, `gM` is bitfield permissions for self in guild, `uId` is id of matched user. Type Object &lt;private, inner&gt; getAllStats(cb) Fetch the bot's stats from all shards, then combine the data. Public as SpikeyBot.getStats after SubModule.initialize. Parameters: Name Type Description cb function One parameter that is guarunteed to have an array of stats objeccts. Source: main.js, line 2757 &lt;private, inner&gt; getStats() Fetch our statistics about the bot on this shard. Source: main.js, line 2876 Returns: The statistics we collected. Type object &lt;private, inner&gt; lookupId(id [, trusted]) Lookup an ID for any data associated with it. This checks guilds, channels, and users. This: external:Discord~Client Parameters: Name Type Argument Default Description id string The ID to lookup. trusted boolean &lt;optional&gt; false Include possibly sensitive information in result. Source: main.js, line 2988 Returns: A Discord formatted string to send. Type string &lt;private, inner&gt; mkAndWrite(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Async. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: main.js, line 687 See: Main~mkAndWriteSync &lt;private, inner&gt; mkAndWriteSync(filename, dir, data) Write data to a file and make sure the directory exists or create it if it doesn't. Synchronous. Parameters: Name Type Description filename string The name of the file including the directory. dir string The directory path without the file's name. data string The data to write to the file. Source: main.js, line 714 See: Main~mkAndWrite &lt;private, inner&gt; onDebug(info) A general debug message was produced. Parameters: Name Type Description info string The information. Source: main.js, line 738 Listens to Events: Discord~Client#event:debug &lt;private, inner&gt; onError(err) An error occurred with our websocket connection to Discord. Parameters: Name Type Description err Discord~Error The websocket error object. Source: main.js, line 778 Listens to Events: Discord~Client#event:error &lt;private, inner&gt; onGuildBanAdd(guild, user) Handle user banned on a guild. Parameters: Name Type Description guild Discord~Guild The guild on which the ban happened. user Discord~User The user that was banned. Source: main.js, line 839 Listens to Events: Discord~Client#event:guildBanAdd &lt;private, inner&gt; onGuildCreate(guild) Handle being added to a guild. Parameters: Name Type Description guild Discord~Guild The guild that we just joined. Source: main.js, line 790 Listens to Events: Discord~Client#event:guildCreate &lt;private, inner&gt; onGuildDelete(guild) Handle being removed from a guild. Parameters: Name Type Description guild Discord~Guild The guild that we just left. Source: main.js, line 827 Listens to Events: Discord~Client#event:guildDelete &lt;private, inner&gt; onMessage(msg) Handle receiving a message for use on auto-muting users who spam @everyone. Parameters: Name Type Description msg Discord~Message The message that was sent. Source: main.js, line 930 Listens to Events: Discord~Client#event:message &lt;private, inner&gt; onWarn(info) A general warning was produced. Parameters: Name Type Description info string The information. Source: main.js, line 767 Listens to Events: Discord~Client#event:warn &lt;private, inner&gt; prePad(num, digits) Pad a number with leading zeroes so that it is `digits` long. Parameters: Name Type Description num string | number The number to pad with zeroes. digits number The minimum number of digits to make the output have. Source: main.js, line 2677 Returns: The padded string. Type string &lt;private, inner&gt; replyPerms(msg, gId, gM [, gY] [, cId] [, cM] [, cY] [, uId] [, embed]) Reply to the given message with the permission information of the given guild, channel, and user. Parameters: Name Type Argument Description msg external:Discord~Message Message to reply to. gId string Guild ID for displaying. gM number Bitfield for self in the guild. gY number &lt;optional&gt; Bitfield for user in guild. cId string &lt;optional&gt; Channel ID for displaying. cM number &lt;optional&gt; Bitfield for self in channel. cY number &lt;optional&gt; Bitfield for user in channel. uId string &lt;optional&gt; User id to show. embed external:Discord~MessageEmbed &lt;optional&gt; Embed object to modify instead of creating a new one. Source: main.js, line 2577 &lt;private, inner&gt; sendTo(id, message) Send a message to a certain channel id. This: external:Discord~ClientUser Parameters: Name Type Description id string The channel ID to send the message to. message string The message to send. Will have decodeURIComponent run on before processing. Source: main.js, line 3118 Returns: True if found channel, false otherwise. Type boolean &lt;private, inner&gt; setTimer(timer) Sets a timer for an amount of time with a message. Parameters: Name Type Description timer Main~Timer The settings for the timer. Source: main.js, line 2354 &lt;private, inner&gt; shardMessage(args) Received a message from the shard manager. Parameters: Name Type Argument Description args * &lt;repeatable&gt; Message received. Source: main.js, line 3361 &lt;private, inner&gt; sigint() Triggered via SIGINT, SIGHUP or SIGTERM. Saves data before exiting. Source: main.js, line 3336 Listens to Events: Process#event:SIGINT Process#event:SIGHUP Process#event:SIGTERM &lt;private, inner&gt; simplify(formula) Simplifies given formula. Parameters: Name Type Description formula string The formula to attempt to simplify. Source: main.js, line 1237 Returns: Simplified formula. Type string Type Definitions Timer An object storing information about a timer. Type: Object Properties: Name Type Description id string The id of the user who set the timer. message string The message for when the timer ends. time number The time since epoch at which the timer will end. Source: main.js, line 2339 × Search results Close "},"MainModule.html":{"id":"MainModule.html","title":"Class: MainModule","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: MainModule MainModule Base class for required modules for the bot to work. Adds interface for maintaining references across reloads. new MainModule() Source: mainModule.js, line 12 Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 Methods &lt;static&gt; extend(child) Extends MainModule as the base class of a child. Parameters: Name Type Description child object The child class to extend. Source: mainModule.js, line 59 begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;abstract&gt; export() Export data required to maintain the bot across reloading this module. Expected to be returned directly to this.import once reloaded. Source: mainModule.js, line 40 Returns: The data to be exported. Type MainModule~ModuleData &lt;abstract&gt; import(data) Imports data from a previous instance of this class in order to maintain references to other objects and classes across reloads. Parameters: Name Type Argument Description data MainModule~ModuleData &lt;nullable&gt; The data that was exported previously, or null if no data to import. Source: mainModule.js, line 30 &lt;abstract, protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;abstract, protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; terminate() Signal that the bot is shutting down and will not be restarting immediately. This is triggered on all shutdowns where all MainModules and SubModules will be unloaded. Source: mainModule.js, line 51 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 Type Definitions ModuleData The data exported and imported by this module intended to be used to persist across reloads. Type: Object.&lt;*&gt; Source: mainModule.js, line 13 × Search results Close "},"Messages.html":{"id":"Messages.html","title":"Class: Messages","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Messages Messages new Messages() Create the instance managing the filesystem. Source: hg/Messages.js, line 13 Members &lt;private, constant&gt; _messageFile :string The file path to read messages. Type: string Default Value: ./save/hgMessages.json Source: hg/Messages.js, line 22 &lt;private&gt; _messages :Object.&lt;Array.&lt;string&gt;&gt; All messages to show for games. Parsed from file. Type: Object.&lt;Array.&lt;string&gt;&gt; Default Value: {} Source: hg/Messages.js, line 31 Methods &lt;private&gt; _updateMessages() Parse all messages from file. Source: hg/Messages.js, line 51 get(type) Get a random message of a given type from hgMessages.json. Parameters: Name Type Description type string The message type to get. Source: hg/Messages.js, line 71 Returns: A random message of the given type. Type string shutdown() Stop watching for file changes. Source: hg/Messages.js, line 43 × Search results Close "},"Moderation.html":{"id":"Moderation.html","title":"Class: Moderation","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Moderation Moderation new Moderation() Instantiate Moderation SubModule. Source: moderation.js, line 14 Extends SubModule Members &lt;private, constant&gt; _banMsgs :Array.&lt;string&gt; All of the possible messages to show when using the ban command. Type: Array.&lt;string&gt; Source: moderation.js, line 48 &lt;private&gt; _disabledAutoSmite :Object.&lt;boolean&gt; All guilds that have disabled the auto-smite feature. Type: Object.&lt;boolean&gt; Source: moderation.js, line 24 &lt;private&gt; _disabledBanMessage :Object.&lt;boolean&gt; All guilds that have disabled sending messages when someone is banned. Type: Object.&lt;boolean&gt; Source: moderation.js, line 32 &lt;private&gt; _mentionAccumulator :Object.&lt;Object.&lt;string&gt;&gt; The guilds with auto-smite enabled, and members who have mentioned Type: Object.&lt;Object.&lt;string&gt;&gt; Source: moderation.js, line 40 &lt;private, constant&gt; _smitePerms :number Permissions required to to use the smite command. Bitfield. Type: number Source: moderation.js, line 80 bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Overrides: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Overrides: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Overrides: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Overrides: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Overrides: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Overrides: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Overrides: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Overrides: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Overrides: SubModule#postPrefix Source: subModule.js, line 27 Methods &lt;private&gt; _commandKick(msg) Kick a mentioed user (or role from ID) and send a message saying they were banned. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: moderation.js, line 391 Listens to Events: Command#event:kick &lt;private&gt; _onGuildMemberAdd(member) Handle someone joining the guild. Parameters: Name Type Description member external:Discord~GuildMember The member that joined. Source: moderation.js, line 263 &lt;private&gt; _onGuildMemberRemove(member) Handle a guild member leaving the guild. Parameters: Name Type Description member external:Discord~GuildMember The member that left or was kicked. Source: moderation.js, line 253 &lt;private&gt; _onMessageDelete(msg) Handle logging when a message is deleted. Parameters: Name Type Description msg external:Discord~Message The deleted message. Source: moderation.js, line 205 &lt;private&gt; _onMessageDeleteBulk(msgs) Handle logging when multiple messages are deleted. Parameters: Name Type Description msgs external:Discord~Collection.&lt;external:Discord~Message&gt; The deleted messages. Source: moderation.js, line 226 begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Overrides: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Overrides: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Overrides: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Overrides: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Overrides: SubModule#log Source: subModule.js, line 194 muteMember(member, cb) Give a guild member a muted role that prevents them from talking in any channel in the guild. Parameters: Name Type Description member external:Discord~GuildMember The member of the guild to mute. cb function Callback function with a single argument which is a string if there was an error, or null if success. Source: moderation.js, line 306 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Overrides: SubModule#warn Source: subModule.js, line 212 × Search results Close "},"ModLog.html":{"id":"ModLog.html","title":"Class: ModLog","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: ModLog ModLog new ModLog() Creates subModule. Source: modLog.js, line 15 Listens to Events: Command#event:setLogChannel Command#event:logChannel Classes Settings Members &lt;private&gt; _settings :Object.&lt;ModLog~Settings&gt; Guild settings for raids mapped by their guild id. Type: Object.&lt;ModLog~Settings&gt; Default Value: {} Source: modLog.js, line 26 myName Source: modLog.js, line 18 Methods &lt;private&gt; _actionColor(action) Fetch the color for the given action. Parameters: Name Type Description action string The action to lookup. Source: modLog.js, line 163 Returns: The color for the given action. Type external:Discord~ColorResolvable &lt;private&gt; _actionString(action) Fetch the human readable action string. Parameters: Name Type Description action string The action to find the human readable format of. Source: modLog.js, line 128 Returns: Human readable string. Type string &lt;private&gt; _commandSetLogChannel(msg) Command to set the output logging channel. Changes to the channel the command was run in, or toggles if ran in the same channel. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: modLog.js, line 88 Listens to Events: Command#event:setLogChannel Command#event:logChannel getSettings(gId) Obtain reference to settings object for a guild. Parameters: Name Type Description gId string The ID of the guild to fetch the settings for. Source: modLog.js, line 117 Returns: Settings object, creates one with default settings first if it doesn't exist. Type ModLog~Settings initialize() Source: modLog.js, line 33 output(guild, action [, user] [, owner] [, message] [, message2]) Log a message in a guild. Parameters: Name Type Argument Default Description guild external:Discord~Guild The guild the action took place in. action string The action that was performed. user external:Discord~User &lt;optional&gt; &lt;nullable&gt; null User that was affected, or null of no user was affected. owner external:Discord~User &lt;optional&gt; &lt;nullable&gt; null User that performed the action. Null is for ourself. message string &lt;optional&gt; null Additional information to attach to the log message. message2 string &lt;optional&gt; null Additional information to attach to the log message. Source: modLog.js, line 206 save() Source: modLog.js, line 64 setLogChannel(gId, cId) Set the log channel for a guild. Parameters: Name Type Argument Description gId string ID of the guild to change the setting for. cId string &lt;nullable&gt; The ID of the channel to set as the output channel. Source: modLog.js, line 105 shutdown() Source: modLog.js, line 60 × Search results Close "},"ModLog-Settings.html":{"id":"ModLog-Settings.html","title":"Class: Settings","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Settings ModLog~ Settings new Settings() Create default settings. Source: modLog.js, line 244 Members &lt;nullable&gt; channel :string The channel ID of where to send log messages. Type: string Source: modLog.js, line 251 logBans :boolean Should the bot log when users are banned? Type: boolean Source: modLog.js, line 265 logKicks :boolean Should the bot log when users are kicked? Type: boolean Source: modLog.js, line 258 logMentionAbuse :boolean Should the bot log when users abuse mentions? Type: boolean Source: modLog.js, line 279 logMessageDelete :boolean Should the bot log when a message is deleted? Type: boolean Source: modLog.js, line 293 logMessagePurge :boolean Should the bot log when messages are purged? Type: boolean Source: modLog.js, line 286 logMutes :boolean Should the bot log when users are muted? Type: boolean Source: modLog.js, line 272 logOther :boolean Log other actions that have not been classified. Type: boolean Source: modLog.js, line 307 logRaidLockdown :boolean Should the bot log when a lockdown is started? Type: boolean Source: modLog.js, line 300 Methods &lt;static&gt; from(obj) Create a Settings object from a Settings-like object. Similar to copy-constructor. Parameters: Name Type Description obj object Object to create a Settings object from. Source: modLog.js, line 353 Returns: The created object. Type ModLog~Settings check(action) Check if the given action should be logged. Ignores if channel is set. Parameters: Name Type Description action string The action to check if should log. Source: modLog.js, line 317 Returns: True if should log. Type boolean × Search results Close "},"module-lib_twemojiChecker.html":{"id":"module-lib_twemojiChecker.html","title":"Module: lib/twemojiChecker","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Module: lib/twemojiChecker Source: lib/twemojiChcker.js, line 1 Members &lt;private, inner, constant&gt; re :RegExp RegExp based on emoji's official Unicode standards http://www.unicode.org/Public/UNIDATA/EmojiSources.txt https://github.com/twitter/twemoji/blob/27fe654b2bed5331cf1730bb4fbba1efa40af626/2/twemoji.js#L228 Type: RegExp Source: lib/twemojiChcker.js, line 10 Methods &lt;inner&gt; match(input) Check a string for any emoji matches. Parameters: Name Type Description input string The string to run the regex against. Source: lib/twemojiChcker.js, line 20 Returns: The matched return value. Type null | Array.&lt;string&gt; × Search results Close "},"Music.html":{"id":"Music.html","title":"Class: Music","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Music Music Music and audio related commands. new Music() Source: music.js, line 38 Fires: Command#event:stop Listens to Events: Discord~Client#event:voiceStateUpdate Command#event:play Command#event:pause Command#event:resume Command#event:leave Command#event:stop Command#event:stfu Command#event:skip Command#event:q Command#event:queue Command#event:playing Command#event:remove Command#event:dequeue Command#event:lyrics Command#event:record Command#event:follow Command#event:unfollow Command#event:stalk Command#event:unstalk Command#event:musicstats Command#event:volume Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; broadcasts :Object.&lt;Music~Broadcast&gt; All current audio broadcasts to voice channels. Stores all relavent data. Stored by guild id. Type: Object.&lt;Music~Broadcast&gt; Source: music.js, line 97 &lt;private, inner, constant&gt; follows :Object.&lt;string&gt; The current user IDs of the users to follow into new voice channels. This is mapped by guild id. Type: Object.&lt;string&gt; Source: music.js, line 106 &lt;private, inner, constant&gt; geniusClient :string The Genuius client token we use to fetch information from their api Type: string Source: music.js, line 48 &lt;private, inner, constant&gt; geniusRequest :Object The request headers to send to genius. Type: Object Default Value: {\"hostname\":\"api.genius.com\",\"path\":\"/search/\",\"headers\":\"\",\"method\":\"GET\"} Source: music.js, line 58 &lt;private, inner, constant&gt; helpObject The object that stores all data to be formatted into the help message. Source: music.js, line 197 &lt;private, inner, constant&gt; primaryStreamOptions :Discord~StreamOptions Options to pass into the primary stream dispatcher (The one in charge of volume control). [StreamOptions]( https://discord.js.org/#/docs/main/master/typedef/StreamOptions) Type: Discord~StreamOptions Default Value: {\"passes\":1,\"fec\":true,\"bitrate\":\"auto\",\"volume\":0.5,\"plp\":0,\"highWaterMark\":5} Source: music.js, line 160 &lt;private, inner, constant&gt; secondaryStreamOptions :Discord~StreamOptions Options to pass into the secondary stream dispatcher (The one buffering for Discord). [StreamOptions]( https://discord.js.org/#/docs/main/master/typedef/StreamOptions) Type: Discord~StreamOptions Default Value: {\"passes\":1,\"fec\":true,\"bitrate\":\"auto\",\"volume\":0.5,\"plp\":0.05,\"highWaterMark\":1000} Source: music.js, line 179 &lt;private, inner, constant&gt; special :Object.&lt;Object.&lt;{cmd: string, url: ?string, file: string}&gt;&gt; Special cases of requests to handle seperately. Type: Object.&lt;Object.&lt;{cmd: string, url: ?string, file: string}&gt;&gt; Source: music.js, line 115 &lt;private, inner, constant&gt; ytdlOpts :Array.&lt;string&gt; Options passed to youtube-dl for fetching videos. Type: Array.&lt;string&gt; Default Value: [\"-f\",\"bestaudio/worst\",\"--no-playlist\",\"--default-search=auto\"] Source: music.js, line 146 Methods &lt;static&gt; streamToOgg(input, file) Coverts an incoming Opus stream to a ogg format and writes it to file. Parameters: Name Type Description input ReadableStream The opus stream from Discord. file WritableStream The file stream we are writing to. Source: music.js, line 1828 begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 clearQueue(msg) Empty a guild's current music queue. Parameters: Name Type Description msg Discord~Message The context for looking up the guild queue to modify. Source: music.js, line 1280 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 getDuration(msg) Get the song's length of the song playing in the given context. Parameters: Name Type Description msg Discord~Message The context to use to fetch the info. Source: music.js, line 530 Returns: Time in seconds, or null if nothing is playing. Type number getProgress(msg) Get the current progress into the song in the given context. Parameters: Name Type Description msg Discord~Message The context to use to fetch the info. Source: music.js, line 511 Returns: Time in seconds, or null if nothing is playing. Type number &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 isSubjugated(msg) Check if music is being subjugated by another script. Parameters: Name Type Description msg Discord~Message The context to lookup the information. Source: music.js, line 1139 Returns: Null if nothing is playing, true if subjugated, false if not subjugated. Type boolean &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 pause(msg) Attempt to pause the current broadcast in a guild. Parameters: Name Type Description msg Discord~Message The context to lookup guild info. Source: music.js, line 918 Returns: True if success, false if failed. Type boolean playSong(msg, song [, seek] [, subjugate]) Start playing or enqueue the requested song. Parameters: Name Type Argument Description msg Discord~Message The message that triggered command, used for context. song string The song search criteria. seek number &lt;optional&gt; The time in seconds to seek to. subjugate boolean &lt;optional&gt; &lt;nullable&gt; Force all control be via external sources using public function calls. All queue control commands are disabled. Also suppresses most information messages that would otherwise be sent to the user. Null means leave as current value. Source: music.js, line 1043 release(msg) Release subjugation. Does not modify any current queue or playing information. Parameters: Name Type Description msg Discord~Message The context to lookup the information. Source: music.js, line 1112 resume(msg) Attempt to resume the current broadcast in a guild. Parameters: Name Type Description msg Discord~Message The context to lookup guild info. Source: music.js, line 974 Returns: True if success, false if failed. Type boolean save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 skipSong(msg) Skip the current song with the given context. Parameters: Name Type Description msg Discord~Message The context storing guild information for looking up. Source: music.js, line 863 subjugate(msg) Begin subjugation. Does not modify any current queue or playing information. Parameters: Name Type Description msg Discord~Message The context to lookup the information. Source: music.js, line 1125 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; changeVolume(broadcast, percentage) Change the volume of the current broadcast. Parameters: Name Type Description broadcast Music~Broadcast The objected storing the current broadcast information. percentage number The volume percentage to set to. 0.5 is half, 2 is double. Source: music.js, line 1790 Returns: True if success, false if something went wrong. Type boolean &lt;private, inner&gt; commandClearQueue(msg) Removes all songs from the current queue except for the currently playing song. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1258 Listens to Events: Command#event:clear Command#event:empty &lt;private, inner&gt; commandFollow(msg) Follow a user as they change voice channels. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 1597 Listens to Events: Command#event:join &lt;private, inner&gt; commandJoin(msg) Join a voice channel that the user is in. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 876 Listens to Events: Command#event:join &lt;private, inner&gt; commandLeave(msg) Cause the bot to leave the voice channel and stop playing music. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1157 Listens to Events: Command#event:leave Command#event:stop Command#event:stfu &lt;private, inner&gt; commandLyrics(msg) Search for a song's lyrics via Genius. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1333 Listens to Events: Command#event:lyrics &lt;private, inner&gt; commandPause(msg) Pause the currently playing music broadcast. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 894 Listens to Events: Command#event:pause &lt;private, inner&gt; commandPlay(msg) Search for a song to play based off user request. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 1010 Listens to Events: Command#event:play &lt;private, inner&gt; commandQueue(msg) Show the user what is in the queue. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1199 Listens to Events: Command#event:q Command#event:queue Command#event:playing &lt;private, inner&gt; commandRecord(msg) Join a voice channel and record the specified users audio to a file on this server. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1523 Listens to Events: Command#event:record &lt;private, inner&gt; commandRemove(msg) Remove a song from the queue. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1293 Listens to Events: Command#event:remove Command#event:dequeue &lt;private, inner&gt; commandResume(msg) Resume the currently paused music broadcast. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 949 Listens to Events: Command#event:resume &lt;private, inner&gt; commandSkip(msg) Skip the currently playing song and continue to the next in the queue. Parameters: Name Type Description msg Discord~Message The message that triggered the command. Source: music.js, line 1178 Listens to Events: Command#event:skip &lt;private, inner&gt; commandStats(msg) Show statistics about current music broadcasts. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 1698 Listens to Events: Command#event:musicstats &lt;private, inner&gt; commandVolume(msg) Change the volume of the current music stream. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: music.js, line 1752 Listens to Events: Command#event:volume Command#event:vol Command#event:v &lt;private, inner&gt; endSong(broadcast) Triggered when a song has finished playing. Parameters: Name Type Description broadcast Music~Broadcast The object storing all relevant information. Source: music.js, line 840 &lt;private, inner&gt; enqueueSong(broadcast, song, msg [, info] [, seek]) Add a song to the given broadcast's queue and start playing it not already. Parameters: Name Type Argument Default Description broadcast Music~Broadcast The broadcast storage container. song string The song that was requested. msg Discord~Message The message that requested the song. info object &lt;optional&gt; The info from ytdl about the song. seek number &lt;optional&gt; 0 The number of seconds into a song to start playing. Source: music.js, line 576 Fires: Command#event:stop &lt;private, inner&gt; fetchLyricsPage(msg, url, title, thumb) Request the webpage that has the song lyrics on them from Genius. Parameters: Name Type Description msg Discord~Message The message that triggered the command. url string The url of the page to request. title string The song title for showing the user later. thumb string The url of the album art thumbnail to show the user later. Source: music.js, line 1428 &lt;private, inner&gt; formatDateTime(date) Formats a given date into a datestring. Parameters: Name Type Description date Date | number | string The date that Date() can accept. Source: music.js, line 1668 Returns: The formatted datetime. Type string &lt;private, inner&gt; formatPlaytime(seconds) Format the given number of seconds into the playtime format. Parameters: Name Type Description seconds number The duration in seconds. Source: music.js, line 545 Returns: The formatted string in minutes and seconds. Type string &lt;private, inner&gt; formatSongInfo(info [, dispatcher] [, seek]) Format the info response from ytdl into a human readable format. Parameters: Name Type Argument Default Description info object The info received from ytdl about the song. dispatcher Discord~StreamDispatcher &lt;optional&gt; The broadcast dispatcher that is currently broadcasting audio. If defined, this will be used to determine remaining play time. seek number &lt;optional&gt; 0 The offset to add to totalStreamTime to correct for starting playback somewhere other than the beginning. Source: music.js, line 462 Returns: The formatted song info. Type Discord~MessageEmbed &lt;private, inner&gt; formNum(num) Add commas between digits on large numbers. Parameters: Name Type Description num number | string The number to format. Source: music.js, line 555 Returns: The formatted number. Type string &lt;private, inner&gt; getRemainingSeconds(info, dispatcher) Get the remaining playtime in the given song info and broadcast. Parameters: Name Type Description info object The song info received from ytdl. dispatcher Discord~StreamDispatcher The dispatcher playing the song currently. Source: music.js, line 498 Returns: Number of seconds remaining in the song playtime. Type number &lt;private, inner&gt; getVolume(broadcast) Get the volume of the current broadcast. Parameters: Name Type Description broadcast Music~Broadcast The objected storing the current broadcast information. Source: music.js, line 1814 Returns: The logarithmic volume percentage. 0.5 is half, 2 is double. Null if error. Type number &lt;private, inner&gt; handleVoiceStateUpdate(oldState, newState) Leave a voice channel if all other users have left. Should also cause music and recordings to stop. Parameters: Name Type Description oldState Discord~VoiceState State before status update. newState Discord~VoiceState State after status update. Source: music.js, line 387 Listens to Events: Discord~Client#event:voiceStateUpdate &lt;private, inner&gt; makeBroadcast(broadcast) Create a voice channel broadcast based off of the media source, and start playing the audio. Parameters: Name Type Description broadcast Music~Broadcast The object storing all relevant information. Source: music.js, line 713 &lt;private, inner&gt; mention(msg) Creates formatted string for mentioning the author of msg. Parameters: Name Type Description msg Discord~Message Message to format a mention for the author of. Source: music.js, line 360 Returns: Formatted mention string. Type string &lt;private, inner&gt; monthToShort(month) Convert the month number to a 3 letter string of the month's name. Parameters: Name Type Description month number The month number (1-12). Source: music.js, line 1683 Returns: The 3 character string. Type string &lt;private, inner&gt; pauseBroadcast(broadcast) Cause the given broadcast to be paused. Parameters: Name Type Description broadcast Music~Broadcast The object storing all relevant information. Source: music.js, line 931 Returns: If the music was actully paused. False if the music is already paused or nothing is playing. Type boolean &lt;private, inner&gt; reply(msg, text, post) Replies to the author and channel of msg with the given message. Parameters: Name Type Description msg Discord~Message Message to reply to. text string The main body of the message. post string The footer of the message. Deprecated: Use Common.reply instead. Source: music.js, line 374 Returns: Promise of Discord~Message that we attempted to send. Type Promise &lt;private, inner&gt; reqLyricsURL(msg, id) Request the song information from Genius from previous search to find the page where the lyrics are. Parameters: Name Type Description msg Discord~Message The message that triggered the command. id string The id of the first song in the search results. Source: music.js, line 1385 &lt;private, inner&gt; resumeBroadcast(broadcast) Cause the given broadcast to be resumed. Parameters: Name Type Description broadcast Music~Broadcast The object storing all relevant information. Source: music.js, line 987 Returns: If the music was actully resumed. False if the music is already playing or nothing is playing or the bot is alone in a channel. Type boolean &lt;private, inner&gt; skipSong(broadcast) Skip the current song, then attempt to play the next. Parameters: Name Type Description broadcast Music~Broadcast The object storing all relevant information. Source: music.js, line 851 &lt;private, inner&gt; startPlaying(broadcast) Start playing the first item in the queue of the broadcast. Parameters: Name Type Description broadcast Music~Broadcast The container storing all information about the song. Source: music.js, line 611 &lt;private, inner&gt; startStream(input, done, progress) Starts the streams as a thread and reports done with the streams. Parameters: Name Type Description input object Input vars. done function Done callback. progress function Progress callback. Source: music.js, line 809 &lt;private, inner&gt; stripLyrics(msg, content, title, url, thumb) Crawl the received webpage for the data we need, then format the data and show it to the user. Parameters: Name Type Description msg Discord~Message The message that triggered the command. content string The entire page received. title string The song title for showing the user. url string The url of where we fetched the lyrics to show the user. thumb string The url of the album art thumbnail to show the user later. Source: music.js, line 1471 Type Definitions Broadcast Information about a server's music and queue. Type: Object Properties: Name Type Argument Description queue Array.&lt;string&gt; Requests that have been queued. skips Object.&lt;boolean&gt; Stores user id's and whether they have voted to skip. Non-existent user means they have not voted to skip. isPlaying boolean Is audio currntly being streamed to the channel. broadcast Discord~VoiceBroadcast &lt;nullable&gt; The Discord voice broadcast actually playing the audio. voice Discord~VoiceConnection &lt;nullable&gt; The current voice connection audio is being streamed to. dispatcher Discord~StreamDispatcher &lt;nullable&gt; The Discord dispatcher for the current audio channel. current Object &lt;nullable&gt; The current broadcast information including thread, readable stream, and song information. Source: music.js, line 70 × Search results Close "},"NPC.html":{"id":"NPC.html","title":"Class: NPC","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: NPC NPC new NPC(username, avatarURL [, id]) Create a non-player character. Parameters: Name Type Argument Description username string The username to show for this npc. avatarURL string The url (or fake url) of the image to use as the player's avatar. id string &lt;optional&gt; Id to assign, if a valid id is not provided, a random id will be generated. Source: hungryGames.js, line 882 Extends HungryGames~Player Members avatarURL :string The URL to the discord avatar of the User. Type: string Inherited From: HungryGames~Player#avatarURL Overrides: HungryGames~Player#avatarURL Default Value: '' Source: hg/Player.js, line 44 bleeding :number How many days has the player been wounded. Type: number Inherited From: HungryGames~Player#bleeding Overrides: HungryGames~Player#bleeding Source: hg/Player.js, line 65 dayOfDeath :number The day at which the player last died in the game. Only a valid number if the player is currently dead. Otherwise a garbage value will be available. Type: number Inherited From: HungryGames~Player#dayOfDeath Overrides: HungryGames~Player#dayOfDeath Source: hg/Player.js, line 109 id :string The id of the User this Player represents. Type: string Inherited From: HungryGames~Player#id Overrides: HungryGames~Player#id Source: hg/Player.js, line 31 &lt;constant&gt; isNPC :boolean Always true. Type: boolean Default Value: true Source: hungryGames.js, line 894 kills :number The number of players this player has caused to die. Type: number Inherited From: HungryGames~Player#kills Overrides: HungryGames~Player#kills Source: hg/Player.js, line 86 living :boolean Is the player still alive. Type: boolean Inherited From: HungryGames~Player#living Overrides: HungryGames~Player#living Default Value: true Source: hg/Player.js, line 58 name :string The name of this Player. Type: string Inherited From: HungryGames~Player#name Overrides: HungryGames~Player#name Source: hg/Player.js, line 37 nickname :string The nickname for this user usually assigned by the guild. If the user does not have a nickname, this will have the same value as `name`. Type: string Inherited From: HungryGames~Player#nickname Overrides: HungryGames~Player#nickname Source: hg/Player.js, line 51 rank :number The current rank of the player in the game. Type: number Inherited From: HungryGames~Player#rank Overrides: HungryGames~Player#rank Default Value: 1 Source: hg/Player.js, line 72 settings :Object Custom settings for this user associated with the games. Type: Object Inherited From: HungryGames~Player#settings Overrides: HungryGames~Player#settings Default Value: {} Source: hg/Player.js, line 100 state :string The current player state (normal, wounded, dead, zombie). Type: string Inherited From: HungryGames~Player#state Overrides: HungryGames~Player#state Default Value: normal Source: hg/Player.js, line 79 username :string Equivalent to `this.name` for compatibility. Type: string Source: hungryGames.js, line 900 weapons :Object.&lt;number&gt; The weapons the player currently has and how many of each. Type: Object.&lt;number&gt; Inherited From: HungryGames~Player#weapons Overrides: HungryGames~Player#weapons Default Value: {} Source: hg/Player.js, line 93 × Search results Close "},"Patreon.html":{"id":"Patreon.html","title":"Class: Patreon","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Patreon Patreon Modifies the SpikeyBot object with an interface for checking the Patreon status of users. new Patreon() Source: patreon.js, line 13 Listens to Events: Command#event:patreon Extends SubModule Classes toExport Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; patreonSettingsFilename :string The filename in the user's directory of the file where the settings related to Patreon rewards are stored. Type: string Default Value: /patreonSettings.json Source: patreon.js, line 30 &lt;private, inner&gt; patreonSettingsTemplate :Object.&lt;Object&gt; The parsed data from Patreon~patreonSettingsTemplateFile. Data that outlines the available options that can be changed, and their possible values. Type: Object.&lt;Object&gt; Default Value: {} Source: patreon.js, line 71 &lt;private, inner, constant&gt; patreonSettingsTemplateFile :string File where the template for the Patreon settings is stored. Type: string Default Value: ./save/patreonSettingTemplate.json Source: patreon.js, line 61 See: Patreon~patreonSettingsTemplate WebAccount~patreonSettingsTemplate &lt;private, inner, constant&gt; patreonTierPermFile :string Path to the file storing information about each patron tier rewards. Type: string Default Value: ./save/patreonTiers.json Source: patreon.js, line 40 &lt;private, inner&gt; patreonTiers :Array.&lt;{0: number, 1: Array.&lt;string&gt;}&gt; The parsed data from file about patron tier rewards. Type: Array.&lt;{0: number, 1: Array.&lt;string&gt;}&gt; Default Value: {} Source: patreon.js, line 49 See: Patreon~patreonTierPermFile Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandPatreon(msg) Shows the user's Patreon information to the user. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: patreon.js, line 162 Listens to Events: Command#event:patreon &lt;private, inner&gt; fetchPatreonRow(uId, cb) Get the Patreon information for a given Discord user. Parameters: Name Type Description uId string | number The Discord user ID to check. cb Patreon~basicCB Callback with parameters for error and success values. Properties Name Type Argument Description data.status object &lt;nullable&gt; A single row if it was found. Source: patreon.js, line 553 &lt;private, inner&gt; updatePatreonSettingsTemplate() Parse template from file. Source: patreon.js, line 112 See: Patreon~patreonSettingsTemplate &lt;private, inner&gt; updateTierPerms() Parse tiers from file. Source: patreon.js, line 80 See: Patreon~patreonTierPermFile Type Definitions basicCB(err, data) Basic callback function that has two parameters. One with error information, and the other with data if there was no error. Parameters: Name Type Argument Description err string &lt;nullable&gt; The error string, or null if no error. data Object &lt;nullable&gt; The returned data if there was no error. Source: patreon.js, line 240 × Search results Close "},"Patreon-toExport.html":{"id":"Patreon-toExport.html","title":"Class: toExport","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: toExport Patreon~ toExport The object to put into the SpikeyBot object. This contains all of the public data available through that interface. Data will be available after Patreon.initialize has been called, at `SpikeyBot.patreon`. new toExport() Source: patreon.js, line 256 Methods &lt;static&gt; checkAllPerms(uId, cId, gId, perm, cb) Check that a user or channel or guild has permission for something. Checks overrides for each, and if the user does not have an override, the request is forwarded to toExport.checkPerm. Parameters: Name Type Argument Description uId string | number The Discord user ID to check. cId string | number The Discord channel ID to check. gId string | number The Discord guild ID to check. perm string &lt;nullable&gt; The permission string to check against. Null to check for overrides only. cb Patreon~basicCB Callback with parameters for error and success values. Properties Name Type Description data.status boolean If the given IDs have permission. Source: patreon.js, line 274 &lt;static&gt; checkPerm(uId, perm, cb) Check that a user has a specific permission. Permissions are defined in Patreon~patreonTierPermFile. This does not check overrides. Parameters: Name Type Description uId string | number The Discord user ID to check. perm string The permission string to check against. cb Patreon~basicCB Callback with parameters for error and success values. Properties Name Type Description data.status boolean If the user has permission. Source: patreon.js, line 382 &lt;static&gt; getAllPerms(uId, cId, gId, cb) Fetch all permissions for a given user, channel, or guild. Parameters: Name Type Description uId string | number The ID of the Discord user. cId string | number The Discord channel ID. gId string | number The Discord guild ID. cb Patreon~basicCB Callback once operation is complete. Source: patreon.js, line 309 &lt;static&gt; getLevelPerms(pledgeAmount, exclusive, cb) Responds with all permissions available at the given pledge amount. Parameters: Name Type Description pledgeAmount number The amount in cents that the user has pledged. exclusive boolean Only get the rewards received at the exact pledge amount. Does not show all tier rewards below the pledge amount. cb Patreon~basicCB Callback with parameters for error and success values. Properties Name Type Description data.status Array.&lt;string&gt; All of the permission strings. Source: patreon.js, line 434 &lt;static&gt; getSettingValue(uId, cId, gId, permString, cb) Responds with the settings value for a user if they have permission for the setting, otherwise replies with the default value. Parameters: Name Type Description uId number | string The user id to check, or null to get the default value. cId number | string The Discord channel id to check, or null to get the default value. gId number | string The Discord guild id to check, or null to get the default value. permString string The permission to check with subvalues separated by spaces. cb Patreon~basicCB Callback with parameters for error and success values. Properties Name Type Description data.status * The setting's value. Source: patreon.js, line 463 × Search results Close "},"Polling.html":{"id":"Polling.html","title":"Class: Polling","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Polling Polling Controlls poll and vote commands. new Polling() Source: poll.js, line 18 Listens to Events: Command#event:poll Command#event:vote Command#event:endpoll Command#event:endvote Extends SubModule Classes Poll Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; currentPolls :Object.&lt;Polling~Poll&gt; Stores the currently cached data about all active polls. Organized by message id that is collecting the poll data. Type: Object.&lt;Polling~Poll&gt; Source: poll.js, line 217 &lt;private, inner, constant&gt; defaultEmojis The default reaction emojis to use for a poll. Default Value: [\"👍\",\"👎\",\"🤷\"] Source: poll.js, line 208 &lt;private, inner, constant&gt; guildSubDir The subdirectory in the guild to store all member polls. Default Value: /polls/ Source: poll.js, line 192 &lt;private, inner, constant&gt; saveFilename The filename in the member's subdirectory, in the guild's subdirectory, to save a poll's state. Default Value: /save.json Source: poll.js, line 200 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; addListenersToPoll(poll, key) Add timeout and possibly other listeners to a poll. Parameters: Name Type Description poll Polling~Poll The poll to register. key string The Polling~currentPolls key to remove the poll from once the poll has ended. Source: poll.js, line 405 &lt;private, inner&gt; addNextReaction(poll [, index]) Create a callback for adding all reactions to a message. Parameters: Name Type Argument Default Description poll Polling~Poll The poll object for adding reactions. index number &lt;optional&gt; 0 The index of the emoji to add first. Source: poll.js, line 429 Returns: The callback to run on Promise completion. Type function &lt;private, inner&gt; commandEndPoll(msg) Ends a poll. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: poll.js, line 446 Listens to Events: Command#event:endpoll Command#event:endvote &lt;private, inner&gt; commandPoll(msg) Starts a poll. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: poll.js, line 294 Listens to Events: Command#event:poll Command#event:vote &lt;private, inner&gt; endPoll(poll) End a poll. Does not remove it from Polling~currentPolls. Parameters: Name Type Description poll Polling~Poll The poll to end. Source: poll.js, line 471 Returns: Was the poll successfully ended. Type boolean &lt;private, inner&gt; mkdirAndWrite(dir, filename, data) Asyncronously create a directory and write a file in the directory. Parameters: Name Type Description dir string The file path to create and write the file to. filename string The file name of the file without the path. data string The data to write to the tile. Source: poll.js, line 145 &lt;private, inner&gt; mkdirAndWriteSync(dir, filename, data) Syncronously create a directory and write a file in the directory. Parameters: Name Type Description dir string The file path to create and write the file to. filename string The file name of the file without the path. data string The data to write to the tile. Source: poll.js, line 169 &lt;private, inner&gt; parsePollString(string) Parse the saved poll data that has been read from file in JSON format. Parameters: Name Type Description string string The file data. Source: poll.js, line 107 × Search results Close "},"Polling-Poll.html":{"id":"Polling-Poll.html","title":"Class: Poll","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Poll Polling~ Poll Stores data related to a single poll. &lt;private&gt; new Poll(author, message, options) Parameters: Name Type Description author string ID of the user who started this poll. message Discord~Message The message to watch for the results. options Polling~PollOptions The settings for this current poll. Properties: Name Type Argument Description author string ID of the user who started this poll. message Discord~Message Reference to the Message object with the reaction listener. title string The user defined text associated with this poll. endTime number &lt;nullable&gt; The timestamp at which this poll is scheduled to end. emojis Array.&lt;string&gt; The emojis to add as reactions to use as buttons. choices Array.&lt;string&gt; The full string that came with the emoji if the user specified custom response options. timeout Array.&lt;string&gt; The scheduled timeout when this poll will end. Source: poll.js, line 239 Members author :string ID of the user who started this poll. Type: string Source: poll.js, line 245 choices :Array.&lt;string&gt; The full string that came with the emoji if the user specified custom response options. Type: Array.&lt;string&gt; Source: poll.js, line 276 emojis :Array.&lt;string&gt; The emojis to add as reactions to use as buttons. Type: Array.&lt;string&gt; Source: poll.js, line 269 &lt;nullable&gt; endTime :number The timestamp at which this poll is scheduled to end. Type: number Source: poll.js, line 263 message :Discord~Message Reference to the Message object with the reaction listener. Type: Discord~Message Source: poll.js, line 251 &lt;nullable&gt; timeout :Timeout The scheduled timeout when this poll will end. Type: Timeout Source: poll.js, line 282 title :string The user defined text associated with this poll. Type: string Source: poll.js, line 257 × Search results Close "},"RaidBlock.html":{"id":"RaidBlock.html","title":"Class: RaidBlock","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: RaidBlock RaidBlock new RaidBlock() SubModule managing echo related commands. Source: raidBlock.js, line 19 Fires: RaidBlock#event:shutdown RaidBlock#event:lockdown RaidBlock#event:action Listens to Events: Discord:external~Client#event:guildMemberAdd Command#event:raid Command#event:lockdown Classes RaidSettings Members &lt;private&gt; _events :Object.&lt;Array.&lt;function()&gt;&gt; All event handlers registered. Type: Object.&lt;Array.&lt;function()&gt;&gt; Default Value: {} Source: raidBlock.js, line 38 &lt;private&gt; _settings :Object.&lt;RaidBlock~RaidSettings&gt; Guild settings for raids mapped by their guild id. Type: Object.&lt;RaidBlock~RaidSettings&gt; Default Value: {} Source: raidBlock.js, line 30 myName Source: raidBlock.js, line 22 Methods &lt;private&gt; _commandLockdown(msg) Initiate a server lockdown, or lift a current lockdown. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: raidBlock.js, line 245 Listens to Events: Command#event:lockdown Command#event:raid &lt;private&gt; _doAction(member, s) Perform lockdown action on a member with given settings. Parameters: Name Type Description member external:Discord~GuildMember Member to perform action on. s RaidBlock~RaidSettings Guild settings for raids. Source: raidBlock.js, line 173 &lt;private&gt; _fire(event, args) Fire an event on all handlers. Parameters: Name Type Argument Description event string The event name to fire. args * &lt;repeatable&gt; The arguments to pass to handlers. Source: raidBlock.js, line 375 &lt;private&gt; _formatDelay(msecs) Format a duration in milliseconds into a human readable string. Parameters: Name Type Description msecs number Duration in milliseconds. Source: raidBlock.js, line 387 Returns: Formatted string. Type string &lt;private&gt; _modLog(args) Send a message to a guild's moderation channel (if configured), describing the action that took place. Parameters: Name Type Argument Description args * &lt;repeatable&gt; The arguments to pass to ModLog. Source: raidBlock.js, line 105 See: ModLog &lt;private&gt; _muteMember(member, cb) Mute a discord guild member. Parameters: Name Type Description member external:Discord~GuildMember Member to mute. cb function Callback function. Source: raidBlock.js, line 119 See: Moderation~muteMember &lt;private&gt; _onGuildMemberAdd(member) Handle a member being added to a guild. Parameters: Name Type Description member external:Discord~GuildMember The guild member that was added to a guild. Source: raidBlock.js, line 132 getSettings(gId) Get the settings for a guilds. Parameters: Name Type Description gId string The ID of the guild to fetch. Source: raidBlock.js, line 338 Returns: Reference to settings object. If it does not exist yet, it will first be created with defaults. Type RaidBlock~RaidSettings initialize() Source: raidBlock.js, line 47 on(event, handler) Register an event handler for a specific event. Fires the handler when the event occurs. Parameters: Name Type Description event string Name of the event to listen for. handler function Callback function handler to fire on the event. Source: raidBlock.js, line 350 removeListener(event, handler) Remove an event handler that was previously registered. Parameters: Name Type Description event string Name of the event to listen for. handler function Callback function handler to fire on the event. Source: raidBlock.js, line 361 save() Source: raidBlock.js, line 83 shutdown() Source: raidBlock.js, line 77 × Search results Close "},"RaidBlock-RaidSettings.html":{"id":"RaidBlock-RaidSettings.html","title":"Class: RaidSettings","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: RaidSettings RaidBlock~ RaidSettings Container for RaidBlock related settings. new RaidSettings( [enabled] [, numJoin] [, timeInterval] [, duration] [, action] [, warnMessage] [, sendWarning]) Create a settings object. Parameters: Name Type Argument Default Description enabled boolean &lt;optional&gt; false Is raid protection enabled. numJoin number &lt;optional&gt; 5 Number of users joined in given time. timeInterval number &lt;optional&gt; 10000 Time interval for checking number of users joined. duration number &lt;optional&gt; 600000 Amount of time to be in automated lockdown. action string &lt;optional&gt; 'kick' Action to perform during lockdown. warnMessage string &lt;optional&gt; &lt;nullable&gt; null DM message to send. sendWarning boolean &lt;optional&gt; false Should send DM. Source: raidBlock.js, line 441 Members action :string Action to perform, while on lockdown, to new member who join. Possible values are `kick`, `ban`, or `mute`. Type: string Default Value: 'kick' Source: raidBlock.js, line 482 duration :number Amount of time to stay on lockdown after a raid has been detected to have ended. Type: number Default Value: 600000 (10 Minutes) Source: raidBlock.js, line 474 enabled :boolean Is raid protection enabled. Type: boolean Default Value: false Source: raidBlock.js, line 450 history :Array.&lt;{time: number, id: string}&gt; History of previous member who joined the server within the time interval. Time is timestamp of join, and id is user's account id. Type: Array.&lt;{time: number, id: string}&gt; Default Value: [] Source: raidBlock.js, line 500 numJoin :number Number of users joined within the configured time interval to be considered a raid. Type: number Default Value: 5 Source: raidBlock.js, line 458 sendWarning :boolean Should we additionally send `warnMessage` in a DM to the user prior to performing the action during a lockdown. Type: boolean Source: raidBlock.js, line 518 &lt;nullable&gt; start :number Current raid block state information. Not null is if server has had a lockdown, start is the last timestamp we consider the raid to be active, or null if no raid is active. Type: number Source: raidBlock.js, line 492 timeInterval :number Amount of time for if too many players join, it will be considered a raid. Time in milliseconds. Type: number Default Value: 10000 Source: raidBlock.js, line 466 warnMessage :string Message to send to users when they are being warned that the raid lockdown is active. Type: string Source: raidBlock.js, line 508 Methods &lt;static&gt; from(obj) Create a RaidSettings object from a similarly structured object. Similar to copy-constructor. Parameters: Name Type Description obj object Object to convert to RaidSettings. Source: raidBlock.js, line 531 Returns: Created raidsettings object. Type RaidBlock~RaidSettings × Search results Close "},"RoleColors.html":{"id":"RoleColors.html","title":"Class: RoleColors","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: RoleColors RoleColors Allows users to change their name color by giving them a role with a color. new RoleColors() Source: roleColors.js, line 13 Listens to Events: Command#event:color Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandColor(msg) Allow a user to set their name color. This isn't very smart, and doesn't check for correct position in hierarchy, but will try not to create multiple roles for one person. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: roleColors.js, line 47 Listens to Events: Command#event:color × Search results Close "},"RoleManager.html":{"id":"RoleManager.html","title":"Class: RoleManager","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: RoleManager RoleManager Manages advanced role controls and features. new RoleManager() Source: roleManager.js, line 16 Listens to Events: Discord#event:message Command#event:chat Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner&gt; cmdRoleAdd :Command~SingleCommand The SingleCommand storing permissions for adding roles. Type: Command~SingleCommand Source: roleManager.js, line 141 &lt;private, inner&gt; cmdRoleRemove :Command~SingleCommand The SingleCommand storing permissions for removing roles. Type: Command~SingleCommand Source: roleManager.js, line 148 &lt;private, inner, constant&gt; findDelay :number The delay after failing to find a guild's data to look for it again. Type: number Default Value: 15 Seconds Source: roleManager.js, line 167 &lt;private, inner, constant&gt; guildPerms :Object.&lt;Object.&lt;Object.&lt;boolean&gt;&gt;&gt; The roles that each user is allowed to give. Mapped by guild id, then user id, then role id. Cached. Use RoleManager~find to access the data. Type: Object.&lt;Object.&lt;Object.&lt;boolean&gt;&gt;&gt; Source: roleManager.js, line 157 &lt;private, inner, constant&gt; saveFile :string The file path to save current state for a specific guild relative to Common~guildSaveDir. Type: string Default Value: /rolePerms.json Source: roleManager.js, line 179 See: Common~guildSaveDir Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 giveRole(guild, member, role) Give a guild member a role. Parameters: Name Type Description guild string | number | Discord~Guild Guild object, or ID. member string | number | Discord~GuildMember Guild Member object, ID or name (username, nickname or tag) to lookup. role string | number | Discord~Role Guild Role object, ID or name to lookup. Source: roleManager.js, line 255 Returns: Null if success, string if error. Type string &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandRole(msg) Manage the basic fallback for the role command. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: roleManager.js, line 189 Listens to Events: Command#event:role &lt;private, inner&gt; commandRoleAdd(msg) Handle the user attempting to add a role. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: roleManager.js, line 268 Listens to Events: Command#event:roleAdd &lt;private, inner&gt; commandRoleManage(msg) Handle the user configuring permissions. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: roleManager.js, line 202 Listens to Events: Command#event:roleManage &lt;private, inner&gt; commandRoleRemove(msg) Handle the user attempting to remove a role. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: roleManager.js, line 280 Listens to Events: Command#event:roleRemove &lt;private, inner&gt; find(id) Returns a guild's data. Returns cached version if that exists, or searches the file system for saved data. Data will only be checked from disk at most once every `RoleManager~findDelay` milliseconds. Returns `null` if data could not be found, or an error occurred. Parameters: Name Type Description id number | string The guild id to get the data for. Source: roleManager.js, line 294 Returns: The role data, or null if no data could be loaded. Type Object × Search results Close "},"Sandbox.html":{"id":"Sandbox.html","title":"Class: Sandbox","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Sandbox Sandbox Creates a safe environment to run untrusted scripts. new Sandbox() Source: sandbox.js, line 10 Listens to Events: Command#event:js Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; execArgs :Object Arguments to pass into child_process.exec. Type: Object Default Value: {\"timeout\":35000,\"maxBuffer\":\"\",\"env\":\"\"} Source: sandbox.js, line 34 &lt;private, inner, constant&gt; jsCommand :string The command to run in the sandbox to run JavaScript. Type: string Default Value: SBnode Source: sandbox.js, line 55 &lt;private, inner, constant&gt; py3Command :string The command to run in the sandbox to run Python3. Type: string Default Value: SBpython3 Source: sandbox.js, line 71 &lt;private, inner, constant&gt; pyCommand :string The command to run in the sandbox to run Python2.7. Type: string Default Value: SBpython Source: sandbox.js, line 63 &lt;private, inner, constant&gt; sandboxCommand :string Command to execute to start a sandbox. Type: string Default Value: firejail --profile=./src/lib/sandbox.profile -- Source: sandbox.js, line 47 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandJS(msg) Run JavaScript code in a sandbox, then show user outcome. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: sandbox.js, line 81 Listens to Events: Command#event:js &lt;private, inner&gt; commandPython(msg) Run Python2.7 code in a sandbox, then show user outcome. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: sandbox.js, line 99 Listens to Events: Command#event:py &lt;private, inner&gt; commandPython3(msg) Run Python3 code in a sandbox, then show user outcome. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: sandbox.js, line 117 Listens to Events: Command#event:py &lt;private, inner&gt; scriptEnd(msg, err, stdout, stderr) Callback when script user's program has finished executing. Parameters: Name Type Description msg Discord~Message The Discord message that triggered the initial execution. err Error Error while running script. stdout string | Buffer All data passed through stdout. stderr string | Buffer All data paseed through stderr. Source: sandbox.js, line 137 × Search results Close "},"SMLoader.html":{"id":"SMLoader.html","title":"Class: SMLoader","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: SMLoader SMLoader Manages loading, unloading, and reloading of all SubModules. new SMLoader() Source: smLoader.js, line 12 Extends MainModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: MainModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; blockedmessage :string The message sent to the channel where the user asked to be DM'd, but we were unable to deliver the DM. Type: string Source: smLoader.js, line 226 &lt;private, inner&gt; goalSubModuleNames :null|Array.&lt;string&gt; The list of all submodules that we are intended to have loaded currently. This should reflect the file at SMloader~smListFilename. Null means the data is not available, and no action should be taken. Type: null | Array.&lt;string&gt; Source: smLoader.js, line 171 &lt;private, inner, constant&gt; helpmessagereply :string The message sent to the channel where the user asked for help. Type: string Source: smLoader.js, line 217 &lt;private, inner, constant&gt; smListFilename :string The filename storing the list of all SubModules to load. Type: string Source: smLoader.js, line 154 &lt;private, inner&gt; subModuleNames :Array.&lt;string&gt; The list of all submodule names currently loaded. Type: Array.&lt;string&gt; Source: smLoader.js, line 162 &lt;private, inner&gt; subModules :Object.&lt;SubModule&gt; Instances of SubModules currently loaded mapped by their name. Type: Object.&lt;SubModule&gt; Source: smLoader.js, line 178 &lt;private, inner, constant&gt; toAssign :Class Properties to merge into other objects. `bot` is merged into self.bot, `client` is merged into self.client. Type: Class Source: smLoader.js, line 144 &lt;private, inner, constant&gt; trustedIds :Array.&lt;string&gt; Discord IDs that are allowed to reboot the bot. Type: Array.&lt;string&gt; Source: smLoader.js, line 205 &lt;private, inner, constant&gt; unloadCallbacks :Object.&lt;Array.&lt;function()&gt;&gt; Callbacks for when a scheduled module to unload, has been unloaded. Mapped by name of subModule, then array of all callbacks. Type: Object.&lt;Array.&lt;function()&gt;&gt; Source: smLoader.js, line 196 &lt;private, inner, constant&gt; unloadTimeouts :Object.&lt;Timeout&gt; Timeouts for retrying to unload submodules that are currently not in an unloadable state. Mapped by name of submodule. Type: Object.&lt;Timeout&gt; Source: smLoader.js, line 187 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 export() Export data required to maintain the bot across reloading this module. Expected to be returned directly to this.import once reloaded. Inherited From: MainModule#export Overrides: MainModule#export Source: mainModule.js, line 40 Returns: The data to be exported. Type MainModule~ModuleData import(data) Imports data from a previous instance of this class in order to maintain references to other objects and classes across reloads. Parameters: Name Type Argument Description data MainModule~ModuleData &lt;nullable&gt; The data that was exported previously, or null if no data to import. Inherited From: MainModule#import Overrides: MainModule#import Source: mainModule.js, line 30 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: MainModule#initialize Source: subModule.js, line 112 load(name [, opts] [, cb]) Loads submodules from file. Parameters: Name Type Argument Description name string Specify submodule to load. If it is already loaded, they will be ignored and return successful. opts object &lt;optional&gt; Options object. Properties Name Type Argument Default Description updateGoal boolean &lt;optional&gt; true Update the goal state of the subModule to loaded. cb function &lt;optional&gt; Callback to fire once the operation is complete. Single parameter is null if success, or string if error. Source: smLoader.js, line 377 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 reload( [name] [, opts] [, cb]) Reloads submodules from file. Reloads currently loaded modules if `name` is not specified. If a submodule is specified that is not loaded, it will skip the unload step, bull will still be attempted to be loaded. Parameters: Name Type Argument Description name string | Array.&lt;string&gt; &lt;optional&gt; Specify submodules to reload, or null to reload all submodules to their goal state. opts object &lt;optional&gt; Options object. Properties Name Type Argument Default Description schedule boolean &lt;optional&gt; true Automatically re-schedule reload for submodules if they are not in an unloadable state. ignoreUnloadable boolean &lt;optional&gt; false Force a submodule to unload even if it is not in an unloadable state. force boolean &lt;optional&gt; false Reload a submodule even if the currently loaded version is identical to the version on file. If false it will not be reloaded if the version would not be changed due to a reload. cb function &lt;optional&gt; Callback to fire once the operation is complete. Single parameter has array of strings of status of each module attempted to be reloaded. Source: smLoader.js, line 439 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: MainModule#save Source: subModule.js, line 242 &lt;abstract, protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: MainModule#shutdown Source: subModule.js, line 231 terminate() Signal that the bot is shutting down and will not be restarting immediately. This is triggered on all shutdowns where all MainModules and SubModules will be unloaded. Inherited From: MainModule#terminate Overrides: MainModule#terminate Source: mainModule.js, line 51 unload(name [, opts] [, cb]) Unloads submodules that is currently loaded. Parameters: Name Type Argument Description name string Specify submodule to unload. If it is already unloaded, it will be ignored and return successful. opts object &lt;optional&gt; Options object. Properties Name Type Argument Default Description schedule boolean &lt;optional&gt; true Automatically re-schedule unload for submodule if it is in an unloadable state. ignoreUnloadable boolean &lt;optional&gt; false Force a submodule to unload even if it is not in an unloadable state. updateGoal boolean &lt;optional&gt; true Update the goal state of the subModule to unloaded. cb function &lt;optional&gt; Callback to fire once the operation is complete. Single parameter is null if success, or string if error. Source: smLoader.js, line 275 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: MainModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandHelp(msg) Send help message to user who requested it. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: smLoader.js, line 781 Listens to Events: Command#event:help &lt;private, inner&gt; commandLoad(msg) Load specific sub modules. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: smLoader.js, line 722 Listens to Events: Command#event:load &lt;private, inner&gt; commandReload(msg) Reload all sub modules by unloading then re-requiring. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: smLoader.js, line 523 Listens to Events: Command#event:reload &lt;private, inner&gt; commandUnload(msg) Unload specific sub modules. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: smLoader.js, line 646 Listens to Events: Command#event:unload &lt;private, inner&gt; shardLoad(message, id) Other shard has requested a load command. Parameters: Name Type Description message string The command message to parse. id number Shard id requesting this. Source: smLoader.js, line 630 &lt;private, inner&gt; shardReload(message, id) Other shard has requested a reload command. Parameters: Name Type Description message string The command message to parse. id number Shard id requesting this. Source: smLoader.js, line 574 &lt;private, inner&gt; shardUnload(message, id) Other shard has requested an unload command. Parameters: Name Type Description message string The command message to parse. id number Shard id requesting this. Source: smLoader.js, line 601 × Search results Close "},"SpikeyBot.html":{"id":"SpikeyBot.html","title":"Class: SpikeyBot","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: SpikeyBot SpikeyBot Main class that manages the bot. new SpikeyBot() Source: SpikeyBot.js, line 76 Listens to Events: Discord~Client#event:ready Discord~Client#event:message Command#event:updateGame Command#event:reboot Command#event:mainreload Members &lt;constant&gt; startTimestamp :number Timestamp at which this process was started. Type: number Source: SpikeyBot.js, line 95 &lt;constant&gt; version :string The current bot version parsed from package.json. Type: string Source: SpikeyBot.js, line 85 &lt;private, inner&gt; botName :string The name of the client secret to use. Defaults to release either release or dev depending on the --dev flag. Type: string Source: SpikeyBot.js, line 265 &lt;private, inner&gt; command :Command The current instance of Command. Type: Command Source: SpikeyBot.js, line 157 &lt;private, inner, constant&gt; commandFilename :string The filename of the Command mainModule. Type: string Default Value: ./commands.js Source: SpikeyBot.js, line 130 &lt;private, inner&gt; delayBoot :number Number of milliseconds to delay the call to client.login in order to prevent race conditions of multiple bots in the same directory. This is set with the `--delay` flag. `--delay` with no value will default to 5000 milliseconds. Type: number Source: SpikeyBot.js, line 277 &lt;private, inner, nullable&gt; disconnectReason :string Reason the bot was disconnected from Discord's servers. Type: string Source: SpikeyBot.js, line 227 &lt;private, inner&gt; enableSharding :boolean Whether or not to spawn the bot as multiple shards. Enabled with `--shards` cli argument. Type: boolean Source: SpikeyBot.js, line 236 &lt;private, inner, constant&gt; fullRebootFilename :string The full filename where information about the bot rebooting is stored. Type: string Source: SpikeyBot.js, line 534 See: rebootFilename &lt;private, inner, constant&gt; guildCustomPrefixFile :string The path in the guild's subdirectory where we store custom prefixes for bots with custom names. Type: string Source: SpikeyBot.js, line 627 &lt;private, inner, constant&gt; guildPrefixes :Object.&lt;string&gt; Cache of all loaded guild's command prefixes. Populated asyncronously after client ready event. Type: Object.&lt;string&gt; Source: SpikeyBot.js, line 606 &lt;private, inner, constant&gt; guildPrefixFile :string The path in the guild's subdirectory where we store custom prefixes. Type: string Source: SpikeyBot.js, line 616 &lt;private, inner&gt; initialized :boolean Has the bot been initialized already. Type: boolean Source: SpikeyBot.js, line 576 &lt;private, inner&gt; inspectShard :number Enable inspecting/profiling for a shard to launch. Set via cli falgs. -1 to disable. (Currently only supports enabling. the `--inspect` flag will be sent to all shards that are started. This is due to limitations of Discord~ShardingManager) Type: number Source: SpikeyBot.js, line 289 &lt;private, inner&gt; isBackup :boolean Is this bot managing backup status monitoring. Type: boolean Source: SpikeyBot.js, line 204 &lt;private, inner, constant&gt; mainModuleListFile :string Filename of which to load additional MainModule names. The file must be a valid JSON array of strings. Type: string Default Value: ./mainModules.json Source: SpikeyBot.js, line 174 &lt;private, inner&gt; mainModuleNames :Array.&lt;string&gt; The list of all mainModules to load. Always includes SpikeyBot~commandFilename and SpikeyBot~smListFilename. Additional mainModules can be loaded from SpikeyBot~mainModuleListFile. Type: Array.&lt;string&gt; Source: SpikeyBot.js, line 183 &lt;private, inner, constant&gt; mainModules :Array.&lt;MainModule&gt; Instances of MainModules currently loaded. Type: Array.&lt;MainModule&gt; Source: SpikeyBot.js, line 219 &lt;private, inner&gt; minimal :boolean Should this bot only load minimal features as to not overlap with multiple instances. Type: boolean Source: SpikeyBot.js, line 212 &lt;private, inner&gt; numShards :number The number of shards to use if sharding is enabled. 0 to let Discord decide. Set from `--shards=#` cli argument. Type: number Source: SpikeyBot.js, line 245 &lt;private, inner, constant&gt; rebootFilename :string Filename without file extension where information about the bot rebooting is stored. Type: string Default Value: ./save/reboot Source: SpikeyBot.js, line 150 See: fullRebootFilename &lt;private, inner&gt; rebooting :boolean Is the bot currently rebooting. Type: boolean Source: SpikeyBot.js, line 298 &lt;private, inner, constant&gt; saveFrequency :number The frequency at which saveInterval will run. Type: number Default Value: 5 Minutes Source: SpikeyBot.js, line 597 See: SpikeyBot~saveInterval &lt;private, inner&gt; saveInterval :Interval The Interval in which we will save and purge data on all mainmodules. Begins after onReady. Type: Interval Source: SpikeyBot.js, line 587 See: SpikeyBot~onReady() SpikeyBot~saveFrequency &lt;private, inner&gt; setDev :boolean Is this bot running in development mode. Type: boolean Source: SpikeyBot.js, line 198 &lt;private, inner, nullable&gt; shardMem :number Number of bytes to allocate for each shard memory. Passed as `--max-old-space-size=` to the spawned node process. Null for default. Type: number Source: SpikeyBot.js, line 255 &lt;private, inner&gt; smLoader :SMLoader The current instance of SMLoader. Type: SMLoader Source: SpikeyBot.js, line 164 &lt;private, inner, constant&gt; smLoaderFilename :string The filename of the SMLoader mainModule. Type: string Default Value: ./smLoader.js Source: SpikeyBot.js, line 139 &lt;private, inner, constant&gt; testChannel :string The channel id for the channel to reserve for only unit testing in. Type: string Default Value: 439642818084995074 Source: SpikeyBot.js, line 112 &lt;private, inner&gt; testInstance :boolean Is the bot started with the intent of solely running a unit test. Reduces messages sent that are unnecessary. Type: boolean Source: SpikeyBot.js, line 120 &lt;private, inner&gt; testMode :boolean Is the bot currently responding as a unit test. Type: boolean Source: SpikeyBot.js, line 103 Methods changePrefix(gId, newPrefix) Change the command prefix for the given guild. Parameters: Name Type Description gId string The guild id of which to change the command prefix. newPrefix string The new prefix to set. Source: SpikeyBot.js, line 1035 getBotName() Getter for the bot's name. If name is null, it is most likely because there is no custom name and common.isRelease should be used instead. Source: SpikeyBot.js, line 310 See: SpikeyBot~botName Returns: The bot's name or null if it has not been defined yet or there is no custom name. Type string getFullBotName() Getter for the bot's name. If botName is null, this will give either `release` or `dev`. Source: SpikeyBot.js, line 324 See: SpikeyBot~botName Returns: The bot's name. Type string getPrefix(id) Get this guild's custom prefix. Returns the default prefix otherwise. Parameters: Name Type Description id Discord~Guild | string | number The guild id or guild to lookup. Source: SpikeyBot.js, line 1626 Returns: The prefix for all commands in the given guild. Type string reloadCommon() Delete cache and re-require common.js and auth.js. Source: SpikeyBot.js, line 381 &lt;private, inner&gt; commandChangePrefix(msg) Change the custom prefix for the given guild. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: SpikeyBot.js, line 1154 Listens to Events: Command#event:changePrefix &lt;private, inner&gt; commandReboot(msg [, silent]) Trigger a reboot of the bot. Actually just gracefully shuts down, and expects to be immediately restarted. Parameters: Name Type Argument Default Description msg Discord~Message Message that triggered command. silent boolean &lt;optional&gt; false Suppress reboot scheduling messages. Source: SpikeyBot.js, line 1215 To Do: Support scheduled reload across multiple shards. Currently the bot waits for the shard at which the command was sent to be ready for reboot instead of all shard deciding on their own when they're ready to reboot. This will also need to check that we are obeying Discord's rebooting rate limits to help reduce downtime. Listens to Events: Command#event:reboot &lt;private, inner&gt; commandReload(msg) Reload all mainmodules by unloading then re-requiring. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: SpikeyBot.js, line 1352 Listens to Events: Command#event:mainreload &lt;private, inner&gt; commandSaveAll(msg) Trigger all mainModules to save their data. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: SpikeyBot.js, line 1567 See: SpikeyBot~saveAll() Listens to Events: Command#event:saveAll &lt;private, inner&gt; commandUpdateGame(msg) Change current status message. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: SpikeyBot.js, line 1120 Listens to Events: Command#event:updateGame &lt;private, inner&gt; createShards() Create a ShardingManager and spawn shards. This shall only be called at most once, and `login()` shall not be called after this. Source: SpikeyBot.js, line 400 &lt;private, inner&gt; exit(info) Trigger a graceful shutdown with process signals. Does not trigger shutdown if exit is -1. Parameters: Name Type Argument Description info * &lt;repeatable&gt; Information about the signal. Source: SpikeyBot.js, line 1691 Listens to Events: event:SIGINT event:SIGHUP event:SIGTERM process#event:exit &lt;private, inner&gt; isCmd(msg, cmd) Checks if given message is the given command. Parameters: Name Type Description msg Discord~Message Message from Discord to check if it is the given command. cmd string Command to check if the message is this command. Source: SpikeyBot.js, line 639 Returns: True if msg is the given command. Type boolean &lt;private, inner&gt; loadGuildPrefixes(guilds) Load prefixes from file for the given guilds asynchronously. Parameters: Name Type Description guilds Array.&lt;Discord~Guild&gt; Array of guilds to fetch the custom prefixes of. Source: SpikeyBot.js, line 1640 &lt;private, inner&gt; login() Login to Discord. This shall only be called at most once. Source: SpikeyBot.js, line 1702 &lt;private, inner&gt; onDisconnect(event) The bot has disconnected from Discord and will not be attempting to reconnect. Parameters: Name Type Description event CloseEvent The websocket close event. Source: SpikeyBot.js, line 837 Listens to Events: Discord~Client#event:disconnect &lt;private, inner&gt; onMessage(msg) Handle a message sent. Parameters: Name Type Description msg Discord~Message Message that was sent in Discord. Source: SpikeyBot.js, line 884 Fires: event:Command Listens to Events: Discord~Client#event:message &lt;private, inner&gt; onPresenceUpdate(oldMem, newMem) Attempt to detect when the main bot goes offline by the presence changing. Parameters: Name Type Description oldMem Discord~GuildMember Member before presence update. newMem Discord~GuildMember Member after presence update. Source: SpikeyBot.js, line 865 &lt;private, inner&gt; onReady() The bot has become ready. Source: SpikeyBot.js, line 668 Listens to Events: Discord~Client#event:ready &lt;private, inner&gt; onReconnecting() The bot has disconnected from Discord, and is reconnecting. Source: SpikeyBot.js, line 850 Listens to Events: Discord~Client#event:reconnecting &lt;private, inner&gt; reloadMainModules( [toReload] [, reloaded] [, schedule]) Reloads mainmodules from file. Reloads all modules if `toReload` is not specified. `reloaded` will contain the list of messages describing which mainmodules were reloaded, or not. Parameters: Name Type Argument Default Description toReload string | Array.&lt;string&gt; &lt;optional&gt; Specify mainmodules to reload, or null to reload all mainmodules. reloaded Array.&lt;string&gt; &lt;optional&gt; Reference to a variable to store output status information about outcomes of attempting to reload mainmodules. schedule boolean &lt;optional&gt; true Automatically re-schedule reload for mainmodules if they are in an unloadable state. Source: SpikeyBot.js, line 1415 Returns: True if something failed and not all mainmodules were reloaded. Type boolean &lt;private, inner&gt; saveAll() Trigger all mainmodules to save their data. Source: SpikeyBot.js, line 1541 &lt;private, inner&gt; updateGame(game [, type]) Changes the bot's status message. Parameters: Name Type Argument Default Description game string New message to set game to. type string &lt;optional&gt; 'WATCHING' The type of activity. Source: SpikeyBot.js, line 649 × Search results Close "},"Spotify.html":{"id":"Spotify.html","title":"Class: Spotify","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Spotify Spotify Attempts to play what a user is playing on Spotify, to a voice channel. new Spotify() Source: spotify.js, line 12 Listens to Events: Command#event:spotify Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; apiRequest :Object The request to send to spotify to fetch the currently playing information for a user. Type: Object Default Value: {\"protocol\":\"https:\",\"host\":\"api.spotify.com\",\"path\":\"/v1/me/player/currently-playing\",\"method\":\"GET\"} Source: spotify.js, line 26 &lt;private, inner, constant&gt; following :Object The current users we are monitoring the spotify status of, and some related information. Mapped by guild id. Type: Object Source: spotify.js, line 56 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; checkMusic() Update current reference to music submodule. Source: spotify.js, line 335 &lt;private, inner&gt; commandSpotify(msg) Lookup what a user is listening to on Spotify, then attempt to play the song in the requester's voice channel. Parameters: Name Type Description msg Discord~Message The message that triggered command. Source: spotify.js, line 67 Listens to Events: Command#event:spotify &lt;private, inner&gt; endFollow(msg) Cleanup and delete data in order to stop following user. Parameters: Name Type Description msg Discord~Message THe context to clear. Source: spotify.js, line 347 &lt;private, inner&gt; getCurrentSong(userId, cb) Fetch the current playing song on spotify for the given discord user id. Parameters: Name Type Description userId string | number The Discord user id to lookup. cb Fucntion Callback with err, and data parameters. Source: spotify.js, line 141 &lt;private, inner&gt; startMusic(msg, song) Attempt to start playing the given song into a voice channel. Parameters: Name Type Description msg Discord~Message Message that caused this to happen, and to pass into Command as context. song Object The current song information. Name is song name, progress is progress into the song in milliseconds. Source: spotify.js, line 324 &lt;private, inner&gt; updateDuration(msg, userId) Fetch the song's length from music because Spotify was unable to provide it for us. Parameters: Name Type Description msg Discord~Message The context. userId string | number The user id we are following. Source: spotify.js, line 288 &lt;private, inner&gt; updateFollowingState(msg, userId [, songInfo] [, start]) Check on the user's follow state and update the playing status to match. Parameters: Name Type Argument Default Description msg Discord~Message The message to use as context. userId string | number The discord user id that we are following. songInfo object &lt;optional&gt; If song info is provided, this will not be fetched first. If it is not, the information will be fetched from Spotify first. start boolean &lt;optional&gt; false Should we setup the player with our settings because this is the first run? Source: spotify.js, line 210 × Search results Close "},"Strings.html":{"id":"Strings.html","title":"Class: Strings","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Strings Strings new Strings( [filename] [, dir] [, defaultLocale]) Strings. Parameters: Name Type Argument Default Description filename string &lt;optional&gt; 'global' Filename to read strings from each locale. Excluding path and extension. dir string &lt;optional&gt; '../..//strings/' Path to find folder of available locales, relative to this file. defaultLocale string &lt;optional&gt; 'en_US' Default and fallback locale to use when unspecified or no string in given locale is found. Source: locale/Strings.js, line 18 Classes Locale Members &lt;static&gt; localRegExp Regular Expression to match a valid locale. Attempts to conform to ISO/IEC 15897. Does not accept modifier. Source: locale/Strings.js, line 73 &lt;private, constant&gt; _stringsDefault :string Default and fallback locale. Type: string Default Value: 'en_US' Source: locale/Strings.js, line 53 &lt;private, constant&gt; _stringsDir :string Path to directory storing locale information. Type: string Default Value: '../../strings/' Source: locale/Strings.js, line 37 &lt;private, constant&gt; _stringsFilename :string Filename in locale directory to read strings from. Type: string Default Value: '/global.js' Source: locale/Strings.js, line 45 defaultLocale :Strings~Locale Reference to default locale. This is used when a string key is unable to be found in a locale, or the locale doesn't exist. Type: Strings~Locale Source: locale/Strings.js, line 63 Methods &lt;static&gt; parseLocale(locale) Parse the given string as a locale. Parameters: Name Type Description locale string The locale to parse. Source: locale/Strings.js, line 90 Returns: Matched groups or null if not a valid locale. Type Object get(key [, locale] [, rep]) Get and format a specific string. Parameters: Name Type Argument Description key string String key to find. locale string &lt;optional&gt; Lookup the string in a specific locale. rep string &lt;optional&gt; &lt;repeatable&gt; Data to replace placeholders in the string. Source: locale/Strings.js, line 124 Returns: Matched and replaced string, or null if unable to find. Type string purge() Purge all strings from memory to force them to be reloaded. Asynchronous. Does not complete immediately. Source: locale/Strings.js, line 101 × Search results Close "},"Strings-Locale.html":{"id":"Strings-Locale.html","title":"Class: Locale","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Locale Strings~ Locale new Locale() Bind this. Source: locale/Locale.js, line 13 Methods get(key [, rep]) Get string with given key and replace placeholders. This: Locale Parameters: Name Type Argument Description key string Key of string to lookup. rep string &lt;optional&gt; &lt;repeatable&gt; Placeholder replacement strings. Source: locale/Locale.js, line 26 Returns: String with replaced placeholders, or null if unable to find. Type string × Search results Close "},"SubModule.html":{"id":"SubModule.html","title":"Class: SubModule","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: SubModule SubModule new SubModule() Create a subModule. Source: subModule.js, line 11 Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Source: subModule.js, line 68 common :Common The common object. Type: Common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Source: subModule.js, line 27 Methods &lt;static&gt; extend(child) Extends SubModule as the base class of a child. Parameters: Name Type Description child object The child class to extend. Source: subModule.js, line 265 begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Source: subModule.js, line 221 &lt;abstract, protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Source: subModule.js, line 242 &lt;abstract, protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Source: subModule.js, line 212 × Search results Close "},"TicTacToe.html":{"id":"TicTacToe.html","title":"Class: TicTacToe","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: TicTacToe TicTacToe Manages a tic-tac-toe game. new TicTacToe() Source: ticTacToe.js, line 11 Listens to Events: Command#event:ticTacToe Extends SubModule Classes Game Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; emoji :Object.&lt;string&gt; Helper object of emoji characters mapped to names. Type: Object.&lt;string&gt; Default Value: {\"undefined\":\"9⃣\",\"X\":\"❌\",\"O\":\"⭕\"} Source: ticTacToe.js, line 51 &lt;private, inner, constant&gt; maxReactAwaitTime :number Maximum amount of time to wait for reactions to a message. Also becomes maximum amount of time a game will run with no input, because controls will be disabled after this timeout. Type: number Default Value: 5 Minutes Source: ticTacToe.js, line 41 &lt;private, inner&gt; numGames :number The number of currently active games. Used to determine of submodule is unloadable. Type: number Source: ticTacToe.js, line 73 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 createGame(players, channel) Create a game with the given players in a given text channel. Parameters: Name Type Description players Object The players in the game. channel Discord~TextChannel The text channel to send messages. Source: ticTacToe.js, line 214 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; addListener(msg, game) Add the listener for reactions to the game. Parameters: Name Type Description msg Discord~Message The message to add the reactions to. game TicTacToe~Game The game to update when changes are made. Source: ticTacToe.js, line 244 &lt;private, inner&gt; addReactions(msg, index) Add the reactions to a message for controls of the game. Recursive. Parameters: Name Type Default Description msg Discord~Message The message to add the reactions to. index number 0 The number of reactions we have added so far. Source: ticTacToe.js, line 231 &lt;inner&gt; checkWin(board, latest) Checks if the given board has a winner, or if the game is over. Parameters: Name Type Description board Array.&lt;number&gt; Array of 9 numbers defining a board. 0 is nobody, 1 is player 1, 2 is player 2. latest number The index where the latest move occurred. Source: ticTacToe.js, line 313 Returns: Returns 0 if game is not over, 1 if player 1 won, 2 if player 2 won, 3 if draw. Type number &lt;private, inner&gt; commandTicTacToe(msg) Starts a tic tac toe game. If someone is mentioned it will start a game between the message author and the mentioned person. Otherwise, waits for someone to play. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: ticTacToe.js, line 85 Listens to Events: Command#event:ticTacToe × Search results Close "},"TicTacToe_Game.html":{"id":"TicTacToe_Game.html","title":"Class: Game","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Game TicTacToe# Game new Game(players, msg) Class that stores the current state of a tic tac toe game. Parameters: Name Type Description players Object The players in this game. msg Discord~Message The message displaying the current game. Source: ticTacToe.js, line 103 Members board :Array.&lt;number&gt; An array of 9 elements that stores 0, 1, or 2 to signify who owns which space of the board. 0 is nobody, 1 is player 1, 2 is player 2. Type: Array.&lt;number&gt; Source: ticTacToe.js, line 115 msg :Discord~Message The message displaying the current game. Type: Discord~Message Source: ticTacToe.js, line 125 players :Object The players in this game. Type: Object Source: ticTacToe.js, line 109 turn :number Which player's turn it is. Either 1 or 2. Type: number Source: ticTacToe.js, line 120 &lt;private, inner, constant&gt; boardString :string The template string for the game's board. Type: string Source: ticTacToe.js, line 135 Methods print( [winner]) Edit the current message to show the current board. Parameters: Name Type Argument Default Description winner number &lt;optional&gt; 0 The player who has won the game. 0 is game not done, 1 is player 1, 2 is player 2, 3 is draw. Source: ticTacToe.js, line 145 × Search results Close "},"TTS.html":{"id":"TTS.html","title":"Class: TTS","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: TTS TTS Adds text-to-speech support for voice channels. new TTS() Source: tts.js, line 20 Listens to Events: Command#event:tts Command#event:speak Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Overrides: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; ttsPermString :string The permission required to use TTS commands. Type: string Default Value: tts:all Source: tts.js, line 55 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandTTS(msg) Joins a user's voice channel and speaks the given message. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: tts.js, line 66 Listens to Events: Command#event:tts Command#event:speak × Search results Close "},"Uno.html":{"id":"Uno.html","title":"Class: Uno","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Uno Uno Manages an Uno game. new Uno() Source: uno.js, line 11 Listens to Events: Command#event:uno Extends SubModule Classes Card Game Members &lt;readonly&gt; bot :boolean Whether this player is a Discord bot or not. Type: boolean Overrides: SubModule#bot Default Value: false Source: uno.js, line 1616 calledUno :boolean Whether this player has called uno recently. Type: boolean Source: uno.js, line 1635 calledUno :boolean Whether this player has called uno recently. Type: boolean Source: uno.js, line 1521 &lt;constant&gt; CardFace :number Enum for card faces. The two least significant nibbles are the card face. The most significant used nibbles are for card effects (designated by the EFFECT_MASK). BASE_MASK is the bitwise not of EFFECT_MASK, except on only the nibbles that are less significant than EFFECT_MASK. 0x01000: The card is a wild card. 0x02000: The card skips the next player's turn. 0x04000: The card reverses play direction. 0x08000: The card causes the next player after the turn is over, to draw 2 cards. 0x10000: The next player must draw 4 cards. EFFECT entries are NOT real card faces, just the bitfield represented with that effect. Type: number Properties: Name Type Default Description EFFECT_MASK number 1044480 BASE_MASK number 4095 WILD_EFFECT number 4096 SKIP_EFFECT number 8192 REVERSE_EFFECT number 16384 DRAW_TWO_EFFECT number 32768 DRAW_FOUR_EFFECT number 65536 SKIP number 8208 DRAW_TWO number 40992 DRAW_2 number 40992 REVERSE number 16432 WILD number 4160 DRAW_FOUR number 77904 DRAW_4 number 77904 ZERO number 0 0 number 0 ONE number 1 1 number 1 TWO number 2 2 number 2 THREE number 3 3 number 3 FOUR number 4 4 number 4 FIVE number 5 5 number 5 SIX number 6 6 number 6 SEVEN number 7 7 number 7 EIGHT number 8 8 number 8 NINE number 9 9 number 9 Source: uno.js, line 275 &lt;readonly, nullable&gt; channel :Discord~TextChannel The channel for this player's private messages for the game. Null until the channel is created. Type: Discord~TextChannel Source: uno.js, line 1530 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 &lt;constant&gt; Color :number Enum for card colors. Type: number Properties: Name Type Default Description NONE number 0 RED number 1 BLUE number 2 GREEN number 3 YELLOW number 4 Default Value: {\"NONE\":0,\"RED\":1,\"BLUE\":2,\"GREEN\":3,\"YELLOW\":4} Source: uno.js, line 228 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 delayCallUno :number Delay before calling uno if this NPC is going to call it. (Milliseconds) Type: number Default Value: 3000 Source: uno.js, line 1660 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 hand :Array.&lt;Uno.Card&gt; The current cards that this player has in their hand. Type: Array.&lt;Uno.Card&gt; Source: uno.js, line 1642 hand :Array.&lt;Uno.Card&gt; The current cards that this player has in their hand. Type: Array.&lt;Uno.Card&gt; Source: uno.js, line 1560 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;readonly&gt; id :string The ID of this npc. Must be uniqueness is not enforced, but is required. Type: string Source: uno.js, line 1592 &lt;readonly&gt; id :string The Discord ID of this player. Type: string Source: uno.js, line 1488 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;readonly&gt; mention :string String for mentioning this user in chat. Type: string Source: uno.js, line 1503 &lt;readonly&gt; mention :string String for mentioning this user in chat. Type: string Source: uno.js, line 1607 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;readonly&gt; name :string The name of this player. Type: string Source: uno.js, line 1599 &lt;readonly&gt; name :string The name of this player. Type: string Source: uno.js, line 1495 &lt;readonly&gt; npc :boolean Whether this player is a npc or not. Must be false. Use Uno.NPC for bots. Type: boolean Default Value: false Source: uno.js, line 1512 &lt;readonly&gt; npc :boolean Whether this player is a NPC or not. Always true. Type: boolean Default Value: true Source: uno.js, line 1626 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 probCallUno :number Probability this NPC will call uno when necessary. Type: number Default Value: 0.5 Source: uno.js, line 1651 &lt;private, inner, constant&gt; cardFacePairs CardFace as entries. Source: uno.js, line 308 &lt;private, inner, constant&gt; cardFaceRegExp :RegExp Regular expression search for acceptable card faces. Case insensitive and global flags are set. Type: RegExp Source: uno.js, line 320 &lt;private, inner, constant&gt; colorPairs Color as entries. Source: uno.js, line 241 &lt;private, inner, constant&gt; colorRegExp :RegExp Regular expression search for acceptable colors. Case insensitive and global flags are set. Type: RegExp Source: uno.js, line 251 &lt;private, inner, constant&gt; games :Object.&lt;Object.&lt;Uno.Game&gt;&gt; All games currently in progress mapped by guilds, then by the game ID. Type: Object.&lt;Object.&lt;Uno.Game&gt;&gt; Source: uno.js, line 85 &lt;private, inner, constant&gt; maxPlayerCount :number Maximum number of players allowed in a game. Type: number Default Value: 10 Source: uno.js, line 121 &lt;private, inner, constant&gt; npcDelay :number Delay for NPC to play their card. Type: number Default Value: 5000 Source: uno.js, line 94 &lt;private, inner, constant&gt; npcNames :Array.&lt;string&gt; Default names of NPCs to add when adding non-bot NPCs. Type: Array.&lt;string&gt; Default Value: [\"HAL\",\"Jane\",\"HEX\",\"Deep Thought\",\"Com Pewter\",\"EDI\",\"JARVIS\",\"Samantha\",\"TARS\",\"Ava\",\"Friday\",\"Legion\",\"Cortana\",\"GLaDOS\",\"Guilty Spark\",\"2B\",\"9S\",\"CL4P-TP\",\"Computer\",\"NPC\",\"AI\",\"Bot\",\"CPU\",\"R2D2\",\"AUTO\",\"CASE\",\"Alexa\",\"Bixby\"] Source: uno.js, line 104 &lt;private, inner&gt; numGames :number The number of currently active games. Used to determine of submodule is unloadable. Type: number Source: uno.js, line 72 &lt;private, inner&gt; pFlags self.Discord.Permissions.FLAGS Source: uno.js, line 78 &lt;private, inner, constant&gt; unoText :string ASCII art text to show when a player calls Uno. Type: string Source: uno.js, line 56 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 getHand() A default hand of cards that the classic game starts with. Source: uno.js, line 1739 Returns: An array of all cards in a deck. Type Array.&lt;Uno.Card&gt; &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 NPC(name, parent [, options]) A single non-player character in the game. This is the same as a normal player, except they are not given a text channel, and their actions are controlled by us. Parameters: Name Type Argument Description name string The display name of this NPC. parent Uno.Game The parent game this player will be in. options NPCOpts &lt;optional&gt; Optional options for this NPC. Source: uno.js, line 1584 Player(member, parent) A single player in the game. Parameters: Name Type Description member Discord~GuildMember The guild member this is based off of. parent Uno.Game The parent game this player will be in. Source: uno.js, line 1447 remove() Remove this player from a game. Deletes the player's text channel. Source: uno.js, line 1567 remove() Remove this player from a game. Cleans up references if any exist. Source: uno.js, line 1667 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; commandEndAll(msg) Ends all Uno games. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: uno.js, line 171 Listens to Events: Command#event:uno_endall &lt;private, inner&gt; commandStats(msg) Sends information about current uno games. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: uno.js, line 197 Listens to Events: Command#event:uno_stats &lt;private, inner&gt; commandUno(msg) Starts an Uno game. If someone is mentioned it will start a game between the message author and the mentioned person. Otherwise, waits for someone to play. Parameters: Name Type Description msg Discord~Message Message that triggered command. Source: uno.js, line 133 Listens to Events: Command#event:uno &lt;private, inner&gt; formatCard(txt) Takes a string that is all caps with underscores and makes it more human readable. Parameters: Name Type Description txt string The text to format. Source: uno.js, line 1725 Returns: The formatted text. Type string &lt;private, inner&gt; getCardEmbed(hand) Format a hand of cards or a single card into Discord~MessageEmbed. Parameters: Name Type Description hand Uno~Card | Array.&lt;Uno~Card&gt; The card or hand of cards to format. Source: uno.js, line 1677 Returns: The MessageEmbed to send to the user. Type Discord~MessageEmbed × Search results Close "},"Uno_Card.html":{"id":"Uno_Card.html","title":"Class: Card","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Card Uno# Card new Card(face, color) Class that stores the current information about a particular card. All cards with the same color and face value are represented here using the `count` attribute. Parameters: Name Type Description face CardFace The face value or type of card this is. color Color The color of this card. Source: uno.js, line 334 Members color :Uno.Color The color of this card. Type: Uno.Color Source: uno.js, line 353 face :Uno.CardFace The face value of this card. Type: Uno.CardFace Source: uno.js, line 344 &lt;private, inner, nullable&gt; myName :string The name of this card retreivable with `toString()`. Null until first `toString()` call. Type: string Source: uno.js, line 362 Methods toString() Stringifies the face and colors to their key names. Source: uno.js, line 371 Returns: This card as a string. Type string × Search results Close "},"Uno_Game.html":{"id":"Uno_Game.html","title":"Class: Game","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: Game Uno# Game new Game(memberList, maker) Class that stores the current state of an Uno game. Parameters: Name Type Description memberList Array.&lt;Discord~GuildMember&gt; The players to initially add to this game. maker Discord~GuildMember The player who created the game and can change settings and manage users. Source: uno.js, line 407 Members &lt;nullable&gt; catChannel :Discord~CategoryChannel The category that stores all channels for this game. Null until it is created. Type: Discord~CategoryChannel Source: uno.js, line 452 &lt;constant&gt; createTimestamp :number The timestamp at which this game was first created. Type: number Source: uno.js, line 488 &lt;nullable&gt; groupChannel :Discord~TextChannel The channel that all players of this game can view and type in. Null until the channel is created. Type: Discord~TextChannel Source: uno.js, line 460 &lt;readonly&gt; id :number The ID of this uno game. Should be unique per guild. Type: number Source: uno.js, line 434 &lt;constant&gt; lastInteractTimestamp :number The timestamp at which this game was last interacted with. Type: number Source: uno.js, line 498 &lt;readonly&gt; started :boolean Has this game been started. Type: boolean Source: uno.js, line 478 &lt;private, inner&gt; currentCollector The current Discord~MessageCollector that is listening to messages in the groupChannel. Default Value: type {?Discord~MessageCollector} Source: uno.js, line 575 &lt;private, inner&gt; direction :number The current direction of play. Either 1 or -1. Type: number Default Value: 1 Source: uno.js, line 565 &lt;private, inner&gt; discarded :Array.&lt;Uno.Card&gt; All cards currently not in a player's hand. Type: Array.&lt;Uno.Card&gt; Source: uno.js, line 468 &lt;private, inner, constant&gt; members :Object.&lt;Discord~GuildMember&gt; The guild members in this game mapped by their ID. Type: Object.&lt;Discord~GuildMember&gt; Source: uno.js, line 424 &lt;private, inner, constant&gt; players :Array.&lt;(Uno.Player|Uno.NPC)&gt; The array of all player in the game in the order of their turn. Type: Array.&lt;(Uno.Player|Uno.NPC)&gt; Source: uno.js, line 443 &lt;private, inner&gt; previousTurn :number The index of the player whose turn it was previously. This is -1 if the current turn is the first turn of the game, and will otherwise be the previous player to play a card. Type: number Source: uno.js, line 546 &lt;private, inner, nullable&gt; topCard :Uno.Card The current card on the top of the discard pile that will need to be matched by the next player to play a card. Type: Uno.Card Source: uno.js, line 556 See: Uno.Game~previousCard &lt;private, inner&gt; turn :number The current index of the player whose turn it is. Type: number Source: uno.js, line 507 Methods addNPCs( [num]) Add a certain number of NPCs into the game. Parameters: Name Type Argument Default Description num number &lt;optional&gt; 1 The number of NPCs to add. Source: uno.js, line 1367 Returns: Success if true, failed if false. Type boolean addPlayer(p) Add the given guild member to the game. Parameters: Name Type Description p Discord~GuildMember The member to add to the game. Source: uno.js, line 1334 Returns: Success if true, failed if false. Type boolean end() Ends this game and deletes all created channels. Source: uno.js, line 1309 getPlayers() Returns the list of all players currently in this game. Source: uno.js, line 1433 Returns: Array of player IDs. Type is number-like. Type Array.&lt;string&gt; | Array.&lt;number&gt; removeNPCs( [num]) Remove a certain number of NPCs from the game. Parameters: Name Type Argument Default Description num number &lt;optional&gt; 1 The number of NPCs to remove. Source: uno.js, line 1390 Returns: Success if true, failed if false. Type boolean removePlayer(p) Remove the user with the given ID from the game. Parameters: Name Type Description p string | number | Discord~GuildMember | Uno.Player The ID of the user to remove. Source: uno.js, line 1410 &lt;private, inner&gt; callUno(caller) A player has called Uno. To say that they are about to have one card, they now have one card after playing, or the previous person now has one card and did not call Uno. Parameters: Name Type Description caller string | number The user ID of the player who called Uno. Source: uno.js, line 1276 &lt;private, inner&gt; checkCard(card [, card2]) Checks if the given card may be played next. Parameters: Name Type Argument Description card Uno.Card The card to check. card2 Uno.Card &lt;optional&gt; The card to check against. If not defined, the current topCard will be used. Source: uno.js, line 1259 See: Uno.Game~topCard Returns: True if can be played, false otherwise. Type boolean &lt;private, inner&gt; drawAndSkip( [num]) Cause the current player to draw cards from the discarded pile, then skip their turn and continue to the next player. Parameters: Name Type Argument Default Description num number &lt;optional&gt; 1 The number of cards to draw. Source: uno.js, line 999 &lt;private, inner&gt; drawCards(num [, silent]) Cause the current player to draw cards from the discarded pile. Parameters: Name Type Argument Default Description num number The number of cards to draw. silent boolean &lt;optional&gt; false Do not send a message to the group channel. Source: uno.js, line 1013 &lt;private, inner&gt; endGame() Called after a game has been won by somebody. Clears all players of their cards, and resets the game to ready for next game state. Source: uno.js, line 902 &lt;private, inner&gt; finishSetup() Begins listening for messages in the groupChannel that relate to the setup of the game, and sends a message to the group channel with game instructions. Source: uno.js, line 648 &lt;inner&gt; listPlayers() Send the list of current players in this game to the group channel. Source: uno.js, line 783 &lt;private, inner&gt; nextTurn( [skip]) Called after a player's turn, to trigger the next player's turn. Parameters: Name Type Argument Default Description skip boolean &lt;optional&gt; false True to add additional message saying this player is skipped. Also doesn't send the player their hand. True if this turn is intended to be skipped. Source: uno.js, line 971 &lt;private, inner&gt; parseToCard(text) Parse a string of text to a playable card. Parameters: Name Type Description text string The user-input to parse. Source: uno.js, line 1225 Returns: The matched card, or null if no match. Type Uno.Card &lt;private, inner&gt; playCard(text) Play a card for the current player. Parameters: Name Type Argument Description text string &lt;nullable&gt; User inputted text to parse into a card to play. Source: uno.js, line 1060 Returns: True if the game has ended. False if the game should continue. Type boolean &lt;private, inner&gt; sendHelp() Sends the game help to the group channel. Source: uno.js, line 918 Returns: Promise of command help being sent to the channel. Type Promise.&lt;Discord~Message&gt; &lt;private, inner&gt; startGame() Deal cards to all players, and start the game. Source: uno.js, line 796 × Search results Close "},"WebAccount.html":{"id":"WebAccount.html","title":"Class: WebAccount","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: WebAccount WebAccount Manages the account webpage. new WebAccount() Source: web/account.js, line 28 Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; patreonSettingsFilename :string The filename in the user's directory of the file where the settings related to Patreon rewards are stored. Type: string Default Value: /patreonSettings.json Source: web/account.js, line 56 &lt;private, inner&gt; patreonSettingsTemplate :Object.&lt;Object&gt; The parsed data from WebAccount~patreonSettingsTemplateFile. Data that outlines the available options that can be changed, and their possible values. Type: Object.&lt;Object&gt; Default Value: {} Source: web/account.js, line 76 &lt;private, inner, constant&gt; patreonSettingsTemplateFile :string File where the template for the Patreon settings is stored. Type: string Default Value: ./save/patreonSettingTemplate.json Source: web/account.js, line 66 See: WebAccount~patreonSettingsTemplate &lt;private, inner, constant&gt; sockets :Object.&lt;Socket&gt; Map of all currently connected sockets. Type: Object.&lt;Socket&gt; Source: web/account.js, line 176 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 shutdown() Causes a full shutdown of all servers. Overrides: SubModule#shutdown Source: web/account.js, line 147 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; changePatreonSetting(userid, setting, value, cb) Change a user's setting that is related to Patreon rewards. Parameters: Name Type Description userid string | number The Discord id of the user to change the setting for. setting string The name of the setting to change. value string The value to set the setting to. cb function Callback that is called once the operations are complete with a single parameter for errors, string if error, null if none. Source: web/account.js, line 675 &lt;private, inner&gt; dateToSQL(date) Convert the given date into a format that SQL can understand. Parameters: Name Type Description date * Something that `new Date()` can interpret. Source: web/account.js, line 909 Returns: Formatted Datetime string not including fractions of a second. Type string &lt;private, inner&gt; getPatreonSettings(userid, cb) Fetch a user's current patreon settings from file. Parameters: Name Type Description userid string | number Thd Discord id of the user to lookup. cb function Callback with 2 parameters, the first is the error string or null if no error, the second will be the settings object if there is no error. Source: web/account.js, line 648 &lt;private, inner&gt; handler(req, res) Handler for all http requests. Should never be called. Parameters: Name Type Description req http.IncomingMessage The client's request. res http.ServerResponse Our response to the client. Source: web/account.js, line 165 &lt;private, inner&gt; handleSpotifyTokenResponse(userid, content, ip, cb) Handle the response after successfully requesting the user's tokens. Parameters: Name Type Description userid string | number Discord user id. content string The response from Spotify. ip string Unique identifier for the client that caused this to happen. Used for logging. cb function Callback with single parameter, string if error, null if no error. Source: web/account.js, line 469 &lt;private, inner&gt; handleSpotifyUserResponse(userid, content, vals, ip, cb) Handle the response after successfully requesting the user's basic account information. Parameters: Name Type Description userid string | number Discord user id. content string The response from Spotify. vals Object The object storing user session information. ip string Unique identifier for the client that caused this to happen. Used for logging. cb function Callback with single parameter, string if error, null if no error. Source: web/account.js, line 520 &lt;private, inner&gt; socketConnection(socket) Handler for a new socket connecting. Parameters: Name Type Description socket socketIo~Socket The socket.io socket that connected. Source: web/account.js, line 185 &lt;private, inner&gt; updatePatreonSettingsTemplate() Parse template from file. Source: web/account.js, line 104 See: WebAccount~patreonSettingsTemplate &lt;private, inner&gt; updateUserPatreonId(userid, patreonid, cb) Update our Discord table with the retrieved patreon account ID for the Discord user. Parameters: Name Type Description userid string | number The Discord ID of the user to link to the patreonid. patreonid string | number The Patreon id of the account to link to the Discord ID. cb function Callback with single argument that is string if error, or null if no error. Source: web/account.js, line 567 &lt;private, inner&gt; updateUserSpotifyId(userid, spotifyid, cb) Update our Discord table with the retrieved spotify account ID for the Discord user. Deletes row from Spotify table if the userId is falsey. Parameters: Name Type Description userid string | number The Discord ID of the user to link to the patreonid. spotifyid string | number The Spotify id of the account to link to the Discord ID. cb function Callback with single argument that is string if error, or null if no error. Source: web/account.js, line 593 &lt;private, inner&gt; validatePatreonCode(code, userid, ip, cb) Validate a code received from the client, then use it to retrieve the user ID associated with it. Parameters: Name Type Description code string The code received from Patreon OAuth2 flow. userid string | number The Discord user ID associated with this code in order to link accounts. ip string The unique identifier for this connection for logging purposes. cb function Callback with a single parameter. The parameter is a string if there was an error, or null if no error. Source: web/account.js, line 396 &lt;private, inner&gt; validateSpotifyCode(code, userid, ip, cb) Validate a code received from the client, then use it to retrieve the user ID associated with it. Parameters: Name Type Description code string The code received from Patreon OAuth2 flow. userid string | number The Discord user ID associated with this code in order to link accounts. ip string The unique identifier for this connection for logging purposes. cb function Callback with a single parameter. The parameter is a string if there was an error, or null if no error. Source: web/account.js, line 432 × Search results Close "},"WebCommands.html":{"id":"WebCommands.html","title":"Class: WebCommands","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: WebCommands WebCommands Handles receiving webhooks requests from external services. new WebCommands() Source: web/webhooks.js, line 15 Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; handler(req, res) Handler for all http requests. Parameters: Name Type Description req http.IncomingMessage The client's request. res http.ServerResponse Our response to the client. Source: web/webhooks.js, line 50 × Search results Close "},"WebProxy.html":{"id":"WebProxy.html","title":"Class: WebProxy","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: WebProxy WebProxy Proxy for account authentication. new WebProxy() Source: web/proxy.js, line 22 Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; apiHost :Object The url to send a request to the discord api. Type: Object Default Value: {\"protocol\":\"https:\",\"host\":\"discordapp.com\",\"path\":\"/api\",\"method\":\"GET\"} Source: web/proxy.js, line 51 &lt;private, inner&gt; loginInfo :Object.&lt;loginState&gt; Stores the tokens and associated data for all clients connected while data is valid. Mapped by session id. Type: Object.&lt;loginState&gt; Source: web/proxy.js, line 95 &lt;private, inner, constant&gt; rateLimitFile :string File storing website rate limit specifications. Type: string Source: web/proxy.js, line 103 &lt;private, inner&gt; rateLimits :Object Object storing parsed rate limit info from rateLimitFile. Type: Object Default Value: {\"commands\":\"\",\"groups\":\"\",\"global\":\"\"} Source: web/proxy.js, line 112 &lt;private, inner, constant&gt; sockets :Object.&lt;Socket&gt; Map of all currently connected sockets. Type: Object.&lt;Socket&gt; Source: web/proxy.js, line 272 &lt;private, inner, constant&gt; tokenHost :Object The url to send a received `code` to via `POST` to receive a user's tokens. Type: Object Default Value: {\"protocol\":\"https:\",\"host\":\"discordapp.com\",\"path\":\"/api/oauth2/token\",\"method\":\"POST\"} Source: web/proxy.js, line 37 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Overrides: SubModule#save Source: subModule.js, line 242 shutdown() Causes a full shutdown of all servers. Overrides: SubModule#shutdown Source: web/proxy.js, line 137 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; apiRequest(loginInfo, path, cb) Formats a request to the discord api at the given path. Parameters: Name Type Description loginInfo LoginInfo The credentials of the user we are sending the request for. path string The path for the api request to send. cb basicCallback The response from the https request with error and data arguments. Source: web/proxy.js, line 662 &lt;private, inner&gt; authorizeRequest(code, cb) Authenticate with the discord server using a login code. Parameters: Name Type Description code string The login code received from our client. cb basicCallback The response from the https request with error and data arguments. Source: web/proxy.js, line 792 &lt;private, inner&gt; discordRequest(data, cb, host) Send a https request to discord. Parameters: Name Type Argument Description data object | string The data to send in the request. cb basicCallback Callback with error, and data arguments. host object &lt;nullable&gt; Request object to override the default with. Source: web/proxy.js, line 679 &lt;private, inner&gt; fetchGuilds(loginInfo, cb) Fetches the guild information of the user we have the token of. Parameters: Name Type Description loginInfo LoginInfo The credentials of the session user. cb singleCB The callback storing the user's data, or null if something went wrong. Source: web/proxy.js, line 641 &lt;private, inner&gt; fetchIdentity(loginInfo, cb) Fetches the identity of the user we have the token of. Parameters: Name Type Description loginInfo LoginInfo The credentials of the session user. cb singleCB The callback storing the user's data, or null if something went wrong. Source: web/proxy.js, line 602 &lt;private, inner&gt; handler(req, res) Handler for all http requests. Should never be called. Parameters: Name Type Description req http.IncomingMessage The client's request. res http.ServerResponse Our response to the client. Source: web/proxy.js, line 261 &lt;private, inner&gt; makeRefreshTimeout(loginInfo, cb) Refreshes the given token once it expires. Parameters: Name Type Description loginInfo LoginInfo The credentials to refresh. cb singleCB The callback that is fired storing the new credentials once they are refreshed. Source: web/proxy.js, line 713 &lt;private, inner&gt; purgeSessions() Purge stale data from loginInfo. Source: web/proxy.js, line 225 &lt;private, inner&gt; refreshToken(refreshToken_, cb) Request new credentials with refresh token from discord. Parameters: Name Type Description refreshToken_ string The refresh token used for refreshing credentials. cb basicCallback The callback from the https request, with an error argument, and a data argument. Source: web/proxy.js, line 749 &lt;private, inner&gt; revokeToken(token, cb) Revoke a current refresh token from discord. Parameters: Name Type Description token string The refresh token to revoke. cb basicCallback The callback from the https request, with an error argument, and a data argument. Source: web/proxy.js, line 770 &lt;private, inner&gt; socketConnection(socket) Handler for a new socket connecting. Parameters: Name Type Description socket socketIo~Socket The socket.io socket that connected. Source: web/proxy.js, line 281 &lt;private, inner&gt; updateRateLimits() Parse rate limits from file. Source: web/proxy.js, line 174 × Search results Close "},"WebSettings.html":{"id":"WebSettings.html","title":"Class: WebSettings","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: WebSettings WebSettings Manages changing settings for the bot from a website. new WebSettings() Source: web/settings.js, line 14 Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, nullable&gt; cmdScheduler :CmdScheduling Stores the current reference to the CmdScheduling subModule. Null if it doesn't exist. Type: CmdScheduling Source: web/settings.js, line 75 &lt;private, inner, nullable&gt; raidBlock :RaidBlock Stores the current reference to the RaidBlock subModule. Null if it doesn't exist. Type: RaidBlock Source: web/settings.js, line 84 &lt;private, inner, constant&gt; siblingSockets :Object.&lt;Socket&gt; Map of all sockets connected that are siblings. Type: Object.&lt;Socket&gt; Source: web/settings.js, line 344 &lt;private, inner, constant&gt; sockets :Object.&lt;Socket&gt; Map of all currently connected sockets. Type: Object.&lt;Socket&gt; Source: web/settings.js, line 326 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Overrides: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;inner&gt; cancelScheduledCommand(userData, socket, gId, cmdId [, cb]) Client has requested that a scheduled command be cancelled. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The id of the guild of which to cancel the command. cmdId string The ID of the command to cancel. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 1200 &lt;inner&gt; changeCommandSetting(userData, socket, gId, cmd, key, value, id, enabled [, cb]) Client has requested to change a single command setting for a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The id of the guild of which to change the setting. cmd string The name of the command to change the setting for. key string The name of the setting to change. value string | boolean The value to set the setting to, or the key if changing an enabled or disabled category. id string &lt;nullable&gt; The ID of the channel, user, or role to change the setting for if changing the enabled or disabled category. enabled boolean &lt;nullable&gt; The setting to set the value of the ID setting. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 1484 &lt;inner&gt; changeModLogSetting(userData, socket, gId, key, value [, cb]) Client has requested to change a single ModLog setting for a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The id of the guild of which to change the setting. key string The name of the setting to change. value string | boolean The value to set the setting to. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 1413 &lt;inner&gt; changePrefix(userData, socket, gId, prefix [, cb]) Client has requested to change the command prefix for a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The id of the guild of which to change the prefix. prefix string The new prefix value to set. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 1318 &lt;inner&gt; changeRaidSetting(userData, socket, gId, key, value [, cb]) Client has requested to change a single raid setting for a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The id of the guild of which to change the setting. key string The name of the setting to change. value string | boolean The value to set the setting to. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 1350 &lt;private, inner&gt; checkChannelPerm(userData, gId, cId) Check that the given user has permission to see and send messages in the given channel, as well as manage the games in the given guild. Parameters: Name Type Description userData UserData The user to check. gId string The guild id of the guild that contains the channel. cId string The channel id to check against. Source: web/settings.js, line 605 Returns: Whether the user has permission or not to manage the hungry games in the given guild and has permission to send messages in the given channel. Type boolean &lt;private, inner&gt; checkMyGuild(gId) Checks if the current shard is responsible for the requested guild. Parameters: Name Type Description gId number | string The guild id to check. Source: web/settings.js, line 566 Returns: True if this shard has this guild. Type boolean &lt;private, inner&gt; checkPerm(userData, gId, cId, cmd) Check that the given user has permission to manage the games in the given guild. Parameters: Name Type Argument Description userData UserData The user to check. gId string The guild id to check against. cId string &lt;nullable&gt; The channel id to check against. cmd string The command being attempted. Source: web/settings.js, line 583 Returns: Whether the user has permission or not to manage the hungry games in the given guild. Type boolean &lt;private, inner&gt; clientSocketConnection(socket) Handler for connecting as a client to the server. Parameters: Name Type Description socket socketIo~Socket The socket.io socket that connected. Source: web/settings.js, line 507 &lt;inner&gt; fetchChannel(userData, socket, gId, cId [, cb]) Client has requested data for a specific channel. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The ID of the Discord guild where the channel is. cId number | string The ID of the Discord channel to fetch. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 901 &lt;inner&gt; fetchCommandSettings(userData, socket, gId, cmd [, cb]) Client has requested settings specific to a single command in a single guild. This only supplies user settings, if values are default, this will reply with null. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string The guild ID to fetch the settings for. cmd string &lt;nullable&gt; The name of the command to fetch the setting for, or null to fetch all settings. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 1058 &lt;private, inner&gt; fetchGuild(userData, socket, gId [, cb]) Fetch a single guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The ID of the guild that was requested. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 834 &lt;private, inner&gt; fetchGuilds(userData, socket [, cb]) Fetch all relevant data for all mutual guilds with the user and send it to the user. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 715 &lt;inner&gt; fetchGuildScheduledCommands(userData, socket, gId [, cb]) Client has requested scheduled commands for a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string The guild ID to fetch. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 1150 &lt;private, inner&gt; fetchMember(userData, socket, gId, mId [, cb]) Fetch data about a member of a guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId number | string The guild id to look at. mId number | string The member's id to lookup. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 872 &lt;inner&gt; fetchModLogSettings(userData, socket, gId [, cb]) Client has requested settings specific to ModLog for single guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string The guild ID to fetch the settings for. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 1019 &lt;inner&gt; fetchRaidSettings(userData, socket, gId [, cb]) Client has requested settings specific to raids for single guild. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string The guild ID to fetch the settings for. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 985 &lt;inner&gt; fetchScheduledCommands(userData, socket [, cb]) Client has requested all scheduled commands for the connected user. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 1096 &lt;inner&gt; fetchSettings(userData, socket [, cb]) Client has requested all settings for all guilds for the connected user. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete and has data, or has failed. Source: web/settings.js, line 936 &lt;private, inner&gt; getNumClients() Returns the number of connected clients that are not siblings. Source: web/settings.js, line 334 Returns: Number of sockets. Type number &lt;private, inner&gt; handleCommandCancelled(cmdId, gId) Handle a CmdScheduling.ScheduledCommand being canceled. Parameters: Name Type Description cmdId string The ID of the command that was cancelled. gId string | number The ID of the guild the command was cancelled in. Source: web/settings.js, line 189 Listens to Events: CmdScheduling#event:commandCancelled &lt;private, inner&gt; handleCommandRegistered(cmd, gId) Handle new CmdScheduling.ScheduledCommand being registered. Parameters: Name Type Description cmd CmdScheduling.ScheduledCommand The command that was scheduled. gId string | number The guild ID of which the command was scheduled in. Source: web/settings.js, line 161 Listens to Events: CmdScheduling#event:commandRegistered &lt;private, inner&gt; handleLockdown(event) Handle a guild going on lockdown. Parameters: Name Type Description event Object Event information. Source: web/settings.js, line 257 Listens to Events: RaidBlock#event:lockdown &lt;private, inner&gt; handler(req, res) Handler for all http requests. Should never be called. Parameters: Name Type Description req http.IncomingMessage The client's request. res http.ServerResponse Our response to the client. Source: web/settings.js, line 315 &lt;private, inner&gt; handleRaidAction(event) Handle a guild lockdown action being performed. Parameters: Name Type Description event Object Event information. Source: web/settings.js, line 279 Listens to Events: RaidBlock#event:action &lt;private, inner&gt; handleRaidShutdown() Handle RaidBlock shutting down. Source: web/settings.js, line 141 Listens to Events: RaidBlock[w#event:shutdown &lt;private, inner&gt; handleSettingsChanged(gId, value, type, id [, id2]) Handle Command~CommandSetting value changed. Parameters: Name Type Argument Description gId string &lt;nullable&gt; The ID of the guild this setting was changed in, or null of not specific to a single guild. value string Value of setting. type string Type of value. id string Setting id. id2 string &lt;optional&gt; Second setting id. Source: web/settings.js, line 215 See: Command~CommandSetting.set Listens to Events: Command.events#event:settingsChanged &lt;private, inner&gt; handleSettingsReset(gId) Handle Command~CommandSetting was deleted or reset in a guild. Parameters: Name Type Description gId string The ID of the guild in which the settings were reset. Source: web/settings.js, line 236 Listens to Events: Command.events#event:settingsReset &lt;private, inner&gt; handleShutdown() Handle CmdScheduling shutting down. Source: web/settings.js, line 125 Listens to Events: CmdScheduling#event:shutdown &lt;private, inner&gt; makeMember(m) Strips a Discord~GuildMember to only the necessary data that a client will need. Parameters: Name Type Description m Discord~GuildMember The guild member to strip the data from. Source: web/settings.js, line 630 Returns: The minimal member. Type object &lt;private, inner&gt; makeMessage(uId, gId, cId, msg) Forms a Discord~Message similar object from given IDs. Parameters: Name Type Argument Description uId string The id of the user who wrote this message. gId string The id of the guild this message is in. cId string &lt;nullable&gt; The id of the channel this message was 'sent' in. msg string &lt;nullable&gt; The message content. Source: web/settings.js, line 681 Returns: The created message-like object. Type Object &lt;inner&gt; registerScheduledCommand(userData, socket, gId, cmd [, cb]) Client has created a new scheduled command. Parameters: Name Type Argument Description userData object The current user's session data. socket socketIo~Socket The socket connection to reply on. gId string | number The id of the guild of which to add the command. cmd object The command data of which to make into a scheduled command and register. cb basicCB &lt;optional&gt; Callback that fires once the requested action is complete, or has failed. Source: web/settings.js, line 1228 See: CmdScheduling~ScheduledCommand &lt;private, inner&gt; replyNoPerm(socket, cmd) Send a message to the given socket informing the client that the command they attempted failed due to insufficient permission. Parameters: Name Type Description socket Socket The socket.io socket to reply on. cmd string THe command the client attempted. Source: web/settings.js, line 551 &lt;private, inner&gt; socketConnection(socket) Handler for a new socket connecting. Parameters: Name Type Description socket socketIo~Socket The socket.io socket that connected. Source: web/settings.js, line 353 &lt;private, inner&gt; startClient() Start a socketio client connection to the primary running server. Source: web/settings.js, line 298 &lt;private, inner&gt; stripGuilds(guilds, userData) Strip a Discord~Guild to the basic information the client will need. Parameters: Name Type Description guilds Array.&lt;Discord~Guild&gt; The array of guilds to strip. userData object The current user's session data. Source: web/settings.js, line 796 Returns: The stripped guilds. Type Array.&lt;object&gt; &lt;private, inner&gt; updateModuleReferences() Update the references to the aplicable subModules. Source: web/settings.js, line 91 Type Definitions basicCB(err) Basic callback with single argument. The argument is null if there is no error, or a string if there was an error. Parameters: Name Type Argument Description err string &lt;nullable&gt; The error response. Source: web/settings.js, line 696 × Search results Close "},"WebStats.html":{"id":"WebStats.html","title":"Class: WebStats","body":" SpikeyBot-Discord Modules lib/twemojiChecker Classes ChatBotCmdSchedulingCmdScheduling~ScheduledCommandCommandCommand~CommandSettingCommand~SingleCommandCommonConnect4Connect4#GameDefineDevCmdsEchoEcho~CharacterFunTranslatorsHGHGWebHungryGamesHungryGames~ArenaEventHungryGames~BattleHungryGames~DayHungryGames~DefaultOptionsHungryGames~DefaultOptions~BooleanOptionHungryGames~DefaultOptions~NumberOptionHungryGames~DefaultOptions~ObjectOptionHungryGames~DefaultOptions~OptionHungryGames~DefaultOptions~SelectOptionHungryGames~EventHungryGames~FinalEventHungryGames~ForcedOutcomeHungryGames~GameHungryGames~GrammarHungryGames~GuildGameHungryGames~MessagesHungryGames~OutcomeProbabilitiesHungryGames~PlayerHungryGames~SimulatorHungryGames~Simulator~WorkerHungryGames~StatGroupHungryGames~StatManagerHungryGames~StatsHungryGames~TeamHungryGames~UserIconUrlHungryGames~WeaponEventMainMainModuleMessagesModerationModLogModLog~SettingsMusicNPCPatreonPatreon~toExportPollingPolling~PollRaidBlockRaidBlock~RaidSettingsRoleColorsRoleManagerSandboxSMLoaderSpikeyBotSpotifyStringsStrings~LocaleSubModuleTicTacToeTicTacToe#GameTTSUnoUno#CardUno#GameWebAccountWebCommandsWebProxyWebSettingsWebStats Global __stackselfsqlConunhandledRejection Externals Discord Class: WebStats WebStats Handles sending the bot's stats to http client requests, and discordbots.org. new WebStats() Source: web/stats.js, line 14 Extends SubModule Members bot :SpikeyBot The parent SpikeyBot instance. Type: SpikeyBot Inherited From: SubModule#bot Source: subModule.js, line 58 client :Discord~Client The current bot client. Type: Discord~Client Inherited From: SubModule#client Source: subModule.js, line 39 command :Command The command object for registering command listeners. Type: Command Inherited From: SubModule#command Source: subModule.js, line 45 &lt;constant&gt; commit :string The commit at HEAD at the time this module was loaded. Essentially the version of this submodule. Type: string Inherited From: SubModule#commit Source: subModule.js, line 68 common :Common The common object. Type: Common Inherited From: SubModule#common Source: subModule.js, line 51 Discord :Discord The current Discord object instance of the bot. Type: Discord Inherited From: SubModule#Discord Source: subModule.js, line 33 helpMessage :string|Discord~MessageEmbed The help message to show the user in the main help message. Type: string | Discord~MessageEmbed Inherited From: SubModule#helpMessage Source: subModule.js, line 17 &lt;protected, readonly&gt; initialized :boolean Has this subModule been initialized yet (Has begin() been called). Type: boolean Inherited From: SubModule#initialized Source: subModule.js, line 103 &lt;constant&gt; loadTime :number The time at which this madule was loaded for use in checking if the module needs to be reloaded because the file has been modified since loading. Type: number Inherited From: SubModule#loadTime Source: subModule.js, line 82 &lt;abstract, protected&gt; myName :string The name of this submodule. Used for differentiating in the log. Should be defined before begin(). Type: string Inherited From: SubModule#myName Overrides: SubModule#myName Source: subModule.js, line 93 &lt;abstract&gt; postPrefix :string The postfix for the global prefix for this subModule. Must be defined before begin(), otherwise it is ignored. Type: string Inherited From: SubModule#postPrefix Source: subModule.js, line 27 &lt;private, inner, constant&gt; apiHosts The request information for updating our server count on bot list websites. Default Value: [\"{\\\"protocol\\\":\\\"https:\\\",\\\"host\\\":\\\"discordbots.org\\\",\\\"path\\\":\\\"/api/bots/{id}/stats\\\",\\\"method\\\":\\\"POST\\\",\\\"headers\\\":\\\"\\\"}\",\"{\\\"protocol\\\":\\\"https:\\\",\\\"host\\\":\\\"discordbotlist.com\\\",\\\"path\\\":\\\"/api/bots/{id}/stats\\\",\\\"method\\\":\\\"POST\\\",\\\"headers\\\":\\\"\\\"}\",\"{\\\"protocol\\\":\\\"https:\\\",\\\"host\\\":\\\"discord.bots.gg\\\",\\\"path\\\":\\\"/api/v1/bots/{id}/stats\\\",\\\"method\\\":\\\"POST\\\",\\\"headers\\\":\\\"\\\"}\",\"{\\\"protocol\\\":\\\"https:\\\",\\\"host\\\":\\\"bots.ondiscord.xyz\\\",\\\"path\\\":\\\"/bot-api/bots/{id}/guilds\\\",\\\"method\\\":\\\"POST\\\",\\\"headers\\\":\\\"\\\"}\",\"{\\\"protocol\\\":\\\"https:\\\",\\\"host\\\":\\\"divinediscordbots.com\\\",\\\"path\\\":\\\"/bot/318552464356016131/stats\\\",\\\"method\\\":\\\"POST\\\",\\\"headers\\\":\\\"\\\"}\"] Source: web/stats.js, line 89 &lt;private, inner, constant&gt; cachedLifespan :number The amount of time the cached data is considered fresh. Anything longer than this must be re-fetched. Type: number Default Value: 5 Minutes Source: web/stats.js, line 57 &lt;private, inner&gt; cachedStats :Main~getAllStats~values The object storing the previously received stats values. Type: Main~getAllStats~values Default Value: {} Source: web/stats.js, line 65 &lt;private, inner&gt; cachedTime :number The timestamp at which the stats were last requested. Type: number Source: web/stats.js, line 48 &lt;private, inner, constant&gt; postFrequency :number The amount frequency at which we will post our stats to discordbots.org Type: number Default Value: 12 Hours Source: web/stats.js, line 74 &lt;private, inner&gt; postTimeout :Timeout The next scheduled event at which to post our stats. Type: Timeout Source: web/stats.js, line 81 Methods begin(Discord, client, command, common, bot) Initialize this submodule. Parameters: Name Type Description Discord Discord The Discord object for the API library. client Discord~Client The client that represents this bot. command Command The command instance in which to register command listeners. common Common Class storing common functions. bot SpikeyBot The parent SpikeyBot instance. Inherited From: SubModule#begin Source: subModule.js, line 126 &lt;protected&gt; debug(msg) Log using common.logDebug, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#debug Source: subModule.js, line 203 end() Trigger subModule to shutdown and get ready for process terminating. Inherited From: SubModule#end Source: subModule.js, line 181 &lt;protected&gt; error(msg) Log using common.error, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#error Source: subModule.js, line 221 &lt;protected&gt; initialize() The function called at the end of begin() for further initialization specific to the subModule. Must be defined before begin() is called. Inherited From: SubModule#initialize Overrides: SubModule#initialize Source: subModule.js, line 112 &lt;protected&gt; log(msg) Log using common.log, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#log Source: subModule.js, line 194 &lt;abstract&gt; save( [opt]) Saves all data to files necessary for saving current state. Parameters: Name Type Argument Default Description opt string &lt;optional&gt; 'sync' Can be 'async', otherwise defaults to synchronous. Inherited From: SubModule#save Source: subModule.js, line 242 &lt;protected&gt; shutdown() Shutdown and disable this submodule. Removes all event listeners. Inherited From: SubModule#shutdown Overrides: SubModule#shutdown Source: subModule.js, line 231 &lt;abstract&gt; unloadable() Check if this module is in a state that is ready to be unloaded. If false is returned, this module should not be unloaded and doing such may risk putting the module into an uncontrollable state. Inherited From: SubModule#unloadable Source: subModule.js, line 255 Returns: True if can be unloaded, false if cannot. Type boolean &lt;protected&gt; warn(msg) Log using common.logWarning, but automatically set name. Parameters: Name Type Description msg string The message to log. Inherited From: SubModule#warn Source: subModule.js, line 212 &lt;private, inner&gt; getStats(cb) Fetch the bot's stats. Parameters: Name Type Description cb object The bot's stats as an object. Source: web/stats.js, line 188 See: Main~getAllStats~values &lt;private, inner&gt; handler(req, res) Handler for all http requests. Always replies to res with JSON encoded bot stats. Parameters: Name Type Description req http.IncomingMessage The client's request. res http.ServerResponse Our response to the client. Source: web/stats.js, line 150 &lt;private, inner&gt; postUpdatedCount() Send our latest guild count to discordbots.org via https post request. Source: web/stats.js, line 205 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
