<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: smLoader.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: smLoader.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Copyright 2018 Campbell Crowley. All rights reserved.
// Author: Campbell Crowley (dev@campbellcrowley.com)
const fs = require('fs');
const childProcess = require('child_process');
require('./mainModule.js')(SMLoader); // Extends the MainModule class.

/**
 * @classdesc Manages loading, unloading, and reloading of all SubModules.
 * @class
 * @augments MainModule
 */
function SMLoader() {
  const self = this;
  /** @inheritdoc */
  this.myName = 'SMLoader';

  /** @inheritdoc */
  this.import = function(data) {
    if (!data) return;
    subModules = data.subModules;
    subModuleNames = data.subModuleNames;
  };
  /** @inheritdoc */
  this.export = function() {
    return {
      subModules: subModules,
      subModuleNames: subModuleNames,
    };
  };
  /** @inheritdoc */
  this.terminate = function() {
    for (const i in subModules) {
      if (subModules[i] &amp;&amp; subModules[i].end) {
        subModules[i].end();
      }
    }
  };
  /** @inheritdoc */
  this.initialize = function() {
    self.command.on('reload', commandReload);
    self.command.on('unload', commandUnload);
    self.command.on('load', commandLoad);
    self.command.on(
        new self.command.SingleCommand(['help', 'commands'], commandHelp));

    Object.assign(self.bot, toAssign.bot);
    Object.assign(self.client, toAssign.client);

    fs.readFile(smListFilename, (err, data) => {
      if (err) {
        self.error(
            'Failed to read list of subModules from file: ' + smListFilename);
        console.error(err);
        return;
      }
      try {
        const parsed = JSON.parse(data);
        if (!parsed) {
          self.error('Empty list of subModules from file: ' + smListFilename);
          return;
        }
        goalSubModuleNames = parsed[self.bot.getFullBotName()];
        if (!goalSubModuleNames) {
          self.error(
              'Unable to find subModule list for bot: (' +
              self.bot.getFullBotName() + ') ' + smListFilename);
          return;
        }
        self.reload();
      } catch (e) {
        self.error(
            'Failed to parse subModule list from file: ' + smListFilename);
        console.error(e);
      }
    });
  };
  this.shutdown = function() {
    self.command.deleteEvent('reload');
    self.command.deleteEvent('unload');
    self.command.deleteEvent('load');
    self.command.deleteEvent('help');

    const data = fs.readFileSync(smListFilename);
    const parsed = JSON.parse(data);
    parsed[self.bot.getFullBotName()] = goalSubModuleNames;
    fs.writeFileSync(smListFilename, JSON.stringify(parsed, null, 2));
  };
  /** @inheritdoc */
  this.unloadable = function() {
    return subModuleNames.findIndex((el) => {
      return !subModules[el].unloadable();
    }) &lt; 0;
  };
  /** @inheritdoc */
  this.save = function(...args) {
    for (const i in subModules) {
      if (subModules[i] &amp;&amp; subModules[i].save) {
        subModules[i].save.apply(null, args);
      }
    }
  };

  /**
   * Properties to merge into other objects. `bot` is merged into self.bot,
   * `client` is merged into self.client.
   *
   * @private
   * @type {Class}
   */
  const toAssign = {bot: {}, client: {}};

  /**
   * The filename storing the list of all SubModules to load.
   *
   * @private
   * @constant
   * @defualt
   * @type {string}
   */
  const smListFilename = './subModules.json';

  /**
   * The list of all submodule names currently loaded.
   *
   * @private
   * @type {string[]}
   */
  let subModuleNames = [];
  /**
   * The list of all submodules that we are intended to have loaded currently.
   * This should reflect the file at {@link SMloader~smListFilename}. Null means
   * the data is not available, and no action should be taken.
   *
   * @private
   * @type {null|string[]}
   */
  let goalSubModuleNames = null;
  /**
   * Instances of SubModules currently loaded mapped by their name.
   *
   * @private
   * @type {Object.&lt;SubModule>}
   */
  let subModules = {};

  /**
   * Timeouts for retrying to unload submodules that are currently not in an
   * unloadable state. Mapped by name of submodule.
   *
   * @private
   * @type {Object.&lt;Timeout>}
   */
  const unloadTimeouts = {};

  /**
   * Callbacks for when a scheduled module to unload, has been unloaded. Mapped
   * by name of subModule, then array of all callbacks.
   *
   * @private
   * @type {Object.&lt;Array.&lt;Function>>}
   */
  const unloadCallbacks = {};

  /**
   * Discord IDs that are allowed to reboot the bot.
   *
   * @private
   * @type {string[]}
   * @constant
   */
  const trustedIds = [
    '124733888177111041',  // Me
    '126464376059330562',  // Rohan
  ];

  /**
   * The message sent to the channel where the user asked for help.
   *
   * @private
   * @type {string}
   * @constant
   */
  const helpmessagereply = 'I sent you a DM with commands!';
  /**
   * The message sent to the channel where the user asked to be DM'd, but we
   * were unable to deliver the DM.
   *
   * @private
   * @type {string}
   * @constant
   */
  const blockedmessage =
      'I couldn\'t send you a message, you probably blocked me :(';

  /**
   * Get array of all submodule names and the commit they were last loaded from.
   *
   * @public
   * @return {Array.&lt;{name: string, commit: string}>}
   */
  toAssign.bot.getSubmoduleCommits = function() {
    return subModuleNames.map((el) => {
      return {name: el, commit: subModules[el].commit || 'Unknown'};
    });
  };

  /**
   * Get a reference to a submodule with the given name.
   *
   * @public
   * @param {string} name The name of the submodule.
   * @return {?SubModule}
   */
  toAssign.bot.getSubmodule = function(name) {
    if (!subModules[name]) {
      return null;
    }
    return subModules[name];
  };

  /**
   * Unloads submodules that is currently loaded.
   * @public
   *
   * @param {string} name Specify submodule to unload. If it is already
   * unloaded, it will be ignored and return successful.
   * @param {Object} [opts] Options object.
   * @param {boolean} [opts.schedule=true] Automatically re-schedule unload for
   * submodule if it is in an unloadable state.
   * @param {boolean} [opts.ignoreUnloadable=false] Force a submodule to unload
   * even if it is not in an unloadable state.
   * @param {boolean} [opts.updateGoal=true] Update the goal state of the
   * subModule to unloaded.
   * @param {Function} [cb] Callback to fire once the operation is complete.
   * Single parameter is null if success, or string if error.
   */
  this.unload = function(name, opts, cb) {
    if (!opts) {
      opts = {schedule: true, updateGoal: true, ignoreUnloadable: false};
    } else {
      if (opts.schedule == null) opts.schedule = true;
      if (opts.updateGoal == null) opts.updateGoal = true;
    }
    const sm = subModules[name];
    if (!sm) {
      const nameIndex = subModuleNames.findIndex((el) => el == name);
      if (nameIndex >= 0) {
        self.error(
            'Unloaded module still exists in list of names!' +
            ' This should not happen!');
        subModuleNames.splice(nameIndex, 1);
      }
      cb(null);
      return;
    }
    if (!opts.ignoreUnloadable) {
      if (!sm.unloadable()) {
        if (opts.schedule) {
          if (unloadTimeouts[name]) {
            if (!unloadCallbacks[name]) unloadCallbacks[name] = [];
            unloadCallbacks[name].push(cb);
          } else {
            unloadTimeouts[name] = setTimeout(function() {
              delete unloadTimeouts[name];
              self.unload(name, opts, cb);
            }, 10000);
          }
        } else {
          cb('Not Unloadable');
        }
        return;
      }
    }
    try {
      if (subModules[name].save) {
        subModules[name].save();
      } else {
        self.error('Submodule ' + name + ' does not have a save() function.');
      }
      if (subModules[name].end) {
        subModules[name].end();
      } else {
        self.error('Submodule ' + name + ' does not have an end() function.');
      }
    } catch (err) {
      self.error('Error on unloading ' + name);
      console.log(err);
    }
    let message;
    try {
      delete require.cache[require.resolve(name)];
      const index = subModuleNames.findIndex((el) => el == name);
      if (index &lt; 0) {
        self.error(
            'Failed to find submodule name in list of loaded submodules! ' +
            name);
        console.log(subModuleNames);
      } else {
        subModuleNames.splice(index, 1);
      }
      if (opts.updateGoal) {
        const goalIndex = goalSubModuleNames.findIndex((el) => el == name);
        if (goalIndex &lt; 0) {
          self.error(
              'Failed to find submodule name in list of goal submodules! ' +
              name);
          console.log(goalSubModuleNames);
        } else {
          goalSubModuleNames.splice(goalIndex, 1);
        }
      }
      delete subModules[name];
      message = null;
    } catch (err) {
      self.error('Failed to clear: ' + name);
      console.log(err);
      message = 'Failed to Unload';
    }
    cb(message);
    if (unloadCallbacks[name]) {
      unloadCallbacks[name].splice(0).forEach((el) => {
        el(message);
      });
    }
  };
  /**
   * Loads submodules from file.
   * @public
   *
   * @param {string} name Specify submodule to load. If it is already loaded,
   * they will be ignored and return successful.
   * @param {Object} [opts] Options object.
   * @param {boolean} [opts.updateGoal=true] Update the goal state of the
   * subModule to loaded.
   * @param {Function} [cb] Callback to fire once the operation is complete.
   * Single parameter is null if success, or string if error.
   */
  this.load = function(name, opts, cb) {
    if (!opts) {
      opts = {updateGoal: true};
    } else {
      if (opts.updateGoal == null) opts.updateGoal = true;
    }
    if (subModules[name]) {
      if (opts.updateGoal &amp;&amp; !goalSubModuleNames.includes(name)) {
        goalSubModuleNames.push(name);
      }
    }
    try {
      subModules[name] = require(name);
      subModules[name].modifiedTime = fs.statSync(__dirname + '/' + name).mtime;
      if (subModuleNames.includes(name)) {
        self.error(
            'Submodule that is not loaded already exists in list of ' +
            'loaded names! This should not happen!');
      } else {
        subModuleNames.push(name);
      }
      if (opts.updateGoal &amp;&amp; !goalSubModuleNames.includes(name)) {
        goalSubModuleNames.push(name);
      }
    } catch (err) {
      cb('Failed to Load');
      self.error('Failed to load submodule: ' + name);
      console.error(err);
      return;
    }
    try {
      subModules[name].begin(
          self.Discord, self.client, self.command, self.common, self.bot);
    } catch (err) {
      self.error('Failed to initialize submodule: ' + name);
      console.error(err);
      delete require.cache[require.resolve(name)];
      cb('Failed to Initialize');
      return;
    }
    cb(null);
  };
  /**
   * Reloads submodules from file. Reloads currently loaded modules if
   * `name` is not specified. If a submodule is specified that is not
   * loaded, it will skip the unload step, bull will still be attempted to be
   * loaded.
   * @public
   *
   * @param {?string|string[]} [name] Specify submodules to reload, or null to
   * reload all submodules to their goal state.
   * @param {Object} [opts] Options object.
   * @param {boolean} [opts.schedule=true] Automatically re-schedule reload for
   * submodules if they are not in an unloadable state.
   * @param {boolean} [opts.ignoreUnloadable=false] Force a submodule to unload
   * even if it is not in an unloadable state.
   * @param {boolean} [opts.force=false] Reload a submodule even if the
   * currently loaded version is identical to the version on file. If false it
   * will not be reloaded if the version would not be changed due to a reload.
   * @param {Function} [cb] Callback to fire once the operation is complete.
   * Single parameter has array of strings of status of each module attempted to
   * be reloaded.
   */
  this.reload = function(name, opts, cb) {
    if (typeof cb !== 'function') cb = function() {};
    if (typeof name === 'string') name = [name];
    if (!name || name.length === 0) name = goalSubModuleNames;
    if (!Array.isArray(name) || name.length === 0) {
      cb([]);
      return;
    }
    if (!opts) {
      opts = {schedule: true, force: false, ignoreUnloadable: false};
    } else if (opts.schedule == null) {
      opts.schedule = true;
    }
    opts.updateGoal = false;

    const numTotal = name.length;
    let numComplete = 0;
    const output = [];
    for (let i = 0; i &lt; numTotal; i++) {
      if (!opts.force &amp;&amp; subModules[name[i]]) {
        try {
          const mtime = fs.statSync(__dirname + '/' + name[i]).mtime;
          // For some reason, directly comparing these two for equality does not
          // work.
          if (mtime - subModules[name[i]].modifiedTime == 0) {
            output.push(`~~${name[i]}~~`);
            done();
            continue;
          }
        } catch (err) {
          self.error(
              'Failed to stat submodule: ' + __dirname + '/' + name[i]);
          console.error(err);
          output.push('(' + name[i] + ': failed to stat)');
        }
      }
      reloadSingle(name[i]);
    }
    /**
     * Actually trigger the reload process for a single submodule.
     * @private
     *
     * @param {string} name The submodule name to reload.
     */
    function reloadSingle(name) {
      self.unload(name, opts, (err) => {
        if (err) {
          output.push(name + ': ' + err);
          done();
          return;
        }
        self.load(name, opts, (err2) => {
          if (err2) {
            output.push(name + ': ' + err2);
            done();
            return;
          }
          output.push(name + ': `Success`');
          done();
        });
      });
    }
    /**
     * Called when a submodule's reload process is completed. Fires main
     * callback once all submodules reloads have been completed.
     * @private
     */
    function done() {
      numComplete++;
      if (numComplete != numTotal) return;
      cb(output);
    }
  };

  /**
   * Reload all sub modules by unloading then re-requiring.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#reload
   */
  function commandReload(msg) {
    if (trustedIds.includes(msg.author.id)) {
      let toReload = msg.text.split(' ').splice(1);
      const opts = {};
      toReload = toReload.filter((el) => {
        switch (el) {
          case '--force':
            opts.force = true;
            return false;
          case '--no-schedule':
            opts.ignoreUnloadable = true;
            return false;
          case '--immediate':
            opts.schedule = false;
            return false;
          default:
            return true;
        }
      });
      self.common
          .reply(
              msg, 'Reloading modules... (waiting until users ' +
                  'won\'t notice interruption)')
          .then((warnMessage) => {
            self.reload(toReload, opts, (out) => {
              const embed = new self.Discord.MessageEmbed();
              embed.setTitle('Reload complete.');
              embed.setColor([255, 0, 255]);
              embed.setDescription(out.join('\n') || 'NOTHING reloaded');
              warnMessage.edit(self.common.mention(msg), embed);
            });
          });
    } else {
      self.common.reply(
          msg, 'LOL! Good try!',
          'It appears SpikeyRobot doesn\'t trust you enough with this ' +
              'command. Sorry!');
    }
  }

  /**
   * Unload specific sub modules.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#unload
   */
  function commandUnload(msg) {
    if (trustedIds.includes(msg.author.id)) {
      let toUnload = msg.text.split(' ').splice(1);
      const opts = {};
      toUnload = toUnload.filter((el) => {
        switch (el) {
          case 'force':
            opts.force = true;
            return false;
          case 'no-schedule':
            opts.ignoreUnloadable = true;
            return false;
          case 'immediate':
            opts.schedule = false;
            return false;
          default:
            return true;
        }
      });
      self.common.reply(msg, 'Unloading modules...').then((warnMessage) => {
        const numTotal = toUnload.length;
        let numComplete = 0;
        const outs = [];
        for (let i = 0; i &lt; numTotal; i++) {
          unloadSingle(toUnload[i]);
        }
        /**
         * Begins actually loading a module.
         * @private
         *
         * @param {string} name The name of the module.
         */
        function unloadSingle(name) {
          self.unload(name, opts, (out) => {
            outs.push(name + ': ' + (out || 'Success'));
            done();
          });
        }
        /**
         * Triggered on each completed action.
         * @private
         */
        function done() {
          numComplete++;
          if (numComplete &lt; numTotal) return;
          const embed = new self.Discord.MessageEmbed();
          embed.setTitle('Unload complete.');
          embed.setColor([255, 0, 255]);
          embed.setDescription(outs.join(' ') || 'NOTHING unloaded');
          warnMessage.edit(self.common.mention(msg), embed);
        }
        if (numTotal == 0) done();
      });
    } else {
      self.common.reply(
          msg, 'LOL! Good try!',
          'It appears SpikeyRobot doesn\'t trust you enough with this ' +
              'command. Sorry!');
    }
  }

  /**
   * Load specific sub modules.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#load
   */
  function commandLoad(msg) {
    if (trustedIds.includes(msg.author.id)) {
      const toLoad = msg.text.split(' ').splice(1);
      self.common.reply(msg, 'Loading modules...').then((warnMessage) => {
        const numTotal = toLoad.length;
        let numComplete = 0;
        const outs = [];
        for (let i = 0; i &lt; numTotal; i++) {
          loadSingle(toLoad[i]);
        }
        /**
         * Begins actually loading a module.
         * @private
         * @param {string} name The name of the subModule.
         */
        function loadSingle(name) {
          self.load(name, null, (out) => {
            outs.push(name + ': ' + (out || 'Success'));
            done();
          });
        }
        /**
         * Triggered on each completed action.
         * @private
         */
        function done() {
          numComplete++;
          if (numComplete &lt; numTotal) return;
          const embed = new self.Discord.MessageEmbed();
          embed.setTitle('Load complete.');
          embed.setColor([255, 0, 255]);
          embed.setDescription(outs.join(' ') || 'NOTHING loaded');
          warnMessage.edit(self.common.mention(msg), embed);
        }
        if (numTotal == 0) done();
      });
    } else {
      self.common.reply(
          msg, 'LOL! Good try!',
          'It appears SpikeyRobot doesn\'t trust you enough with this ' +
              'command. Sorry!');
    }
  }

  /**
   * Send help message to user who requested it.
   *
   * @private
   * @type {Command~commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#help
   */
  function commandHelp(msg) {
    let error = false;
    /**
     * Send the help message.
     * @private
     * @param {Discord~MessageEmbed} help THe message to send.
     */
    function send(help) {
      msg.author.send(help).catch((err) => {
        if (msg.guild !== null &amp;&amp; !error) {
          error = true;
          self.common
              .reply(
                  msg, 'Oops! I wasn\'t able to send you the help!\n' +
                      'Did you block me?',
                  err.message)
              .catch(() => {});
          self.error(
              'Failed to send help message in DM to user: ' + msg.author.id +
              ' ' + help.title);
          console.error(err);
        }
      });
    }
    try {
      for (const i in subModules) {
        if (!(subModules[i] instanceof Object) || !subModules[i].helpMessage) {
          continue;
        }
        if (!Array.isArray(subModules[i].helpMessage)) {
          subModules[i].helpMessage = [subModules[i].helpMessage];
        }
        subModules[i].helpMessage.forEach(send);
      }
      if (msg.guild !== null) {
        self.common
            .reply(
                msg, helpmessagereply,
                'Tip: https://www.spikeybot.com/help/ also has more ' +
                    'information.')
            .catch((err) => {
              self.error(
                  'Unable to reply to help command in channel: ' +
                  msg.channel.id);
              console.log(err);
            });
      }
    } catch (err) {
      self.common.reply(msg, blockedmessage);
      self.error('An error occured while sending help message!');
      console.error(err);
    }
  }


  /**
   * Check current loaded submodule commit to last modified commit, and reload
   * if the file has changed.
   *
   * @public
   */
  toAssign.client.reloadUpdatedSubModules = function() {
    try {
      self.log('Reloading updated submodules.');
      for (let i = 0; i &lt; subModuleNames.length; i++) {
        childProcess
            .exec(
                'git diff-index --quiet ' +
                subModules[subModuleNames[i]].commit + ' -- ./src/' +
                subModuleNames[i])
            .on('close', ((name) => {
              return (code, signal) => {
                if (code) {
                  self.reload(name, {force: true}, (out) => {
                    self.log(out.join(' '));
                  });
                } else {
                  self.debug(name + ' unchanged (' + code + ')');
                }
              };
            })(subModuleNames[i]));
      }
    } catch (err) {
      self.error('Failed to reload updated submodules!');
      console.error(err);
    }
  };
}
module.exports = new SMLoader();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-lib_twemojiChecker.html">lib/twemojiChecker</a></li></ul><h3>Classes</h3><ul><li><a href="ChatBot.html">ChatBot</a></li><li><a href="CmdScheduling.html">CmdScheduling</a></li><li><a href="CmdScheduling-ScheduledCommand.html">CmdScheduling~ScheduledCommand</a></li><li><a href="Command.html">Command</a></li><li><a href="Command-CommandSetting.html">Command~CommandSetting</a></li><li><a href="Command-SingleCommand.html">Command~SingleCommand</a></li><li><a href="Common.html">Common</a></li><li><a href="Connect4.html">Connect4</a></li><li><a href="Connect4_Game.html">Connect4#Game</a></li><li><a href="Define.html">Define</a></li><li><a href="DevCmds.html">DevCmds</a></li><li><a href="FunTranslators.html">FunTranslators</a></li><li><a href="HGWeb.html">HGWeb</a></li><li><a href="HungryGames.html">HungryGames</a></li><li><a href="HungryGames-ArenaEvent.html">HungryGames~ArenaEvent</a></li><li><a href="HungryGames-Day.html">HungryGames~Day</a></li><li><a href="HungryGames-Event.html">HungryGames~Event</a></li><li><a href="HungryGames-Event-Battle.html">HungryGames~Event~Battle</a></li><li><a href="HungryGames-ForcedOutcome.html">HungryGames~ForcedOutcome</a></li><li><a href="HungryGames-Game.html">HungryGames~Game</a></li><li><a href="HungryGames-GuildGame.html">HungryGames~GuildGame</a></li><li><a href="HungryGames-NPC.html">HungryGames~NPC</a></li><li><a href="HungryGames-OutcomeProbabilities.html">HungryGames~OutcomeProbabilities</a></li><li><a href="HungryGames-Player.html">HungryGames~Player</a></li><li><a href="HungryGames-Team.html">HungryGames~Team</a></li><li><a href="HungryGames-WeaponEvent.html">HungryGames~WeaponEvent</a></li><li><a href="Main.html">Main</a></li><li><a href="MainModule.html">MainModule</a></li><li><a href="Music.html">Music</a></li><li><a href="Patreon.html">Patreon</a></li><li><a href="Patreon-toExport.html">Patreon~toExport</a></li><li><a href="Polling.html">Polling</a></li><li><a href="Polling-Poll.html">Polling~Poll</a></li><li><a href="RoleColors.html">RoleColors</a></li><li><a href="RoleManager.html">RoleManager</a></li><li><a href="Sandbox.html">Sandbox</a></li><li><a href="SMLoader.html">SMLoader</a></li><li><a href="SpikeyBot.html">SpikeyBot</a></li><li><a href="Spotify.html">Spotify</a></li><li><a href="SubModule.html">SubModule</a></li><li><a href="TicTacToe.html">TicTacToe</a></li><li><a href="TicTacToe_Game.html">TicTacToe#Game</a></li><li><a href="TTS.html">TTS</a></li><li><a href="Uno.html">Uno</a></li><li><a href="Uno_Card.html">Uno#Card</a></li><li><a href="Uno_Game.html">Uno#Game</a></li><li><a href="WebAccount.html">WebAccount</a></li><li><a href="WebCommands.html">WebCommands</a></li><li><a href="WebProxy.html">WebProxy</a></li><li><a href="WebSettings.html">WebSettings</a></li><li><a href="WebStats.html">WebStats</a></li></ul><h3>Global</h3><ul><li><a href="global.html#__stack">__stack</a></li><li><a href="global.html#autoPlay">autoPlay</a></li><li><a href="global.html#consumable">consumable</a></li><li><a href="global.html#currentGame">currentGame</a></li><li><a href="global.html#customEvents">customEvents</a></li><li><a href="global.html#day">day</a></li><li><a href="global.html#disabledEvents">disabledEvents</a></li><li><a href="global.html#ended">ended</a></li><li><a href="global.html#events">events</a></li><li><a href="global.html#excludedNPCs">excludedNPCs</a></li><li><a href="global.html#excludedUsers">excludedUsers</a></li><li><a href="global.html#forcedOutcomes">forcedOutcomes</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#includedNPCs">includedNPCs</a></li><li><a href="global.html#includedUsers">includedUsers</a></li><li><a href="global.html#inProgress">inProgress</a></li><li><a href="global.html#kill">kill</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html#message">message</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nothing">nothing</a></li><li><a href="global.html#num">num</a></li><li><a href="global.html#numAlive">numAlive</a></li><li><a href="global.html#options">options</a></li><li><a href="global.html#outcomeProbs">outcomeProbs</a></li><li><a href="global.html#outcomes">outcomes</a></li><li><a href="global.html#persists">persists</a></li><li><a href="global.html#revive">revive</a></li><li><a href="global.html#state">state</a></li><li><a href="global.html#teams">teams</a></li><li><a href="global.html#text">text</a></li><li><a href="global.html#thrive">thrive</a></li><li><a href="global.html#unhandledRejection">unhandledRejection</a></li><li><a href="global.html#wound">wound</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Apr 11 2019 16:09:16 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
