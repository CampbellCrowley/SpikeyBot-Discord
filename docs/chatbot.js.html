<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: chatbot.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: chatbot.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Copyright 2018-2019 Campbell Crowley. All rights reserved.
// Author: Campbell Crowley (dev@campbellcrowley.com)
const dialogflow = require('dialogflow');
const auth = require('../auth.js');
const fs = require('fs');
const mkdirp = require('mkdirp');
require('./subModule.js')(ChatBot);  // Extends the SubModule class.

/**
 * @classdesc Manages natural language interaction.
 * @class
 * @augments SubModule
 * @listens Discord#message
 * @listens Command#chat
 */
function ChatBot() {
  const self = this;
  /** @inheritdoc */
  this.myName = 'ChatBot';

  /**
   * The guilds that have disabled the chatbot feature.
   * @private
   * @type {Object.&lt;boolean>}
   */
  const disabledChatBot = {};

  /** @inheritdoc */
  this.initialize = function() {
    self.command.on('chat', onChatMessage);
    self.command.on(
        new self.command.SingleCommand(
            'togglechatbot', commandToggleChatBot,
            new self.command.CommandSetting({
              validOnlyInGuild: true,
              defaultDisabled: true,
              permissions: self.Discord.Permissions.FLAGS.MANAGE_ROLES |
                  self.Discord.Permissions.FLAGS.MANAGE_GUILD |
                  self.Discord.Permissions.FLAGS.BAN_MEMBERS,
            })));

    self.client.on('message', onMessage);

    if (self.bot.getBotName()) {
      process.env.GOOGLE_APPLICATION_CREDENTIALS =
          './gApiCredentials-' + self.bot.getBotName() + '.json';
    } else {
      process.env.GOOGLE_APPLICATION_CREDENTIALS = './gApiCredentials.json';
    }

    sessionClient = new dialogflow.SessionsClient();

    self.client.guilds.forEach(function(g) {
      fs.readFile(
          self.common.guildSaveDir + g.id + '/chatbot-config.json',
          function(err, file) {
            if (err) return;
            let parsed;
            try {
              parsed = JSON.parse(file);
            } catch (e) {
              return;
            }
            disabledChatBot[g.id] = parsed.disabledChatBot || false;
          });
    });
  };
  /** @inheritdoc */
  this.shutdown = function() {
    self.command.deleteEvent('chat');
    self.command.deleteEvent('togglechatbot');
    self.client.removeListener('message', onMessage);
  };
  /**
   * @override
   * @inheritdoc
   */
  this.save = function(opt) {
    self.client.guilds.forEach(function(g) {
      const dir = self.common.guildSaveDir + g.id;
      const filename = dir + '/chatbot-config.json';
      const obj = {
        disabledChatBot: disabledChatBot[g.id],
      };
      if (opt == 'async') {
        mkAndWrite(filename, dir, JSON.stringify(obj));
      } else {
        mkAndWriteSync(filename, dir, JSON.stringify(obj));
      }
    });
  };

  /**
   * Write data to a file and make sure the directory exists or create it if it
   * doesn't. Async.
   *
   * @see {@link Main~mkAndWriteSync}
   *
   * @private
   * @param {string} filename The name of the file including the directory.
   * @param {string} dir The directory path without the file's name.
   * @param {string} data The data to write to the file.
   */
  function mkAndWrite(filename, dir, data) {
    mkdirp(dir, function(err) {
      if (err) {
        self.error('Failed to make directory: ' + dir, 'Main');
        console.error(err);
        return;
      }
      fs.writeFile(filename, data, function(err2) {
        if (err2) {
          self.error('Failed to save timer: ' + filename, 'Main');
          console.error(err2);
          return;
        }
      });
    });
  }
  /**
   * Write data to a file and make sure the directory exists or create it if it
   * doesn't. Synchronous.
   *
   * @see {@link Main~mkAndWrite}
   *
   * @private
   * @param {string} filename The name of the file including the directory.
   * @param {string} dir The directory path without the file's name.
   * @param {string} data The data to write to the file.
   */
  function mkAndWriteSync(filename, dir, data) {
    try {
      mkdirp.sync(dir);
    } catch (err) {
      self.error('Failed to make directory: ' + dir, 'Main');
      console.error(err);
      return;
    }
    try {
      fs.writeFileSync(filename, data);
    } catch (err) {
      self.error('Failed to save timer: ' + filename, 'Main');
      console.error(err);
      return;
    }
  }

  let sessionClient;

  const reqTemplate = {
    session: 'default-session',
    queryInput: {
      text: {
        text: 'Hello World!',
        languageCode: 'en-US',
      },
    },
  };

  /**
   * Respond to messages where I've been mentioned.
   *
   * @private
   * @param {Discord~Message} msg Message was sent.
   * @listens Discord#message
   */
  function onMessage(msg) {
    if (msg.guild &amp;&amp; disabledChatBot[msg.guild.id]) return;
    msg.prefix = self.bot.getPrefix(msg.guild);
    if (!msg.author.bot &amp;&amp; msg.guild &amp;&amp;
        msg.mentions.users.get(self.client.user.id) &amp;&amp;
        !self.command.find(msg.content.match(/^\S+/)[0], msg)) {
      const withoutMe =
          msg.content
              .replace(
                  new RegExp('\\s*&lt;@!?' + self.client.user.id + '>\\s*'), '')
              .trim();
      if (!withoutMe || withoutMe.length &lt; 2) {
        return;
      }
      self.log(msg.channel.id + '@' + msg.author.id + ' ' + msg.content);
      msg.text = ' ' +
          msg.cleanContent
              .replace(
                  new RegExp(
                      '@' + escapeRegExp(
                          msg.guild.me.nickname ||
                                self.client.user.username),
                      'g'),
                  'SpikeyBot')
              .trim();
      onChatMessage(msg);
    }
  }

  /**
   * Send message text content to dialogflow for handling.
   *
   * @private
   * @type {commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#chat
   */
  function onChatMessage(msg) {
    if (msg.guild &amp;&amp; disabledChatBot[msg.guild.id]) return;
    const perms =
        (msg.channel.permissionsFor &amp;&amp;
         msg.channel.permissionsFor(self.client.user));
    if (perms &amp;&amp; !perms.has(self.Discord.Permissions.FLAGS.SEND_MESSAGES)) {
      return;
    }
    if (!msg.text || msg.text.length &lt; 2) return;
    const request = Object.assign({}, reqTemplate);
    request.session = sessionClient.sessionPath(
        auth['dialogflowProjectId' + (self.bot.getBotName() || '')],
        msg.channel.id);
    request.queryInput.text.text = msg.text.slice(1);

    if (request.queryInput.text.text.length > 256) {
      request.queryInput.text.text =
          request.queryInput.text.text.substr(0, 256);
    }

    // msg.channel.startTyping().catch(() => {});

    const startTime = Date.now();

    sessionClient.detectIntent(request)
        .then((responses) => {
          self.debug(
              'Dialogflow response delay: ' + (Date.now() - startTime) + 'ms');
          // msg.channel.stopTyping();
          // console.log('Intent');
          const result = responses[0].queryResult;
          if (result.parameters.fields.thing) {
            const list = result.parameters.fields.thing.listValue.values;
            const chosen =
                list[Math.floor(list.length * Math.random())].stringValue;
            result.fulfillmentText =
                result.fulfillmentText.replace(/~thing/g, chosen);
          }
          /* console.log(`  Query: ${result.queryText}`);
          console.log(`  Response: ${result.fulfillmentText}`);
          if (result.intent) {
            console.log(`  Intent: ${result.intent.displayName}`);
          } else {
            console.log(`  No intent matched.`);
          } */
          if (result.fulfillmentText) {
            msg.channel.send(result.fulfillmentText.replace(/\\n/g, '\n'))
                .catch((err) => {
                  self.error(
                      'Unable to reply to chat message: ' + msg.channel.id);
                  console.error(err);
                });
          }
          if (result.parameters.fields.loopback) {
            msg.text = result.parameters.fields.loopback.stringValue;
            onChatMessage(msg);
          }
          if (result.parameters.fields.command) {
            let cmd = result.parameters.fields.command.stringValue.replace(
                /^command /, msg.prefix);
            // Replace parameters in the command with the values matched by
            // dialogflow.
            Object.entries(result.parameters.fields).forEach((el) => {
              if (el[0] == 'command') return;
              cmd = cmd.replace(
                  new RegExp(escapeRegExp('$' + el[0]), 'g'),
                  el[1].stringValue);
            });

            self.log('Triggered command: ' + cmd);
            msg.content = cmd;
            if (!self.command.trigger(msg)) {
              self.warn('Command "' + cmd + '" failed!');
            }
          }
        })
        .catch((err) => {
          self.debug(
              'Dialogflow response delay: ' + (Date.now() - startTime) + 'ms');
          self.error('Dialogflow failed request: ' + JSON.stringify(request));
          console.error('ERROR:', err);
          // msg.channel.stopTyping();
          msg.channel.send('Failed to contact DialogFlow: ' + err.details);
        });
  }

  /**
   * Toggles the chatbot feature on a guild.
   *
   * @private
   * @type {commandHandler}
   * @param {Discord~Message} msg Message that triggered command.
   * @listens Command#togglechatbot
   */
  function commandToggleChatBot(msg) {
    if (disabledChatBot[msg.guild.id]) {
      disabledChatBot[msg.guild.id] = false;
      self.common.reply(msg, 'Enabled chatbot feature.');
    } else {
      disabledChatBot[msg.guild.id] = true;
      self.common.reply(msg, 'Disabled chatbot feature.');
    }
  }

  /**
   * Escape a given string to be passed into a regular expression.
   *
   * @private
   *
   * @param {string} str Input to escape.
   * @returns {string} Escaped string.
   */
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&amp;');
  }
}
module.exports = new ChatBot();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-lib_twemojiChecker.html">lib/twemojiChecker</a></li></ul><h3>Externals</h3><ul><li><a href="external-Discord.html">external:Discord</a></li></ul><h3>Classes</h3><ul><li><a href="ChatBot.html">ChatBot</a></li><li><a href="CmdScheduling.html">CmdScheduling</a></li><li><a href="CmdScheduling-ScheduledCommand.html">CmdScheduling~ScheduledCommand</a></li><li><a href="Command.html">Command</a></li><li><a href="Command-CommandSetting.html">Command~CommandSetting</a></li><li><a href="Command-SingleCommand.html">Command~SingleCommand</a></li><li><a href="Common.html">Common</a></li><li><a href="Connect4.html">Connect4</a></li><li><a href="Connect4_Game.html">Connect4#Game</a></li><li><a href="Define.html">Define</a></li><li><a href="DevCmds.html">DevCmds</a></li><li><a href="FunTranslators.html">FunTranslators</a></li><li><a href="HG.html">HG</a></li><li><a href="HGWeb.html">HGWeb</a></li><li><a href="HungryGames.html">HungryGames</a></li><li><a href="HungryGames-ArenaEvent.html">HungryGames~ArenaEvent</a></li><li><a href="HungryGames-Battle.html">HungryGames~Battle</a></li><li><a href="HungryGames-Day.html">HungryGames~Day</a></li><li><a href="HungryGames-DefaultOptions.html">HungryGames~DefaultOptions</a></li><li><a href="HungryGames-DefaultOptions-BooleanOption.html">HungryGames~DefaultOptions~BooleanOption</a></li><li><a href="HungryGames-DefaultOptions-NumberOption.html">HungryGames~DefaultOptions~NumberOption</a></li><li><a href="HungryGames-DefaultOptions-ObjectOption.html">HungryGames~DefaultOptions~ObjectOption</a></li><li><a href="HungryGames-DefaultOptions-Option.html">HungryGames~DefaultOptions~Option</a></li><li><a href="HungryGames-DefaultOptions-SelectOption.html">HungryGames~DefaultOptions~SelectOption</a></li><li><a href="HungryGames-Event.html">HungryGames~Event</a></li><li><a href="HungryGames-FinalEvent.html">HungryGames~FinalEvent</a></li><li><a href="HungryGames-ForcedOutcome.html">HungryGames~ForcedOutcome</a></li><li><a href="HungryGames-Game.html">HungryGames~Game</a></li><li><a href="HungryGames-Grammar.html">HungryGames~Grammar</a></li><li><a href="HungryGames-GuildGame.html">HungryGames~GuildGame</a></li><li><a href="HungryGames-Messages.html">HungryGames~Messages</a></li><li><a href="HungryGames-OutcomeProbabilities.html">HungryGames~OutcomeProbabilities</a></li><li><a href="HungryGames-Player.html">HungryGames~Player</a></li><li><a href="HungryGames-Simulator.html">HungryGames~Simulator</a></li><li><a href="HungryGames-Simulator-Worker.html">HungryGames~Simulator~Worker</a></li><li><a href="HungryGames-Team.html">HungryGames~Team</a></li><li><a href="HungryGames-UserIconUrl.html">HungryGames~UserIconUrl</a></li><li><a href="HungryGames-WeaponEvent.html">HungryGames~WeaponEvent</a></li><li><a href="Main.html">Main</a></li><li><a href="MainModule.html">MainModule</a></li><li><a href="Messages.html">Messages</a></li><li><a href="Music.html">Music</a></li><li><a href="NPC.html">NPC</a></li><li><a href="Patreon.html">Patreon</a></li><li><a href="Patreon-toExport.html">Patreon~toExport</a></li><li><a href="Polling.html">Polling</a></li><li><a href="Polling-Poll.html">Polling~Poll</a></li><li><a href="RoleColors.html">RoleColors</a></li><li><a href="RoleManager.html">RoleManager</a></li><li><a href="Sandbox.html">Sandbox</a></li><li><a href="SMLoader.html">SMLoader</a></li><li><a href="SpikeyBot.html">SpikeyBot</a></li><li><a href="Spotify.html">Spotify</a></li><li><a href="SubModule.html">SubModule</a></li><li><a href="TicTacToe.html">TicTacToe</a></li><li><a href="TicTacToe_Game.html">TicTacToe#Game</a></li><li><a href="TTS.html">TTS</a></li><li><a href="Uno.html">Uno</a></li><li><a href="Uno_Card.html">Uno#Card</a></li><li><a href="Uno_Game.html">Uno#Game</a></li><li><a href="WebAccount.html">WebAccount</a></li><li><a href="WebCommands.html">WebCommands</a></li><li><a href="WebProxy.html">WebProxy</a></li><li><a href="WebSettings.html">WebSettings</a></li><li><a href="WebStats.html">WebStats</a></li></ul><h3>Global</h3><ul><li><a href="global.html#__stack">__stack</a></li><li><a href="global.html#self">self</a></li><li><a href="global.html#unhandledRejection">unhandledRejection</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Apr 19 2019 12:21:16 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
