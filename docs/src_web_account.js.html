<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>SpikeyBot-Discord Source: src/web/account.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.slate.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">SpikeyBot-Discord</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-lib_twemojiChecker.html">lib/twemojiChecker</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="ApiEndpoint.html">ApiEndpoint</a></li><li><a href="ApiRequestBody.html">ApiRequestBody</a></li><li><a href="BotCommands.html">BotCommands</a></li><li><a href="ChatBot.html">ChatBot</a></li><li><a href="CmdScheduling.html">CmdScheduling</a></li><li><a href="CmdScheduling-ScheduledCommand.html">CmdScheduling~ScheduledCommand</a></li><li><a href="Command.html">Command</a></li><li><a href="Command-CommandSetting.html">Command~CommandSetting</a></li><li><a href="Command-SingleCommand.html">Command~SingleCommand</a></li><li><a href="Common.html">Common</a></li><li><a href="Connect4.html">Connect4</a></li><li><a href="Connect4_Game.html">Connect4#Game</a></li><li><a href="CpuWatcher.html">CpuWatcher</a></li><li><a href="Define.html">Define</a></li><li><a href="DevCmds.html">DevCmds</a></li><li><a href="Echo.html">Echo</a></li><li><a href="Echo-Character.html">Echo~Character</a></li><li><a href="EE.html">EE</a></li><li><a href="EventEmitter.html">EventEmitter</a></li><li><a href="Events.html">Events</a></li><li><a href="FileServer.html">FileServer</a></li><li><a href="FunTranslators.html">FunTranslators</a></li><li><a href="HG.html">HG</a></li><li><a href="HGWeb.html">HGWeb</a></li><li><a href="HungryGames.html">HungryGames</a></li><li><a href="HungryGames-Action.html">HungryGames~Action</a></li><li><a href="HungryGames-ActionManager.html">HungryGames~ActionManager</a></li><li><a href="HungryGames-ActionStore.html">HungryGames~ActionStore</a></li><li><a href="HungryGames-Action-GiveRoleAction.html">HungryGames~Action~GiveRoleAction</a></li><li><a href="HungryGames-Action-RunCommandAction.html">HungryGames~Action~RunCommandAction</a></li><li><a href="HungryGames-Action-SendAutoplayingMessageAlertAction.html">HungryGames~Action~SendAutoplayingMessageAlertAction</a></li><li><a href="HungryGames-Action-SendDayEndMessageAction.html">HungryGames~Action~SendDayEndMessageAction</a></li><li><a href="HungryGames-Action-SendDayStartMessageAction.html">HungryGames~Action~SendDayStartMessageAction</a></li><li><a href="HungryGames-Action-SendEventMessageAction.html">HungryGames~Action~SendEventMessageAction</a></li><li><a href="HungryGames-Action-SendMessageAction.html">HungryGames~Action~SendMessageAction</a></li><li><a href="HungryGames-Action-SendPlayerRankMessageAction.html">HungryGames~Action~SendPlayerRankMessageAction</a></li><li><a href="HungryGames-Action-SendStatusListAction.html">HungryGames~Action~SendStatusListAction</a></li><li><a href="HungryGames-Action-SendTeamRankMessageAction.html">HungryGames~Action~SendTeamRankMessageAction</a></li><li><a href="HungryGames-Action-SendVictorAction.html">HungryGames~Action~SendVictorAction</a></li><li><a href="HungryGames-Action-TakeRoleAction.html">HungryGames~Action~TakeRoleAction</a></li><li><a href="HungryGames-ArenaEvent.html">HungryGames~ArenaEvent</a></li><li><a href="HungryGames-Battle.html">HungryGames~Battle</a></li><li><a href="HungryGames-ChannelAction.html">HungryGames~ChannelAction</a></li><li><a href="HungryGames-Day.html">HungryGames~Day</a></li><li><a href="HungryGames-DefaultOptions.html">HungryGames~DefaultOptions</a></li><li><a href="HungryGames-DefaultOptions-BooleanOption.html">HungryGames~DefaultOptions~BooleanOption</a></li><li><a href="HungryGames-DefaultOptions-NumberOption.html">HungryGames~DefaultOptions~NumberOption</a></li><li><a href="HungryGames-DefaultOptions-ObjectOption.html">HungryGames~DefaultOptions~ObjectOption</a></li><li><a href="HungryGames-DefaultOptions-Option.html">HungryGames~DefaultOptions~Option</a></li><li><a href="HungryGames-DefaultOptions-SelectOption.html">HungryGames~DefaultOptions~SelectOption</a></li><li><a href="HungryGames-Event.html">HungryGames~Event</a></li><li><a href="HungryGames-EventContainer.html">HungryGames~EventContainer</a></li><li><a href="HungryGames-FinalEvent.html">HungryGames~FinalEvent</a></li><li><a href="HungryGames-ForcedOutcome.html">HungryGames~ForcedOutcome</a></li><li><a href="HungryGames-Game.html">HungryGames~Game</a></li><li><a href="HungryGames-Grammar.html">HungryGames~Grammar</a></li><li><a href="HungryGames-GuildGame.html">HungryGames~GuildGame</a></li><li><a href="HungryGames-MemberAction.html">HungryGames~MemberAction</a></li><li><a href="HungryGames-Messages.html">HungryGames~Messages</a></li><li><a href="HungryGames-NormalEvent.html">HungryGames~NormalEvent</a></li><li><a href="HungryGames-OutcomeProbabilities.html">HungryGames~OutcomeProbabilities</a></li><li><a href="HungryGames-Player.html">HungryGames~Player</a></li><li><a href="HungryGames-Simulator.html">HungryGames~Simulator</a></li><li><a href="HungryGames-Simulator-Worker.html">HungryGames~Simulator~Worker</a></li><li><a href="HungryGames-StatGroup.html">HungryGames~StatGroup</a></li><li><a href="HungryGames-StatManager.html">HungryGames~StatManager</a></li><li><a href="HungryGames-Stats.html">HungryGames~Stats</a></li><li><a href="HungryGames-Team.html">HungryGames~Team</a></li><li><a href="HungryGames-UserIconUrl.html">HungryGames~UserIconUrl</a></li><li><a href="HungryGames-WeaponEvent.html">HungryGames~WeaponEvent</a></li><li><a href="Images.html">Images</a></li><li><a href="LocaleManager.html">LocaleManager</a></li><li><a href="Main.html">Main</a></li><li><a href="MainModule.html">MainModule</a></li><li><a href="MemWatcher.html">MemWatcher</a></li><li><a href="MessageMaker.html">MessageMaker</a></li><li><a href="Messages.html">Messages</a></li><li><a href="Moderation.html">Moderation</a></li><li><a href="ModLog.html">ModLog</a></li><li><a href="ModLog-Settings.html">ModLog~Settings</a></li><li><a href="Music.html">Music</a></li><li><a href="NPC.html">NPC</a></li><li><a href="Patreon.html">Patreon</a></li><li><a href="Patreon-toExport.html">Patreon~toExport</a></li><li><a href="Pets.html">Pets</a></li><li><a href="Pets-BaseMoves.html">Pets~BaseMoves</a></li><li><a href="Pets-BasePetClasses.html">Pets~BasePetClasses</a></li><li><a href="Pets-BasePets.html">Pets~BasePets</a></li><li><a href="Pets-Constants.html">Pets~Constants</a></li><li><a href="Pets-NPC.html">Pets~NPC</a></li><li><a href="Pets-Pet.html">Pets~Pet</a></li><li><a href="Polling.html">Polling</a></li><li><a href="Polling-Poll.html">Polling~Poll</a></li><li><a href="RaidBlock.html">RaidBlock</a></li><li><a href="RaidBlock-RaidSettings.html">RaidBlock~RaidSettings</a></li><li><a href="RoleColors.html">RoleColors</a></li><li><a href="RoleManager.html">RoleManager</a></li><li><a href="Sandbox.html">Sandbox</a></li><li><a href="ShardingMaster.html">ShardingMaster</a></li><li><a href="ShardingMaster.ShardInfo.html">ShardingMaster.ShardInfo</a></li><li><a href="ShardingMaster.ShardMasterConfig.html">ShardingMaster.ShardMasterConfig</a></li><li><a href="ShardingMaster.ShardMasterConfig.HeartbeatConfig.html">ShardingMaster.ShardMasterConfig.HeartbeatConfig</a></li><li><a href="ShardingMaster.ShardMasterConfig.MailConfig.html">ShardingMaster.ShardMasterConfig.MailConfig</a></li><li><a href="ShardingMaster.ShardStatus.html">ShardingMaster.ShardStatus</a></li><li><a href="ShardingSlave.html">ShardingSlave</a></li><li><a href="SMLoader.html">SMLoader</a></li><li><a href="SpikeyBot.html">SpikeyBot</a></li><li><a href="Spotify.html">Spotify</a></li><li><a href="Strings.html">Strings</a></li><li><a href="Strings-Locale.html">Strings~Locale</a></li><li><a href="SubModule.html">SubModule</a></li><li><a href="TicTacToe.html">TicTacToe</a></li><li><a href="TicTacToe_Game.html">TicTacToe#Game</a></li><li><a href="TTS.html">TTS</a></li><li><a href="Twitch.html">Twitch</a></li><li><a href="Uno.html">Uno</a></li><li><a href="Uno_Card.html">Uno#Card</a></li><li><a href="Uno_Game.html">Uno#Game</a></li><li><a href="WebAccount.html">WebAccount</a></li><li><a href="WebApi.html">WebApi</a></li><li><a href="WebProxy.html">WebProxy</a></li><li><a href="WebSettings.html">WebSettings</a></li><li><a href="WebStats.html">WebStats</a></li><li><a href="WebUserData.html">WebUserData</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="global.html#__stack">__stack</a></li><li><a href="global.html#_handler">_handler</a></li><li><a href="global.html#_saveData">_saveData</a></li><li><a href="global.html#addListener">addListener</a></li><li><a href="global.html#clearEvent">clearEvent</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createProxyServer">createProxyServer</a></li><li><a href="global.html#createRightProxy">createRightProxy</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#hasPort">hasPort</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#self">self</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#sqlCon">sqlCon</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#unhandledRejection">unhandledRejection</a></li><li><a href="global.html#useColors">useColors</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="externals.list.html" class="dropdown-toggle" data-toggle="dropdown">Externals<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="external-Discord.html">Discord</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: src/web/account.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">// Copyright 2018-2020 Campbell Crowley. All rights reserved.
// Author: Campbell Crowley (web@campbellcrowley.com)
const fs = require('fs');
const http = require('http');
const https = require('https');
const socketIo = require('socket.io');
const auth = require('../../auth.js');
const patreon = require('patreon');
const mkdirp = require('mkdirp'); // mkdir -p
const querystring = require('querystring');
const crypto = require('crypto');

const PATREON_CLIENT_ID = auth.patreonClientId;
const PATREON_CLIENT_SECRET = auth.patreonClientSecret;
const redirectURL = 'https://www.spikeybot.com/redirect/';

const patreonAPI = patreon.patreon;
const patreonOAuthClient =
    patreon.oauth(PATREON_CLIENT_ID, PATREON_CLIENT_SECRET);

require('../subModule.js').extend(WebAccount);  // Extends the SubModule class.

/**
 * @classdesc Manages the account webpage.
 * @class
 * @augments SubModule
 */
function WebAccount() {
  const self = this;
  this.myName = 'WebAccount';

  let app;
  let io;
  if (!self.common.isSlave) {
    app = http.createServer(handler);
    io = socketIo(app, {path: '/socket.io/'});
    io.on('connection', socketConnection);

    app.on('error', function(err) {
      if (err.code === 'EADDRINUSE') {
        self.debug(
            'Accounts failed to bind to port because it is in use. (' +
            err.port + ')');
        self.shutdown(true);
      } else {
        self.error('Account failed to bind to port for unknown reason.', err);
      }
    });
  }

  /**
   * The filename in the user's directory of the file where the settings related
   * to Patreon rewards are stored.
   *
   * @private
   * @constant
   * @default
   * @type {string}
   */
  const patreonSettingsFilename = '/patreonSettings.json';
  /**
   * File where the template for the Patreon settings is stored.
   *
   * @see {@link WebAccount~patreonSettingsTemplate}
   *
   * @private
   * @constant
   * @default
   * @type {string}
   */
  const patreonSettingsTemplateFile = './save/patreonSettingTemplate.json';
  /**
   * The parsed data from {@link WebAccount~patreonSettingsTemplateFile}. Data
   * that outlines the available options that can be changed, and their possible
   * values.
   *
   * @private
   *
   * @default
   * @type {object.&lt;object>}
   */
  let patreonSettingsTemplate = {};

  const defaultSpotifyTokenReq = {
    protocol: 'https:',
    host: 'accounts.spotify.com',
    path: '/api/token',
    method: 'POST',
    headers: {
      'Authorization':
          'Basic ' + (Buffer.from(auth.spotifyId + ':' + auth.spotifySecret)
              .toString('base64')),
      'Content-Type': 'application/x-www-form-urlencoded',
      'User-Agent': require('../common.js').ua,
    },
  };

  const defaultSpotifyUserReq = {
    protocol: 'https:',
    host: 'api.spotify.com',
    path: '/v1/me',
    method: 'GET',
    headers: {
      'User-Agent': require('../common.js').ua,
    },
  };

  /**
   * Parse template from file.
   *
   * @see {@link WebAccount~patreonSettingsTemplate}
   * @private
   */
  function updatePatreonSettingsTemplate() {
    fs.readFile(patreonSettingsTemplateFile, (err, data) => {
      if (err) {
        self.error('Failed to read ' + patreonSettingsTemplateFile);
        return;
      }
      try {
        const parsed = JSON.parse(data);
        if (!parsed) return;
        patreonSettingsTemplate = parsed;
      } catch (e) {
        self.error('Failed to parse ' + patreonSettingsTemplateFile);
        console.error(e);
      }
    });
  }
  updatePatreonSettingsTemplate();
  fs.watchFile(
      patreonSettingsTemplateFile, {persistent: false}, (curr, prev) => {
        if (curr.mtime == prev.mtime) return;
        if (self.initialized) {
          self.log('Re-reading Patreon setting template information from file');
        } else {
          console.log(
              'WebAccount: Re-reading setting template information from file');
        }
        updatePatreonSettingsTemplate();
      });


  /** @inheritdoc */
  this.initialize = function() {
    if (self.common.isSlave) {
      self.error('WebAccount not starting due to this being a slave shard.');
      return;
    }
    app.listen(self.common.isRelease ? 8014 : 8015, '127.0.0.1');
    self.bot.accounts = toExport;
    self.common.connectSQL();
  };

  const toExport = {};

  /**
   * Causes a full shutdown of all servers.
   *
   * @public
   */
  this.shutdown = function() {
    if (io) io.close();
    if (app) app.close();
    fs.unwatchFile(patreonSettingsTemplateFile);
  };

  /** @inheritdoc */
  this.unloadable = function() {
    return true;
  };

  /**
   * Handler for all http requests. Should never be called.
   *
   * @private
   * @param {http.IncomingMessage} req The client's request.
   * @param {http.ServerResponse} res Our response to the client.
   */
  function handler(req, res) {
    res.writeHead(418);
    res.end('TEAPOT');
  }

  /**
   * Map of all currently connected sockets.
   *
   * @private
   * @type {object.&lt;Socket>}
   */
  const sockets = {};

  /**
   * Handler for a new socket connecting.
   *
   * @private
   * @param {socketIo~Socket} socket The socket.io socket that connected.
   */
  function socketConnection(socket) {
    // x-forwarded-for is trusted because the last process this jumps through is
    // our local proxy.
    const ipName = self.common.getIPName(
        socket.handshake.headers['x-forwarded-for'] ||
        socket.handshake.address);

    self.common.log(
        'Socket connected (' + Object.keys(sockets).length + '): ' + ipName,
        socket.id);
    sockets[socket.id] = socket;

    socket.on('getAccountInfo', (userData, cb) => {
      if (typeof cb !== 'function') {
        self.error('NO CB');
        return;
      }
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      fetchDiscordSQL();
      /**
       * Fetch the Discord table data from our SQL server.
       *
       * @private
       */
      function fetchDiscordSQL() {
        const toSend = global.sqlCon.format(
            'SELECT * FROM Discord WHERE id=? LIMIT 1', [userData.id]);
        global.sqlCon.query(toSend, (err, rows) => {
          if (err) {
            self.error(err);
            cb('Server Error', null);
            return;
          }
          fetchPatreonSQL((rows &amp;&amp; rows[0]) || {});
        });
      }
      /**
       * Fetch the Patreon info from our SQL server.
       *
       * @private
       *
       * @param {object} data The data previously received to add the Patreon
       * info onto.
       */
      function fetchPatreonSQL(data) {
        if (!data.patreonId) {
          fetchSpotifySQL(data);
          return;
        }
        const toSend = global.sqlCon.format(
            'SELECT * FROM Patreon WHERE id=? LIMIT 1', [data.patreonId]);
        global.sqlCon.query(toSend, (err, rows) => {
          if (err) {
            self.error(err);
            cb('Server Error', null);
            return;
          }
          if (rows &amp;&amp; rows.length > 0) {
            data.patreon = rows[0];
          }
          fetchSpotifySQL(data);
        });
      }
      /**
       * Fetch the Spotify info from our SQL server.
       *
       * @private
       *
       * @param {object} data The data previously received to add the Spotify
       * info onto.
       */
      function fetchSpotifySQL(data) {
        if (!data.spotifyId) {
          fetchDiscordBot(data);
          return;
        }
        const toSend = global.sqlCon.format(
            'SELECT * FROM Spotify WHERE id=? LIMIT 1', [data.spotifyId]);
        global.sqlCon.query(toSend, (err, rows) => {
          if (err) {
            self.error(err);
            cb('Server Error', null);
            return;
          }
          if (rows &amp;&amp; rows.length > 0) {
            data.spotify = {
              id: rows[0].id,
              haveToken: rows[0].access_token !== null,
              name: rows[0].name,
            };
          }
          fetchDiscordBot(data);
        });
      }
      /**
       * Fetch the Discord user information through the Discord bot API.
       *
       * @private
       *
       * @param {object} data The data previously received to add the Discord
       * user info onto, then send to the client.
       */
      function fetchDiscordBot(data) {
        const onData = (user) => {
          data.username = user.username;
          data.avatarURL = user.displayAvatarURL({dynamic: true});
          data.createdAt = user.createdAt;
          data.discriminator = user.discriminator;
          data.activity = user.presence.activity;
          cb(null, data);
        };
        const onError = (err) => {
          cb('Server Error', null);
          self.error('Failed to fetch user data from discord.');
          console.error(err);
        };
        if (self.common.isMaster) {
          self.client.shard
              .broadcastEval(`this.users.resolve('${userData.id}')`)
              .then(
                  (res) => onData(
                      new self.Discord.User(self.client, res.find((el) => el))))
              .catch(onError);
        } else {
          self.client.users.fetch(userData.id)
              .then(onData)
              .catch(onError);
        }
      }
    });

    socket.on('linkPatreon', (userData, code, cb) => {
      if (typeof cb !== 'function') cb = function() {};
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      validatePatreonCode(code, userData.id, socket.id, cb);
    });
    socket.on('unlinkPatreon', (userData, cb) => {
      if (typeof cb !== 'function') cb = function() {};
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      updateUserPatreonId(userData.id, null, cb);
    });
    socket.on('linkSpotify', (userData, code, cb) => {
      if (typeof cb !== 'function') cb = function() {};
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      validateSpotifyCode(code, userData.id, socket.id, cb);
    });
    socket.on('unlinkSpotify', (userData, cb) => {
      if (typeof cb !== 'function') cb = function() {};
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      updateUserSpotifyId(userData.id, null, cb);
    });
    socket.on('getSettingsTemplate', (userData, cb) => {
      if (typeof cb !== 'function') {
        self.error('Requested setting template without callback.', socket.id);
        return;
      }
      cb(patreonSettingsTemplate);
    });
    socket.on('getUserSettings', (userData, cb) => {
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      getPatreonSettings(userData.id, cb);
    });
    socket.on('getUserPerms', (userData, cb) => {
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      if (!self.bot.patreon) {
        self.error('Patreon submodule has not been loaded!');
        cb('Internal Error', null);
      } else {
        self.bot.patreon.getAllPerms(userData.id, null, null, cb);
      }
    });
    socket.on('changeSetting', (userData, setting, value, cb) => {
      if (typeof cb !== 'function') cb = function() {};
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      changePatreonSetting(userData.id, setting, value, cb);
    });
    socket.on('fetchApiToken', (userData, cb) => {
      if (typeof cb !== 'function') return;
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      const toSend = global.sqlCon.format(
          'SELECT apiToken FROM Discord WHERE id=?', [userData.id]);
      global.sqlCon.query(toSend, (err, rows) => {
        if (err) {
          self.error('Failed to fetch apiToken from database.');
          console.error(err);
          cb('Internal Server Error');
          return;
        }
        cb(null, rows &amp;&amp; rows[0] &amp;&amp; rows[0].apiToken);
      });
    });
    socket.on('resetApiToken', (userData, cb) => {
      if (typeof cb !== 'function') cb = function() {};
      if (!userData) {
        cb('Not signed in.', null);
        return;
      }
      const token = crypto.randomBytes(128).toString('base64');
      const toSend = global.sqlCon.format(
          'UPDATE Discord SET apiToken=? WHERE id=?', [token, userData.id]);
      global.sqlCon.query(toSend, (err) => {
        if (err) {
          self.error('Failed to reset apiToken in database.');
          console.error(err);
          cb('Internal Server Error');
          return;
        }
        cb(null, token);
      });
    });

    socket.on('disconnect', () => {
      self.common.log(
          'Socket disconnected (' + (Object.keys(sockets).length - 1) + '): ' +
              ipName,
          socket.id);
      delete sockets[socket.id];
    });
  }
  /**
   * @description Validate a code received from the client, then use it to
   * retrieve the user ID associated with it.
   *
   * @private
   * @param {string} code The code received from Patreon OAuth2 flow.
   * @param {string|number} userid The Discord user ID associated with this code
   * in order to link accounts.
   * @param {string} ip The unique identifier for this connection for logging
   * purposes.
   * @param {Function} cb Callback with a single parameter. The parameter is a
   * string if there was an error, or null if no error.
   */
  function validatePatreonCode(code, userid, ip, cb) {
    patreonOAuthClient.getTokens(code, redirectURL)
        .then(function(tokensResponse) {
          const patreonAPIClient = patreonAPI(tokensResponse.access_token);
          return patreonAPIClient('/current_user');
        })
        .then(function(result) {
          const store = result.store;
          const users = store.findAll('user').map((user) => user.serialize());
          if (!users || users.length &lt; 1 || !users[0].data ||
              !users[0].data.id) {
            self.common.error('Failed to get patreonid', ip);
            cb('Internal Server Error');
            return;
          }
          updateUserPatreonId(userid, users[0].data.id, cb);
        })
        .catch(function(err) {
          self.common.error('Failed to get patreonId');
          console.error(err);
          cb('Internal Server Error');
        });
  }
  /**
   * @description Validate a code received from the client, then use it to
   * retrieve the user ID associated with it.
   *
   * @private
   * @param {string} code The code received from Patreon OAuth2 flow.
   * @param {string|number} userid The Discord user ID associated with this code
   * in order to link accounts.
   * @param {string} ip The unique identifier for this connection for logging
   * purposes.
   * @param {Function} cb Callback with a single parameter. The parameter is a
   * string if there was an error, or null if no error.
   */
  function validateSpotifyCode(code, userid, ip, cb) {
    const req = https.request(defaultSpotifyTokenReq, (res) => {
      let content = '';
      res.on('data', (chunk) => {
        content += chunk;
      });
      res.on('end', () => {
        if (res.statusCode == 200) {
          handleSpotifyTokenResponse(userid, content, ip, cb);
        } else {
          self.common.error(content, ip);
          cb('Internal Server Error');
          return;
        }
      });
    });
    req.end(querystring.stringify({
      code: code,
      redirect_uri: redirectURL,
      grant_type: 'authorization_code',
    }));
  }

  /**
   * Handle the response after successfully requesting the user's tokens.
   *
   * @private
   *
   * @param {string|number} userid Discord user id.
   * @param {string} content The response from Spotify.
   * @param {string} ip Unique identifier for the client that caused this to
   * happen. Used for logging.
   * @param {Function} cb Callback with single parameter, string if error, null
   * if no error.
   */
  function handleSpotifyTokenResponse(userid, content, ip, cb) {
    let parsed;
    try {
      parsed = JSON.parse(content);
    } catch (err) {
      cb('Internal Server Error');
      self.common.error('Failed to parse token response from Spotify.', ip);
      console.error(err);
      return;
    }
    const vals = {
      accessToken: parsed.access_token,
      expiresIn: parsed.expires_in,
      expiresAt: dateToSQL(Date.now() + parsed.expires_in * 1000),
    };
    if (parsed.refresh_token) {
      vals.refreshToken = parsed.refresh_token;
    }
    const req = https.request(defaultSpotifyUserReq, (res) => {
      let content = '';
      res.on('data', (chunk) => {
        content += chunk;
      });
      res.on('end', () => {
        if (res.statusCode == 200) {
          handleSpotifyUserResponse(userid, content, vals, ip, cb);
        } else {
          self.common.error(content, ip);
          cb('Internal Server Error');
          return;
        }
      });
    });
    req.setHeader('Authorization', 'Bearer ' + vals.accessToken);
    req.end();
  }

  /**
   * @description Handle the response after successfully requesting the user's
   * basic account information.
   * @private
   *
   * @param {string|number} userid Discord user id.
   * @param {string} content The response from Spotify.
   * @param {{accessToken: string, expiresIn: number, expiresAt: string,
   * refreshToken: string}} vals The object storing user session information.
   * @param {string} ip Unique identifier for the client that caused this to
   * happen. Used for logging.
   * @param {Function} cb Callback with single parameter, string if error, null
   * if no error.
   */
  function handleSpotifyUserResponse(userid, content, vals, ip, cb) {
    let parsed;
    try {
      parsed = JSON.parse(content);
    } catch (err) {
      self.common.error('Failed to parse user response from Spotify.', ip);
      console.error(err);
      cb('Internal Server Error');
      return;
    }
    vals.id = parsed.id;
    vals.name = parsed.display_name;
    const toSend = global.sqlCon.format(
        'INSERT INTO Spotify (id,name,accessToken,refreshToken,tokenExpiresAt' +
            ') VALUES (?,?,?,?,?) ON DUPLICATE KEY UPDATE accessToken=?,token' +
            'ExpiresAt=?',
        [
          vals.id,
          vals.name,
          vals.accessToken,
          vals.refreshToken,
          vals.expiresAt,
          vals.accessToken,
          vals.expiresAt,
        ]);
    global.sqlCon.query(toSend, (err) => {
      if (err) {
        self.common.error('Failed to update Spotify table with user data.', ip);
        console.error(err);
        cb('Internal Server Error');
        return;
      }
      updateUserSpotifyId(userid, vals.id, cb);
    });
  }
  /**
   * @description Update our Discord table with the retrieved patreon account ID
   * for the Discord user.
   *
   * @private
   * @param {string|number} userid The Discord ID of the user to link to the
   * patreonid.
   * @param {string|number} patreonid The Patreon id of the account to link to
   * the Discord ID.
   * @param {Function} cb Callback with single argument that is string if error,
   * or null if no error.
   */
  function updateUserPatreonId(userid, patreonid, cb) {
    const toSend = global.sqlCon.format(
        'UPDATE Discord SET patreonId=? WHERE id=?', [patreonid, userid]);
    global.sqlCon.query(toSend, (err) => {
      if (err) {
        self.common.error('Failed to update patreonId in Discord table.');
        console.log(err);
        cb('Internal Server Error');
      } else {
        cb(null);
      }
    });
  }
  /**
   * @description Update our Discord table with the retrieved spotify account ID
   * for the Discord user. Deletes row from Spotify table if the userId is
   * falsey.
   *
   * @private
   * @param {string|number} userid The Discord ID of the user to link to the
   * patreonid.
   * @param {string|number} spotifyid The Spotify id of the account to link to
   * the Discord ID.
   * @param {Function} cb Callback with single argument that is string if error,
   * or null if no error.
   */
  function updateUserSpotifyId(userid, spotifyid, cb) {
    if (!spotifyid) {
      const toSendGet = global.sqlCon.format(
          'SELECT spotifyId FROM Discord WHERE id=?', [userid]);
      global.sqlCon.query(toSendGet, (err, rows) => {
        if (err) {
          self.common.error('Failed to fetch spotifyId from Discord table.');
          console.log(err);
          cb('Internal Server Error');
        } else {
          const toSend2 = global.sqlCon.format(
              'DELETE FROM Spotify WHERE id=?', [rows[0].spotifyId]);
          global.sqlCon.query(toSend2, (err) => {
            if (err) {
              self.common.error(
                  'Failed to delete spotifyId from Spotify table.');
              console.log(err);
              cb('Internal Server Error');
            } else {
              setId();
            }
          });
        }
      });
    } else {
      setId();
    }

    /**
     * Send request to sql server.
     */
    function setId() {
      const toSend = global.sqlCon.format(
          'UPDATE Discord SET spotifyId=? WHERE id=?', [spotifyid, userid]);
      global.sqlCon.query(toSend, (err) => {
        if (err) {
          self.common.error('Failed to update spotifyId in Discord table.');
          console.log(err);
          cb('Internal Server Error');
        } else {
          cb(null);
        }
      });
    }
  }
  /**
   * Fetch a user's current patreon settings from file.
   *
   * @private
   *
   * @param {string|number} userid Thd Discord id of the user to lookup.
   * @param {Function} cb Callback with 2 parameters, the first is the error
   * string or null if no error, the second will be the settings object if there
   * is no error.
   */
  function getPatreonSettings(userid, cb) {
    fs.readFile(
        self.common.userSaveDir + userid + patreonSettingsFilename,
        (err, data) => {
          if (err) {
            cb(err, null);
            return;
          }
          try {
            cb(null, JSON.parse(data));
          } catch (e) {
            cb(e, null);
          }
        });
  }
  /**
   * Change a user's setting that is related to Patreon rewards.
   *
   * @private
   *
   * @param {string|number} userid The Discord id of the user to change the
   * setting for.
   * @param {string} setting The name of the setting to change.
   * @param {string} value The value to set the setting to.
   * @param {Function} cb Callback that is called once the operations are
   * complete with a single parameter for errors, string if error, null if none.
   */
  function changePatreonSetting(userid, setting, value, cb) {
    const dirname = self.common.userSaveDir + userid;
    const filename = dirname + patreonSettingsFilename;
    const split = setting.split(' ');
    setting = split[0];
    /**
     * Make the directory for writing the user's settings if it does not exist
     * already.
     *
     * @private
     * @param {?Error} err The error in readin the existing file.
     * @param {?string} data The data read from the existing file if any.
     */
    function makeDirectory(err, data) {
      if (err) {
        mkdirp(dirname)
            .then(() => writeFile(null, data))
            .catch((err) => writeFile(err, null));
      } else {
        writeFile(null, data);
      }
    }
    /**
     * Checks that the setting that was requested to be changed is a valid
     * setting to change.
     *
     * @private
     * @param {object} obj The template object to compare the request against.
     * @param {string[]} s The array of each setting key that was a part of
     * the request.
     * @param {string|number} value The value to change the setting to.
     * @returns {boolean} True if the request was invalid in some way, or false
     * if everything is fine.
     */
    function isInvalid(obj, s, value) {
      const type = obj.type;
      let valid = false;
      if (type === 'select') {
        for (let i = 0; i &lt; obj.values.length; i++) {
          if (obj.values[i] == value) {
            valid = true;
            break;
          }
        }
      } else if (type === 'number') {
        if (!isNaN(Number(value))) valid = true;
        if (valid &amp;&amp; obj.range) {
          if (value &lt; obj.range.min || value > obj.range.max) {
            valid = false;
          }
        }
      } else if (type === 'string') {
        valid = true;
      } else if (type === 'color') {
        valid =
            typeof value === 'string' &amp;&amp; value.match(/^0x[0-9a-fA-f]{6,9}$/);
      } else if (type === 'boolean') {
        valid = typeof value === 'boolean' ||
            (typeof value === 'string' &amp;&amp; (value.toLowerCase() === 'false' ||
                                           value.toLowerCase() === 'true'));
      } else if (type === 'object') {
        return isInvalid(obj.values[s[0]], s.slice(1), value);
      }
      if (!valid) {
        cb('Invalid Value', {status: type || 'NOTYPE', message: value});
        return true;
      } else {
        return false;
      }
    }
    /**
     * Write the modified data to file.
     *
     * @private
     *
     * @param {?Error} err The error in creating the directory.
     * @param {?string} file The current file data that was read.
     */
    function writeFile(err, file) {
      let parsed = {};
      if (file != null) {
        try {
          parsed = JSON.parse(file);
        } catch (e) {
          self.error(
              'Failed to parse ' + self.common.userSaveDir + userid +
              patreonSettingsFilename);
          console.error(e);
          cb('Internal Error');
          return;
        }
      }
      if (split.length > 1) {
        if (!parsed[setting]) parsed[setting] = {};
        let obj = parsed[setting];
        while (split.length > 2) {
          const next = split.splice(1, 1)[0];
          if (!obj[next]) obj[next] = {};
          obj = obj[next];
        }
        obj[split[1]] = value;
      } else {
        parsed[setting] = value;
      }

      fs.writeFile(filename, JSON.stringify(parsed), (err) => {
        if (!err) {
          cb(null);
          return;
        }
        self.error('Failed to write user settings to file: ' + filename);
        console.error(err);
        cb('Internal Error');
      });
    }

    if (patreonSettingsTemplate[setting] == null) {
      cb('Invalid Setting');
      return;
    } else {
      if (isInvalid(patreonSettingsTemplate[setting], split.slice(1), value)) {
        return;
      }
    }
    fs.readFile(filename, makeDirectory);
  }

  /**
   * Get a current access token for a given discord user to make a request to
   * the Spotify API.
   *
   * @public
   *
   * @param {string|number} uId The Discord user id to get the token for.
   * @param {Function} cb Callback with a single argument that is the token, or
   * null if no token is available.
   */
  toExport.getSpotifyToken = function(uId, cb) {
    let firstAttempt = true;
    let sId;
    const toSend = global.sqlCon.format(
        'SELECT spotifyId FROM Discord WHERE id=? LIMIT 1', [uId]);
    global.sqlCon.query(toSend, (err, rows) => {
      if (err) {
        self.error(err);
        cb(null);
        return;
      }
      if (rows[0]) {
        fetchSpotifySQL(rows[0].spotifyId);
      } else {
        fetchSpotifySQL(null);
      }
    });
    /**
     * Request the user's Spotify info from our SQL server.
     *
     * @private
     *
     * @param {string} id The spotify ID of the user to fetch.
     */
    function fetchSpotifySQL(id) {
      if (!id) {
        cb(null);
        return;
      }
      sId = id;
      const toSend = global.sqlCon.format(
          'SELECT * FROM Spotify WHERE id=? LIMIT 1', [sId]);
      global.sqlCon.query(toSend, (err, rows) => {
        if (err) {
          self.error(err);
          cb(null);
          return;
        }
        const expiresAt = new Date(rows[0].tokenExpiresAt);
        if (Date.now() - expiresAt.getTime() > 0) {
          refreshSpotifyToken(rows[0].refreshToken);
        } else {
          cb(rows[0].accessToken);
        }
      });
    }
    /**
     * Use the user's refresh token to request a new access token. Only
     * attempted once.
     *
     * @private
     *
     * @param {string} token The refresh token to use.
     */
    function refreshSpotifyToken(token) {
      if (!firstAttempt || !token) {
        cb(null);
        return;
      }
      firstAttempt = false;
      const req = https.request(defaultSpotifyTokenReq, (res) => {
        let content = '';
        res.on('data', (chunk) => {
          content += chunk;
        });
        res.on('end', () => {
          if (res.statusCode == 200) {
            handleSpotifyTokenResponse(uId, content, null, (err) => {
              if (err) {
                cb(null);
              } else {
                fetchSpotifySQL(sId);
              }
            });
          } else {
            self.error(content);
            cb(null);
            return;
          }
        });
      });
      req.end(querystring.stringify({
        refresh_token: token,
        grant_type: 'refresh_token',
      }));
    }
  };
  /**
   * Convert the given date into a format that SQL can understand.
   *
   * @private
   * @param {*} date Something that `new Date()` can interpret.
   * @returns {string} Formatted Datetime string not including fractions of a
   * second.
   */
  function dateToSQL(date) {
    date = new Date(date);
    return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' +
        date.getDate() + ' ' + date.getHours() + ':' + date.getMinutes() + ':' +
        date.getSeconds();
  }
}

module.exports = new WebAccount();
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	<small>Website Contact: <a href="mailto:web@spikeybot.com">web@spikeybot.com</a>.</small><br><small>&copy; Copyright 2019-2020, Campbell Crowley. <a href="https://docs.google.com/document/d/1SAC2aPxxeNqRjlZzjwrnCyyWWyt09ZP-AP7BDBjjQDg/edit?usp=sharing">Privacy Policy</a></small>
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
	
		on Friday, June 19, 2020 3:57 PM (-07:00)
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->

<script>
	(function ( i, s, o, g, r, a, m ) {
		i['GoogleAnalyticsObject'] = r;
		i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push( arguments )
		}, i[r].l = 1 * new Date();
		a = s.createElement( o ),
			m = s.getElementsByTagName( o )[0];
		a.async = 1;
		a.src = g;
		m.parentNode.insertBefore( a, m )
	})( window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga' );

	ga( 'create', 'UA-89923351-1', 'www.spikeybot.com' );
	ga( 'send', 'pageview' );
</script>



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
